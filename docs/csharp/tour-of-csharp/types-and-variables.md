---
title: Tipi e variabili C# - Panoramica del linguaggio C#
description: Informazioni sulla definizione di tipi e la dichiarazione di variabili nel linguaggio C#
ms.date: 02/25/2020
ms.assetid: f8a8051e-0049-43f1-b594-9c84cc7b1224
ms.openlocfilehash: dc80a7ea80790ef5af5218f5a608e5829d2970cc
ms.sourcegitcommit: 8b02d42f93adda304246a47f49f6449fc74a3af4
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/24/2020
ms.locfileid: "82135958"
---
# <a name="types-and-variables"></a><span data-ttu-id="901b9-103">Tipi e variabili</span><span class="sxs-lookup"><span data-stu-id="901b9-103">Types and variables</span></span>

<span data-ttu-id="901b9-104">In C# esistono due generi di tipi: *tipi valore* e *tipi riferimento*.</span><span class="sxs-lookup"><span data-stu-id="901b9-104">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="901b9-105">Le variabili dei tipi valore contengono direttamente i propri dati, mentre le variabili dei tipi riferimento archiviano i riferimenti ai propri dati, noti come oggetti.</span><span class="sxs-lookup"><span data-stu-id="901b9-105">Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="901b9-106">Con i tipi di riferimento, è possibile che due variabili facciano riferimento allo stesso oggetto e pertanto le operazioni su una variabile influiscano sull'oggetto a cui fa riferimento l'altra variabile.</span><span class="sxs-lookup"><span data-stu-id="901b9-106">With reference types, it's possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="901b9-107">Con i tipi valore, ogni variabile ha una propria copia dei dati e non è possibile che le operazioni su uno influiscano sull'altro (ad eccezione `ref` delle `out` variabili di parametro e).</span><span class="sxs-lookup"><span data-stu-id="901b9-107">With value types, the variables each have their own copy of the data, and it isn't possible for operations on one to affect the other (except for `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="901b9-108">I tipi valore di C# sono ulteriormente suddivisi in *tipi semplici*, *tipi enum*, *tipi struct* e *tipi valore nullable*.</span><span class="sxs-lookup"><span data-stu-id="901b9-108">C#’s value types are further divided into *simple types*, *enum types*, *struct types*, and *nullable value types*.</span></span> <span data-ttu-id="901b9-109">I tipi riferimento di C# sono ulteriormente suddivisi in *tipi classe*, *tipi interfaccia*, *tipi matrice* e *tipi delegato*.</span><span class="sxs-lookup"><span data-stu-id="901b9-109">C#’s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="901b9-110">La struttura seguente fornisce una panoramica del sistema di tipi di C#.</span><span class="sxs-lookup"><span data-stu-id="901b9-110">The following outline provides an overview of C#’s type system.</span></span>

- <span data-ttu-id="901b9-111">[Tipi valore][ValueTypes]</span><span class="sxs-lookup"><span data-stu-id="901b9-111">[Value types][ValueTypes]</span></span>
  - <span data-ttu-id="901b9-112">[Tipi semplici][SimpleTypes]</span><span class="sxs-lookup"><span data-stu-id="901b9-112">[Simple types][SimpleTypes]</span></span>
    - <span data-ttu-id="901b9-113">Signed Integer: `sbyte`, `short`, `int`,`long`</span><span class="sxs-lookup"><span data-stu-id="901b9-113">Signed integral: `sbyte`, `short`, `int`, `long`</span></span>
    - <span data-ttu-id="901b9-114">Unsigned Integer: `byte`, `ushort`, `uint`,`ulong`</span><span class="sxs-lookup"><span data-stu-id="901b9-114">Unsigned integral: `byte`, `ushort`, `uint`, `ulong`</span></span>
    - <span data-ttu-id="901b9-115">Caratteri Unicode: `char`</span><span class="sxs-lookup"><span data-stu-id="901b9-115">Unicode characters: `char`</span></span>
    - <span data-ttu-id="901b9-116">File binario IEEE a virgola mobile: `float`, `double`</span><span class="sxs-lookup"><span data-stu-id="901b9-116">IEEE binary floating-point: `float`, `double`</span></span>
    - <span data-ttu-id="901b9-117">Decimale ad alta precisione a virgola mobile: `decimal`</span><span class="sxs-lookup"><span data-stu-id="901b9-117">High-precision decimal floating-point: `decimal`</span></span>
    - <span data-ttu-id="901b9-118">Booleano: `bool`</span><span class="sxs-lookup"><span data-stu-id="901b9-118">Boolean: `bool`</span></span>
  - <span data-ttu-id="901b9-119">[Tipi enum][EnumTypes]</span><span class="sxs-lookup"><span data-stu-id="901b9-119">[Enum types][EnumTypes]</span></span>
    - <span data-ttu-id="901b9-120">Tipi definiti dall'utente nel formato `enum E {...}`</span><span class="sxs-lookup"><span data-stu-id="901b9-120">User-defined types of the form `enum E {...}`</span></span>
  - <span data-ttu-id="901b9-121">[Tipi struct][StructTypes]</span><span class="sxs-lookup"><span data-stu-id="901b9-121">[Struct types][StructTypes]</span></span>
    - <span data-ttu-id="901b9-122">Tipi definiti dall'utente nel formato `struct S {...}`</span><span class="sxs-lookup"><span data-stu-id="901b9-122">User-defined types of the form `struct S {...}`</span></span>
  - <span data-ttu-id="901b9-123">[Tipi valore nullable][NullableTypes]</span><span class="sxs-lookup"><span data-stu-id="901b9-123">[Nullable value types][NullableTypes]</span></span>
    - <span data-ttu-id="901b9-124">Estensioni di tutti gli altri tipi valore con un valore `null`</span><span class="sxs-lookup"><span data-stu-id="901b9-124">Extensions of all other value types with a `null` value</span></span>
- <span data-ttu-id="901b9-125">[Tipi riferimento][ReferenceTypes]</span><span class="sxs-lookup"><span data-stu-id="901b9-125">[Reference types][ReferenceTypes]</span></span>
  - <span data-ttu-id="901b9-126">[Tipi di classe][ClassTypes]</span><span class="sxs-lookup"><span data-stu-id="901b9-126">[Class types][ClassTypes]</span></span>
    - <span data-ttu-id="901b9-127">Classe di base principale di tutti gli altri tipi: `object`</span><span class="sxs-lookup"><span data-stu-id="901b9-127">Ultimate base class of all other types: `object`</span></span>
    - <span data-ttu-id="901b9-128">Stringhe Unicode: `string`</span><span class="sxs-lookup"><span data-stu-id="901b9-128">Unicode strings: `string`</span></span>
    - <span data-ttu-id="901b9-129">Tipi definiti dall'utente nel formato `class C {...}`</span><span class="sxs-lookup"><span data-stu-id="901b9-129">User-defined types of the form `class C {...}`</span></span>
  - <span data-ttu-id="901b9-130">[Tipi interfaccia][InterfaceTypes]</span><span class="sxs-lookup"><span data-stu-id="901b9-130">[Interface types][InterfaceTypes]</span></span>
    - <span data-ttu-id="901b9-131">Tipi definiti dall'utente nel formato `interface I {...}`</span><span class="sxs-lookup"><span data-stu-id="901b9-131">User-defined types of the form `interface I {...}`</span></span>
  - <span data-ttu-id="901b9-132">[Tipi di matrice][ArrayTypes]</span><span class="sxs-lookup"><span data-stu-id="901b9-132">[Array types][ArrayTypes]</span></span>
    - <span data-ttu-id="901b9-133">Unidimensionale e multidimensionale, ad esempio `int[]` e `int[,]`</span><span class="sxs-lookup"><span data-stu-id="901b9-133">Single- and multi-dimensional, for example, `int[]` and `int[,]`</span></span>
  - <span data-ttu-id="901b9-134">[Tipi delegato][DelegateTypes]</span><span class="sxs-lookup"><span data-stu-id="901b9-134">[Delegate types][DelegateTypes]</span></span>
    - <span data-ttu-id="901b9-135">Tipi definiti dall'utente nel formato `delegate int D(...)`</span><span class="sxs-lookup"><span data-stu-id="901b9-135">User-defined types of the form `delegate int D(...)`</span></span>

[ValueTypes]: ../language-reference/builtin-types/value-types.md
[SimpleTypes]: ../language-reference/builtin-types/value-types.md#built-in-value-types
[EnumTypes]: ../language-reference/builtin-types/enum.md
[StructTypes]: ../language-reference/builtin-types/struct.md
[NullableTypes]: ../language-reference/builtin-types/nullable-value-types.md
[ReferenceTypes]: ../language-reference/keywords/reference-types.md
[ClassTypes]: ../language-reference/keywords/class.md
[InterfaceTypes]: ../language-reference/keywords/interface.md
[DelegateTypes]: ../language-reference/keywords/delegate.md
[ArrayTypes]: ../programming-guide/arrays/index.md

<span data-ttu-id="901b9-136">Per altre informazioni sui tipi numerici, vedere la [tabella dei tipi integrali](../language-reference/builtin-types/integral-numeric-types.md) e la [tabella dei tipi a virgola mobile](../language-reference/builtin-types/floating-point-numeric-types.md).</span><span class="sxs-lookup"><span data-stu-id="901b9-136">For more information about numeric types, see [Integral types](../language-reference/builtin-types/integral-numeric-types.md) and [Floating-point types table](../language-reference/builtin-types/floating-point-numeric-types.md).</span></span>

<span data-ttu-id="901b9-137">Il tipo `bool` di C# viene usato per rappresentare valori booleani, ovvero valori che sono `true` o `false`.</span><span class="sxs-lookup"><span data-stu-id="901b9-137">C#’s `bool` type is used to represent Boolean values—values that are either `true` or `false`.</span></span>

<span data-ttu-id="901b9-138">Per l'elaborazione di caratteri e stringhe, in C# viene usata la codifica Unicode.</span><span class="sxs-lookup"><span data-stu-id="901b9-138">Character and string processing in C# uses Unicode encoding.</span></span> <span data-ttu-id="901b9-139">Il tipo `char` rappresenta un'unità di codice UTF-16, mentre il tipo `string` rappresenta una sequenza di unità di codice UTF-16.</span><span class="sxs-lookup"><span data-stu-id="901b9-139">The `char` type represents a UTF-16 code unit, and the `string` type represents a sequence of UTF-16 code units.</span></span>

<span data-ttu-id="901b9-140">I programmi C# usano le *dichiarazioni di tipo* per creare nuovi tipi.</span><span class="sxs-lookup"><span data-stu-id="901b9-140">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="901b9-141">Una dichiarazione di tipo consente di specificare il nome e i membri del nuovo tipo.</span><span class="sxs-lookup"><span data-stu-id="901b9-141">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="901b9-142">Cinque delle categorie di tipi di C# possono essere definite dall'utente: tipi classe, tipi struct, tipi interfaccia, tipi enum e tipi delegato.</span><span class="sxs-lookup"><span data-stu-id="901b9-142">Five of C#’s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.</span></span>

<span data-ttu-id="901b9-143">Un tipo `class` definisce una struttura dati contenente membri dati (campi) e membri funzione (metodi, proprietà e altro).</span><span class="sxs-lookup"><span data-stu-id="901b9-143">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="901b9-144">I tipi classe supportano l'ereditarietà singola e il polimorfismo, meccanismi in base ai quali le classi derivate possono estendere e specializzare le classi di base.</span><span class="sxs-lookup"><span data-stu-id="901b9-144">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>

<span data-ttu-id="901b9-145">Un tipo `struct` è simile a un tipo classe in quanto rappresenta una struttura con membri dati e membri funzione.</span><span class="sxs-lookup"><span data-stu-id="901b9-145">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="901b9-146">Tuttavia, a differenza delle classi, gli struct sono tipi di valore e in genere non richiedono l'allocazione dell'heap.</span><span class="sxs-lookup"><span data-stu-id="901b9-146">However, unlike classes, structs are value types and don't typically require heap allocation.</span></span> <span data-ttu-id="901b9-147">I tipi struct non supportano l'ereditarietà specificata dall'utente e tutti i tipi struct ereditano implicitamente dal tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="901b9-147">Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>

<span data-ttu-id="901b9-148">Un tipo `interface` definisce un contratto come un set denominato di membri funzione pubblici.</span><span class="sxs-lookup"><span data-stu-id="901b9-148">An `interface` type defines a contract as a named set of public function members.</span></span> <span data-ttu-id="901b9-149">Un tipo `class` o `struct` che implementa un tipo `interface` deve fornire le implementazioni dei membri funzione dell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="901b9-149">A `class` or `struct` that implements an `interface` must provide implementations of the interface’s function members.</span></span> <span data-ttu-id="901b9-150">Un tipo `interface` può ereditare da più interfacce di base e un tipo `class` o `struct` può implementare più interfacce.</span><span class="sxs-lookup"><span data-stu-id="901b9-150">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>

<span data-ttu-id="901b9-151">Un tipo `delegate` rappresenta i riferimenti ai metodi, con un elenco di parametri e un tipo restituito particolari.</span><span class="sxs-lookup"><span data-stu-id="901b9-151">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="901b9-152">I delegati consentono di trattare i metodi come entità che è possibile assegnare a variabili e passare come parametri.</span><span class="sxs-lookup"><span data-stu-id="901b9-152">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="901b9-153">I delegati sono analoghi ai tipi funzione forniti dai linguaggi funzionali.</span><span class="sxs-lookup"><span data-stu-id="901b9-153">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="901b9-154">Sono anche simili al concetto di puntatori a funzione disponibili in altri linguaggi.</span><span class="sxs-lookup"><span data-stu-id="901b9-154">They're also similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="901b9-155">A differenza dei puntatori a funzione, i delegati sono orientati agli oggetti e indipendenti dai tipi.</span><span class="sxs-lookup"><span data-stu-id="901b9-155">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="901b9-156">I `class`tipi `struct`, `interface`, e `delegate` supportano tutti i generics, in base ai quali possono essere parametrizzati con altri tipi.</span><span class="sxs-lookup"><span data-stu-id="901b9-156">The `class`, `struct`, `interface`, and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="901b9-157">Un tipo `enum` è un tipo distinto con costanti denominate.</span><span class="sxs-lookup"><span data-stu-id="901b9-157">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="901b9-158">Ogni tipo `enum` ha un tipo sottostante, che deve essere uno degli otto tipi integrali.</span><span class="sxs-lookup"><span data-stu-id="901b9-158">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="901b9-159">Il set di valori di un tipo `enum` coincide con il set di valori del tipo sottostante.</span><span class="sxs-lookup"><span data-stu-id="901b9-159">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>

<span data-ttu-id="901b9-160">C# supporta matrici unidimensionali e multidimensionali di qualsiasi tipo.</span><span class="sxs-lookup"><span data-stu-id="901b9-160">C# supports single- and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="901b9-161">A differenza dei tipi elencati in precedenza, i tipi di matrice non devono essere dichiarati prima di poter essere usati.</span><span class="sxs-lookup"><span data-stu-id="901b9-161">Unlike the types listed above, array types don't have to be declared before they can be used.</span></span> <span data-ttu-id="901b9-162">Al contrario, i tipi matrice vengono costruiti facendo seguire a un nome di tipo delle parentesi quadre.</span><span class="sxs-lookup"><span data-stu-id="901b9-162">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="901b9-163">Ad esempio, `int[]` è una matrice unidimensionale di `int`, `int[,]` è una matrice bidimensionale di `int` e `int[][]` è una matrice unidimensionale di matrici unidimensionali di `int`.</span><span class="sxs-lookup"><span data-stu-id="901b9-163">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional array of `int`.</span></span>

<span data-ttu-id="901b9-164">Anche i tipi di valore nullable non devono essere dichiarati prima di poter essere usati.</span><span class="sxs-lookup"><span data-stu-id="901b9-164">Nullable value types also don't have to be declared before they can be used.</span></span> <span data-ttu-id="901b9-165">Per ogni tipo `T`di valore che non ammette i valori null, esiste un tipo `T?`di valore nullable corrispondente, che può avere `null`un valore aggiuntivo,.</span><span class="sxs-lookup"><span data-stu-id="901b9-165">For each non-nullable value type `T`, there is a corresponding nullable value type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="901b9-166">Ad esempio, `int?` è un tipo che può contenere qualsiasi Integer a 32 bit o il valore `null`.</span><span class="sxs-lookup"><span data-stu-id="901b9-166">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`.</span></span>

<span data-ttu-id="901b9-167">Il sistema di tipi di C# è unificato in modo tale che un valore di qualsiasi tipo può essere trattato come un `object`.</span><span class="sxs-lookup"><span data-stu-id="901b9-167">C#’s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="901b9-168">In C# ogni tipo deriva direttamente o indirettamente dal tipo classe `object` e `object` è la classe di base principale di tutti i tipi.</span><span class="sxs-lookup"><span data-stu-id="901b9-168">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="901b9-169">I valori dei tipi riferimento vengono trattati come oggetti semplicemente visualizzando tali valori come tipi `object`.</span><span class="sxs-lookup"><span data-stu-id="901b9-169">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="901b9-170">I valori dei tipi valore vengono trattati come oggetti mediante l'esecuzione di operazioni di *boxing* e *unboxing*.</span><span class="sxs-lookup"><span data-stu-id="901b9-170">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="901b9-171">Nell'esempio seguente un valore `int` viene convertito in `object` e quindi convertito nuovamente in `int`.</span><span class="sxs-lookup"><span data-stu-id="901b9-171">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

[!code-csharp[Boxing](../../../samples/snippets/csharp/tour/types-and-variables/Program.cs#L1-L10)]

<span data-ttu-id="901b9-172">Quando un valore di un tipo di valore viene assegnato a `object` un riferimento, viene allocata una "casella" per conservare il valore.</span><span class="sxs-lookup"><span data-stu-id="901b9-172">When a value of a value type is assigned to an `object` reference, a "box" is allocated to hold the value.</span></span> <span data-ttu-id="901b9-173">Questa casella è un'istanza di un tipo di riferimento e il valore viene copiato in tale casella.</span><span class="sxs-lookup"><span data-stu-id="901b9-173">That box is an instance of a reference type, and the value is copied into that box.</span></span> <span data-ttu-id="901b9-174">Viceversa, quando viene eseguito il `object` cast di un riferimento a un tipo valore, viene eseguito un controllo che l'oggetto `object` a cui si fa riferimento è una casella del tipo di valore corretto.</span><span class="sxs-lookup"><span data-stu-id="901b9-174">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type.</span></span> <span data-ttu-id="901b9-175">Se il controllo ha esito positivo, il valore nella casella viene copiato nel tipo di valore.</span><span class="sxs-lookup"><span data-stu-id="901b9-175">If the check succeeds, the value in the box is copied to the value type.</span></span>

<span data-ttu-id="901b9-176">Il sistema di tipi unificato di C# significa che i tipi di valore `object` vengono considerati come riferimenti "su richiesta".</span><span class="sxs-lookup"><span data-stu-id="901b9-176">C#’s unified type system effectively means that value types are treated as `object` references "on demand."</span></span> <span data-ttu-id="901b9-177">A causa dell'unificazione, le librerie di uso generico che usano `object` il tipo possono essere usate con tutti i tipi che `object`derivano da, inclusi sia i tipi di riferimento che i tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="901b9-177">Because of the unification, general-purpose libraries that use type `object` can be used with all types that derive from `object`, including both reference types and value types.</span></span>

<span data-ttu-id="901b9-178">In C# sono disponibili diversi tipi di *variabili*, inclusi campi, elementi matrice, variabili locali e parametri.</span><span class="sxs-lookup"><span data-stu-id="901b9-178">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="901b9-179">Le variabili rappresentano posizioni di archiviazione e ogni variabile dispone di un tipo che determina quali valori possono essere archiviati nella variabile stessa, come illustrato di seguito.</span><span class="sxs-lookup"><span data-stu-id="901b9-179">Variables represent storage locations, and every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

- <span data-ttu-id="901b9-180">Tipo valore non-nullable</span><span class="sxs-lookup"><span data-stu-id="901b9-180">Non-nullable value type</span></span>
  - <span data-ttu-id="901b9-181">Valore esattamente del tipo indicato</span><span class="sxs-lookup"><span data-stu-id="901b9-181">A value of that exact type</span></span>
- <span data-ttu-id="901b9-182">Tipo valore nullable</span><span class="sxs-lookup"><span data-stu-id="901b9-182">Nullable value type</span></span>
  - <span data-ttu-id="901b9-183">Valore `null` o valore esattamente del tipo indicato</span><span class="sxs-lookup"><span data-stu-id="901b9-183">A `null` value or a value of that exact type</span></span>
- <span data-ttu-id="901b9-184">oggetto</span><span class="sxs-lookup"><span data-stu-id="901b9-184">object</span></span>
  - <span data-ttu-id="901b9-185">Riferimento `null`, riferimento a un oggetto di qualsiasi tipo riferimento oppure riferimento a un valore boxed di qualsiasi tipo valore</span><span class="sxs-lookup"><span data-stu-id="901b9-185">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
- <span data-ttu-id="901b9-186">Tipo classe</span><span class="sxs-lookup"><span data-stu-id="901b9-186">Class type</span></span>
  - <span data-ttu-id="901b9-187">Riferimento `null`, riferimento a un'istanza del tipo classe oppure riferimento a un'istanza di una classe derivata dal tipo classe</span><span class="sxs-lookup"><span data-stu-id="901b9-187">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
- <span data-ttu-id="901b9-188">Tipo interfaccia</span><span class="sxs-lookup"><span data-stu-id="901b9-188">Interface type</span></span>
  - <span data-ttu-id="901b9-189">Riferimento `null`, riferimento a un'istanza di un tipo classe che implementa il tipo interfaccia oppure riferimento a un valore boxed di un tipo valore che implementa il tipo interfaccia</span><span class="sxs-lookup"><span data-stu-id="901b9-189">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
- <span data-ttu-id="901b9-190">Tipo matrice</span><span class="sxs-lookup"><span data-stu-id="901b9-190">Array type</span></span>
  - <span data-ttu-id="901b9-191">Riferimento `null`, riferimento a un'istanza del tipo matrice oppure riferimento a un'istanza di un tipo matrice compatibile</span><span class="sxs-lookup"><span data-stu-id="901b9-191">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
- <span data-ttu-id="901b9-192">Tipo delegato</span><span class="sxs-lookup"><span data-stu-id="901b9-192">Delegate type</span></span>
  - <span data-ttu-id="901b9-193">Riferimento `null` oppure riferimento a un'istanza di un tipo delegato compatibile</span><span class="sxs-lookup"><span data-stu-id="901b9-193">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="901b9-194">[Precedente](program-structure.md)
> [successivo](expressions.md)</span><span class="sxs-lookup"><span data-stu-id="901b9-194">[Previous](program-structure.md)
[Next](expressions.md)</span></span>
