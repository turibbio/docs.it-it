---
title: where (vincolo di tipo generico) - Riferimenti per C#
ms.date: 04/15/2020
f1_keywords:
- whereconstraint
- whereconstraint_CSharpKeyword
helpviewer_keywords:
- where (generic type constraint) [C#]
ms.openlocfilehash: 5a56b8058735d3ca786520a82424c79d1975bfc4
ms.sourcegitcommit: 927b7ea6b2ea5a440c8f23e3e66503152eb85591
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/16/2020
ms.locfileid: "81463018"
---
# <a name="where-generic-type-constraint-c-reference"></a><span data-ttu-id="d4d86-102">where (vincolo di tipo generico) (Riferimenti per C#)</span><span class="sxs-lookup"><span data-stu-id="d4d86-102">where (generic type constraint) (C# Reference)</span></span>

<span data-ttu-id="d4d86-103">La clausola `where` in una definizione generica specifica i vincoli per i tipi che vengono usati come argomenti per i parametri di tipo in un tipo generico, metodo, delegato o funzione locale.</span><span class="sxs-lookup"><span data-stu-id="d4d86-103">The `where` clause in a generic definition specifies constraints on the types that are used as arguments for type parameters in a generic type, method, delegate, or local function.</span></span> <span data-ttu-id="d4d86-104">I vincoli possono specificare interfacce, classi di base o richiedere che un tipo generico sia un riferimento, un valore o un tipo non gestito.</span><span class="sxs-lookup"><span data-stu-id="d4d86-104">Constraints can specify interfaces, base classes, or require a generic type to be a reference, value, or unmanaged type.</span></span> <span data-ttu-id="d4d86-105">Dichiarano le funzionalità che l'argomento di tipo deve avere.</span><span class="sxs-lookup"><span data-stu-id="d4d86-105">They declare capabilities that the type argument must have.</span></span>

<span data-ttu-id="d4d86-106">Ad esempio, una classe generica, `MyGenericClass`, può essere dichiarata in modo che tramite il parametro di tipo `T` venga implementata l'interfaccia <xref:System.IComparable%601>:</span><span class="sxs-lookup"><span data-stu-id="d4d86-106">For example, you can declare a generic class, `MyGenericClass`, such that the type parameter `T` implements the <xref:System.IComparable%601> interface:</span></span>

[!code-csharp[using an interface constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#1)]

> [!NOTE]
> <span data-ttu-id="d4d86-107">Per altre informazioni sulla clausola where in un'espressione di query, vedere [Clausola where](where-clause.md).</span><span class="sxs-lookup"><span data-stu-id="d4d86-107">For more information on the where clause in a query expression, see [where clause](where-clause.md).</span></span>

<span data-ttu-id="d4d86-108">La clausola `where` può inoltre includere un vincolo di classe di base.</span><span class="sxs-lookup"><span data-stu-id="d4d86-108">The `where` clause can also include a base class constraint.</span></span> <span data-ttu-id="d4d86-109">Il vincolo della classe base indica che un tipo da utilizzare come argomento di tipo per tale tipo generico ha la classe specificata come classe base o è tale classe base.</span><span class="sxs-lookup"><span data-stu-id="d4d86-109">The base class constraint states that a type to be used as a type argument for that generic type has the specified class as a base class, or is that base class.</span></span> <span data-ttu-id="d4d86-110">Se viene usato il vincolo della classe di base, deve apparire prima di tutti gli altri vincoli per quel parametro di tipo.</span><span class="sxs-lookup"><span data-stu-id="d4d86-110">If the base class constraint is used, it must appear before any other constraints on that type parameter.</span></span> <span data-ttu-id="d4d86-111">Alcuni tipi non sono consentiti come vincoli di classe di base: <xref:System.Object>, <xref:System.Array> e <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="d4d86-111">Some types are disallowed as a base class constraint: <xref:System.Object>, <xref:System.Array>, and <xref:System.ValueType>.</span></span> <span data-ttu-id="d4d86-112">Prima della versione 7.3, <xref:System.Enum>, <xref:System.Delegate>e <xref:System.MulticastDelegate> non erano consentiti anche come vincoli della classe base.</span><span class="sxs-lookup"><span data-stu-id="d4d86-112">Before C# 7.3, <xref:System.Enum>, <xref:System.Delegate>, and <xref:System.MulticastDelegate> were also disallowed as base class constraints.</span></span> <span data-ttu-id="d4d86-113">L'esempio seguente illustra i tipi possono ora essere specificati come una classe di base:</span><span class="sxs-lookup"><span data-stu-id="d4d86-113">The following example shows the types that can now be specified as a base class:</span></span>

[!code-csharp[using an interface constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#2)]

<span data-ttu-id="d4d86-114">In un contesto nullable in C , 8.0 e versioni successive, viene applicato il supporto di valori Null del tipo di classe base.</span><span class="sxs-lookup"><span data-stu-id="d4d86-114">In a nullable context in C# 8.0 and later, the nullability of the base class type is enforced.</span></span> <span data-ttu-id="d4d86-115">Se la classe base non può `Base`essere nullable (ad esempio ), l'argomento di tipo deve essere non nullable.</span><span class="sxs-lookup"><span data-stu-id="d4d86-115">If the base class is non-nullable (for example `Base`), the type argument must be non-nullable.</span></span> <span data-ttu-id="d4d86-116">Se la classe base è `Base?`nullable (ad esempio ), l'argomento di tipo può essere un tipo di riferimento nullable o non nullable.</span><span class="sxs-lookup"><span data-stu-id="d4d86-116">If the base class is nullable (for example `Base?`), the type argument may be either a nullable or non-nullable reference type.</span></span> <span data-ttu-id="d4d86-117">Il compilatore genera un avviso se l'argomento di tipo è un tipo di riferimento nullable quando la classe base non è nullable.</span><span class="sxs-lookup"><span data-stu-id="d4d86-117">The compiler issues a warning if the type argument is a nullable reference type when the base class is non-nullable.</span></span>

<span data-ttu-id="d4d86-118">La clausola `where` può specificare che il tipo è un oggetto `class` o `struct`.</span><span class="sxs-lookup"><span data-stu-id="d4d86-118">The `where` clause can specify that the type is a `class` or a `struct`.</span></span> <span data-ttu-id="d4d86-119">Il vincolo `struct` elimina la necessità di specificare un vincolo di classe di base di `System.ValueType`.</span><span class="sxs-lookup"><span data-stu-id="d4d86-119">The `struct` constraint removes the need to specify a base class constraint of `System.ValueType`.</span></span> <span data-ttu-id="d4d86-120">Il tipo `System.ValueType` non può essere usato come vincolo di classe di base.</span><span class="sxs-lookup"><span data-stu-id="d4d86-120">The `System.ValueType` type may not be used as a base class constraint.</span></span> <span data-ttu-id="d4d86-121">Nell'esempio seguente vengono illustrati i vincoli `class` e `struct`:</span><span class="sxs-lookup"><span data-stu-id="d4d86-121">The following example shows both the `class` and `struct` constraints:</span></span>

[!code-csharp[using the class and struct constraints](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#3)]

<span data-ttu-id="d4d86-122">In un contesto nullable in C , `class` 8.0 e versioni successive, il vincolo richiede che un tipo sia un tipo di riferimento non nullable.</span><span class="sxs-lookup"><span data-stu-id="d4d86-122">In a nullable context in C# 8.0 and later, the `class` constraint requires a type to be a non-nullable reference type.</span></span> <span data-ttu-id="d4d86-123">Per consentire i tipi di `class?` riferimento nullable, utilizzare il vincolo , che consente i tipi di riferimento nullable e non nullable.</span><span class="sxs-lookup"><span data-stu-id="d4d86-123">To allow nullable reference types, use the `class?` constraint, which allows both nullable and non-nullable reference types.</span></span>

<span data-ttu-id="d4d86-124">La `where` clausola `notnull` può includere il vincolo.</span><span class="sxs-lookup"><span data-stu-id="d4d86-124">The `where` clause may include the `notnull` constraint.</span></span> <span data-ttu-id="d4d86-125">Il `notnull` vincolo limita il parametro di tipo a tipi non nullable.</span><span class="sxs-lookup"><span data-stu-id="d4d86-125">The `notnull` constraint limits the type parameter to non-nullable types.</span></span> <span data-ttu-id="d4d86-126">Tale tipo può essere un tipo di [valore](../builtin-types/value-types.md) o un tipo di riferimento non nullable.</span><span class="sxs-lookup"><span data-stu-id="d4d86-126">That type may be a [value type](../builtin-types/value-types.md) or a non-nullable reference type.</span></span> <span data-ttu-id="d4d86-127">Il `notnull` vincolo è disponibile a partire da C , 8.0 per il codice compilato in un [ `nullable enable` contesto](../../nullable-references.md#nullable-contexts).</span><span class="sxs-lookup"><span data-stu-id="d4d86-127">The `notnull` constraint is available starting in C# 8.0 for code compiled in a [`nullable enable` context](../../nullable-references.md#nullable-contexts).</span></span> <span data-ttu-id="d4d86-128">A differenza di altri vincoli, `notnull` se un argomento di tipo viola il vincolo, il compilatore genera un avviso anziché un errore.</span><span class="sxs-lookup"><span data-stu-id="d4d86-128">Unlike other constraints, if a type argument violates the `notnull` constraint, the compiler generates a warning instead of an error.</span></span> <span data-ttu-id="d4d86-129">Gli avvisi vengono `nullable enable` generati solo in un contesto.</span><span class="sxs-lookup"><span data-stu-id="d4d86-129">Warnings are only generated in a `nullable enable` context.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="d4d86-130">Le dichiarazioni generiche che includono il `notnull` vincolo possono essere utilizzate in un contesto ignario nullable, ma il compilatore non applica il vincolo.</span><span class="sxs-lookup"><span data-stu-id="d4d86-130">Generic declarations that include the `notnull` constraint can be used in a nullable oblivious context, but compiler does not enforce the constraint.</span></span>

[!code-csharp[using the nonnull constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#NotNull)]

<span data-ttu-id="d4d86-131">La clausola `where` può anche includere un vincolo `unmanaged`.</span><span class="sxs-lookup"><span data-stu-id="d4d86-131">The `where` clause may also include an `unmanaged` constraint.</span></span> <span data-ttu-id="d4d86-132">Il vincolo `unmanaged` limita il parametro di tipo ai tipi noti come [tipi non gestiti](../builtin-types/unmanaged-types.md).</span><span class="sxs-lookup"><span data-stu-id="d4d86-132">The `unmanaged` constraint limits the type parameter to types known as [unmanaged types](../builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="d4d86-133">Il vincolo `unmanaged` rende più semplice la scrittura di codice di interoperabilità di basso livello in C#.</span><span class="sxs-lookup"><span data-stu-id="d4d86-133">The `unmanaged` constraint makes it easier to write low-level interop code in C#.</span></span> <span data-ttu-id="d4d86-134">Questo vincolo abilita le routine riutilizzabili in tutti i tipi non gestiti.</span><span class="sxs-lookup"><span data-stu-id="d4d86-134">This constraint enables reusable routines across all unmanaged types.</span></span> <span data-ttu-id="d4d86-135">Il vincolo `unmanaged` non può essere combinato con il vincolo `class` o `struct`.</span><span class="sxs-lookup"><span data-stu-id="d4d86-135">The `unmanaged` constraint can't be combined with the `class` or `struct` constraint.</span></span> <span data-ttu-id="d4d86-136">Il vincolo `unmanaged` impone che il tipo deve essere un elemento `struct`:</span><span class="sxs-lookup"><span data-stu-id="d4d86-136">The `unmanaged` constraint enforces that the type must be a `struct`:</span></span>

[!code-csharp[using the unmanaged constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#4)]

<span data-ttu-id="d4d86-137">La clausola `where` può anche includere un vincolo di costruttore, `new()`.</span><span class="sxs-lookup"><span data-stu-id="d4d86-137">The `where` clause may also include a constructor constraint, `new()`.</span></span> <span data-ttu-id="d4d86-138">Tale vincolo consente di creare un'istanza di un parametro di tipo usando l'operatore `new`.</span><span class="sxs-lookup"><span data-stu-id="d4d86-138">That constraint makes it possible to create an instance of a type parameter using the `new` operator.</span></span> <span data-ttu-id="d4d86-139">Il [vincolo new()](new-constraint.md) consente al compilatore di sapere che qualsiasi argomento di tipo fornito deve avere un costruttore senza parametri accessibile.</span><span class="sxs-lookup"><span data-stu-id="d4d86-139">The [new() Constraint](new-constraint.md) lets the compiler know that any type argument supplied must have an accessible parameterless constructor.</span></span> <span data-ttu-id="d4d86-140">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="d4d86-140">For example:</span></span>

[!code-csharp[using the new constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#5)]

<span data-ttu-id="d4d86-141">Il vincolo `new()` viene visualizzato per ultimo nella clausola `where`.</span><span class="sxs-lookup"><span data-stu-id="d4d86-141">The `new()` constraint appears last in the `where` clause.</span></span> <span data-ttu-id="d4d86-142">Il vincolo `new()` non può essere combinato con i vincoli `struct` o `unmanaged`.</span><span class="sxs-lookup"><span data-stu-id="d4d86-142">The `new()` constraint can't be combined with the `struct` or `unmanaged` constraints.</span></span> <span data-ttu-id="d4d86-143">Tutti i tipi che soddisfano i vincoli devono avere un costruttore senza parametri accessibile, per rendere il vincolo `new()` ridondante.</span><span class="sxs-lookup"><span data-stu-id="d4d86-143">All types satisfying those constraints must have an accessible parameterless constructor, making the `new()` constraint redundant.</span></span>

<span data-ttu-id="d4d86-144">Con più parametri di tipo, usare una clausola `where` per ogni parametro di tipo, ad esempio:</span><span class="sxs-lookup"><span data-stu-id="d4d86-144">With multiple type parameters, use one `where` clause for each type parameter, for example:</span></span>

[!code-csharp[using multiple where constraints](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#6)]

<span data-ttu-id="d4d86-145">È anche possibile associare vincoli ai parametri di tipo di metodi generici, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="d4d86-145">You can also attach constraints to type parameters of generic methods, as shown in the following example:</span></span>

[!code-csharp[where constraints with generic methods](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#7)]

<span data-ttu-id="d4d86-146">Si noti che la sintassi usata per descrivere i vincoli dei parametri di tipo per i delegati è uguale a quella dei metodi:</span><span class="sxs-lookup"><span data-stu-id="d4d86-146">Notice that the syntax to describe type parameter constraints on delegates is the same as that of methods:</span></span>

[!code-csharp[where constraints with generic methods](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#8)]

<span data-ttu-id="d4d86-147">Per informazioni sui delegati generici, vedere [Delegati generici](../../programming-guide/generics/generic-delegates.md).</span><span class="sxs-lookup"><span data-stu-id="d4d86-147">For information on generic delegates, see [Generic Delegates](../../programming-guide/generics/generic-delegates.md).</span></span>

<span data-ttu-id="d4d86-148">Per informazioni dettagliate sulla sintassi e sull'uso dei vincoli, vedere [Vincoli sui parametri di tipo](../../programming-guide/generics/constraints-on-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="d4d86-148">For details on the syntax and use of constraints, see [Constraints on Type Parameters](../../programming-guide/generics/constraints-on-type-parameters.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="d4d86-149">Specifiche del linguaggio C#</span><span class="sxs-lookup"><span data-stu-id="d4d86-149">C# language specification</span></span>

 [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]

## <a name="see-also"></a><span data-ttu-id="d4d86-150">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="d4d86-150">See also</span></span>

- [<span data-ttu-id="d4d86-151">Guida di riferimento a C</span><span class="sxs-lookup"><span data-stu-id="d4d86-151">C# Reference</span></span>](../index.md)
- [<span data-ttu-id="d4d86-152">Guida alla programmazione in C</span><span class="sxs-lookup"><span data-stu-id="d4d86-152">C# Programming Guide</span></span>](../../programming-guide/index.md)
- [<span data-ttu-id="d4d86-153">Introduzione ai generics</span><span class="sxs-lookup"><span data-stu-id="d4d86-153">Introduction to Generics</span></span>](../../programming-guide/generics/index.md)
- [<span data-ttu-id="d4d86-154">nuovo vincolo</span><span class="sxs-lookup"><span data-stu-id="d4d86-154">new Constraint</span></span>](./new-constraint.md)
- [<span data-ttu-id="d4d86-155">Vincoli sui parametri di tipo</span><span class="sxs-lookup"><span data-stu-id="d4d86-155">Constraints on Type Parameters</span></span>](../../programming-guide/generics/constraints-on-type-parameters.md)
