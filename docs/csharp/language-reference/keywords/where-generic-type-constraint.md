---
title: where (vincolo di tipo generico) - Riferimenti per C#
ms.date: 04/15/2020
f1_keywords:
- whereconstraint
- whereconstraint_CSharpKeyword
helpviewer_keywords:
- where (generic type constraint) [C#]
ms.openlocfilehash: 406c710cd884363c32b98336717732a09b3d1fc1
ms.sourcegitcommit: f8c270376ed905f6a8896ce0fe25b4f4b38ff498
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/04/2020
ms.locfileid: "84401875"
---
# <a name="where-generic-type-constraint-c-reference"></a><span data-ttu-id="61bee-102">where (vincolo di tipo generico) (Riferimenti per C#)</span><span class="sxs-lookup"><span data-stu-id="61bee-102">where (generic type constraint) (C# Reference)</span></span>

<span data-ttu-id="61bee-103">La clausola `where` in una definizione generica specifica i vincoli per i tipi che vengono usati come argomenti per i parametri di tipo in un tipo generico, metodo, delegato o funzione locale.</span><span class="sxs-lookup"><span data-stu-id="61bee-103">The `where` clause in a generic definition specifies constraints on the types that are used as arguments for type parameters in a generic type, method, delegate, or local function.</span></span> <span data-ttu-id="61bee-104">I vincoli possono specificare interfacce, classi base o richiedere che un tipo generico sia un riferimento, un valore o un tipo non gestito.</span><span class="sxs-lookup"><span data-stu-id="61bee-104">Constraints can specify interfaces, base classes, or require a generic type to be a reference, value, or unmanaged type.</span></span> <span data-ttu-id="61bee-105">Dichiarano le funzionalità che l'argomento di tipo deve avere.</span><span class="sxs-lookup"><span data-stu-id="61bee-105">They declare capabilities that the type argument must have.</span></span>

<span data-ttu-id="61bee-106">Ad esempio, una classe generica, `MyGenericClass`, può essere dichiarata in modo che tramite il parametro di tipo `T` venga implementata l'interfaccia <xref:System.IComparable%601>:</span><span class="sxs-lookup"><span data-stu-id="61bee-106">For example, you can declare a generic class, `MyGenericClass`, such that the type parameter `T` implements the <xref:System.IComparable%601> interface:</span></span>

[!code-csharp[using an interface constraint](snippets/GenericWhereConstraints.cs#1)]

> [!NOTE]
> <span data-ttu-id="61bee-107">Per altre informazioni sulla clausola where in un'espressione di query, vedere [Clausola where](where-clause.md).</span><span class="sxs-lookup"><span data-stu-id="61bee-107">For more information on the where clause in a query expression, see [where clause](where-clause.md).</span></span>

<span data-ttu-id="61bee-108">La clausola `where` può inoltre includere un vincolo di classe di base.</span><span class="sxs-lookup"><span data-stu-id="61bee-108">The `where` clause can also include a base class constraint.</span></span> <span data-ttu-id="61bee-109">Il vincolo della classe base dichiara che un tipo da usare come argomento di tipo per il tipo generico ha la classe specificata come classe di base o è tale classe base.</span><span class="sxs-lookup"><span data-stu-id="61bee-109">The base class constraint states that a type to be used as a type argument for that generic type has the specified class as a base class, or is that base class.</span></span> <span data-ttu-id="61bee-110">Se viene usato il vincolo della classe di base, deve apparire prima di tutti gli altri vincoli per quel parametro di tipo.</span><span class="sxs-lookup"><span data-stu-id="61bee-110">If the base class constraint is used, it must appear before any other constraints on that type parameter.</span></span> <span data-ttu-id="61bee-111">Alcuni tipi non sono consentiti come vincoli di classe di base: <xref:System.Object>, <xref:System.Array> e <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="61bee-111">Some types are disallowed as a base class constraint: <xref:System.Object>, <xref:System.Array>, and <xref:System.ValueType>.</span></span> <span data-ttu-id="61bee-112">Prima di C# 7,3,, <xref:System.Enum> <xref:System.Delegate> e non <xref:System.MulticastDelegate> sono consentiti come vincoli di classe di base.</span><span class="sxs-lookup"><span data-stu-id="61bee-112">Before C# 7.3, <xref:System.Enum>, <xref:System.Delegate>, and <xref:System.MulticastDelegate> were also disallowed as base class constraints.</span></span> <span data-ttu-id="61bee-113">L'esempio seguente illustra i tipi possono ora essere specificati come una classe di base:</span><span class="sxs-lookup"><span data-stu-id="61bee-113">The following example shows the types that can now be specified as a base class:</span></span>

[!code-csharp[using an interface constraint](snippets/GenericWhereConstraints.cs#2)]

<span data-ttu-id="61bee-114">In un contesto nullable in C# 8,0 e versioni successive, viene applicato il supporto di valori null del tipo di classe base.</span><span class="sxs-lookup"><span data-stu-id="61bee-114">In a nullable context in C# 8.0 and later, the nullability of the base class type is enforced.</span></span> <span data-ttu-id="61bee-115">Se la classe base è non Nullable (ad esempio `Base` ), l'argomento di tipo deve essere non nullable.</span><span class="sxs-lookup"><span data-stu-id="61bee-115">If the base class is non-nullable (for example `Base`), the type argument must be non-nullable.</span></span> <span data-ttu-id="61bee-116">Se la classe di base ammette i valori null (ad esempio `Base?` ), l'argomento di tipo può essere un tipo di riferimento nullable o non nullable.</span><span class="sxs-lookup"><span data-stu-id="61bee-116">If the base class is nullable (for example `Base?`), the type argument may be either a nullable or non-nullable reference type.</span></span> <span data-ttu-id="61bee-117">Il compilatore genera un avviso se l'argomento di tipo è un tipo di riferimento Nullable quando la classe base è non nullable.</span><span class="sxs-lookup"><span data-stu-id="61bee-117">The compiler issues a warning if the type argument is a nullable reference type when the base class is non-nullable.</span></span>

<span data-ttu-id="61bee-118">La clausola `where` può specificare che il tipo è un oggetto `class` o `struct`.</span><span class="sxs-lookup"><span data-stu-id="61bee-118">The `where` clause can specify that the type is a `class` or a `struct`.</span></span> <span data-ttu-id="61bee-119">Il vincolo `struct` elimina la necessità di specificare un vincolo di classe di base di `System.ValueType`.</span><span class="sxs-lookup"><span data-stu-id="61bee-119">The `struct` constraint removes the need to specify a base class constraint of `System.ValueType`.</span></span> <span data-ttu-id="61bee-120">Il tipo `System.ValueType` non può essere usato come vincolo di classe di base.</span><span class="sxs-lookup"><span data-stu-id="61bee-120">The `System.ValueType` type may not be used as a base class constraint.</span></span> <span data-ttu-id="61bee-121">Nell'esempio seguente vengono illustrati i vincoli `class` e `struct`:</span><span class="sxs-lookup"><span data-stu-id="61bee-121">The following example shows both the `class` and `struct` constraints:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#3)]

<span data-ttu-id="61bee-122">In un contesto nullable in C# 8,0 e versioni successive, il `class` vincolo richiede che un tipo sia un tipo di riferimento non nullable.</span><span class="sxs-lookup"><span data-stu-id="61bee-122">In a nullable context in C# 8.0 and later, the `class` constraint requires a type to be a non-nullable reference type.</span></span> <span data-ttu-id="61bee-123">Per consentire i tipi di riferimento Nullable, usare il `class?` vincolo, che consente i tipi di riferimento nullable e non nullable.</span><span class="sxs-lookup"><span data-stu-id="61bee-123">To allow nullable reference types, use the `class?` constraint, which allows both nullable and non-nullable reference types.</span></span>

<span data-ttu-id="61bee-124">La `where` clausola può includere il `notnull` vincolo.</span><span class="sxs-lookup"><span data-stu-id="61bee-124">The `where` clause may include the `notnull` constraint.</span></span> <span data-ttu-id="61bee-125">Il `notnull` vincolo limita il parametro di tipo ai tipi che non ammettono valori null.</span><span class="sxs-lookup"><span data-stu-id="61bee-125">The `notnull` constraint limits the type parameter to non-nullable types.</span></span> <span data-ttu-id="61bee-126">Il tipo può essere un [tipo di valore](../builtin-types/value-types.md) o un tipo di riferimento non nullable.</span><span class="sxs-lookup"><span data-stu-id="61bee-126">That type may be a [value type](../builtin-types/value-types.md) or a non-nullable reference type.</span></span> <span data-ttu-id="61bee-127">Il `notnull` vincolo è disponibile a partire da C# 8,0 per il codice compilato in un [ `nullable enable` contesto](../../nullable-references.md#nullable-contexts).</span><span class="sxs-lookup"><span data-stu-id="61bee-127">The `notnull` constraint is available starting in C# 8.0 for code compiled in a [`nullable enable` context](../../nullable-references.md#nullable-contexts).</span></span> <span data-ttu-id="61bee-128">Diversamente da altri vincoli, se un argomento di tipo viola il `notnull` vincolo, il compilatore genera un avviso anziché un errore.</span><span class="sxs-lookup"><span data-stu-id="61bee-128">Unlike other constraints, if a type argument violates the `notnull` constraint, the compiler generates a warning instead of an error.</span></span> <span data-ttu-id="61bee-129">Gli avvisi vengono generati solo in un `nullable enable` contesto.</span><span class="sxs-lookup"><span data-stu-id="61bee-129">Warnings are only generated in a `nullable enable` context.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="61bee-130">Le dichiarazioni generiche che includono il `notnull` vincolo possono essere utilizzate in un contesto ignaro Nullable, ma il compilatore non impone il vincolo.</span><span class="sxs-lookup"><span data-stu-id="61bee-130">Generic declarations that include the `notnull` constraint can be used in a nullable oblivious context, but compiler does not enforce the constraint.</span></span>

[!code-csharp[using the nonnull constraint](snippets/GenericWhereConstraints.cs#NotNull)]

<span data-ttu-id="61bee-131">La clausola `where` può anche includere un vincolo `unmanaged`.</span><span class="sxs-lookup"><span data-stu-id="61bee-131">The `where` clause may also include an `unmanaged` constraint.</span></span> <span data-ttu-id="61bee-132">Il vincolo `unmanaged` limita il parametro di tipo ai tipi noti come [tipi non gestiti](../builtin-types/unmanaged-types.md).</span><span class="sxs-lookup"><span data-stu-id="61bee-132">The `unmanaged` constraint limits the type parameter to types known as [unmanaged types](../builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="61bee-133">Il vincolo `unmanaged` rende più semplice la scrittura di codice di interoperabilità di basso livello in C#.</span><span class="sxs-lookup"><span data-stu-id="61bee-133">The `unmanaged` constraint makes it easier to write low-level interop code in C#.</span></span> <span data-ttu-id="61bee-134">Questo vincolo abilita le routine riutilizzabili in tutti i tipi non gestiti.</span><span class="sxs-lookup"><span data-stu-id="61bee-134">This constraint enables reusable routines across all unmanaged types.</span></span> <span data-ttu-id="61bee-135">Il vincolo `unmanaged` non può essere combinato con il vincolo `class` o `struct`.</span><span class="sxs-lookup"><span data-stu-id="61bee-135">The `unmanaged` constraint can't be combined with the `class` or `struct` constraint.</span></span> <span data-ttu-id="61bee-136">Il vincolo `unmanaged` impone che il tipo deve essere un elemento `struct`:</span><span class="sxs-lookup"><span data-stu-id="61bee-136">The `unmanaged` constraint enforces that the type must be a `struct`:</span></span>

[!code-csharp[using the unmanaged constraint](snippets/GenericWhereConstraints.cs#4)]

<span data-ttu-id="61bee-137">La clausola `where` può anche includere un vincolo di costruttore, `new()`.</span><span class="sxs-lookup"><span data-stu-id="61bee-137">The `where` clause may also include a constructor constraint, `new()`.</span></span> <span data-ttu-id="61bee-138">Tale vincolo consente di creare un'istanza di un parametro di tipo usando l'operatore `new`.</span><span class="sxs-lookup"><span data-stu-id="61bee-138">That constraint makes it possible to create an instance of a type parameter using the `new` operator.</span></span> <span data-ttu-id="61bee-139">Il [vincolo New ()](new-constraint.md) consente al compilatore di verificare che qualsiasi argomento di tipo fornito disponga di un costruttore senza parametri accessibile.</span><span class="sxs-lookup"><span data-stu-id="61bee-139">The [new() Constraint](new-constraint.md) lets the compiler know that any type argument supplied must have an accessible parameterless constructor.</span></span> <span data-ttu-id="61bee-140">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="61bee-140">For example:</span></span>

[!code-csharp[using the new constraint](snippets/GenericWhereConstraints.cs#5)]

<span data-ttu-id="61bee-141">Il vincolo `new()` viene visualizzato per ultimo nella clausola `where`.</span><span class="sxs-lookup"><span data-stu-id="61bee-141">The `new()` constraint appears last in the `where` clause.</span></span> <span data-ttu-id="61bee-142">Il vincolo `new()` non può essere combinato con i vincoli `struct` o `unmanaged`.</span><span class="sxs-lookup"><span data-stu-id="61bee-142">The `new()` constraint can't be combined with the `struct` or `unmanaged` constraints.</span></span> <span data-ttu-id="61bee-143">Tutti i tipi che soddisfano i vincoli devono avere un costruttore senza parametri accessibile, per rendere il vincolo `new()` ridondante.</span><span class="sxs-lookup"><span data-stu-id="61bee-143">All types satisfying those constraints must have an accessible parameterless constructor, making the `new()` constraint redundant.</span></span>

<span data-ttu-id="61bee-144">Con più parametri di tipo, usare una clausola `where` per ogni parametro di tipo, ad esempio:</span><span class="sxs-lookup"><span data-stu-id="61bee-144">With multiple type parameters, use one `where` clause for each type parameter, for example:</span></span>

[!code-csharp[using multiple where constraints](snippets/GenericWhereConstraints.cs#6)]

<span data-ttu-id="61bee-145">È anche possibile associare vincoli ai parametri di tipo di metodi generici, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="61bee-145">You can also attach constraints to type parameters of generic methods, as shown in the following example:</span></span>

[!code-csharp[where constraints with generic methods](snippets/GenericWhereConstraints.cs#7)]

<span data-ttu-id="61bee-146">Si noti che la sintassi usata per descrivere i vincoli dei parametri di tipo per i delegati è uguale a quella dei metodi:</span><span class="sxs-lookup"><span data-stu-id="61bee-146">Notice that the syntax to describe type parameter constraints on delegates is the same as that of methods:</span></span>

[!code-csharp[where constraints with generic methods](snippets/GenericWhereConstraints.cs#8)]

<span data-ttu-id="61bee-147">Per informazioni sui delegati generici, vedere [Delegati generici](../../programming-guide/generics/generic-delegates.md).</span><span class="sxs-lookup"><span data-stu-id="61bee-147">For information on generic delegates, see [Generic Delegates](../../programming-guide/generics/generic-delegates.md).</span></span>

<span data-ttu-id="61bee-148">Per informazioni dettagliate sulla sintassi e sull'uso dei vincoli, vedere [Vincoli sui parametri di tipo](../../programming-guide/generics/constraints-on-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="61bee-148">For details on the syntax and use of constraints, see [Constraints on Type Parameters](../../programming-guide/generics/constraints-on-type-parameters.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="61bee-149">Specifiche del linguaggio C#</span><span class="sxs-lookup"><span data-stu-id="61bee-149">C# language specification</span></span>

 [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]

## <a name="see-also"></a><span data-ttu-id="61bee-150">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="61bee-150">See also</span></span>

- [<span data-ttu-id="61bee-151">Riferimenti per C#</span><span class="sxs-lookup"><span data-stu-id="61bee-151">C# Reference</span></span>](../index.md)
- [<span data-ttu-id="61bee-152">Guida per programmatori C#</span><span class="sxs-lookup"><span data-stu-id="61bee-152">C# Programming Guide</span></span>](../../programming-guide/index.md)
- [<span data-ttu-id="61bee-153">Introduzione ai generics</span><span class="sxs-lookup"><span data-stu-id="61bee-153">Introduction to Generics</span></span>](../../programming-guide/generics/index.md)
- [<span data-ttu-id="61bee-154">nuovo vincolo</span><span class="sxs-lookup"><span data-stu-id="61bee-154">new Constraint</span></span>](./new-constraint.md)
- [<span data-ttu-id="61bee-155">Vincoli sui parametri di tipo</span><span class="sxs-lookup"><span data-stu-id="61bee-155">Constraints on Type Parameters</span></span>](../../programming-guide/generics/constraints-on-type-parameters.md)
