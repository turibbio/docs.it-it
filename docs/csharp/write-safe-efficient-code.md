---
title: Scrivere codice C# sicuro ed efficiente
description: I recenti miglioramenti apportati al linguaggio C# consentono di scrivere codice sicuro verificabile, con prestazioni superiori a quelle in precedenza associate al codice non gestito.
ms.date: 03/17/2020
ms.technology: csharp-advanced-concepts
ms.custom: mvc
ms.openlocfilehash: dc697d822c4d471d2b67ce074ab9af8fc2724b23
ms.sourcegitcommit: c91110ef6ee3fedb591f3d628dc17739c4a7071e
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/15/2020
ms.locfileid: "81389676"
---
# <a name="write-safe-and-efficient-c-code"></a><span data-ttu-id="a9e52-103">Scrivere codice C# sicuro ed efficiente</span><span class="sxs-lookup"><span data-stu-id="a9e52-103">Write safe and efficient C# code</span></span>

<span data-ttu-id="a9e52-104">Le nuove funzionalità di C# consentono di scrivere codice sicuro verificabile con prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="a9e52-104">New features in C# enable you to write verifiable safe code with better performance.</span></span> <span data-ttu-id="a9e52-105">Se si applicano queste tecniche attentamente, un numero inferiore di scenari richiede codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="a9e52-105">If you carefully apply these techniques, fewer scenarios require unsafe code.</span></span> <span data-ttu-id="a9e52-106">Queste funzionalità semplificano l'uso dei riferimenti ai tipi valore come argomenti di metodo e valori restituiti di metodi.</span><span class="sxs-lookup"><span data-stu-id="a9e52-106">These features make it easier to use references to value types as method arguments and method returns.</span></span> <span data-ttu-id="a9e52-107">Se eseguite in modo sicuro, queste tecniche riducono al minimo la copia dei tipi valore.</span><span class="sxs-lookup"><span data-stu-id="a9e52-107">When done safely, these techniques minimize copying value types.</span></span> <span data-ttu-id="a9e52-108">Usando i tipi valore, è possibile ridurre al minimo il numero di allocazioni e di passaggi di Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="a9e52-108">By using value types, you can minimize the number of allocations and garbage collection passes.</span></span>

<span data-ttu-id="a9e52-109">Gran parte del codice di esempio in questo articolo usa le funzionalità aggiunte in C# 7.2.</span><span class="sxs-lookup"><span data-stu-id="a9e52-109">Much of the sample code in this article uses features added in C# 7.2.</span></span> <span data-ttu-id="a9e52-110">Per usare tali funzionalità, è necessario configurare il progetto per l'uso di C# 7.2 o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="a9e52-110">To use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="a9e52-111">Per ulteriori informazioni sull'impostazione della versione della lingua, vedere [configurare la versione della lingua](language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="a9e52-111">For more information on setting the language version, see [configure the language version](language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="a9e52-112">Questo articolo è incentrato sulle tecniche per la gestione efficiente delle risorse.</span><span class="sxs-lookup"><span data-stu-id="a9e52-112">This article focuses on techniques for efficient resource management.</span></span> <span data-ttu-id="a9e52-113">Un vantaggio dell'uso dei tipi valore è che spesso evitano le allocazioni di heap.</span><span class="sxs-lookup"><span data-stu-id="a9e52-113">One advantage to using value types is that they often avoid heap allocations.</span></span> <span data-ttu-id="a9e52-114">Lo svantaggio è invece che vengono copiati in base al valore.</span><span class="sxs-lookup"><span data-stu-id="a9e52-114">The disadvantage is that they're copied by value.</span></span> <span data-ttu-id="a9e52-115">Questo compromesso rende più difficile ottimizzare gli algoritmi che operano su grandi quantità di dati.</span><span class="sxs-lookup"><span data-stu-id="a9e52-115">This trade-off makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="a9e52-116">Le nuove funzionalità del linguaggio C# 7.2 forniscono meccanismi che abilitano il codice sicuro efficiente tramite i riferimenti ai tipi valore.</span><span class="sxs-lookup"><span data-stu-id="a9e52-116">New language features in C# 7.2 provide mechanisms that enable safe efficient code using references to value types.</span></span> <span data-ttu-id="a9e52-117">Usare queste funzionalità con criterio, per ridurre al minimo sia le allocazioni che le operazioni di copia.</span><span class="sxs-lookup"><span data-stu-id="a9e52-117">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="a9e52-118">Questo articolo esamina le nuove funzionalità.</span><span class="sxs-lookup"><span data-stu-id="a9e52-118">This article explores those new features.</span></span>

<span data-ttu-id="a9e52-119">Questo articolo è incentrato sulle tecniche per la gestione delle risorse seguenti:</span><span class="sxs-lookup"><span data-stu-id="a9e52-119">This article focuses on the following resource management techniques:</span></span>

- <span data-ttu-id="a9e52-120">Dichiarare [`readonly struct`](language-reference/builtin-types/struct.md#readonly-struct) un per esprimere che un tipo non è **modificabile.**</span><span class="sxs-lookup"><span data-stu-id="a9e52-120">Declare a [`readonly struct`](language-reference/builtin-types/struct.md#readonly-struct) to express that a type is **immutable**.</span></span> <span data-ttu-id="a9e52-121">Ciò consente al compilatore di [`in`](language-reference/keywords/in-parameter-modifier.md) salvare copie difensive quando si utilizzano parametri.</span><span class="sxs-lookup"><span data-stu-id="a9e52-121">That enables the compiler to save defensive copies when using [`in`](language-reference/keywords/in-parameter-modifier.md) parameters.</span></span>
- <span data-ttu-id="a9e52-122">Se un tipo non può essere immutabile, dichiarare `struct` i membri [`readonly`](language-reference/builtin-types/struct.md#readonly-instance-members) per indicare che il membro non modifica lo stato.</span><span class="sxs-lookup"><span data-stu-id="a9e52-122">If a type can't be immutable, declare `struct` members [`readonly`](language-reference/builtin-types/struct.md#readonly-instance-members) to indicate that the member doesn't modify state.</span></span>
- <span data-ttu-id="a9e52-123">Utilizzare [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) un valore restituito quando `struct` il <xref:System.IntPtr.Size?displayProperty=nameWithType> valore restituito è maggiore di e la durata di archiviazione è maggiore del metodo che restituisce il valore.</span><span class="sxs-lookup"><span data-stu-id="a9e52-123">Use a [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) return when the return value is a `struct` larger than <xref:System.IntPtr.Size?displayProperty=nameWithType> and the storage lifetime is greater than the method returning the value.</span></span>
- <span data-ttu-id="a9e52-124">Quando le dimensioni di `readonly struct` sono maggiori di <xref:System.IntPtr.Size?displayProperty=nameWithType>, è consigliabile passarle come parametro `in` per motivi di prestazioni.</span><span class="sxs-lookup"><span data-stu-id="a9e52-124">When the size of a `readonly struct` is bigger than <xref:System.IntPtr.Size?displayProperty=nameWithType>, you should pass it as an `in` parameter for performance reasons.</span></span>
- <span data-ttu-id="a9e52-125">Non passare `struct` mai `in` un come parametro `readonly` a meno che `readonly` non venga dichiarato con il modificatore o il metodo non chiami solo i membri dello struct.</span><span class="sxs-lookup"><span data-stu-id="a9e52-125">Never pass a `struct` as an `in` parameter unless it's declared with the `readonly` modifier or the method calls only `readonly` members of the struct.</span></span> <span data-ttu-id="a9e52-126">La violazione di queste indicazioni può influire negativamente sulle prestazioni e potrebbe portare a un comportamento oscuro.</span><span class="sxs-lookup"><span data-stu-id="a9e52-126">Violating this guidance may negatively affect performance and could lead to an obscure behavior.</span></span>
- <span data-ttu-id="a9e52-127">Utilizzare [`ref struct`](language-reference/keywords/ref.md#ref-struct-types)un oggetto `readonly ref struct` , <xref:System.Span%601> <xref:System.ReadOnlySpan%601> o ad esempio o per lavorare con la memoria come sequenza di byte.</span><span class="sxs-lookup"><span data-stu-id="a9e52-127">Use a [`ref struct`](language-reference/keywords/ref.md#ref-struct-types), or a `readonly ref struct` such as <xref:System.Span%601> or <xref:System.ReadOnlySpan%601> to work with memory as a sequence of bytes.</span></span>

<span data-ttu-id="a9e52-128">Queste tecniche obbligano a trovare un compromesso tra due obiettivi opposti in termini di **riferimenti** e **valori**.</span><span class="sxs-lookup"><span data-stu-id="a9e52-128">These techniques force you to balance two competing goals with regard to **references** and **values**.</span></span> <span data-ttu-id="a9e52-129">Le variabili che sono [tipi riferimento](programming-guide/types/index.md#reference-types) contengono un riferimento alla posizione in memoria.</span><span class="sxs-lookup"><span data-stu-id="a9e52-129">Variables that are [reference types](programming-guide/types/index.md#reference-types) hold a reference to the location in memory.</span></span> <span data-ttu-id="a9e52-130">Le variabili che sono [tipi valore](programming-guide/types/index.md#value-types) contengono direttamente il rispettivo valore.</span><span class="sxs-lookup"><span data-stu-id="a9e52-130">Variables that are [value types](programming-guide/types/index.md#value-types) directly contain their value.</span></span> <span data-ttu-id="a9e52-131">Queste caratteristiche evidenziano le principali differenze da tenere in considerazione per la gestione delle risorse della memoria.</span><span class="sxs-lookup"><span data-stu-id="a9e52-131">These differences highlight the key differences that are important for managing memory resources.</span></span> <span data-ttu-id="a9e52-132">I **tipi valore** vengono in genere copiati se passati a un metodo o restituiti da un metodo.</span><span class="sxs-lookup"><span data-stu-id="a9e52-132">**Value types** are typically copied when passed to a method or returned from a method.</span></span> <span data-ttu-id="a9e52-133">Questo comportamento include la copia del valore di `this` quando si chiamano i membri di un tipo valore.</span><span class="sxs-lookup"><span data-stu-id="a9e52-133">This behavior includes copying the value of `this` when calling members of a value type.</span></span> <span data-ttu-id="a9e52-134">Il costo della copia è correlato alla dimensione del tipo.</span><span class="sxs-lookup"><span data-stu-id="a9e52-134">The cost of the copy is related to the size of the type.</span></span> <span data-ttu-id="a9e52-135">I **tipi riferimento** vengono allocati nell'heap gestito.</span><span class="sxs-lookup"><span data-stu-id="a9e52-135">**Reference types** are allocated on the managed heap.</span></span> <span data-ttu-id="a9e52-136">Ogni nuovo oggetto richiede una nuova allocazione e successivamente deve essere recuperato.</span><span class="sxs-lookup"><span data-stu-id="a9e52-136">Each new object requires a new allocation, and subsequently must be reclaimed.</span></span> <span data-ttu-id="a9e52-137">Entrambe queste operazioni richiedono tempo.</span><span class="sxs-lookup"><span data-stu-id="a9e52-137">Both these operations take time.</span></span> <span data-ttu-id="a9e52-138">Il riferimento viene copiato quando un tipo riferimento viene passato come argomento a un metodo o restituito da un metodo.</span><span class="sxs-lookup"><span data-stu-id="a9e52-138">The reference is copied when a reference type is passed as an argument to a method or returned from a method.</span></span>

<span data-ttu-id="a9e52-139">Questo articolo usa il concetto di esempio seguente relativo alla struttura di punti 3D per illustrare queste raccomandazioni:</span><span class="sxs-lookup"><span data-stu-id="a9e52-139">This article uses the following example concept of the 3D-point structure to explain these recommendations:</span></span>

```csharp
public struct Point3D
{
    public double X;
    public double Y;
    public double Z;
}
```

<span data-ttu-id="a9e52-140">Le implementazioni di questo concetto variano a seconda degli esempi.</span><span class="sxs-lookup"><span data-stu-id="a9e52-140">Different examples use different implementations of this concept.</span></span>

## <a name="declare-readonly-structs-for-immutable-value-types"></a><span data-ttu-id="a9e52-141">Dichiarare struct readonly per tipi valore non modificabili</span><span class="sxs-lookup"><span data-stu-id="a9e52-141">Declare readonly structs for immutable value types</span></span>

<span data-ttu-id="a9e52-142">Dichiarando uno `struct` tramite il modificatore `readonly`, si informa il compilatore che la finalità è la creazione di un tipo non modificabile.</span><span class="sxs-lookup"><span data-stu-id="a9e52-142">Declaring a `struct` using the `readonly` modifier informs the compiler that your intent is to create an immutable type.</span></span> <span data-ttu-id="a9e52-143">Il compilatore applica tale decisione di progettazione con le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="a9e52-143">The compiler enforces that design decision with the following rules:</span></span>

- <span data-ttu-id="a9e52-144">Tutti i membri dei campi devono essere `readonly`</span><span class="sxs-lookup"><span data-stu-id="a9e52-144">All field members must be `readonly`</span></span>
- <span data-ttu-id="a9e52-145">Tutte le proprietà devono essere di sola lettura, incluse le proprietà implementate automaticamente.</span><span class="sxs-lookup"><span data-stu-id="a9e52-145">All properties must be read-only, including auto-implemented properties.</span></span>

<span data-ttu-id="a9e52-146">Queste due regole sono sufficienti a garantire che nessun membro di un `readonly struct` modifichi lo stato di tale struct.</span><span class="sxs-lookup"><span data-stu-id="a9e52-146">These two rules are sufficient to ensure that no member of a `readonly struct` modifies the state of that struct.</span></span> <span data-ttu-id="a9e52-147">Lo `struct` non è modificabile.</span><span class="sxs-lookup"><span data-stu-id="a9e52-147">The `struct` is immutable.</span></span> <span data-ttu-id="a9e52-148">La struttura `Point3D` può essere definita come struct non modificabile, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="a9e52-148">The `Point3D` structure could be defined as an immutable struct as shown in the following example:</span></span>

```csharp
readonly public struct ReadonlyPoint3D
{
    public ReadonlyPoint3D(double x, double y, double z)
    {
        this.X = x;
        this.Y = y;
        this.Z = z;
    }

    public double X { get; }
    public double Y { get; }
    public double Z { get; }
}
```

<span data-ttu-id="a9e52-149">Seguire questa raccomandazione quando la finalità della progettazione è la creazione di un tipo valore non modificabile.</span><span class="sxs-lookup"><span data-stu-id="a9e52-149">Follow this recommendation whenever your design intent is to create an immutable value type.</span></span> <span data-ttu-id="a9e52-150">Qualsiasi miglioramento delle prestazioni comporta un ulteriore vantaggio.</span><span class="sxs-lookup"><span data-stu-id="a9e52-150">Any performance improvements are an added benefit.</span></span> <span data-ttu-id="a9e52-151">Il `readonly struct` esprime chiaramente la finalità della progettazione.</span><span class="sxs-lookup"><span data-stu-id="a9e52-151">The `readonly struct` clearly expresses your design intent.</span></span>

## <a name="declare-readonly-members-when-a-struct-cant-be-immutable"></a><span data-ttu-id="a9e52-152">Dichiarare membri readonly quando uno struct non può essere immutabileDeclare readonly members when a struct can't be immutable</span><span class="sxs-lookup"><span data-stu-id="a9e52-152">Declare readonly members when a struct can't be immutable</span></span>

<span data-ttu-id="a9e52-153">Quando un tipo struct è modificabile, in Cè 8.0 e versioni successive, `readonly`è necessario dichiarare i membri che non causano la mutazione.</span><span class="sxs-lookup"><span data-stu-id="a9e52-153">In C# 8.0 and later, when a struct type is mutable, you should declare members that don't cause mutation to be `readonly`.</span></span> <span data-ttu-id="a9e52-154">Si consideri un'applicazione diversa che richiede una struttura di punti 3D, ma deve supportare la mutabilità.</span><span class="sxs-lookup"><span data-stu-id="a9e52-154">Consider a different application that needs a 3D point structure, but must support mutability.</span></span> <span data-ttu-id="a9e52-155">La versione seguente della struttura dei `readonly` punti 3D aggiunge il modificatore solo ai membri che non modificano la struttura.</span><span class="sxs-lookup"><span data-stu-id="a9e52-155">The following version of the 3D point structure adds the `readonly` modifier only to those members that don't modify the structure.</span></span> <span data-ttu-id="a9e52-156">Seguire questo esempio quando la progettazione deve supportare le modifiche apportate allo struct da parte di alcuni membri, ma si desidera comunque i vantaggi derivanti dall'applicazione di readonly su alcuni membri:</span><span class="sxs-lookup"><span data-stu-id="a9e52-156">Follow this example when your design must support modifications to the struct by some members, but you still want the benefits of enforcing readonly on some members:</span></span>

```csharp
public struct Point3D
{
    public Point3D(double x, double y, double z)
    {
        _x = x;
        _y = y;
        _z = z;
    }

    private double _x;
    public double X
    {
        readonly get => _x;
        set => _x = value;
    }

    private double _y;
    public double Y
    {
        readonly get => _y;
        set => _y = value;
    }

    private double _z;
    public double Z
    {
        readonly get => _z;
        set => _z = value;
    }

    public readonly double Distance => Math.Sqrt(X * X + Y * Y + Z * Z);

    public readonly override string ToString() => $"{X}, {Y}, {Z}";
}
```

<span data-ttu-id="a9e52-157">Nell'esempio precedente vengono illustrate molte delle `readonly` posizioni in cui è possibile applicare il modificatore: metodi, proprietà e funzioni di accesso alle proprietà.</span><span class="sxs-lookup"><span data-stu-id="a9e52-157">The preceding sample shows many of the locations where you can apply the `readonly` modifier: methods, properties, and property accessors.</span></span> <span data-ttu-id="a9e52-158">Se si utilizzano proprietà implementate `readonly` automaticamente, `get` il compilatore aggiunge il modificatore alla funzione di accesso per le proprietà di lettura/scrittura.</span><span class="sxs-lookup"><span data-stu-id="a9e52-158">If you use auto-implemented properties, the compiler adds the `readonly` modifier to the `get` accessor for read-write properties.</span></span> <span data-ttu-id="a9e52-159">Il compilatore `readonly` aggiunge il modificatore alle dichiarazioni di `get` proprietà implementate automaticamente per le proprietà con solo una funzione di accesso.</span><span class="sxs-lookup"><span data-stu-id="a9e52-159">The compiler adds the `readonly` modifier to the auto-implemented property declarations for properties with only a `get` accessor.</span></span>

<span data-ttu-id="a9e52-160">L'aggiunta del `readonly` modificatore ai membri che non modificano lo stato offre due vantaggi correlati.</span><span class="sxs-lookup"><span data-stu-id="a9e52-160">Adding the `readonly` modifier to members that don't mutate state provides two related benefits.</span></span> <span data-ttu-id="a9e52-161">In primo luogo, il compilatore applica l'intento.</span><span class="sxs-lookup"><span data-stu-id="a9e52-161">First, the compiler enforces your intent.</span></span> <span data-ttu-id="a9e52-162">Tale membro non può mutare lo stato dello struct.</span><span class="sxs-lookup"><span data-stu-id="a9e52-162">That member can't mutate the struct's state.</span></span> <span data-ttu-id="a9e52-163">In secondo luogo, il compilatore `in` non creerà `readonly` copie difensive dei parametri quando si accede a un membro.</span><span class="sxs-lookup"><span data-stu-id="a9e52-163">Second, the compiler won't create defensive copies of `in` parameters when accessing a `readonly` member.</span></span> <span data-ttu-id="a9e52-164">Il compilatore può rendere questa ottimizzazione `struct` in modo `readonly` sicuro perché garantisce che l'oggetto non viene modificato da un membro.</span><span class="sxs-lookup"><span data-stu-id="a9e52-164">The compiler can make this optimization safely because it guarantees that the `struct` is not modified by a `readonly` member.</span></span>

## <a name="use-ref-readonly-return-statements-for-large-structures-when-possible"></a><span data-ttu-id="a9e52-165">Usare le istruzioni `ref readonly return` per le strutture di grandi dimensioni, se possibile</span><span class="sxs-lookup"><span data-stu-id="a9e52-165">Use `ref readonly return` statements for large structures when possible</span></span>

<span data-ttu-id="a9e52-166">È possibile restituire i valori per riferimento quando il valore restituito non è locale per il metodo di restituzione.</span><span class="sxs-lookup"><span data-stu-id="a9e52-166">You can return values by reference when the value being returned isn't local to the returning method.</span></span> <span data-ttu-id="a9e52-167">Con la restituzione per riferimento viene copiato solo il riferimento, non la struttura.</span><span class="sxs-lookup"><span data-stu-id="a9e52-167">Returning by reference means that only the reference is copied, not the structure.</span></span> <span data-ttu-id="a9e52-168">Nell'esempio seguente la proprietà `Origin` non può usare un valore restituito `ref` perché il valore da restituire è una variabile locale:</span><span class="sxs-lookup"><span data-stu-id="a9e52-168">In the following example, the `Origin` property can't use a `ref` return because the value being returned is a local variable:</span></span>

```csharp
public Point3D Origin => new Point3D(0,0,0);
```

<span data-ttu-id="a9e52-169">La definizione della proprietà seguente può tuttavia essere restituita per riferimento perché il valore restituito è un membro statico:</span><span class="sxs-lookup"><span data-stu-id="a9e52-169">However, the following property definition can be returned by reference because the returned value is a static member:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    // Dangerous! returning a mutable reference to internal storage
    public ref Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="a9e52-170">Per fare in modo che i chiamanti non modifichino l'origine, restituire il valore per `ref readonly`:</span><span class="sxs-lookup"><span data-stu-id="a9e52-170">You don't want callers modifying the origin, so you should return the value by `ref readonly`:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    public static ref readonly Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="a9e52-171">La restituzione di `ref readonly` consente un risparmio a livello di copie di strutture di dimensioni maggiori e di mantenere l'immutabilità dei membri dati interni.</span><span class="sxs-lookup"><span data-stu-id="a9e52-171">Returning `ref readonly` enables you to save copying larger structures and preserve the immutability of your internal data members.</span></span>

<span data-ttu-id="a9e52-172">Nel sito della chiamata i chiamanti scelgono di usare la proprietà `Origin` come `ref readonly` o come valore:</span><span class="sxs-lookup"><span data-stu-id="a9e52-172">At the call site, callers make the choice to use the `Origin` property as a `ref readonly` or as a value:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="a9e52-173">La prima assegnazione del codice precedente crea una copia della costante `Origin` e assegna tale copia.</span><span class="sxs-lookup"><span data-stu-id="a9e52-173">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="a9e52-174">La seconda assegna un riferimento.</span><span class="sxs-lookup"><span data-stu-id="a9e52-174">The second assigns a reference.</span></span> <span data-ttu-id="a9e52-175">Si noti che il modificatore `readonly` deve fare parte della dichiarazione della variabile.</span><span class="sxs-lookup"><span data-stu-id="a9e52-175">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="a9e52-176">Il riferimento a cui viene fatto riferimento non può essere modificato.</span><span class="sxs-lookup"><span data-stu-id="a9e52-176">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="a9e52-177">I tentativi di eseguire questa operazione generano un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="a9e52-177">Attempts to do so result in a compile-time error.</span></span>

<span data-ttu-id="a9e52-178">Il modificatore `readonly` è necessario nella dichiarazione di `originReference`.</span><span class="sxs-lookup"><span data-stu-id="a9e52-178">The `readonly` modifier is required on the declaration of `originReference`.</span></span>

<span data-ttu-id="a9e52-179">Il compilatore fa in modo che il chiamante non possa modificare il riferimento.</span><span class="sxs-lookup"><span data-stu-id="a9e52-179">The compiler enforces that the caller can't modify the reference.</span></span> <span data-ttu-id="a9e52-180">I tentativi di assegnazione diretta del valore generano un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="a9e52-180">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="a9e52-181">Il compilatore non può tuttavia sapere se un metodo del membro modifica lo stato dello struct.</span><span class="sxs-lookup"><span data-stu-id="a9e52-181">However, the compiler can't know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="a9e52-182">Per assicurarsi che l'oggetto non venga modificato, il compilatore crea una copia e chiama i riferimenti al membro usando tale copia.</span><span class="sxs-lookup"><span data-stu-id="a9e52-182">To ensure that the object isn't modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="a9e52-183">Tutte le modifiche vengono apportate a tale copia difensiva.</span><span class="sxs-lookup"><span data-stu-id="a9e52-183">Any modifications are to that defensive copy.</span></span>

## <a name="apply-the-in-modifier-to-readonly-struct-parameters-larger-than-systemintptrsize"></a><span data-ttu-id="a9e52-184">Applicare il modificatore `in` ai parametri `readonly struct` maggiori di `System.IntPtr.Size`</span><span class="sxs-lookup"><span data-stu-id="a9e52-184">Apply the `in` modifier to `readonly struct` parameters larger than `System.IntPtr.Size`</span></span>

<span data-ttu-id="a9e52-185">La parola chiave `in` è completare alle parole chiave `ref` e `out` esistenti per passare gli argomenti per riferimento.</span><span class="sxs-lookup"><span data-stu-id="a9e52-185">The `in` keyword complements the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="a9e52-186">La parola chiave `in` specifica il passaggio dell'argomento per riferimento, ma il metodo chiamato non modifica il valore.</span><span class="sxs-lookup"><span data-stu-id="a9e52-186">The `in` keyword specifies passing the argument by reference, but the called method doesn't modify the value.</span></span>

<span data-ttu-id="a9e52-187">Questa aggiunta fornisce un vocabolario completo per esprimere le finalità di progettazione.</span><span class="sxs-lookup"><span data-stu-id="a9e52-187">This addition provides a full vocabulary to express your design intent.</span></span>
<span data-ttu-id="a9e52-188">I tipi valore vengono copiati quando vengono passati a un metodo chiamato se nella firma del metodo non si specifica alcuno dei modificatori seguenti.</span><span class="sxs-lookup"><span data-stu-id="a9e52-188">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="a9e52-189">Ognuno di questi modificatori specifica che una variabile viene passata per riferimento, evitando la copia.</span><span class="sxs-lookup"><span data-stu-id="a9e52-189">Each of these modifiers specifies that a variable is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="a9e52-190">Ogni modificatore esprime una finalità diversa:</span><span class="sxs-lookup"><span data-stu-id="a9e52-190">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="a9e52-191">`out`: questo metodo imposta il valore dell'argomento usato come parametro.</span><span class="sxs-lookup"><span data-stu-id="a9e52-191">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="a9e52-192">`ref`: questo metodo può impostare il valore dell'argomento usato come parametro.</span><span class="sxs-lookup"><span data-stu-id="a9e52-192">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="a9e52-193">`in`: questo metodo non modifica il valore dell'argomento utilizzato come parametro.</span><span class="sxs-lookup"><span data-stu-id="a9e52-193">`in`: This method doesn't modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="a9e52-194">Aggiungere il modificatore `in` per passare un argomento per riferimento e dichiarare che la finalità di passare argomenti per riferimento, per evitare operazioni di copia non necessarie,</span><span class="sxs-lookup"><span data-stu-id="a9e52-194">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="a9e52-195">non quella di modificare l'oggetto usato come argomento.</span><span class="sxs-lookup"><span data-stu-id="a9e52-195">You don't intend to modify the object used as that argument.</span></span>

<span data-ttu-id="a9e52-196">Questa procedura spesso migliora le prestazioni per i tipi valore readonly di dimensioni superiori a <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a9e52-196">This practice often improves performance for readonly value types that are larger than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a9e52-197">Per i tipi semplici (tipi `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` e `bool` ed `enum`), i potenziali miglioramenti alle prestazioni sono minimi.</span><span class="sxs-lookup"><span data-stu-id="a9e52-197">For simple types (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` and `bool`, and `enum` types), any potential performance gains are minimal.</span></span> <span data-ttu-id="a9e52-198">Le prestazioni potrebbero infatti peggiorare usando il passaggio per riferimento per i tipi con dimensioni inferiori a <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a9e52-198">In fact, performance may degrade by using pass-by-reference for types smaller than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="a9e52-199">Il codice seguente illustra un esempio di metodo che calcola la distanza tra due punti nello spazio 3D.</span><span class="sxs-lookup"><span data-stu-id="a9e52-199">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span>

[!code-csharp[InArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="a9e52-200">Gli argomenti sono due strutture, contenenti ognuna tre valori double.</span><span class="sxs-lookup"><span data-stu-id="a9e52-200">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="a9e52-201">Un valore double è pari a 8 byte, quindi ogni argomento è pari a 24 byte.</span><span class="sxs-lookup"><span data-stu-id="a9e52-201">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="a9e52-202">Specificando il modificatore `in`, si passa un riferimento a 4 byte o 8 byte a tali argomenti, a seconda dell'architettura del computer.</span><span class="sxs-lookup"><span data-stu-id="a9e52-202">By specifying the `in` modifier, you pass a 4 byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="a9e52-203">La differenza a livello di dimensioni è piccola, ma aumenta quando l'applicazione chiama questo metodo in un ciclo ridotto usando più valori diversi.</span><span class="sxs-lookup"><span data-stu-id="a9e52-203">The difference in size is small, but it adds up when your application calls this method in a tight loop using many different values.</span></span>

<span data-ttu-id="a9e52-204">Il modificatore `in` integra `out` e `ref` anche in altri modi.</span><span class="sxs-lookup"><span data-stu-id="a9e52-204">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="a9e52-205">Non è possibile creare overload di un metodo che si distinguono solo per la presenza di `in`, `out` o `ref`.</span><span class="sxs-lookup"><span data-stu-id="a9e52-205">You can't create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="a9e52-206">Queste nuove regole estendono lo stesso comportamento da sempre definito per i parametri `out` e `ref`.</span><span class="sxs-lookup"><span data-stu-id="a9e52-206">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span> <span data-ttu-id="a9e52-207">Come i modificatori `out` e `ref`, i tipi valore non sono boxed perché viene applicato il modificatore `in`.</span><span class="sxs-lookup"><span data-stu-id="a9e52-207">Like the `out` and `ref` modifiers, value types aren't boxed because the `in` modifier is applied.</span></span>

<span data-ttu-id="a9e52-208">Il modificatore `in` può essere applicato a tutti i membri che accettano parametri: metodi, delegati, espressioni lambda, funzioni locali, indicizzatori, operatori.</span><span class="sxs-lookup"><span data-stu-id="a9e52-208">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="a9e52-209">Un'altra caratteristica dei parametri `in` è che è possibile usare valori letterali o costanti per l'argomento in un parametro `in`.</span><span class="sxs-lookup"><span data-stu-id="a9e52-209">Another feature of `in` parameters is that you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="a9e52-210">Inoltre, diversamente da un parametro `ref` o `out`, non è necessario applicare il modificatore `in` nel sito di chiamata.</span><span class="sxs-lookup"><span data-stu-id="a9e52-210">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="a9e52-211">Il codice seguente illustra due esempi di chiamata al metodo `CalculateDistance`.</span><span class="sxs-lookup"><span data-stu-id="a9e52-211">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="a9e52-212">Il primo usa due variabili locali passate per riferimento.</span><span class="sxs-lookup"><span data-stu-id="a9e52-212">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="a9e52-213">Il secondo include una variabile temporanea creata durante la chiamata al metodo.</span><span class="sxs-lookup"><span data-stu-id="a9e52-213">The second includes a temporary variable created as part of the method call.</span></span>

[!code-csharp[UseInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="a9e52-214">Il compilatore applica la natura di sola lettura di un argomento `in` in diversi modi.</span><span class="sxs-lookup"><span data-stu-id="a9e52-214">There are several ways in which the compiler enforces the read-only nature of an `in` argument.</span></span>  <span data-ttu-id="a9e52-215">Prima di tutto il metodo chiamato non può essere direttamente assegnato a un parametro `in`.</span><span class="sxs-lookup"><span data-stu-id="a9e52-215">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="a9e52-216">Non può essere direttamente assegnato ai campi di un parametro `in` se quel valore è un tipo `struct`.</span><span class="sxs-lookup"><span data-stu-id="a9e52-216">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="a9e52-217">Non è neppure possibile passare un parametro `in` a metodi che usano il modificatore `ref` o `out`.</span><span class="sxs-lookup"><span data-stu-id="a9e52-217">In addition, you can't pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="a9e52-218">Queste regole sono valide per qualsiasi campo di un parametro `in`, a condizione che il campo sia di tipo `struct` e che anche il parametro sia di tipo `struct`.</span><span class="sxs-lookup"><span data-stu-id="a9e52-218">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="a9e52-219">Queste regole, in effetti, vengono applicate per più livelli di accesso ai membri, a condizione che a tutti i livelli di accesso ai membri i tipi siano `structs`.</span><span class="sxs-lookup"><span data-stu-id="a9e52-219">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span>
<span data-ttu-id="a9e52-220">Il compilatore impone che i tipi `struct` passati come argomenti `in` e i relativi membri `struct` siano variabili di sola lettura, se usati come argomenti per altri metodi.</span><span class="sxs-lookup"><span data-stu-id="a9e52-220">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="a9e52-221">L'uso di parametri `in` consente di evitare i costi potenziali sulle prestazioni per l'esecuzione di copie,</span><span class="sxs-lookup"><span data-stu-id="a9e52-221">The use of `in` parameters can avoid the potential performance costs of making copies.</span></span> <span data-ttu-id="a9e52-222">ma non modifica la semantica delle chiamate a metodi.</span><span class="sxs-lookup"><span data-stu-id="a9e52-222">It doesn't change the semantics of any method call.</span></span> <span data-ttu-id="a9e52-223">Non è quindi necessario specificare il modificatore `in` presso il sito di chiamata.</span><span class="sxs-lookup"><span data-stu-id="a9e52-223">Therefore, you don't need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="a9e52-224">Omettendo il modificatore `in` presso il sito di chiamata si informa il compilatore che può effettuare una copia dell'argomento per i motivi seguenti:</span><span class="sxs-lookup"><span data-stu-id="a9e52-224">Omitting the `in` modifier at the call site informs the compiler that it's allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="a9e52-225">Esiste una conversione implicita, ma non una conversione di identità dal tipo di argomento al tipo di parametro.</span><span class="sxs-lookup"><span data-stu-id="a9e52-225">There exists an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="a9e52-226">L'argomento è un'espressione, ma non ha una variabile di archiviazione nota.</span><span class="sxs-lookup"><span data-stu-id="a9e52-226">The argument is an expression but doesn't have a known storage variable.</span></span>
- <span data-ttu-id="a9e52-227">È presente un overload diverso per la presenza o l'assenza di `in`.</span><span class="sxs-lookup"><span data-stu-id="a9e52-227">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="a9e52-228">In tal caso, l'overload in base al valore è una corrispondenza migliore.</span><span class="sxs-lookup"><span data-stu-id="a9e52-228">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="a9e52-229">Queste regole sono utili quando si aggiorna codice esistente per usare argomenti di riferimento di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="a9e52-229">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="a9e52-230">All'interno del metodo chiamato è possibile chiamare qualsiasi metodo di istanza che usa parametri in base al valore.</span><span class="sxs-lookup"><span data-stu-id="a9e52-230">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="a9e52-231">In tali istanze viene creata una copia del parametro `in`.</span><span class="sxs-lookup"><span data-stu-id="a9e52-231">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="a9e52-232">Poiché il compilatore può creare una variabile temporanea per qualsiasi parametro `in`, è anche possibile specificare i valori predefiniti per qualsiasi parametro `in`.</span><span class="sxs-lookup"><span data-stu-id="a9e52-232">Because the compiler may create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="a9e52-233">Il codice seguente specifica l'origine (punto 0,0) come valore predefinito per il secondo punto:</span><span class="sxs-lookup"><span data-stu-id="a9e52-233">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="a9e52-234">Per imporre al compilatore di passare argomenti di sola lettura per riferimento, specificare il modificatore `in` per gli argomenti presso il sito di chiamata, come illustrato nel codice seguente:</span><span class="sxs-lookup"><span data-stu-id="a9e52-234">To force the compiler to pass read-only arguments by reference, specify the `in` modifier on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="a9e52-235">Questo comportamento semplifica nel tempo l'adozione di parametri `in` in codebase di grandi dimensioni in cui è possibile ottenere miglioramenti delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="a9e52-235">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="a9e52-236">È prima necessario aggiungere il modificatore `in` alle firme dei metodi.</span><span class="sxs-lookup"><span data-stu-id="a9e52-236">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="a9e52-237">È quindi possibile aggiungere il modificatore `in` presso i siti di chiamata e creare tipi `readonly struct` per consentire al compilatore di evitare di creare copie difensive di parametri `in` in altre posizioni.</span><span class="sxs-lookup"><span data-stu-id="a9e52-237">Then, you can add the `in` modifier at call sites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="a9e52-238">La designazione del parametro `in` può anche essere usata con tipi riferimento o valori numerici.</span><span class="sxs-lookup"><span data-stu-id="a9e52-238">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="a9e52-239">Gli eventuali vantaggi in entrambi i casi sono tuttavia minimi.</span><span class="sxs-lookup"><span data-stu-id="a9e52-239">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="avoid-mutable-structs-as-an-in-argument"></a><span data-ttu-id="a9e52-240">Evitare struct modificabili `in` come argomentoAvoid mutable structs as an argument</span><span class="sxs-lookup"><span data-stu-id="a9e52-240">Avoid mutable structs as an `in` argument</span></span>

<span data-ttu-id="a9e52-241">Le tecniche descritte in precedenza illustrano come evitare le copie restituendo i riferimenti e passando i valori per riferimento.</span><span class="sxs-lookup"><span data-stu-id="a9e52-241">The techniques described above explain how to avoid copies by returning references and passing values by reference.</span></span> <span data-ttu-id="a9e52-242">Queste tecniche garantiscono prestazioni ottimali quando i tipi di argomenti vengono dichiarati come tipi `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="a9e52-242">These techniques work best when the argument types are declared as `readonly struct` types.</span></span> <span data-ttu-id="a9e52-243">In caso contrario, il compilatore deve creare **copie difensive** in molte situazioni per applicare la natura di sola lettura degli argomenti.</span><span class="sxs-lookup"><span data-stu-id="a9e52-243">Otherwise, the compiler must create **defensive copies** in many situations to enforce the readonly-ness of any arguments.</span></span> <span data-ttu-id="a9e52-244">Considerare l'esempio seguente che calcola la distanza di un punto 3D dall'origine:</span><span class="sxs-lookup"><span data-stu-id="a9e52-244">Consider the following example that calculates the distance of a 3D point from the origin:</span></span>

[!code-csharp[InArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="a9e52-245">La struttura `Point3D`*non* è uno struct readonly.</span><span class="sxs-lookup"><span data-stu-id="a9e52-245">The `Point3D` structure is *not* a readonly struct.</span></span> <span data-ttu-id="a9e52-246">Sono presenti sei diverse chiamate di accesso a proprietà nel corpo di questo metodo.</span><span class="sxs-lookup"><span data-stu-id="a9e52-246">There are six different property access calls in the body of this method.</span></span> <span data-ttu-id="a9e52-247">A un primo esame, si potrebbe pensare che questi accessi siano sicuri.</span><span class="sxs-lookup"><span data-stu-id="a9e52-247">On first examination, you may have thought these accesses were safe.</span></span> <span data-ttu-id="a9e52-248">Una funzione di accesso `get` infatti non dovrebbe modificare lo stato dell'oggetto,</span><span class="sxs-lookup"><span data-stu-id="a9e52-248">After all, a `get` accessor shouldn't modify the state of the object.</span></span> <span data-ttu-id="a9e52-249">ma nessuna regola del linguaggio lo impone.</span><span class="sxs-lookup"><span data-stu-id="a9e52-249">But there's no language rule that enforces that.</span></span> <span data-ttu-id="a9e52-250">È solo una convenzione comune.</span><span class="sxs-lookup"><span data-stu-id="a9e52-250">It's only a common convention.</span></span> <span data-ttu-id="a9e52-251">Qualsiasi tipo può implementare una funzione di accesso `get` che modifica lo stato interno.</span><span class="sxs-lookup"><span data-stu-id="a9e52-251">Any type could implement a `get` accessor that modified the internal state.</span></span> <span data-ttu-id="a9e52-252">Senza una certa garanzia del linguaggio, il compilatore deve creare `readonly` una copia temporanea dell'argomento prima di chiamare qualsiasi membro non contrassegnato con il modificatore.</span><span class="sxs-lookup"><span data-stu-id="a9e52-252">Without some language guarantee, the compiler must create a temporary copy of the argument before calling any member not marked with the `readonly` modifier.</span></span> <span data-ttu-id="a9e52-253">La risorsa di archiviazione temporanea viene creata nello stack, i valori dell'argomento vengono copiati nella risorsa di archiviazione temporanea e il valore viene copiato nello stack per ogni accesso ai membri come argomento `this`.</span><span class="sxs-lookup"><span data-stu-id="a9e52-253">The temporary storage is created on the stack, the values of the argument are copied to the temporary storage, and the value is copied to the stack for each member access as the `this` argument.</span></span> <span data-ttu-id="a9e52-254">In molte situazioni, queste copie danneggiano le prestazioni in modo sufficiente che il pass-by-value è `readonly struct` più veloce del riferimento pass-by-readonly quando il tipo di argomento non è un e il metodo chiama membri non contrassegnati `readonly`con .</span><span class="sxs-lookup"><span data-stu-id="a9e52-254">In many situations, these copies harm performance enough that pass-by-value is faster than pass-by-readonly-reference when the argument type isn't a `readonly struct` and the method calls members that aren't marked `readonly`.</span></span> <span data-ttu-id="a9e52-255">Se si contrassegnano tutti i metodi `readonly`che non modificano lo stato struct come , il compilatore può determinare in modo sicuro che lo stato struct non viene modificato e non è necessaria una copia difensiva.</span><span class="sxs-lookup"><span data-stu-id="a9e52-255">If you mark all methods that don't modify the struct state as `readonly`, the compiler can safely determine that the struct state isn't modified, and a defensive copy is not needed.</span></span>

<span data-ttu-id="a9e52-256">Al contrario, se il calcolo della `ReadonlyPoint3D`distanza utilizza lo struct non modificabile, non sono necessari oggetti temporanei:</span><span class="sxs-lookup"><span data-stu-id="a9e52-256">Instead, if the distance calculation uses the immutable struct, `ReadonlyPoint3D`, temporary objects aren't needed:</span></span>

[!code-csharp[readonlyInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ReadOnlyInArgument "Specifying a readonly in argument")]

<span data-ttu-id="a9e52-257">Il compilatore genera codice più efficiente `readonly struct`quando `this` si chiamano i membri di un `in` oggetto : il riferimento, anziché una copia del ricevitore, è sempre un parametro passato per riferimento al metodo membro.</span><span class="sxs-lookup"><span data-stu-id="a9e52-257">The compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="a9e52-258">Questa ottimizzazione consente un risparmio a livello di copie quando si usa `readonly struct` come argomento `in`.</span><span class="sxs-lookup"><span data-stu-id="a9e52-258">This optimization saves copying when you use a `readonly struct` as an `in` argument.</span></span>

<span data-ttu-id="a9e52-259">Non è necessario passare un tipo di `in` valore nullable come argomento.</span><span class="sxs-lookup"><span data-stu-id="a9e52-259">You shouldn't pass a nullable value type as an `in` argument.</span></span> <span data-ttu-id="a9e52-260">Il <xref:System.Nullable%601> tipo non è dichiarato come struct di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="a9e52-260">The <xref:System.Nullable%601> type isn't declared as a read-only struct.</span></span> <span data-ttu-id="a9e52-261">Ciò significa che il compilatore deve generare le copie difensive di tutti gli argomenti del valore di tipo nullable passato a un metodo tramite il modificatore `in` nella dichiarazione del parametro.</span><span class="sxs-lookup"><span data-stu-id="a9e52-261">That means the compiler must generate defensive copies for any nullable value type argument passed to a method using the `in` modifier on the parameter declaration.</span></span>

<span data-ttu-id="a9e52-262">È possibile visualizzare un programma di esempio che illustra le differenze di prestazioni utilizzando [BenchmarkDotNet](https://www.nuget.org/packages/BenchmarkDotNet/) nel repository degli esempi su GitHub.You can see an example program that demonstrates the performance differences using BenchmarkDotNet in our [samples repository](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) on GitHub.</span><span class="sxs-lookup"><span data-stu-id="a9e52-262">You can see an example program that demonstrates the performance differences using [BenchmarkDotNet](https://www.nuget.org/packages/BenchmarkDotNet/) in our [samples repository](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) on GitHub.</span></span> <span data-ttu-id="a9e52-263">Viene confrontato il passaggio di uno struct modificabile per valore e per riferimento con il passaggio di uno struct non modificabile per valore e per riferimento.</span><span class="sxs-lookup"><span data-stu-id="a9e52-263">It compares passing a mutable struct by value and by reference with passing an immutable struct by value and by reference.</span></span> <span data-ttu-id="a9e52-264">L'uso dello struct non modificabile e del passaggio per riferimento è più veloce.</span><span class="sxs-lookup"><span data-stu-id="a9e52-264">The use of the immutable struct and pass by reference is fastest.</span></span>

## <a name="use-ref-struct-types-to-work-with-blocks-or-memory-on-a-single-stack-frame"></a><span data-ttu-id="a9e52-265">Usare i tipi `ref struct` per lavorare con i blocchi o la memoria in un singolo stack frame</span><span class="sxs-lookup"><span data-stu-id="a9e52-265">Use `ref struct` types to work with blocks or memory on a single stack frame</span></span>

<span data-ttu-id="a9e52-266">Una funzionalità del linguaggio correlata è la possibilità di dichiarare un tipo valore che deve essere vincolato a un singolo stack frame.</span><span class="sxs-lookup"><span data-stu-id="a9e52-266">A related language feature is the ability to declare a value type that must be constrained to a single stack frame.</span></span> <span data-ttu-id="a9e52-267">Questa restrizione consente al compilatore di eseguire diverse ottimizzazioni.</span><span class="sxs-lookup"><span data-stu-id="a9e52-267">This restriction enables the compiler to make several optimizations.</span></span> <span data-ttu-id="a9e52-268">La principale motivazione di questa funzionalità sono stati <xref:System.Span%601> e le strutture correlate.</span><span class="sxs-lookup"><span data-stu-id="a9e52-268">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="a9e52-269">Da questi miglioramenti si otterranno prestazioni più avanzate grazie alle API .NET nuove e aggiornate che usano il tipo <xref:System.Span%601>.</span><span class="sxs-lookup"><span data-stu-id="a9e52-269">You'll achieve performance improvements from these enhancements by using new and updated .NET APIs that make use of the <xref:System.Span%601> type.</span></span>

<span data-ttu-id="a9e52-270">È possibile avere requisiti simili [`stackalloc`](language-reference/operators/stackalloc.md) quando si usa la memoria creata con o quando si usa memoria dalle API di interoperabilità.</span><span class="sxs-lookup"><span data-stu-id="a9e52-270">You may have similar requirements working with memory created using [`stackalloc`](language-reference/operators/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="a9e52-271">È possibile definire i tipi `ref struct` in base a tali esigenze.</span><span class="sxs-lookup"><span data-stu-id="a9e52-271">You can define your own `ref struct` types for those needs.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="a9e52-272">Tipo di`readonly ref struct`</span><span class="sxs-lookup"><span data-stu-id="a9e52-272">`readonly ref struct` type</span></span>

<span data-ttu-id="a9e52-273">Dichiarando uno struct come `readonly ref` si combinano i vantaggi e le restrizioni delle dichiarazioni `ref struct` e `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="a9e52-273">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations.</span></span> <span data-ttu-id="a9e52-274">La memoria usata dallo span di sola lettura è limitata a un singolo stack frame e non può essere modificata.</span><span class="sxs-lookup"><span data-stu-id="a9e52-274">The memory used by the readonly span is restricted to a single stack frame, and the memory used by the readonly span can't be modified.</span></span>

## <a name="conclusions"></a><span data-ttu-id="a9e52-275">Conclusioni</span><span class="sxs-lookup"><span data-stu-id="a9e52-275">Conclusions</span></span>

<span data-ttu-id="a9e52-276">L'uso di tipi valore ridice al minimo il numero di operazioni di allocazione:</span><span class="sxs-lookup"><span data-stu-id="a9e52-276">Using value types minimizes the number of allocation operations:</span></span>

- <span data-ttu-id="a9e52-277">Lo spazio di archiviazione per i tipi valore viene allocato nello stack per le variabili locali e gli argomenti dei metodi.</span><span class="sxs-lookup"><span data-stu-id="a9e52-277">Storage for value types is stack allocated for local variables and method arguments.</span></span>
- <span data-ttu-id="a9e52-278">Lo spazio di archiviazione per i tipi valore membri di altri oggetti viene allocato come parte dell'oggetto, non come allocazione separata.</span><span class="sxs-lookup"><span data-stu-id="a9e52-278">Storage for value types that are members of other objects is allocated as part of that object, not as a separate allocation.</span></span>
- <span data-ttu-id="a9e52-279">Lo spazio di archiviazione per i valori restituiti dei tipi valore viene allocato nello stack.</span><span class="sxs-lookup"><span data-stu-id="a9e52-279">Storage for value type return values is stack allocated.</span></span>

<span data-ttu-id="a9e52-280">Confrontare questi tipi con i tipi riferimento nelle stesse situazioni:</span><span class="sxs-lookup"><span data-stu-id="a9e52-280">Contrast that with reference types in those same situations:</span></span>

- <span data-ttu-id="a9e52-281">Lo spazio di archiviazione per i tipi riferimento viene allocato nell'heap per le variabili locali e gli argomenti dei metodi.</span><span class="sxs-lookup"><span data-stu-id="a9e52-281">Storage for reference types are heap allocated for local variables and method arguments.</span></span> <span data-ttu-id="a9e52-282">Il riferimento è archiviato nello stack.</span><span class="sxs-lookup"><span data-stu-id="a9e52-282">The reference is stored on the stack.</span></span>
- <span data-ttu-id="a9e52-283">Lo spazio di archiviazione per i tipi riferimento membri di altri oggetti viene allocato separatamente nell'heap.</span><span class="sxs-lookup"><span data-stu-id="a9e52-283">Storage for reference types that are members of other objects are separately allocated on the heap.</span></span> <span data-ttu-id="a9e52-284">L'oggetto contenitore archivia il riferimento.</span><span class="sxs-lookup"><span data-stu-id="a9e52-284">The containing object stores the reference.</span></span>
- <span data-ttu-id="a9e52-285">Lo spazio di archiviazione per i valori restituiti dei tipi riferimento viene allocato nell'heap.</span><span class="sxs-lookup"><span data-stu-id="a9e52-285">Storage for reference type return values is heap allocated.</span></span> <span data-ttu-id="a9e52-286">Il riferimento a tale spazio di archiviazione è archiviato nello stack.</span><span class="sxs-lookup"><span data-stu-id="a9e52-286">The reference to that storage is stored on the stack.</span></span>

<span data-ttu-id="a9e52-287">La riduzione al minimo delle allocazioni richiede alcuni compromessi.</span><span class="sxs-lookup"><span data-stu-id="a9e52-287">Minimizing allocations comes with tradeoffs.</span></span> <span data-ttu-id="a9e52-288">Si copia più memoria quando le dimensioni dello `struct` sono superiori a quelle di un riferimento.</span><span class="sxs-lookup"><span data-stu-id="a9e52-288">You copy more memory when the size of the `struct` is larger than the size of a reference.</span></span> <span data-ttu-id="a9e52-289">Un riferimento è in genere a 64 bit o a 32 bit e dipende dalla CPU del computer di destinazione.</span><span class="sxs-lookup"><span data-stu-id="a9e52-289">A reference is typically 64 bits or 32 bits, and depends on the target machine CPU.</span></span>

<span data-ttu-id="a9e52-290">Questi compromessi in genere hanno un impatto minimo sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="a9e52-290">These tradeoffs generally have minimal performance impact.</span></span> <span data-ttu-id="a9e52-291">Tuttavia, per gli struct di grandi dimensioni o le raccolte di dimensioni maggiori, l'impatto sulle prestazioni aumenta.</span><span class="sxs-lookup"><span data-stu-id="a9e52-291">However, for large structs or larger collections, the performance impact increases.</span></span> <span data-ttu-id="a9e52-292">L'impatto può essere forte nei cicli ridotti e nei percorsi critici per i programmi.</span><span class="sxs-lookup"><span data-stu-id="a9e52-292">The impact can be large in tight loops and hot paths for programs.</span></span>

<span data-ttu-id="a9e52-293">Questi miglioramenti del linguaggio C# sono progettati per gli algoritmi con prestazioni critiche in cui la riduzione al minimo delle allocazioni della memoria è un fattore determinante per raggiungere le prestazioni necessarie.</span><span class="sxs-lookup"><span data-stu-id="a9e52-293">These enhancements to the C# language are designed for performance critical algorithms where minimizing memory allocations is a major factor in achieving the necessary performance.</span></span> <span data-ttu-id="a9e52-294">È possibile che non si usino spesso queste funzionalità nella scrittura del codice.</span><span class="sxs-lookup"><span data-stu-id="a9e52-294">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="a9e52-295">Tuttavia, questi miglioramenti sono stati adottati in .NET.</span><span class="sxs-lookup"><span data-stu-id="a9e52-295">However, these enhancements have been adopted throughout .NET.</span></span> <span data-ttu-id="a9e52-296">Il sempre maggior numero di API che useranno queste funzionalità renderà evidente il miglioramento delle prestazioni delle applicazioni.</span><span class="sxs-lookup"><span data-stu-id="a9e52-296">As more and more APIs make use of these features, you'll see the performance of your applications improve.</span></span>

## <a name="see-also"></a><span data-ttu-id="a9e52-297">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="a9e52-297">See also</span></span>

- [<span data-ttu-id="a9e52-298">ref (parola chiave)</span><span class="sxs-lookup"><span data-stu-id="a9e52-298">ref keyword</span></span>](language-reference/keywords/ref.md)
- [<span data-ttu-id="a9e52-299">Valori restituiti e variabili locali ref</span><span class="sxs-lookup"><span data-stu-id="a9e52-299">Ref returns and ref locals</span></span>](programming-guide/classes-and-structs/ref-returns.md)
