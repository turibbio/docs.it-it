---
title: Introduzione alla trasformazione della sintassi (API Roslyn)
description: Introduzione all'attraversamento, all'esecuzione di query e all'esplorazione di alberi della sintassi.
ms.date: 06/01/2018
ms.custom: mvc
ms.openlocfilehash: 232fe5fcba35f152dbc3f00b2f2c092b5df0dd35
ms.sourcegitcommit: de7f589de07a9979b6ac28f54c3e534a617d9425
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 05/05/2020
ms.locfileid: "82794793"
---
# <a name="get-started-with-syntax-transformation"></a><span data-ttu-id="06b4b-103">Introduzione alla trasformazione della sintassi</span><span class="sxs-lookup"><span data-stu-id="06b4b-103">Get started with syntax transformation</span></span>

<span data-ttu-id="06b4b-104">Questa esercitazione si basa sui concetti e sulle tecniche descritti nelle guide introduttive [Introduzione all'analisi della sintassi](syntax-analysis.md) e [Introduzione all'analisi semantica](semantic-analysis.md).</span><span class="sxs-lookup"><span data-stu-id="06b4b-104">This tutorial builds on concepts and techniques explored in the [Get started with syntax analysis](syntax-analysis.md) and [Get started with semantic analysis](semantic-analysis.md) quickstarts.</span></span> <span data-ttu-id="06b4b-105">Se non è già stato fatto, consultare tali guide introduttive prima di procedere con questa.</span><span class="sxs-lookup"><span data-stu-id="06b4b-105">If you haven't already, you should complete those quickstarts before beginning this one.</span></span>

<span data-ttu-id="06b4b-106">In questa guida verranno illustrate le tecniche per la creazione e la trasformazione degli alberi della sintassi.</span><span class="sxs-lookup"><span data-stu-id="06b4b-106">In this quickstart, you explore techniques for creating and transforming syntax trees.</span></span> <span data-ttu-id="06b4b-107">In combinazione con le tecniche apprese nelle guide precedenti, sarà possibile creare il primo refactoring dalla riga di comando.</span><span class="sxs-lookup"><span data-stu-id="06b4b-107">In combination with the techniques you learned in previous quickstarts, you create your first command-line refactoring!</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="immutability-and-the-net-compiler-platform"></a><span data-ttu-id="06b4b-108">Non modificabilità e piattaforma del compilatore .NET</span><span class="sxs-lookup"><span data-stu-id="06b4b-108">Immutability and the .NET compiler platform</span></span>

<span data-ttu-id="06b4b-109">La **non modificabilità** è un principio fondamentale della piattaforma del compilatore .NET.</span><span class="sxs-lookup"><span data-stu-id="06b4b-109">**Immutability** is a fundamental tenet of the .NET compiler platform.</span></span> <span data-ttu-id="06b4b-110">Le strutture di dati non modificabili non possono essere alterate dopo essere state create.</span><span class="sxs-lookup"><span data-stu-id="06b4b-110">Immutable data structures can't be changed after they're created.</span></span> <span data-ttu-id="06b4b-111">Le strutture di dati non modificabili possono essere condivise in modo sicuro e analizzate da più consumer contemporaneamente.</span><span class="sxs-lookup"><span data-stu-id="06b4b-111">Immutable data structures can be safely shared and analyzed by multiple consumers simultaneously.</span></span> <span data-ttu-id="06b4b-112">Non vi è alcun rischio che un consumer influisca su un altro in modi imprevedibili.</span><span class="sxs-lookup"><span data-stu-id="06b4b-112">There's no danger that one consumer affects another in unpredictable ways.</span></span> <span data-ttu-id="06b4b-113">L'analizzatore non richiede blocchi o altre misure di concorrenza.</span><span class="sxs-lookup"><span data-stu-id="06b4b-113">Your analyzer doesn't need locks or other concurrency measures.</span></span> <span data-ttu-id="06b4b-114">Questa regola si applica ad alberi della sintassi, compilazioni, simboli, modelli semantici e tutte le altre strutture di dati.</span><span class="sxs-lookup"><span data-stu-id="06b4b-114">This rule applies to syntax trees, compilations, symbols, semantic models, and every other data structure you encounter.</span></span> <span data-ttu-id="06b4b-115">Invece di modificare le strutture esistenti, le API creano nuovi oggetti in base alle differenze specificate rispetto a quelli precedenti.</span><span class="sxs-lookup"><span data-stu-id="06b4b-115">Instead of modifying existing structures, APIs create new objects based on specified differences to the old ones.</span></span> <span data-ttu-id="06b4b-116">È possibile applicare questo concetto agli alberi della sintassi per creare nuovi alberi tramite trasformazioni.</span><span class="sxs-lookup"><span data-stu-id="06b4b-116">You apply this concept to syntax trees to create new trees using transformations.</span></span>

## <a name="create-and-transform-trees"></a><span data-ttu-id="06b4b-117">Creare e trasformare alberi</span><span class="sxs-lookup"><span data-stu-id="06b4b-117">Create and transform trees</span></span>

<span data-ttu-id="06b4b-118">È possibile scegliere tra due strategie per le trasformazioni della sintassi.</span><span class="sxs-lookup"><span data-stu-id="06b4b-118">You choose one of two strategies for syntax transformations.</span></span> <span data-ttu-id="06b4b-119">I **metodi factory** sono particolarmente indicati per la ricerca di nodi specifici da sostituire o di posizioni specifiche in cui inserire nuovo codice.</span><span class="sxs-lookup"><span data-stu-id="06b4b-119">**Factory methods** are best used when you're searching for specific nodes to replace, or specific locations where you want to insert new code.</span></span> <span data-ttu-id="06b4b-120">I **rewriter** sono la soluzione migliore per analizzare un intero progetto alla ricerca di modelli di codice da sostituire.</span><span class="sxs-lookup"><span data-stu-id="06b4b-120">**Rewriters** are best when you want to scan an entire project for code patterns that you want to replace.</span></span>

### <a name="create-nodes-with-factory-methods"></a><span data-ttu-id="06b4b-121">Creare nodi con metodi factory</span><span class="sxs-lookup"><span data-stu-id="06b4b-121">Create nodes with factory methods</span></span>

<span data-ttu-id="06b4b-122">La prima trasformazione della sintassi illustra i metodi factory.</span><span class="sxs-lookup"><span data-stu-id="06b4b-122">The first syntax transformation demonstrates the factory methods.</span></span> <span data-ttu-id="06b4b-123">Si sostituirà un'istruzione `using System.Collections;` con un'istruzione `using System.Collections.Generic;`.</span><span class="sxs-lookup"><span data-stu-id="06b4b-123">You're going to replace a `using System.Collections;` statement with a `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="06b4b-124">Questo esempio illustra come creare oggetti <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> mediante i metodi factory <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="06b4b-124">This example demonstrates how you create <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> objects using the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> factory methods.</span></span> <span data-ttu-id="06b4b-125">Per ogni tipo di **nodo**, **token** o **elemento semplice** è disponibile un metodo factory che crea un'istanza del tipo corrispondente.</span><span class="sxs-lookup"><span data-stu-id="06b4b-125">For each kind of **node**, **token**, or **trivia** there's a factory method that creates an instance of that type.</span></span> <span data-ttu-id="06b4b-126">È possibile creare alberi della sintassi componendo gerarchicamente i nodi dal basso verso l'alto.</span><span class="sxs-lookup"><span data-stu-id="06b4b-126">You create syntax trees by composing nodes hierarchically in a bottom-up fashion.</span></span> <span data-ttu-id="06b4b-127">Si trasformerà quindi il programma esistente sostituendo i nodi esistenti con il nuovo albero creato.</span><span class="sxs-lookup"><span data-stu-id="06b4b-127">Then, you'll transform the existing program be replacing existing nodes with the new tree you've created.</span></span>

<span data-ttu-id="06b4b-128">Avviare Visual Studio e creare un nuovo progetto C# **Stand-Alone Code Analysis Tool** (Strumento di analisi del codice autonomo).</span><span class="sxs-lookup"><span data-stu-id="06b4b-128">Start Visual Studio, and create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="06b4b-129">In Visual Studio scegliere **file** > **nuovo** > **progetto** per visualizzare la finestra di dialogo nuovo progetto.</span><span class="sxs-lookup"><span data-stu-id="06b4b-129">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span> <span data-ttu-id="06b4b-130">In**Extensibility** di **Visual C#** > scegliere uno **strumento di analisi del codice autonomo**.</span><span class="sxs-lookup"><span data-stu-id="06b4b-130">Under **Visual C#** > **Extensibility** choose a **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="06b4b-131">Questa guida include due progetti di esempio, quindi denominare la soluzione **SyntaxTransformationQuickStart** e il progetto **ConstructionCS**.</span><span class="sxs-lookup"><span data-stu-id="06b4b-131">This quickstart has two example projects, so name the solution **SyntaxTransformationQuickStart**, and name the project **ConstructionCS**.</span></span> <span data-ttu-id="06b4b-132">Fare clic su **OK**.</span><span class="sxs-lookup"><span data-stu-id="06b4b-132">Click **OK**.</span></span>

<span data-ttu-id="06b4b-133">Questo progetto usa i metodi della classe <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> per costruire un <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> che rappresenta lo spazio dei nomi `System.Collections.Generic`.</span><span class="sxs-lookup"><span data-stu-id="06b4b-133">This project uses the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> class methods to construct a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> representing the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="06b4b-134">Aggiungere la direttiva using seguente all'inizio del file `Program.cs` per importare i metodi factory della classe <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> e i metodi di <xref:System.Console>, in modo da poterli usare in un secondo momento senza qualificarli:</span><span class="sxs-lookup"><span data-stu-id="06b4b-134">Add the following using directive to the top of the `Program.cs` file to import the factory methods of the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> class and the methods of <xref:System.Console> so that you can use them later without qualifying them:</span></span>

[!code-csharp[import the SyntaxFactory class](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#StaticUsings "import the Syntax Factory class and the System.Console class")]

<span data-ttu-id="06b4b-135">Verranno creati i **nodi della sintassi dei nomi** per creare l'albero che rappresenta l'istruzione `using System.Collections.Generic;`.</span><span class="sxs-lookup"><span data-stu-id="06b4b-135">You'll create **name syntax nodes** to build the tree that represents the `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="06b4b-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> è la classe di base per quattro tipi di nomi disponibili in C#.</span><span class="sxs-lookup"><span data-stu-id="06b4b-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> is the base class for four types of names that appear in C#.</span></span> <span data-ttu-id="06b4b-137">Questi quattro tipi di nomi possono essere combinati per creare qualsiasi nome disponibile nel linguaggio C#:</span><span class="sxs-lookup"><span data-stu-id="06b4b-137">You compose these four types of names together to create any name that can appear in the C# language:</span></span>

* <span data-ttu-id="06b4b-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, che rappresenta i nomi di singoli identificatori semplici, come `System` e `Microsoft`.</span><span class="sxs-lookup"><span data-stu-id="06b4b-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, which represents simple single identifier names like `System` and `Microsoft`.</span></span>
* <span data-ttu-id="06b4b-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, che rappresenta un nome di tipo o di metodo generico, come `List<int>`.</span><span class="sxs-lookup"><span data-stu-id="06b4b-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, which represents a generic type or method name such as `List<int>`.</span></span>
* <span data-ttu-id="06b4b-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, che rappresenta un nome completo nel formato `<left-name>.<right-identifier-or-generic-name>`, come `System.IO`.</span><span class="sxs-lookup"><span data-stu-id="06b4b-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, which represents a qualified name of the form `<left-name>.<right-identifier-or-generic-name>` such as `System.IO`.</span></span>
* <span data-ttu-id="06b4b-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, che rappresenta un nome usando un alias assembly extern, come `LibraryV2::Foo`.</span><span class="sxs-lookup"><span data-stu-id="06b4b-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, which represents a name using an assembly extern alias such a `LibraryV2::Foo`.</span></span>

<span data-ttu-id="06b4b-142">Usare il metodo <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> per creare un nodo <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="06b4b-142">You use the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> method to create a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> node.</span></span> <span data-ttu-id="06b4b-143">Aggiungere il codice seguente nel metodo `Main` in `Program.cs`:</span><span class="sxs-lookup"><span data-stu-id="06b4b-143">Add the following code in your `Main` method in `Program.cs`:</span></span>

[!code-csharp[create the system identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateIdentifierName "Create and display the system name identifier")]

<span data-ttu-id="06b4b-144">Il codice precedente crea un oggetto <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> e lo assegna alla variabile `name`.</span><span class="sxs-lookup"><span data-stu-id="06b4b-144">The preceding code creates an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> object and assigns it to the variable `name`.</span></span> <span data-ttu-id="06b4b-145">Molte API Roslyn restituiscono classi di base per agevolare l'uso dei tipi correlati.</span><span class="sxs-lookup"><span data-stu-id="06b4b-145">Many of the Roslyn APIs return base classes to make it easier to work with related types.</span></span> <span data-ttu-id="06b4b-146">La variabile `name`, un oggetto <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, può essere riutilizzata durante la creazione di <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="06b4b-146">The variable `name`, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, can be reused as you build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="06b4b-147">Non usare l'inferenza del tipo durante la creazione dell'esempio.</span><span class="sxs-lookup"><span data-stu-id="06b4b-147">Don't use type inference as you build the sample.</span></span> <span data-ttu-id="06b4b-148">Tale passaggio verrà automatizzato in questo progetto.</span><span class="sxs-lookup"><span data-stu-id="06b4b-148">You'll automate that step in this project.</span></span>

<span data-ttu-id="06b4b-149">Il nome è stato creato.</span><span class="sxs-lookup"><span data-stu-id="06b4b-149">You've created the name.</span></span> <span data-ttu-id="06b4b-150">A questo punto, è possibile creare altri nodi nell'albero compilando un oggetto <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="06b4b-150">Now, it's time to build more nodes into the tree by building a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="06b4b-151">Il nuovo albero usa `name` a sinistra del nome e una nuova <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> per lo spazio dei nomi `Collections` come lato destro dell'oggetto <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="06b4b-151">The new tree uses `name` as the left of the name, and a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> for the `Collections` namespace as the right side of the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="06b4b-152">Aggiungere il codice seguente a `program.cs`:</span><span class="sxs-lookup"><span data-stu-id="06b4b-152">Add the following code to `program.cs`:</span></span>

[!code-csharp[create the collections identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateQualifiedIdentifierName "Build the System.Collections identifier")]

<span data-ttu-id="06b4b-153">Eseguire nuovamente il codice e visualizzare i risultati.</span><span class="sxs-lookup"><span data-stu-id="06b4b-153">Run the code again, and see the results.</span></span> <span data-ttu-id="06b4b-154">Si sta creando un albero dei nodi che rappresenta il codice.</span><span class="sxs-lookup"><span data-stu-id="06b4b-154">You're building a tree of nodes that represents code.</span></span> <span data-ttu-id="06b4b-155">Si continuerà con questo modello per creare l'oggetto <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> per lo spazio dei nomi `System.Collections.Generic`.</span><span class="sxs-lookup"><span data-stu-id="06b4b-155">You'll continue this pattern to build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> for the namespace `System.Collections.Generic`.</span></span> <span data-ttu-id="06b4b-156">Aggiungere il codice seguente a `Program.cs`:</span><span class="sxs-lookup"><span data-stu-id="06b4b-156">Add the following code to `Program.cs`:</span></span>

[!code-csharp[create the full identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateFullNamespace "Build the System.Collections.Generic identifier")]

<span data-ttu-id="06b4b-157">Eseguire nuovamente il programma per verificare che sia stata compilata la struttura ad albero del codice da aggiungere.</span><span class="sxs-lookup"><span data-stu-id="06b4b-157">Run the program again to see that you've built the tree for the code to add.</span></span>

### <a name="create-a-modified-tree"></a><span data-ttu-id="06b4b-158">Creare una struttura modificata</span><span class="sxs-lookup"><span data-stu-id="06b4b-158">Create a modified tree</span></span>

<span data-ttu-id="06b4b-159">È stato creato un albero della sintassi di piccole dimensioni che contiene una sola istruzione.</span><span class="sxs-lookup"><span data-stu-id="06b4b-159">You've built a small syntax tree that contains one statement.</span></span> <span data-ttu-id="06b4b-160">Le API per la creazione di nuovi nodi sono la soluzione ideale per creare singole istruzioni o altri piccoli blocchi di codice.</span><span class="sxs-lookup"><span data-stu-id="06b4b-160">The APIs to create new nodes are the right choice to create single statements or other small code blocks.</span></span> <span data-ttu-id="06b4b-161">Tuttavia, per creare blocchi di codice di maggiori dimensioni, è necessario usare metodi che sostituiscono i nodi o inseriscono i nodi in una struttura esistente.</span><span class="sxs-lookup"><span data-stu-id="06b4b-161">However, to build larger blocks of code, you should use methods that replace nodes or insert nodes into an existing tree.</span></span> <span data-ttu-id="06b4b-162">Tenere presente che gli alberi della sintassi non sono modificabili.</span><span class="sxs-lookup"><span data-stu-id="06b4b-162">Remember that syntax trees are immutable.</span></span> <span data-ttu-id="06b4b-163">L'**API Syntax** non offre alcun meccanismo per la modifica di un albero della sintassi esistente dopo la costruzione.</span><span class="sxs-lookup"><span data-stu-id="06b4b-163">The **Syntax API** doesn't provide any mechanism for modifying an existing syntax tree after construction.</span></span> <span data-ttu-id="06b4b-164">Fornisce invece metodi che producono nuovi alberi in base alle modifiche a quelli esistenti.</span><span class="sxs-lookup"><span data-stu-id="06b4b-164">Instead, it provides methods that produce new trees based on changes to existing ones.</span></span> <span data-ttu-id="06b4b-165">I metodi `With*` sono definiti nelle classi concrete che derivano da <xref:Microsoft.CodeAnalysis.SyntaxNode> o nei metodi di estensione dichiarati nella classe <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions>.</span><span class="sxs-lookup"><span data-stu-id="06b4b-165">`With*` methods are defined in concrete classes that derive from <xref:Microsoft.CodeAnalysis.SyntaxNode> or in extension methods declared in the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> class.</span></span> <span data-ttu-id="06b4b-166">Questi metodi creano un nuovo nodo applicando le modifiche alle proprietà figlio del nodo esistente.</span><span class="sxs-lookup"><span data-stu-id="06b4b-166">These methods create a new node by applying changes to an existing node's child properties.</span></span> <span data-ttu-id="06b4b-167">Inoltre, il metodo di estensione <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> può essere usato per sostituire un nodo discendente in un sottoalbero.</span><span class="sxs-lookup"><span data-stu-id="06b4b-167">Additionally, the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method can be used to replace a descendent node in a subtree.</span></span> <span data-ttu-id="06b4b-168">Anche questo metodo aggiorna l'elemento padre in modo da puntare all'elemento figlio appena creato e ripete il processo per l'intero albero: un processo noto come _re-spinning_ dell'albero.</span><span class="sxs-lookup"><span data-stu-id="06b4b-168">This method also updates the parent to point to the newly created child and repeats this process up the entire tree - a process known as _re-spinning_ the tree.</span></span>

<span data-ttu-id="06b4b-169">Il passaggio successivo consiste nel creare un albero che rappresenta un intero programma (di piccole dimensioni) e quindi modificarlo.</span><span class="sxs-lookup"><span data-stu-id="06b4b-169">The next step is to create a tree that represents an entire (small) program and then modify it.</span></span> <span data-ttu-id="06b4b-170">Aggiungere il codice seguente all'inizio della classe `Program`:</span><span class="sxs-lookup"><span data-stu-id="06b4b-170">Add the following code to the beginning of the `Program` class:</span></span>

[!code-csharp[create a parse tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#DeclareSampleCode "Create a tree that represents a small program")]

> [!NOTE]
> <span data-ttu-id="06b4b-171">Nell'esempio di codice viene usato lo spazio dei nomi `System.Collections`, invece dello spazio dei nomi `System.Collections.Generic`.</span><span class="sxs-lookup"><span data-stu-id="06b4b-171">The example code uses the `System.Collections` namespace and not the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="06b4b-172">Aggiungere quindi il codice seguente alla fine del metodo `Main` per analizzare il testo e creare un albero:</span><span class="sxs-lookup"><span data-stu-id="06b4b-172">Next, add the following code to the bottom of the `Main` method to parse the text and create a tree:</span></span>

[!code-csharp[create a parse tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateParseTree "Create a tree that represents a small program")]

<span data-ttu-id="06b4b-173">In questo esempio viene usato il metodo <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> per sostituire il nome in un nodo <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> con quello creato nel codice precedente.</span><span class="sxs-lookup"><span data-stu-id="06b4b-173">This example uses the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> method to replace the name in a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node with the one constructed in the preceding code.</span></span>

<span data-ttu-id="06b4b-174">Creare un nuovo nodo <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usando il metodo <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> per aggiornare il nome `System.Collections` con il nome creato nel codice precedente.</span><span class="sxs-lookup"><span data-stu-id="06b4b-174">Create a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node using the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> method to update the `System.Collections` name with the name you created in the preceding code.</span></span> <span data-ttu-id="06b4b-175">Aggiungere il codice seguente alla fine del metodo `Main`:</span><span class="sxs-lookup"><span data-stu-id="06b4b-175">Add the following code to the bottom of the `Main` method:</span></span>

[!code-csharp[create a new subtree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#BuildNewUsing "Create the subtree with the replaced namespace")]

<span data-ttu-id="06b4b-176">Eseguire il programma ed esaminare attentamente l'output.</span><span class="sxs-lookup"><span data-stu-id="06b4b-176">Run the program and look carefully at the output.</span></span> <span data-ttu-id="06b4b-177">`newusing` non è stato inserito nell'albero della radice.</span><span class="sxs-lookup"><span data-stu-id="06b4b-177">The `newusing` hasn't been placed in the root tree.</span></span> <span data-ttu-id="06b4b-178">La struttura originale non è stata modificata.</span><span class="sxs-lookup"><span data-stu-id="06b4b-178">The original tree hasn't been changed.</span></span>

<span data-ttu-id="06b4b-179">Aggiungere il codice seguente usando il metodo di estensione <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> per creare un nuovo albero.</span><span class="sxs-lookup"><span data-stu-id="06b4b-179">Add the following code using the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method to create a new tree.</span></span> <span data-ttu-id="06b4b-180">Il nuovo albero è il risultato della sostituzione dell'importazione esistente con il nodo `newUsing` aggiornato.</span><span class="sxs-lookup"><span data-stu-id="06b4b-180">The new tree is the result of replacing the existing import with the updated `newUsing` node.</span></span> <span data-ttu-id="06b4b-181">Questo nuovo albero viene assegnato alla variabile `root` esistente:</span><span class="sxs-lookup"><span data-stu-id="06b4b-181">You assign this new tree to the existing `root` variable:</span></span>

[!code-csharp[create a new root tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#TransformTree "Create the transformed root tree with the replaced namespace")]

<span data-ttu-id="06b4b-182">Eseguire di nuovo il programma.</span><span class="sxs-lookup"><span data-stu-id="06b4b-182">Run the program again.</span></span> <span data-ttu-id="06b4b-183">Questa volta l'albero importa correttamente lo spazio dei nomi `System.Collections.Generic`.</span><span class="sxs-lookup"><span data-stu-id="06b4b-183">This time the tree now correctly imports the `System.Collections.Generic` namespace.</span></span>

### <a name="transform-trees-using-syntaxrewriters"></a><span data-ttu-id="06b4b-184">Trasformare alberi tramite `SyntaxRewriters`</span><span class="sxs-lookup"><span data-stu-id="06b4b-184">Transform trees using `SyntaxRewriters`</span></span>

<span data-ttu-id="06b4b-185">I metodi `With*` e <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> offrono una pratica soluzione per trasformare singoli rami di un albero della sintassi.</span><span class="sxs-lookup"><span data-stu-id="06b4b-185">The `With*` and <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> methods provide convenient means to transform individual branches of a syntax tree.</span></span> <span data-ttu-id="06b4b-186">La classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> esegue più trasformazioni in una struttura della sintassi.</span><span class="sxs-lookup"><span data-stu-id="06b4b-186">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class performs multiple transformations on a syntax tree.</span></span> <span data-ttu-id="06b4b-187">La classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> è una sottoclasse di <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="06b4b-187">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class is a subclass of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="06b4b-188"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> applica una trasformazione a un tipo specifico di <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span><span class="sxs-lookup"><span data-stu-id="06b4b-188">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> applies a transformation to a specific type of <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span></span> <span data-ttu-id="06b4b-189">È possibile applicare trasformazioni a vari tipi di oggetti <xref:Microsoft.CodeAnalysis.SyntaxNode> ogni volta che compaiono in un albero della sintassi.</span><span class="sxs-lookup"><span data-stu-id="06b4b-189">You can apply transformations to multiple types of <xref:Microsoft.CodeAnalysis.SyntaxNode> objects wherever they appear in a syntax tree.</span></span> <span data-ttu-id="06b4b-190">Il secondo progetto in questa guida introduttiva crea un refactoring dalla riga di comando che rimuove i tipi espliciti nelle dichiarazioni di variabili locali ovunque sia possibile usare l'inferenza del tipo.</span><span class="sxs-lookup"><span data-stu-id="06b4b-190">The second project in this quickstart creates a command-line refactoring that removes explicit types in local variable declarations anywhere that type inference could be used.</span></span>

<span data-ttu-id="06b4b-191">Creare un nuovo progetto **dello strumento di analisi del codice** in C# autonomo.</span><span class="sxs-lookup"><span data-stu-id="06b4b-191">Create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="06b4b-192">In Visual Studio fare doppio clic sul nodo `SyntaxTransformationQuickStart` della soluzione.</span><span class="sxs-lookup"><span data-stu-id="06b4b-192">In Visual Studio, right-click the `SyntaxTransformationQuickStart` solution node.</span></span> <span data-ttu-id="06b4b-193">Scegliere **Aggiungi** > **nuovo progetto** per visualizzare la **finestra di dialogo nuovo progetto**.</span><span class="sxs-lookup"><span data-stu-id="06b4b-193">Choose **Add** > **New Project** to display the **New Project dialog**.</span></span> <span data-ttu-id="06b4b-194">In**Extensibility**di **Visual C#** > scegliere **strumento di analisi del codice autonomo**.</span><span class="sxs-lookup"><span data-stu-id="06b4b-194">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="06b4b-195">Assegnare al progetto il nome `TransformationCS` e fare clic su OK.</span><span class="sxs-lookup"><span data-stu-id="06b4b-195">Name your project `TransformationCS` and click OK.</span></span>

<span data-ttu-id="06b4b-196">Il primo passaggio consiste nella creazione di una classe che deriva da <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> per eseguire le trasformazioni.</span><span class="sxs-lookup"><span data-stu-id="06b4b-196">The first step is to create a class that derives from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> to perform your transformations.</span></span> <span data-ttu-id="06b4b-197">Aggiungere un nuovo file di classe al progetto.</span><span class="sxs-lookup"><span data-stu-id="06b4b-197">Add a new class file to the project.</span></span> <span data-ttu-id="06b4b-198">In Visual Studio scegliere **progetto** > **Aggiungi classe**.... Nella finestra di dialogo **Aggiungi nuovo elemento** Digitare `TypeInferenceRewriter.cs` come nome file.</span><span class="sxs-lookup"><span data-stu-id="06b4b-198">In Visual Studio, choose **Project** > **Add Class...**. In the **Add New Item** dialog type `TypeInferenceRewriter.cs` as the filename.</span></span>

<span data-ttu-id="06b4b-199">Aggiungere le direttive using seguenti al file `TypeInferenceRewriter.cs`:</span><span class="sxs-lookup"><span data-stu-id="06b4b-199">Add the following using directives to the `TypeInferenceRewriter.cs` file:</span></span>

[!code-csharp[add necessary usings](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#AddUsings "Add required usings")]

<span data-ttu-id="06b4b-200">Impostare quindi la classe `TypeInferenceRewriter` in modo da estendere la classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter>:</span><span class="sxs-lookup"><span data-stu-id="06b4b-200">Next, make the `TypeInferenceRewriter` class extend the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> class:</span></span>

[!code-csharp[add base class](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BaseClass "Add base class")]

<span data-ttu-id="06b4b-201">Aggiungere il codice seguente per dichiarare un campo privato di sola lettura che contiene un <xref:Microsoft.CodeAnalysis.SemanticModel> e inizializzarlo nel costruttore.</span><span class="sxs-lookup"><span data-stu-id="06b4b-201">Add the following code to declare a private read-only field to hold a <xref:Microsoft.CodeAnalysis.SemanticModel> and initialize it in the constructor.</span></span> <span data-ttu-id="06b4b-202">Questo campo sarà necessario in un secondo momento per determinare dove è possibile usare l'inferenza del tipo:</span><span class="sxs-lookup"><span data-stu-id="06b4b-202">You will need this field later on to determine where type inference can be used:</span></span>

[!code-csharp[initialize members](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Construction "Declare and initialize member variables")]

<span data-ttu-id="06b4b-203">Eseguire l'override del metodo <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)>:</span><span class="sxs-lookup"><span data-stu-id="06b4b-203">Override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method:</span></span>

```csharp
public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
{

}
```

> [!NOTE]
> <span data-ttu-id="06b4b-204">Molte API Roslyn dichiarano tipi restituiti che sono classi di base degli effettivi tipi di runtime restituiti.</span><span class="sxs-lookup"><span data-stu-id="06b4b-204">Many of the Roslyn APIs declare return types that are base classes of the actual runtime types returned.</span></span> <span data-ttu-id="06b4b-205">In molti scenari un tipo di nodo può essere interamente sostituito da un altro tipo di nodo o può essere addirittura rimosso.</span><span class="sxs-lookup"><span data-stu-id="06b4b-205">In many scenarios, one kind of node may be replaced by another kind of node entirely - or even removed.</span></span> <span data-ttu-id="06b4b-206">In questo esempio, il metodo <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> restituisce un <xref:Microsoft.CodeAnalysis.SyntaxNode>, anziché il tipo derivato <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>.</span><span class="sxs-lookup"><span data-stu-id="06b4b-206">In this example, the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method returns a <xref:Microsoft.CodeAnalysis.SyntaxNode>, instead of the derived type of   <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>.</span></span> <span data-ttu-id="06b4b-207">Il rewriter restituisce un nuovo nodo <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> basato su quello esistente.</span><span class="sxs-lookup"><span data-stu-id="06b4b-207">This rewriter returns a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> node based on the existing one.</span></span>

<span data-ttu-id="06b4b-208">Questa guida introduttiva gestisce le dichiarazioni di variabili locali.</span><span class="sxs-lookup"><span data-stu-id="06b4b-208">This quickstart handles local variable declarations.</span></span> <span data-ttu-id="06b4b-209">È possibile estenderla ad altre dichiarazioni, ad esempio cicli `foreach`, cicli `for`, espressioni LINQ ed espressioni lambda.</span><span class="sxs-lookup"><span data-stu-id="06b4b-209">You could extend it to other declarations such as `foreach` loops, `for` loops, LINQ expressions, and lambda expressions.</span></span> <span data-ttu-id="06b4b-210">Inoltre, il rewriter trasformerà solo le dichiarazioni nella forma più semplice:</span><span class="sxs-lookup"><span data-stu-id="06b4b-210">Furthermore this rewriter will only transform declarations of the simplest form:</span></span>

```csharp
Type variable = expression;
```

<span data-ttu-id="06b4b-211">Se si vuole esplorare in autonomia, considerare di estendere l'esempio completato per questi tipi di dichiarazioni di variabili:</span><span class="sxs-lookup"><span data-stu-id="06b4b-211">If you want to explore on your own, consider extending the finished sample for these types of variable declarations:</span></span>

```csharp
// Multiple variables in a single declaration.
Type variable1 = expression1,
     variable2 = expression2;
// No initializer.
Type variable;
```

<span data-ttu-id="06b4b-212">Aggiungere il codice seguente nel corpo del metodo `VisitLocalDeclarationStatement` per ignorare la riscrittura di queste forme di dichiarazioni:</span><span class="sxs-lookup"><span data-stu-id="06b4b-212">Add the following code to the body of the `VisitLocalDeclarationStatement` method to skip rewriting these forms of declarations:</span></span>

[!code-csharp[exclude other declarations](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Exclusions "Exclude variables declarations not processed by this sample")]

<span data-ttu-id="06b4b-213">Il metodo indica che non viene eseguita alcuna riscrittura restituendo il parametro `node` senza modifiche.</span><span class="sxs-lookup"><span data-stu-id="06b4b-213">The method indicates that no rewriting takes place by returning the `node` parameter unmodified.</span></span> <span data-ttu-id="06b4b-214">Se nessuna di queste espressioni `if` è true, il nodo rappresenta una possibile dichiarazione con l'inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="06b4b-214">If neither of those `if` expressions are true, the node represents a possible declaration with initialization.</span></span> <span data-ttu-id="06b4b-215">Aggiungere queste istruzioni per estrarre il nome del tipo specificato nella dichiarazione ed eseguirne il binding usando il campo <xref:Microsoft.CodeAnalysis.SemanticModel> per ottenere un simbolo di tipo:</span><span class="sxs-lookup"><span data-stu-id="06b4b-215">Add these statements to extract the type name specified in the declaration and bind it using the <xref:Microsoft.CodeAnalysis.SemanticModel> field to obtain a type symbol:</span></span>

[!code-csharp[extract type name](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ExtractTypeSymbol "Extract the type name specified by the declaration")]

<span data-ttu-id="06b4b-216">A questo punto, aggiungere l'istruzione seguente per eseguire il binding dell'espressione dell'inizializzatore:</span><span class="sxs-lookup"><span data-stu-id="06b4b-216">Now, add this statement to bind the initializer expression:</span></span>

[!code-csharp[bind initializer](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BindInitializer "Bind the initializer expressions")]

<span data-ttu-id="06b4b-217">Infine, aggiungere l'istruzione `if` seguente per sostituire il nome del tipo esistente con la parola chiave `var` se il tipo di espressione dell'inizializzatore corrisponde al tipo specificato:</span><span class="sxs-lookup"><span data-stu-id="06b4b-217">Finally, add the following `if` statement to replace the existing type name with the `var` keyword if the type of the initializer expression matches the type specified:</span></span>

[!code-csharp[ReplaceNode](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ReplaceNode "Replace the initializer node")]

<span data-ttu-id="06b4b-218">L'operazione condizionale è necessaria perché la dichiarazione può esegue il cast dell'espressione dell'inizializzatore su un'interfaccia o una classe di base.</span><span class="sxs-lookup"><span data-stu-id="06b4b-218">The conditional is required because the declaration may cast the initializer expression to a base class or interface.</span></span> <span data-ttu-id="06b4b-219">Se si vuole ottenere tale risultato, i tipi sul lato sinistro e destro dell'assegnazione non corrispondono.</span><span class="sxs-lookup"><span data-stu-id="06b4b-219">If that's desired, the types on the left and right-hand side of the assignment don't match.</span></span> <span data-ttu-id="06b4b-220">La rimozione del tipo esplicito in questi casi comporterebbe la modifica della semantica di un programma.</span><span class="sxs-lookup"><span data-stu-id="06b4b-220">Removing the explicit type in these cases would change the semantics of a program.</span></span> <span data-ttu-id="06b4b-221">`var` viene specificato come un identificatore anziché come una parola chiave poiché `var` è una parola chiave contestuale.</span><span class="sxs-lookup"><span data-stu-id="06b4b-221">`var` is specified as an identifier rather than a keyword because `var` is a contextual keyword.</span></span> <span data-ttu-id="06b4b-222">Gli elementi semplici iniziali e finali (spazio) vengono trasferiti dal nome del tipo precedente alla parola chiave `var` per mantenere lo spazio vuoto verticale e il rientro.</span><span class="sxs-lookup"><span data-stu-id="06b4b-222">The leading and trailing trivia (white space) are transferred from the old type name to the `var` keyword to maintain vertical white space and indentation.</span></span> <span data-ttu-id="06b4b-223">È più semplice usare `ReplaceNode` anziché `With*` per trasformare <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>, perché il nome del tipo è di fatto il nipote dell'istruzione di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="06b4b-223">It's simpler to use `ReplaceNode` rather than `With*` to transform the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> because the type name is actually the grandchild of the declaration statement.</span></span>

<span data-ttu-id="06b4b-224">`TypeInferenceRewriter` è stato completato.</span><span class="sxs-lookup"><span data-stu-id="06b4b-224">You've finished the `TypeInferenceRewriter`.</span></span> <span data-ttu-id="06b4b-225">A questo punto, eseguire la restituzione nel file `Program.cs` per completare l'esempio.</span><span class="sxs-lookup"><span data-stu-id="06b4b-225">Now return to your `Program.cs` file to finish the example.</span></span> <span data-ttu-id="06b4b-226">Creare un <xref:Microsoft.CodeAnalysis.Compilation> di test e ottenere <xref:Microsoft.CodeAnalysis.SemanticModel> da quest'ultimo.</span><span class="sxs-lookup"><span data-stu-id="06b4b-226">Create a test <xref:Microsoft.CodeAnalysis.Compilation> and obtain the <xref:Microsoft.CodeAnalysis.SemanticModel> from it.</span></span> <span data-ttu-id="06b4b-227">Usare tale <xref:Microsoft.CodeAnalysis.SemanticModel> per provare `TypeInferenceRewriter`.</span><span class="sxs-lookup"><span data-stu-id="06b4b-227">Use that <xref:Microsoft.CodeAnalysis.SemanticModel> to try your `TypeInferenceRewriter`.</span></span> <span data-ttu-id="06b4b-228">Questo passaggio verrà eseguito per ultimo.</span><span class="sxs-lookup"><span data-stu-id="06b4b-228">You'll do this step last.</span></span> <span data-ttu-id="06b4b-229">Nel frattempo dichiarare una variabile segnaposto che rappresenta la compilazione di test:</span><span class="sxs-lookup"><span data-stu-id="06b4b-229">In the meantime declare a placeholder variable representing your test compilation:</span></span>

[!code-csharp[DeclareCompilation](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#DeclareTestCompilation "Declare the test compilation")]

<span data-ttu-id="06b4b-230">Dopo qualche istante, dovrebbe essere visualizzata una sottolineatura ondulata di errore che indica che non è presente alcun metodo `CreateTestCompilation`.</span><span class="sxs-lookup"><span data-stu-id="06b4b-230">After pausing a moment, you should see an error squiggle appear reporting that no `CreateTestCompilation` method exists.</span></span> <span data-ttu-id="06b4b-231">Premere **CTRL+PUNTO** per aprire la lampadina e quindi premere INVIO per richiamare il comando **Genera stub di metodo**.</span><span class="sxs-lookup"><span data-stu-id="06b4b-231">Press **Ctrl+Period** to open the light-bulb and then press Enter to invoke the **Generate Method Stub** command.</span></span> <span data-ttu-id="06b4b-232">Questo comando genererà uno stub di metodo per il metodo `CreateTestCompilation` nella classe `Program`.</span><span class="sxs-lookup"><span data-stu-id="06b4b-232">This command will generate a method stub for the `CreateTestCompilation` method in the `Program` class.</span></span> <span data-ttu-id="06b4b-233">Si tornerà a questo metodo per la compilazione in un secondo momento:</span><span class="sxs-lookup"><span data-stu-id="06b4b-233">You'll come back to fill in this method later:</span></span>

![Uso della generazione del metodo in C#](./media/syntax-transformation/generate-from-usage.png)

<span data-ttu-id="06b4b-235">Scrivere il codice seguente per eseguire l'iterazione su ogni <xref:Microsoft.CodeAnalysis.SyntaxTree> nel <xref:Microsoft.CodeAnalysis.Compilation> di test.</span><span class="sxs-lookup"><span data-stu-id="06b4b-235">Write the following code to iterate over each <xref:Microsoft.CodeAnalysis.SyntaxTree> in the test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="06b4b-236">Per ognuno, inizializzare un nuovo `TypeInferenceRewriter` con il <xref:Microsoft.CodeAnalysis.SemanticModel> per l'albero corrispondente:</span><span class="sxs-lookup"><span data-stu-id="06b4b-236">For each one, initialize a new `TypeInferenceRewriter` with the <xref:Microsoft.CodeAnalysis.SemanticModel> for that tree:</span></span>

[!code-csharp[IterateTrees](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#IterateTrees "Iterate all the source trees in the test compilation")]

<span data-ttu-id="06b4b-237">All'interno dell'istruzione `foreach` che è stata creata, aggiungere il codice seguente per eseguire la trasformazione su ogni albero di origine.</span><span class="sxs-lookup"><span data-stu-id="06b4b-237">Inside the `foreach` statement you created, add the following code to perform the transformation on each source tree.</span></span> <span data-ttu-id="06b4b-238">Questo codice scrive in modo condizionale il nuovo albero trasformato se sono state apportate modifiche.</span><span class="sxs-lookup"><span data-stu-id="06b4b-238">This code conditionally writes out the new transformed tree if any edits were made.</span></span> <span data-ttu-id="06b4b-239">Il rewriter deve modificare un albero solo se rileva una o più dichiarazioni di variabili locali che potrebbero essere semplificate tramite l'inferenza del tipo:</span><span class="sxs-lookup"><span data-stu-id="06b4b-239">Your rewriter should only modify a tree if it encounters one or more local variable declarations that could be simplified using type inference:</span></span>

[!code-csharp[TransformTrees](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#TransformTrees "Transform and save any trees that are modified by the rewriter")]

<span data-ttu-id="06b4b-240">Dovrebbero essere visualizzate sottolineature ondulate sotto il codice `File.WriteAllText`.</span><span class="sxs-lookup"><span data-stu-id="06b4b-240">You should see squiggles under the `File.WriteAllText` code.</span></span> <span data-ttu-id="06b4b-241">Selezionare la lampadina e aggiungere l'istruzione `using System.IO;` necessaria.</span><span class="sxs-lookup"><span data-stu-id="06b4b-241">Select the light bulb, and add the necessary `using System.IO;` statement.</span></span>

<span data-ttu-id="06b4b-242">Ci siamo quasi.</span><span class="sxs-lookup"><span data-stu-id="06b4b-242">You're almost done!</span></span> <span data-ttu-id="06b4b-243">È stato lasciato un solo passaggio: creazione di <xref:Microsoft.CodeAnalysis.Compilation>un test.</span><span class="sxs-lookup"><span data-stu-id="06b4b-243">There's one step left: creating a test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="06b4b-244">Poiché non è stata usata l'inferenza del tipo, questa guida introduttiva rappresenterebbe un test case perfetto.</span><span class="sxs-lookup"><span data-stu-id="06b4b-244">Since you haven't been using type inference at all during this quickstart, it would have made a perfect test case.</span></span> <span data-ttu-id="06b4b-245">Purtroppo, la creazione di una compilazione da un file di progetto C# esula dall'ambito di questa procedura dettagliata.</span><span class="sxs-lookup"><span data-stu-id="06b4b-245">Unfortunately, creating a Compilation from a C# project file is beyond the scope of this walkthrough.</span></span> <span data-ttu-id="06b4b-246">Tuttavia, se le istruzioni sono state seguite con attenzione, esiste una possibilità.</span><span class="sxs-lookup"><span data-stu-id="06b4b-246">But fortunately, if you've been following instructions carefully, there's hope.</span></span> <span data-ttu-id="06b4b-247">Sostituire il contenuto del metodo `CreateTestCompilation` con il codice riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="06b4b-247">Replace the contents of the `CreateTestCompilation` method with the following code.</span></span> <span data-ttu-id="06b4b-248">Tale codice crea una compilazione di test che casualmente corrisponde al progetto descritto in questa guida introduttiva:</span><span class="sxs-lookup"><span data-stu-id="06b4b-248">It creates a test compilation that coincidentally matches the project described in this quickstart:</span></span>

[!code-csharp[CreateTestCompilation](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#CreateTestCompilation "Create a test compilation using the code written for this quickstart.")]

<span data-ttu-id="06b4b-249">Eseguire il progetto.</span><span class="sxs-lookup"><span data-stu-id="06b4b-249">Cross your fingers and run the project.</span></span> <span data-ttu-id="06b4b-250">In Visual Studio scegliere **debug** > **Avvia debug**.</span><span class="sxs-lookup"><span data-stu-id="06b4b-250">In Visual Studio, choose **Debug** > **Start Debugging**.</span></span> <span data-ttu-id="06b4b-251">Visual Studio dovrebbe segnalare che i file nel progetto sono stati modificati.</span><span class="sxs-lookup"><span data-stu-id="06b4b-251">You should be prompted by Visual Studio that the files in your project have changed.</span></span> <span data-ttu-id="06b4b-252">Fare clic su **Sì a tutti** per ricaricare i file modificati.</span><span class="sxs-lookup"><span data-stu-id="06b4b-252">Click "**Yes to All**" to reload the modified files.</span></span> <span data-ttu-id="06b4b-253">Esaminarli per osservare i risultati ottenuti.</span><span class="sxs-lookup"><span data-stu-id="06b4b-253">Examine them to observe your awesomeness.</span></span> <span data-ttu-id="06b4b-254">Si noti quanto risulta più pulito il codice senza tutti gli identificatori di tipi espliciti e ridondanti.</span><span class="sxs-lookup"><span data-stu-id="06b4b-254">Note how much cleaner the code looks without all those explicit and redundant type specifiers.</span></span>

<span data-ttu-id="06b4b-255">Congratulazioni!</span><span class="sxs-lookup"><span data-stu-id="06b4b-255">Congratulations!</span></span> <span data-ttu-id="06b4b-256">Sono state usate le **API del compilatore** per scrivere un refactoring che cerca alcuni modelli sintattici in tutti i file in un progetto C#, analizza la semantica del codice sorgente che corrisponde a tali modelli e la trasforma.</span><span class="sxs-lookup"><span data-stu-id="06b4b-256">You've used the **Compiler APIs** to write your own refactoring that searches all files in a C# project for certain syntactic patterns, analyzes the semantics of source code that matches those patterns, and transforms it.</span></span> <span data-ttu-id="06b4b-257">Sei ora ufficialmente un autore del refactoring.</span><span class="sxs-lookup"><span data-stu-id="06b4b-257">You're now officially a refactoring author!</span></span>
