---
title: Usare il modello di sintassi di .NET Compiler Platform SDK
description: Questa panoramica consente di conoscere i tipi usati per comprendere e modificare i nodi di sintassi.
ms.date: 10/15/2017
ms.custom: mvc
ms.openlocfilehash: fdb13095c2b91e54d58988a51a51b05652e57ea6
ms.sourcegitcommit: 488aced39b5f374bc0a139a4993616a54d15baf0
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 05/12/2020
ms.locfileid: "83208395"
---
# <a name="work-with-syntax"></a><span data-ttu-id="0b8fa-103">Utilizzare la sintassi</span><span class="sxs-lookup"><span data-stu-id="0b8fa-103">Work with syntax</span></span>

<span data-ttu-id="0b8fa-104">L'*albero della sintassi* è una struttura dei dati fondamentale esposta dalle API del compilatore.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-104">The *syntax tree* is a fundamental data structure exposed by the compiler APIs.</span></span> <span data-ttu-id="0b8fa-105">Questi alberi rappresentano la struttura lessicale e sintattica del codice sorgente</span><span class="sxs-lookup"><span data-stu-id="0b8fa-105">These trees represent the lexical and syntactic structure of source code.</span></span> <span data-ttu-id="0b8fa-106">e svolgono due funzioni importanti:</span><span class="sxs-lookup"><span data-stu-id="0b8fa-106">They serve two important purposes:</span></span>

- <span data-ttu-id="0b8fa-107">Per consentire agli strumenti, ad esempio un IDE, componenti aggiuntivi, strumenti di analisi del codice e refactoring, di visualizzare ed elaborare la struttura sintattica del codice sorgente nel progetto di un utente.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-107">To allow tools - such as an IDE, add-ins, code analysis tools, and refactorings - to see and process the syntactic structure of source code in a user's project.</span></span>
- <span data-ttu-id="0b8fa-108">Per abilitare strumenti, ad esempio refactoring e IDE, per creare, modificare e ridisporre il codice sorgente in modo naturale senza dover usare modifiche di testo diretto.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-108">To enable tools - such as refactorings and an IDE - to create, modify, and rearrange source code in a natural manner without having to use direct text edits.</span></span> <span data-ttu-id="0b8fa-109">Mediante la creazione e modifica degli alberi, gli strumenti possono facilmente creare e modificare il codice sorgente.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-109">By creating and manipulating trees, tools can easily create and rearrange source code.</span></span>

## <a name="syntax-trees"></a><span data-ttu-id="0b8fa-110">Alberi della sintassi</span><span class="sxs-lookup"><span data-stu-id="0b8fa-110">Syntax trees</span></span>

<span data-ttu-id="0b8fa-111">Gli alberi della sintassi sono la struttura primaria usata per compilazione, analisi codice, binding, refactoring, funzionalità dell'IDE e generazione di codice.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-111">Syntax trees are the primary structure used for compilation, code analysis, binding, refactoring, IDE features, and code generation.</span></span> <span data-ttu-id="0b8fa-112">Nessuna parte del codice sorgente può essere compresa senza prima essere identificata e categorizzata in uno dei numerosi elementi di linguaggio strutturali noti.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-112">No part of the source code is understood without it first being identified and categorized into one of many well-known structural language elements.</span></span>

<span data-ttu-id="0b8fa-113">Per gli alberi della sintassi esistono tre attributi chiave.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-113">Syntax trees have three key attributes.</span></span> <span data-ttu-id="0b8fa-114">Il primo attributo è che gli alberi della sintassi contengono tutte le informazioni di origine con la massima fedeltà.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-114">The first attribute is that syntax trees hold all the source information in full fidelity.</span></span> <span data-ttu-id="0b8fa-115">Per fedeltà completa si intende che l'albero della sintassi contiene tutte le informazioni contenute nel testo di origine, ogni costrutto grammaticale, ogni token lessicale e tutti gli altri elementi tra, inclusi spazi vuoti, commenti e direttive per il preprocessore.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-115">Full fidelity means that the syntax tree contains every piece of information found in the source text, every grammatical construct, every lexical token, and everything else in between, including white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="0b8fa-116">Ad esempio, ogni valore letterale nell'origine viene rappresentato esattamente nel modo in cui è stato digitato.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-116">For example, each literal mentioned in the source is represented exactly as it was typed.</span></span> <span data-ttu-id="0b8fa-117">Gli alberi della sintassi acquisiscono anche errori nel codice sorgente quando il programma è incompleto o non corretto, rappresentando i token ignorati o mancanti.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-117">Syntax trees also capture errors in source code when the program is incomplete or malformed by representing skipped or missing tokens.</span></span>

<span data-ttu-id="0b8fa-118">Il secondo attributo degli alberi della sintassi è che possono produrre il testo esatto da cui sono stati analizzati.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-118">The second attribute of syntax trees is that they can produce the exact text that they were parsed from.</span></span> <span data-ttu-id="0b8fa-119">Da qualsiasi nodo di sintassi è possibile ottenere la rappresentazione testuale del sottoalbero radice in quel nodo.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-119">From any syntax node, it's possible to get the text representation of the subtree rooted at that node.</span></span> <span data-ttu-id="0b8fa-120">Questa possibilità significa che è possibile usare gli alberi della sintassi come modo per costruire e modificare il testo di origine.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-120">This ability means that syntax trees can be used as a way to construct and edit source text.</span></span> <span data-ttu-id="0b8fa-121">Creando una struttura ad albero, in modo implicito, è stato creato il testo equivalente e modificando un albero della sintassi, rendendo un nuovo albero da modifiche a un albero esistente, il testo è stato modificato.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-121">By creating a tree you have, by implication, created the equivalent text, and by editing a syntax tree, making a new tree out of changes to an existing tree, you have effectively edited the text.</span></span>

<span data-ttu-id="0b8fa-122">Il terzo attributo degli alberi della sintassi è che sono thread-safe e non modificabili.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-122">The third attribute of syntax trees is that they are immutable and thread-safe.</span></span> <span data-ttu-id="0b8fa-123">Una volta ottenuto un albero, è uno snapshot dello stato corrente del codice e non viene mai modificato.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-123">After a tree is obtained, it's a snapshot of the current state of the code and never changes.</span></span> <span data-ttu-id="0b8fa-124">In questo modo, più utenti possono interagire con lo stesso albero della sintassi contemporaneamente in thread diversi, senza causare blocchi o duplicazioni.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-124">This allows multiple users to interact with the same syntax tree at the same time in different threads without locking or duplication.</span></span> <span data-ttu-id="0b8fa-125">Dato che gli alberi non sono modificabili e non è possibile apportare modifiche direttamente a un albero, i metodi factory sono utili per creare e modificare gli alberi della sintassi mediante la creazione di snapshot aggiuntivi dell'albero.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-125">Because the trees are immutable and no modifications can be made directly to a tree, factory methods help create and modify syntax trees by creating additional snapshots of the tree.</span></span> <span data-ttu-id="0b8fa-126">L'efficienza degli alberi sta nel modo in cui vengono riutilizzati i nodi sottostanti, che consente di ricompilare una nuova versione velocemente e con una quantità limitata di memoria aggiuntiva.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-126">The trees are efficient in the way they reuse underlying nodes, so a new version can be rebuilt fast and with little extra memory.</span></span>

<span data-ttu-id="0b8fa-127">Un albero della sintassi è letteralmente una struttura dei dati ad albero, in cui gli elementi strutturali non terminali fungono da padre per altri elementi.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-127">A syntax tree is literally a tree data structure, where non-terminal structural elements parent other elements.</span></span> <span data-ttu-id="0b8fa-128">Ogni albero della sintassi è composto da nodi, token ed elementi semplici.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-128">Each syntax tree is made up of nodes, tokens, and trivia.</span></span>

## <a name="syntax-nodes"></a><span data-ttu-id="0b8fa-129">Nodi di sintassi</span><span class="sxs-lookup"><span data-stu-id="0b8fa-129">Syntax nodes</span></span>

<span data-ttu-id="0b8fa-130">I nodi di sintassi sono tra gli elementi principali degli alberi della sintassi.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-130">Syntax nodes are one of the primary elements of syntax trees.</span></span> <span data-ttu-id="0b8fa-131">Questi nodi rappresentano costrutti sintattici, ad esempio dichiarazioni, istruzioni, clausole ed espressioni.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-131">These nodes represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span> <span data-ttu-id="0b8fa-132">Ogni categoria di nodi di sintassi è rappresentata da una classe separata derivata da <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-132">Each category of syntax nodes is represented by a separate class derived from <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0b8fa-133">Il set di classi dei nodi non è estendibile.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-133">The set of node classes is not extensible.</span></span>

<span data-ttu-id="0b8fa-134">Tutti i nodi di sintassi sono i nodi non terminali nell'albero della sintassi, ovvero hanno sempre altri nodi e token come elementi figlio.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-134">All syntax nodes are non-terminal nodes in the syntax tree, which means they always have other nodes and tokens as children.</span></span> <span data-ttu-id="0b8fa-135">In quanto elemento figlio di un altro nodo, ogni nodo ha un nodo padre accessibile tramite la proprietà <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-135">As a child of another node, each node has a parent node that can be accessed through the <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="0b8fa-136">Dato che i nodi e gli alberi non sono modificabili, l'elemento padre di un nodo non cambia mai.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-136">Because nodes and trees are immutable, the parent of a node never changes.</span></span> <span data-ttu-id="0b8fa-137">La radice dell'albero ha un padre null.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-137">The root of the tree has a null parent.</span></span>

<span data-ttu-id="0b8fa-138">Ogni nodo ha un metodo <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType>, che restituisce un elenco di nodi figlio in ordine sequenziale in base alla posizione nel testo di origine.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-138">Each node has a <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> method, which returns a list of child nodes in sequential order based on their position in the source text.</span></span> <span data-ttu-id="0b8fa-139">L'elenco non contiene token.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-139">This list does not contain tokens.</span></span> <span data-ttu-id="0b8fa-140">Ogni nodo dispone anche di metodi per esaminare i discendenti, ad esempio <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A> , <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A> o, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> che rappresentano un elenco di tutti i nodi, i token o le banalità presenti nel sottoalbero radice da tale nodo.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-140">Each node also has methods to examine Descendants, such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>, or <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> - that represent a list of all the nodes, tokens, or trivia that exist in the subtree rooted by that node.</span></span>

<span data-ttu-id="0b8fa-141">Inoltre, ogni sottoclasse di nodo della sintassi espone gli stessi elementi figlio tramite proprietà fortemente tipizzate.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-141">In addition, each syntax node subclass exposes all the same children through strongly typed properties.</span></span> <span data-ttu-id="0b8fa-142">Ad esempio, una classe di nodo <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> include tre proprietà aggiuntive specifiche per gli operatori binari: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> e <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-142">For example, a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> node class has three additional properties specific to binary operators: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span></span> <span data-ttu-id="0b8fa-143">Il tipo di <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> e <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> è <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> e il tipo di <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> è <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-143">The type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> is <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, and the type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> is <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span></span>

<span data-ttu-id="0b8fa-144">Alcuni nodi di sintassi hanno elementi figlio facoltativi.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-144">Some syntax nodes have optional children.</span></span> <span data-ttu-id="0b8fa-145">Ad esempio, per un elemento <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> è disponibile un elemento <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax> facoltativo.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-145">For example, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> has an optional <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span></span> <span data-ttu-id="0b8fa-146">Se l'elemento figlio non è presente, la proprietà restituisce null.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-146">If the child is not present, the property returns null.</span></span>

## <a name="syntax-tokens"></a><span data-ttu-id="0b8fa-147">Token di sintassi</span><span class="sxs-lookup"><span data-stu-id="0b8fa-147">Syntax tokens</span></span>

<span data-ttu-id="0b8fa-148">I token di sintassi sono i terminali della grammatica del linguaggio, che rappresentano i frammenti sintattici più piccoli del codice.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-148">Syntax tokens are the terminals of the language grammar, representing the smallest syntactic fragments of the code.</span></span> <span data-ttu-id="0b8fa-149">Questi elementi non fungono mai da padre per altri nodi o token.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-149">They are never parents of other nodes or tokens.</span></span> <span data-ttu-id="0b8fa-150">I token di sintassi sono costituiti da parole chiave, identificatori, valori letterali e punteggiatura.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-150">Syntax tokens consist of keywords, identifiers, literals, and punctuation.</span></span>

<span data-ttu-id="0b8fa-151">Per motivi di efficienza, il tipo <xref:Microsoft.CodeAnalysis.SyntaxToken> è un tipo valore CLR.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-151">For efficiency purposes, the <xref:Microsoft.CodeAnalysis.SyntaxToken> type is a CLR value type.</span></span> <span data-ttu-id="0b8fa-152">Pertanto, a differenza dei nodi di sintassi, è presente una sola struttura per tutti i tipi di token con una combinazione di proprietà che hanno un significato in base al tipo di token rappresentato.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-152">Therefore, unlike syntax nodes, there is only one structure for all kinds of tokens with a mix of properties that have meaning depending on the kind of token that is being represented.</span></span>

<span data-ttu-id="0b8fa-153">Ad esempio, un token letterale integer rappresenta un valore numerico.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-153">For example, an integer literal token represents a numeric value.</span></span> <span data-ttu-id="0b8fa-154">Oltre al testo di origine non elaborato rappresentato dal token, il token letterale ha una proprietà <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> che indica l'esatto valore integer decodificato.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-154">In addition to the raw source text the token spans, the literal token has a <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property that tells you the exact decoded integer value.</span></span> <span data-ttu-id="0b8fa-155">Questa proprietà è tipizzata come <xref:System.Object> perché può essere uno di molti tipi primitivi.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-155">This property is typed as <xref:System.Object> because it may be one of many primitive types.</span></span>

<span data-ttu-id="0b8fa-156">La proprietà <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> offre le stesse informazioni della proprietà <xref:Microsoft.CodeAnalysis.SyntaxToken.Value>, tuttavia questa proprietà è sempre tipizzata come <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-156">The <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property tells you the same information as the <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property; however this property is always typed as <xref:System.String>.</span></span> <span data-ttu-id="0b8fa-157">Un identificatore nel testo di origine C# può includere caratteri di escape Unicode, ma la sintassi della sequenza di escape stessa non viene considerata parte del nome dell'identificatore.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-157">An identifier in C# source text may include Unicode escape characters, yet the syntax of the escape sequence itself is not considered part of the identifier name.</span></span> <span data-ttu-id="0b8fa-158">In tal caso, anche se il testo non elaborato a cui fa riferimento il token include la sequenza di escape, la proprietà <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> non la include</span><span class="sxs-lookup"><span data-stu-id="0b8fa-158">So although the raw text spanned by the token does include the escape sequence, the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property does not.</span></span> <span data-ttu-id="0b8fa-159">e include invece i caratteri Unicode identificati dal carattere di escape.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-159">Instead, it includes the Unicode characters identified by the escape.</span></span> <span data-ttu-id="0b8fa-160">Ad esempio, se il testo di origine contiene un identificatore scritto come `\u03C0`, la proprietà <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> per questo token restituirà `π`.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-160">For example, if the source text contains an identifier written as `\u03C0`, then the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property for this token will return `π`.</span></span>

## <a name="syntax-trivia"></a><span data-ttu-id="0b8fa-161">Elementi semplici della sintassi</span><span class="sxs-lookup"><span data-stu-id="0b8fa-161">Syntax trivia</span></span>

<span data-ttu-id="0b8fa-162">Gli elementi semplici della sintassi rappresentano le parti del testo di origine in gran parte poco significative per la normale comprensione del codice, ad esempio spazi vuoti, commenti e direttive del preprocessore.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-162">Syntax trivia represent the parts of the source text that are largely insignificant for normal understanding of the code, such as white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="0b8fa-163">Come i token di sintassi, gli elementi semplici sono tipi valore.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-163">Like syntax tokens, trivia are value types.</span></span> <span data-ttu-id="0b8fa-164">Il singolo tipo <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> viene usato per descrivere tutti i tipi di elementi semplici.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-164">The single <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> type is used to describe all kinds of trivia.</span></span>

<span data-ttu-id="0b8fa-165">Dato che gli elementi semplici non fanno parte della sintassi del linguaggio normale e possono trovarsi ovunque tra due token, non vengono inclusi nell'albero della sintassi come elemento figlio di un nodo.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-165">Because trivia are not part of the normal language syntax and can appear anywhere between any two tokens, they are not included in the syntax tree as a child of a node.</span></span> <span data-ttu-id="0b8fa-166">Tuttavia, dato che sono importanti quando si implementa una funzionalità come il refactoring e per mantenere la massima fedeltà con il testo di origine, esistono come parte dell'albero della sintassi.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-166">Yet, because they are important when implementing a feature like refactoring and to maintain full fidelity with the source text, they do exist as part of the syntax tree.</span></span>

<span data-ttu-id="0b8fa-167">È possibile accedere a Trivia controllando le raccolte o di un token <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="0b8fa-167">You can access trivia by inspecting a token's <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> collections.</span></span> <span data-ttu-id="0b8fa-168">Quando viene analizzato il testo di origine, le sequenze di elementi semplici vengono associate ai token.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-168">When source text is parsed, sequences of trivia are associated with tokens.</span></span> <span data-ttu-id="0b8fa-169">In generale, un token possiede tutti gli elementi semplici dopo di esso sulla stessa riga fino al token successivo.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-169">In general, a token owns any trivia after it on the same line up to the next token.</span></span> <span data-ttu-id="0b8fa-170">Tutti gli elementi semplici dopo tale riga vengono associati al token seguente.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-170">Any trivia after that line is associated with the following token.</span></span> <span data-ttu-id="0b8fa-171">Il primo token nel file di origine ottiene tutti gli elementi semplici iniziali e l'ultima sequenza degli elementi semplici nel file viene associata al token di fine del file, che in caso contrario ha larghezza zero.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-171">The first token in the source file gets all the initial trivia, and the last sequence of trivia in the file is tacked onto the end-of-file token, which otherwise has zero width.</span></span>

<span data-ttu-id="0b8fa-172">A differenza dei nodi e dei token di sintassi, per gli elementi semplici della sintassi non vi sono elementi padre.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-172">Unlike syntax nodes and tokens, syntax trivia do not have parents.</span></span> <span data-ttu-id="0b8fa-173">Tuttavia, dato che fanno parte dell'albero e ognuno è associato a un singolo token, è possibile accedere al token associato tramite la proprietà <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-173">Yet, because they are part of the tree and each is associated with a single token, you may access the token it is associated with using the <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> property.</span></span>

## <a name="spans"></a><span data-ttu-id="0b8fa-174">Intervalli</span><span class="sxs-lookup"><span data-stu-id="0b8fa-174">Spans</span></span>

<span data-ttu-id="0b8fa-175">Ogni nodo, token o elemento semplice conosce la propria posizione all'interno del testo di origine e il numero di caratteri di cui è costituito.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-175">Each node, token, or trivia knows its position within the source text and the number of characters it consists of.</span></span> <span data-ttu-id="0b8fa-176">Una posizione del testo è rappresentata come intero a 32 bit, ovvero un indice `char` in base zero.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-176">A text position is represented as a 32-bit integer, which is a zero-based `char` index.</span></span> <span data-ttu-id="0b8fa-177">Un oggetto <xref:Microsoft.CodeAnalysis.Text.TextSpan> rappresenta la posizione di inizio e il conteggio di caratteri, entrambi rappresentati come valori integer.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-177">A <xref:Microsoft.CodeAnalysis.Text.TextSpan> object is the beginning position and a count of characters, both represented as integers.</span></span> <span data-ttu-id="0b8fa-178">Se <xref:Microsoft.CodeAnalysis.Text.TextSpan> ha lunghezza zero, fa riferimento a una posizione tra due caratteri.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-178">If <xref:Microsoft.CodeAnalysis.Text.TextSpan> has a zero length, it refers to a location between two characters.</span></span>

<span data-ttu-id="0b8fa-179">Ogni nodo ha due proprietà <xref:Microsoft.CodeAnalysis.Text.TextSpan>: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> e <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A>.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-179">Each node has two <xref:Microsoft.CodeAnalysis.Text.TextSpan> properties: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> and <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A>.</span></span>

<span data-ttu-id="0b8fa-180">La <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> proprietà è l'intervallo di testo dall'inizio del primo token nel sottoalbero del nodo alla fine dell'ultimo token.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-180">The <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> property is the text span from the start of the first token in the node's subtree to the end of the last token.</span></span> <span data-ttu-id="0b8fa-181">Questo intervallo non include alcun elemento semplice iniziale o finale.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-181">This span does not include any leading or trailing trivia.</span></span>

<span data-ttu-id="0b8fa-182">La <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A> proprietà è l'intervallo di testo che include l'intervallo normale del nodo, più l'intervallo di eventuali Trivia iniziali o finali.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-182">The <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A> property is the text span that includes the node's normal span, plus the span of any leading or trailing trivia.</span></span>

<span data-ttu-id="0b8fa-183">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="0b8fa-183">For example:</span></span>

``` csharp
      if (x > 3)
      {
||        // this is bad
          |throw new Exception("Not right.");|  // better exception?||
      }
```

<span data-ttu-id="0b8fa-184">Il nodo dell'istruzione all'interno del blocco ha un intervallo indicato da singole barre verticali (|)</span><span class="sxs-lookup"><span data-stu-id="0b8fa-184">The statement node inside the block has a span indicated by the single vertical bars (|).</span></span> <span data-ttu-id="0b8fa-185">e include i caratteri `throw new Exception("Not right.");`.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-185">It includes the characters `throw new Exception("Not right.");`.</span></span> <span data-ttu-id="0b8fa-186">L'intervallo completo è indicato dalla doppia barra verticale (||)</span><span class="sxs-lookup"><span data-stu-id="0b8fa-186">The full span is indicated by the double vertical bars (||).</span></span> <span data-ttu-id="0b8fa-187">e include gli stessi caratteri dell'intervallo, oltre ai caratteri associati agli elementi semplici iniziali e finali.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-187">It includes the same characters as the span and the characters associated with the leading and trailing trivia.</span></span>

## <a name="kinds"></a><span data-ttu-id="0b8fa-188">Tipi</span><span class="sxs-lookup"><span data-stu-id="0b8fa-188">Kinds</span></span>

<span data-ttu-id="0b8fa-189">Ogni nodo, token o elemento semplice ha una proprietà <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> di tipo <xref:System.Int32?displayProperty=nameWithType>, che identifica l'elemento di sintassi esatto rappresentato.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-189">Each node, token, or trivia has a <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> property, of type <xref:System.Int32?displayProperty=nameWithType>, that identifies the exact syntax element represented.</span></span> <span data-ttu-id="0b8fa-190">È possibile eseguire il cast di questo valore in un'enumerazione specifica del linguaggio.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-190">This value can be cast to a language-specific enumeration.</span></span> <span data-ttu-id="0b8fa-191">Ogni linguaggio, C# o Visual Basic, ha una sola `SyntaxKind` enumerazione ( <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> e <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType> rispettivamente) che elenca tutti i possibili nodi, token ed elementi Trivia nella grammatica.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-191">Each language, C# or Visual Basic, has a single `SyntaxKind` enumeration  (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> and <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>, respectively) that lists all the possible nodes, tokens, and trivia elements in the grammar.</span></span> <span data-ttu-id="0b8fa-192">Questa conversione può essere eseguita automaticamente mediante l'accesso ai metodi di estensione <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A?displayProperty=nameWithType> o <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-192">This conversion can be done automatically by accessing the <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind%2A?displayProperty=nameWithType> extension methods.</span></span>

<span data-ttu-id="0b8fa-193">La proprietà <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> consente di risolvere facilmente eventuali ambiguità per i tipi di nodi della sintassi che condividono la stessa classe di nodo.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-193">The <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> property allows for easy disambiguation of syntax node types that share the same node class.</span></span> <span data-ttu-id="0b8fa-194">Per i token e gli elementi semplici, questa proprietà è l'unico modo per distinguere un tipo di elemento da un alto.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-194">For tokens and trivia, this property is the only way to distinguish one type of element from another.</span></span>

<span data-ttu-id="0b8fa-195">Ad esempio, una singola classe <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> include gli elementi figlio <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> e <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-195">For example, a single <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> class has <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> as children.</span></span> <span data-ttu-id="0b8fa-196">La proprietà <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A> consente di stabilire se si tratta di un nodo di sintassi di tipo <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression> o <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression>.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-196">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A> property distinguishes whether it is an <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>, or <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> kind of syntax node.</span></span>

## <a name="errors"></a><span data-ttu-id="0b8fa-197">Errori</span><span class="sxs-lookup"><span data-stu-id="0b8fa-197">Errors</span></span>

<span data-ttu-id="0b8fa-198">Anche quando il testo di origine contiene errori di sintassi, viene esposto un albero della sintassi completo riconducibile tramite round-trip all'origine.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-198">Even when the source text contains syntax errors, a full syntax tree that is round-trippable to the source is exposed.</span></span> <span data-ttu-id="0b8fa-199">Quando il parser rileva codice non conforme alla sintassi definita del linguaggio, usa una delle due tecniche per creare un albero della sintassi:</span><span class="sxs-lookup"><span data-stu-id="0b8fa-199">When the parser encounters code that does not conform to the defined syntax of the language, it uses one of two techniques to create a syntax tree:</span></span>

- <span data-ttu-id="0b8fa-200">Se il parser prevede un tipo specifico di token ma non lo trova, può inserire un token mancante nell'albero della sintassi nella posizione in cui era previsto il token.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-200">If the parser expects a particular kind of token but does not find it, it may insert a missing token into the syntax tree in the location that the token was expected.</span></span> <span data-ttu-id="0b8fa-201">Un token mancante rappresenta il token effettivo previsto, ma con intervallo vuoto e la relativa proprietà <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-201">A missing token represents the actual token that was expected, but it has an empty span, and its <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> property returns `true`.</span></span>

- <span data-ttu-id="0b8fa-202">Il parser può ignorare i token finché non ne trova uno che può continuare l'analisi.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-202">The parser may skip tokens until it finds one where it can continue parsing.</span></span> <span data-ttu-id="0b8fa-203">In questo caso, i token ignorati vengono associati come nodo di elementi semplici con il tipo <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span><span class="sxs-lookup"><span data-stu-id="0b8fa-203">In this case, the skipped tokens are attached as a trivia node with the kind <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span></span>
