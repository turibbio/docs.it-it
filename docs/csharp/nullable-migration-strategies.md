---
title: Aggiornare la codebase per utilizzare tipi di riferimento nullableUpdate your codebase to use nullable reference types
description: Scegliere la strategia migliore per l'aggiornamento della codebase per l'utilizzo di tipi di riferimento nullable.
ms.technology: csharp-null-safety
ms.date: 07/31/2019
ms.openlocfilehash: b4a10863aea5c47b47c2a017afb20786b1e67528
ms.sourcegitcommit: 73aa9653547a1cd70ee6586221f79cc29b588ebd
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/23/2020
ms.locfileid: "82103527"
---
# <a name="update-libraries-to-use-nullable-reference-types-and-communicate-nullable-rules-to-callers"></a><span data-ttu-id="23b01-103">Aggiornare le librerie per utilizzare tipi di riferimento nullable e comunicare regole nullable ai chiamantiUpdate libraries to use nullable reference types and communicate nullable rules to callers</span><span class="sxs-lookup"><span data-stu-id="23b01-103">Update libraries to use nullable reference types and communicate nullable rules to callers</span></span>

<span data-ttu-id="23b01-104">L'aggiunta di tipi di [riferimento nullable](nullable-references.md) `null` significa che è possibile dichiarare se un valore è consentito o previsto per ogni variabile.</span><span class="sxs-lookup"><span data-stu-id="23b01-104">The addition of [nullable reference types](nullable-references.md) means you can declare whether or not a `null` value is allowed or expected for every variable.</span></span> <span data-ttu-id="23b01-105">Inoltre, è possibile applicare una `AllowNull`serie `DisallowNull` `MaybeNull`di `NotNull` `NotNullWhen`attributi: , , , , `MaybeNullWhen`, e `NotNullIfNotNull` per descrivere completamente gli stati null dei valori argument e return .</span><span class="sxs-lookup"><span data-stu-id="23b01-105">In addition, you can apply a number of attributes: `AllowNull`, `DisallowNull`, `MaybeNull`, `NotNull`, `NotNullWhen`, `MaybeNullWhen`, and `NotNullIfNotNull` to completely describe the null states of argument and return values.</span></span> <span data-ttu-id="23b01-106">Ciò offre un'esperienza eccezionale durante la scrittura del codice.</span><span class="sxs-lookup"><span data-stu-id="23b01-106">That provides a great experience as you write code.</span></span> <span data-ttu-id="23b01-107">Si ricevono avvisi se una variabile non `null`nullable può essere impostata su .</span><span class="sxs-lookup"><span data-stu-id="23b01-107">You get warnings if a non-nullable variable might be set to `null`.</span></span> <span data-ttu-id="23b01-108">Si ricevono avvisi se una variabile nullable non è sottoposta a controllo null prima di dereferenziarla.</span><span class="sxs-lookup"><span data-stu-id="23b01-108">You get warnings if a nullable variable isn't null-checked before you dereference it.</span></span> <span data-ttu-id="23b01-109">L'aggiornamento delle librerie può richiedere tempo, ma i payoff ne valgono la pena.</span><span class="sxs-lookup"><span data-stu-id="23b01-109">Updating your libraries can take time, but the payoffs are worth it.</span></span> <span data-ttu-id="23b01-110">Maggiore è il numero di informazioni `null` fornite al compilatore su *quando* un valore è consentito o non consentito, migliore sarà il otter degli utenti dell'API.</span><span class="sxs-lookup"><span data-stu-id="23b01-110">The more information you provide to the compiler about *when* a `null` value is allowed or prohibited, the better warnings users of your API will get.</span></span> <span data-ttu-id="23b01-111">Iniziamo con un esempio familiare.</span><span class="sxs-lookup"><span data-stu-id="23b01-111">Let's start with a familiar example.</span></span> <span data-ttu-id="23b01-112">Si supponga che la libreria disponga dell'API seguente per recuperare una stringa di risorsa:Imagine your library has the following API to retrieve a resource string:</span><span class="sxs-lookup"><span data-stu-id="23b01-112">Imagine your library has the following API to retrieve a resource string:</span></span>

```csharp
bool TryGetMessage(string key, out string message)
```

<span data-ttu-id="23b01-113">L'esempio precedente segue `Try*` il modello familiare in .NET.</span><span class="sxs-lookup"><span data-stu-id="23b01-113">The preceding example follows the familiar `Try*` pattern in .NET.</span></span> <span data-ttu-id="23b01-114">Esistono due argomenti di riferimento `key` per `message` questa API: il e il parametro.</span><span class="sxs-lookup"><span data-stu-id="23b01-114">There are two reference arguments for this API: the `key` and the `message` parameter.</span></span> <span data-ttu-id="23b01-115">Questa API ha le seguenti regole relative al nullo di questi argomenti:</span><span class="sxs-lookup"><span data-stu-id="23b01-115">This API has the following rules relating to the nullness of these arguments:</span></span>

- <span data-ttu-id="23b01-116">I chiamanti non `null` devono passare `key`come argomento per .</span><span class="sxs-lookup"><span data-stu-id="23b01-116">Callers shouldn't pass `null` as the argument for `key`.</span></span>
- <span data-ttu-id="23b01-117">I chiamanti possono passare `null` una variabile `message`il cui valore è come argomento per .</span><span class="sxs-lookup"><span data-stu-id="23b01-117">Callers can pass a variable whose value is `null` as the argument for `message`.</span></span>
- <span data-ttu-id="23b01-118">Se `TryGetMessage` il `true`metodo restituisce `message` , il valore di non è null.</span><span class="sxs-lookup"><span data-stu-id="23b01-118">If the `TryGetMessage` method returns `true`, the value of `message` isn't null.</span></span> <span data-ttu-id="23b01-119">Se il valore `false,` restituito `message` è il valore di (e il relativo stato null) è null.</span><span class="sxs-lookup"><span data-stu-id="23b01-119">If the return value is `false,` the value of `message` (and its null state) is null.</span></span>

<span data-ttu-id="23b01-120">La regola `key` per può essere completamente `key` espressa dal tipo di variabile: deve essere un tipo di riferimento non nullable.</span><span class="sxs-lookup"><span data-stu-id="23b01-120">The rule for `key` can be completely expressed by the variable type: `key` should be a non-nullable reference type.</span></span> <span data-ttu-id="23b01-121">Il `message` parametro è più complesso.</span><span class="sxs-lookup"><span data-stu-id="23b01-121">The `message` parameter is more complex.</span></span> <span data-ttu-id="23b01-122">Permette `null` come argomento, ma garantisce che, `out` in caso di esito positivo, tale argomento non sia null.</span><span class="sxs-lookup"><span data-stu-id="23b01-122">It allows `null` as the argument, but guarantees that, on success, that `out` argument isn't null.</span></span> <span data-ttu-id="23b01-123">Per questi scenari, è necessario un vocabolario più ricco per descrivere le aspettative.</span><span class="sxs-lookup"><span data-stu-id="23b01-123">For these scenarios, you need a richer vocabulary to describe the expectations.</span></span>

<span data-ttu-id="23b01-124">L'aggiornamento della libreria per i riferimenti nullable richiede più di spolverare `?` alcune delle variabili e dei nomi di tipo.</span><span class="sxs-lookup"><span data-stu-id="23b01-124">Updating your library for nullable references requires more than sprinkling `?` on some of the variables and type names.</span></span> <span data-ttu-id="23b01-125">L'esempio precedente mostra che è necessario esaminare le API e considerare le aspettative per ogni argomento di input.</span><span class="sxs-lookup"><span data-stu-id="23b01-125">The preceding example shows that you need to examine your APIs and consider your expectations for each input argument.</span></span> <span data-ttu-id="23b01-126">Considerare le garanzie per il `out` valore `ref` restituito e qualsiasi o argomenti al momento della restituzione del metodo.</span><span class="sxs-lookup"><span data-stu-id="23b01-126">Consider the guarantees for the return value, and any `out` or `ref` arguments upon the method's return.</span></span> <span data-ttu-id="23b01-127">Comunicare quindi tali regole al compilatore e il compilatore fornirà avvisi quando i chiamanti non rispettano tali regole.</span><span class="sxs-lookup"><span data-stu-id="23b01-127">Then communicate those rules to the compiler, and the compiler will provide warnings when callers don't abide by those rules.</span></span>

<span data-ttu-id="23b01-128">Questo lavoro richiede tempo.</span><span class="sxs-lookup"><span data-stu-id="23b01-128">This work takes time.</span></span> <span data-ttu-id="23b01-129">Iniziamo con strategie per rendere la libreria o l'applicazione compatibile con i valori Null, bilanciando al contempo altri requisiti e risultati finali.</span><span class="sxs-lookup"><span data-stu-id="23b01-129">Let's start with strategies to make your library or application nullable-aware, while balancing other requirements and deliverables.</span></span> <span data-ttu-id="23b01-130">Verrà illustrato come bilanciare lo sviluppo in corso abilitando i tipi di riferimento nullable.</span><span class="sxs-lookup"><span data-stu-id="23b01-130">You'll see how to balance ongoing development enabling nullable reference types.</span></span> <span data-ttu-id="23b01-131">Si apprenderanno le sfide per le definizioni di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="23b01-131">You'll learn challenges for generic type definitions.</span></span> <span data-ttu-id="23b01-132">Imparerai ad applicare gli attributi per descrivere le pre e post-condizioni sulle singole API.</span><span class="sxs-lookup"><span data-stu-id="23b01-132">You'll learn to apply attributes to describe pre- and post-conditions on individual APIs.</span></span>

## <a name="choose-a-strategy-for-nullable-reference-types"></a><span data-ttu-id="23b01-133">Scegliere una strategia per i tipi di riferimento nullableChoose a strategy for nullable reference types</span><span class="sxs-lookup"><span data-stu-id="23b01-133">Choose a strategy for nullable reference types</span></span>

<span data-ttu-id="23b01-134">La prima scelta è se i tipi di riferimento nullable devono essere attivati o disattivati per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="23b01-134">The first choice is whether nullable reference types should be on or off by default.</span></span> <span data-ttu-id="23b01-135">Sono disponibili due strategie:</span><span class="sxs-lookup"><span data-stu-id="23b01-135">You have two strategies:</span></span>

- <span data-ttu-id="23b01-136">Abilitare i tipi di riferimento nullable per l'intero progetto e disabilitarlo nel codice che non è pronto.</span><span class="sxs-lookup"><span data-stu-id="23b01-136">Enable nullable reference types for the entire project, and disable it in code that's not ready.</span></span>
- <span data-ttu-id="23b01-137">Abilitare i tipi di riferimento nullable solo per il codice che è stato annotato per i tipi di riferimento nullable.</span><span class="sxs-lookup"><span data-stu-id="23b01-137">Only enable nullable reference types for code that's been annotated for nullable reference types.</span></span>

<span data-ttu-id="23b01-138">La prima strategia funziona meglio quando si aggiungono altre funzionalità alla libreria quando viene aggiornata per i tipi di riferimento nullable.</span><span class="sxs-lookup"><span data-stu-id="23b01-138">The first strategy works best when you're adding other features to the library as you update it for nullable reference types.</span></span> <span data-ttu-id="23b01-139">Tutto il nuovo sviluppo è nullable in grado di riconoscere.</span><span class="sxs-lookup"><span data-stu-id="23b01-139">All new development is nullable aware.</span></span> <span data-ttu-id="23b01-140">Quando si aggiorna il codice esistente, si abilitano i tipi di riferimento nullable in tali classi.</span><span class="sxs-lookup"><span data-stu-id="23b01-140">As you update existing code, you enable nullable reference types in those classes.</span></span>

<span data-ttu-id="23b01-141">Attenendosi a questa prima strategia, eseguire le operazioni seguenti:Following this first strategy, you do the following:</span><span class="sxs-lookup"><span data-stu-id="23b01-141">Following this first strategy, you do the following:</span></span>

1. <span data-ttu-id="23b01-142">Abilitare i tipi di riferimento nullable per l'intero progetto aggiungendo l'elemento `<Nullable>enable</Nullable>` ai file *csproj.*</span><span class="sxs-lookup"><span data-stu-id="23b01-142">Enable nullable reference types for the entire project by adding the `<Nullable>enable</Nullable>` element to your *csproj* files.</span></span>
1. <span data-ttu-id="23b01-143">Aggiungere `#nullable disable` il pragma a ogni file di origine nel progetto.</span><span class="sxs-lookup"><span data-stu-id="23b01-143">Add the `#nullable disable` pragma to every source file in your project.</span></span>
1. <span data-ttu-id="23b01-144">Mentre si lavora su ogni file, rimuovere il pragma e risolvere eventuali avvisi.</span><span class="sxs-lookup"><span data-stu-id="23b01-144">As you work on each file, remove the pragma and address any warnings.</span></span>

<span data-ttu-id="23b01-145">Questa prima strategia ha più lavoro iniziale per aggiungere il pragma a ogni file.</span><span class="sxs-lookup"><span data-stu-id="23b01-145">This first strategy has more up-front work to add the pragma to every file.</span></span> <span data-ttu-id="23b01-146">Il vantaggio è che ogni nuovo file di codice aggiunto al progetto sarà nullable abilitato.</span><span class="sxs-lookup"><span data-stu-id="23b01-146">The advantage is that every new code file added to the project will be nullable enabled.</span></span> <span data-ttu-id="23b01-147">Qualsiasi nuovo lavoro sarà nullable in grado di riconoscere; solo il codice esistente deve essere aggiornato.</span><span class="sxs-lookup"><span data-stu-id="23b01-147">Any new work will be nullable aware; only existing code must be updated.</span></span>

<span data-ttu-id="23b01-148">La seconda strategia funziona meglio se la libreria è generalmente stabile e l'obiettivo principale dello sviluppo è quello di adottare tipi di riferimento nullable.</span><span class="sxs-lookup"><span data-stu-id="23b01-148">The second strategy works better if the library is generally stable, and the main focus of the development is to adopt nullable reference types.</span></span> <span data-ttu-id="23b01-149">Attivare i tipi di riferimento nullable durante l'annotazione API.</span><span class="sxs-lookup"><span data-stu-id="23b01-149">You turn on nullable reference types as you annotate APIs.</span></span> <span data-ttu-id="23b01-150">Al termine, si abilitano i tipi di riferimento nullable per l'intero progetto.</span><span class="sxs-lookup"><span data-stu-id="23b01-150">When you've finished, you enable nullable reference types for the entire project.</span></span>

<span data-ttu-id="23b01-151">Seguendo questa seconda strategia si fanno le seguenti operazioni:</span><span class="sxs-lookup"><span data-stu-id="23b01-151">Following this second strategy you do the following:</span></span>

1. <span data-ttu-id="23b01-152">Aggiungere `#nullable enable` il pragma al file che si desidera rendere nullable consapevole.</span><span class="sxs-lookup"><span data-stu-id="23b01-152">Add the `#nullable enable` pragma to the file you want to make nullable aware.</span></span>
1. <span data-ttu-id="23b01-153">Risolvere eventuali avvisi.</span><span class="sxs-lookup"><span data-stu-id="23b01-153">Address any warnings.</span></span>
1. <span data-ttu-id="23b01-154">Continuare questi primi due passaggi fino a quando non è stata resa l'intera libreria nullable in grado di riconoscere.</span><span class="sxs-lookup"><span data-stu-id="23b01-154">Continue these first two steps until you've made the entire library nullable aware.</span></span>
1. <span data-ttu-id="23b01-155">Abilitare i tipi nullable per `<Nullable>enable</Nullable>` l'intero progetto aggiungendo l'elemento ai file *csproj.*</span><span class="sxs-lookup"><span data-stu-id="23b01-155">Enable nullable types for the entire project by adding the `<Nullable>enable</Nullable>` element to your *csproj* files.</span></span>
1. <span data-ttu-id="23b01-156">Rimuovere `#nullable enable` i pragma, in quanto non sono più necessari.</span><span class="sxs-lookup"><span data-stu-id="23b01-156">Remove the `#nullable enable` pragmas, as they're no longer needed.</span></span>

<span data-ttu-id="23b01-157">Questa seconda strategia ha meno lavoro in anticipo.</span><span class="sxs-lookup"><span data-stu-id="23b01-157">This second strategy has less work up-front.</span></span> <span data-ttu-id="23b01-158">Il compromesso è che la prima attività quando si crea un nuovo file consiste nell'aggiungere il pragma e renderlo nullable.</span><span class="sxs-lookup"><span data-stu-id="23b01-158">The tradeoff is that the first task when you create a new file is to add the pragma and make it nullable aware.</span></span> <span data-ttu-id="23b01-159">Se gli sviluppatori del team dimenticano, che il nuovo codice è ora nel backlog del lavoro per rendere tutto il codice nullable in grado di riconoscere.</span><span class="sxs-lookup"><span data-stu-id="23b01-159">If any developers on your team forget, that new code is now in the backlog of work to make all code nullable aware.</span></span>

<span data-ttu-id="23b01-160">Quale di queste strategie si sceglie dipende da quanto sviluppo attivo sta avvenendo nel vostro progetto.</span><span class="sxs-lookup"><span data-stu-id="23b01-160">Which of these strategies you pick depends on how much active development is taking place in your project.</span></span> <span data-ttu-id="23b01-161">Più il tuo progetto è maturo e stabile, migliore è la seconda strategia.</span><span class="sxs-lookup"><span data-stu-id="23b01-161">The more mature and stable your project, the better the second strategy.</span></span> <span data-ttu-id="23b01-162">Più caratteristiche vengono sviluppate, migliore è la prima strategia.</span><span class="sxs-lookup"><span data-stu-id="23b01-162">The more features being developed, the better the first strategy.</span></span>

## <a name="should-nullable-warnings-introduce-breaking-changes"></a><span data-ttu-id="23b01-163">Gli avvisi nullable devono introdurre modifiche di rilievo?</span><span class="sxs-lookup"><span data-stu-id="23b01-163">Should nullable warnings introduce breaking changes?</span></span>

<span data-ttu-id="23b01-164">Prima di abilitare i tipi di riferimento nullable, le variabili vengono considerate *nullable oblio .*</span><span class="sxs-lookup"><span data-stu-id="23b01-164">Before you enable nullable reference types, variables are considered *nullable oblivious*.</span></span> <span data-ttu-id="23b01-165">Dopo aver abilitato i tipi di riferimento nullable, tutte queste variabili non sono *nullable.*</span><span class="sxs-lookup"><span data-stu-id="23b01-165">Once you enable nullable reference types, all those variables are *non-nullable*.</span></span> <span data-ttu-id="23b01-166">Il compilatore rilascerà avvisi se tali variabili non vengono inizializzate su valori non null.</span><span class="sxs-lookup"><span data-stu-id="23b01-166">The compiler will issue warnings if those variables aren't initialized to non-null values.</span></span>

<span data-ttu-id="23b01-167">Un'altra probabile origine di avvisi è restituire valori quando il valore non è stato inizializzato.</span><span class="sxs-lookup"><span data-stu-id="23b01-167">Another likely source of warnings is return values when the value hasn't been initialized.</span></span>

<span data-ttu-id="23b01-168">Il primo passaggio nell'indirizzamento `?` degli avvisi del compilatore consiste nell'utilizzare le annotazioni sui tipi parameter e return per indicare quando gli argomenti o i valori restituiti possono essere null.</span><span class="sxs-lookup"><span data-stu-id="23b01-168">The first step in addressing the compiler warnings is to use `?` annotations on parameter and return types to indicate when arguments or return values may be null.</span></span> <span data-ttu-id="23b01-169">Quando le variabili di riferimento non devono essere null, la dichiarazione originale è corretta.</span><span class="sxs-lookup"><span data-stu-id="23b01-169">When reference variables must not be null, the original declaration is correct.</span></span> <span data-ttu-id="23b01-170">In questo modo, l'obiettivo non è solo quello di correggere gli avvisi.</span><span class="sxs-lookup"><span data-stu-id="23b01-170">As you do this, your goal isn't just to fix warnings.</span></span> <span data-ttu-id="23b01-171">L'obiettivo più importante è quello di rendere il compilatore comprendere l'intento per i potenziali valori null.</span><span class="sxs-lookup"><span data-stu-id="23b01-171">The more important goal is to make the compiler understand your intent for potential null values.</span></span> <span data-ttu-id="23b01-172">Mentre esamini gli avvisi, raggiungi la tua prossima decisione importante per la tua biblioteca.</span><span class="sxs-lookup"><span data-stu-id="23b01-172">As you examine the warnings, you reach your next major decision for your library.</span></span> <span data-ttu-id="23b01-173">Si vuole prendere in considerazione la modifica delle firme API per comunicare in modo più chiaro le finalità di progettazione?</span><span class="sxs-lookup"><span data-stu-id="23b01-173">Do you want to consider modifying API signatures to more clearly communicate your design intent?</span></span> <span data-ttu-id="23b01-174">Una migliore firma `TryGetMessage` API per il metodo esaminato in precedenza potrebbe essere:A better API signature for the method examined earlier could be:</span><span class="sxs-lookup"><span data-stu-id="23b01-174">A better API signature for the `TryGetMessage` method examined earlier could be:</span></span>

```csharp
string? TryGetMessage(string key);
```

<span data-ttu-id="23b01-175">Il valore restituito indica l'esito positivo o negativo e contiene il valore se il valore è stato trovato.</span><span class="sxs-lookup"><span data-stu-id="23b01-175">The return value indicates success or failure, and carries the value if the value was found.</span></span> <span data-ttu-id="23b01-176">In molti casi, la modifica delle firme API può migliorare il modo in cui comunicano valori null.</span><span class="sxs-lookup"><span data-stu-id="23b01-176">In many cases, changing API signatures can improve how they communicate null values.</span></span>

<span data-ttu-id="23b01-177">Tuttavia, per le librerie pubbliche o le librerie con basi di utenti di grandi dimensioni, è preferibile non introdurre modifiche alla firma API.</span><span class="sxs-lookup"><span data-stu-id="23b01-177">However, for public libraries, or libraries with large user bases, you may prefer not introducing any API signature changes.</span></span> <span data-ttu-id="23b01-178">In questi casi e altri modelli comuni, è possibile applicare attributi per `null`definire in modo più chiaro quando un argomento o un valore restituito può essere .</span><span class="sxs-lookup"><span data-stu-id="23b01-178">For those cases, and other common patterns, you can apply attributes to more clearly define when an argument or return value may be `null`.</span></span> <span data-ttu-id="23b01-179">Indipendentemente dal fatto che si consideri o meno la modifica della superficie dell'API, è probabile che le annotazioni di tipo da sole non sono sufficienti per descrivere `null` i valori per gli argomenti o i valori restituiti.</span><span class="sxs-lookup"><span data-stu-id="23b01-179">Whether or not you consider changing the surface of your API, you'll likely find that type annotations alone aren't sufficient for describing `null` values for arguments or return values.</span></span> <span data-ttu-id="23b01-180">In questi casi, è possibile applicare attributi per descrivere in modo più chiaro un'API.</span><span class="sxs-lookup"><span data-stu-id="23b01-180">In those instances, you can apply attributes to more clearly describe an API.</span></span>

## <a name="attributes-extend-type-annotations"></a><span data-ttu-id="23b01-181">Gli attributi estendono le annotazioni di tipo</span><span class="sxs-lookup"><span data-stu-id="23b01-181">Attributes extend type annotations</span></span>

<span data-ttu-id="23b01-182">Sono stati aggiunti diversi attributi per esprimere informazioni aggiuntive sullo stato null delle variabili.</span><span class="sxs-lookup"><span data-stu-id="23b01-182">Several attributes have been added to express additional information about the null state of variables.</span></span> <span data-ttu-id="23b01-183">Tutto il codice scritto prima dell'introduzione di tipi di riferimento nullable in C, 8, era *null oblio.*</span><span class="sxs-lookup"><span data-stu-id="23b01-183">All code you wrote before C# 8 introduced nullable reference types was *null oblivious*.</span></span> <span data-ttu-id="23b01-184">Ciò significa che qualsiasi variabile di tipo riferimento può essere null, ma i controlli null non sono necessari.</span><span class="sxs-lookup"><span data-stu-id="23b01-184">That means any reference type variable may be null, but null checks aren't required.</span></span> <span data-ttu-id="23b01-185">Una volta che il codice è *nullable in grado di riconoscere*, tali regole cambiano.</span><span class="sxs-lookup"><span data-stu-id="23b01-185">Once your code is *nullable aware*, those rules change.</span></span> <span data-ttu-id="23b01-186">I tipi di `null` riferimento non devono mai essere il `null` valore e i tipi di riferimento nullable devono essere confrontati prima di essere dereferenziati.</span><span class="sxs-lookup"><span data-stu-id="23b01-186">Reference types should never be the `null` value, and nullable reference types must be checked against `null` before being dereferenced.</span></span>

<span data-ttu-id="23b01-187">Le regole per le API sono probabilmente più `TryGetValue` complicate, come si è visto con lo scenario API.</span><span class="sxs-lookup"><span data-stu-id="23b01-187">The rules for your APIs are likely more complicated, as you saw with the `TryGetValue` API scenario.</span></span> <span data-ttu-id="23b01-188">Molte delle API hanno regole più complesse per quando le `null`variabili possono o non possono essere .</span><span class="sxs-lookup"><span data-stu-id="23b01-188">Many of your APIs have more complex rules for when variables can or can't be `null`.</span></span> <span data-ttu-id="23b01-189">In questi casi, userai gli attributi per esprimere tali regole.</span><span class="sxs-lookup"><span data-stu-id="23b01-189">In these cases, you'll use attributes to express those rules.</span></span> <span data-ttu-id="23b01-190">Gli attributi che descrivono la semantica dell'API sono disponibili nell'articolo [Attributi che influiscono sull'analisi nullable.](./language-reference/attributes/nullable-analysis.md)</span><span class="sxs-lookup"><span data-stu-id="23b01-190">The attributes that describe the semantics of your API are found in the article on [Attributes that impact nullable analysis](./language-reference/attributes/nullable-analysis.md).</span></span>

## <a name="generic-definitions-and-nullability"></a><span data-ttu-id="23b01-191">Definizioni generiche e supporto di valori NullGeneric definitions and nullability</span><span class="sxs-lookup"><span data-stu-id="23b01-191">Generic definitions and nullability</span></span>

<span data-ttu-id="23b01-192">La comunicazione corretta dello stato null dei tipi generici e dei metodi generici richiede particolare attenzione.</span><span class="sxs-lookup"><span data-stu-id="23b01-192">Correctly communicating the null state of generic types and generic methods requires special care.</span></span> <span data-ttu-id="23b01-193">Ciò deriva dal fatto che un tipo di valore nullable e un tipo di riferimento nullable sono fondamentalmente diversi.</span><span class="sxs-lookup"><span data-stu-id="23b01-193">This stems from the fact that a nullable value type and a nullable reference type are fundamentally different.</span></span> <span data-ttu-id="23b01-194">Un `int?` è un sinonimo di `Nullable<int>`, `string?` `string` mentre è con un attributo aggiunto dal compilatore.</span><span class="sxs-lookup"><span data-stu-id="23b01-194">An `int?` is a synonym for `Nullable<int>`, whereas `string?` is `string` with an attribute added by the compiler.</span></span> <span data-ttu-id="23b01-195">Il risultato è che il compilatore `T?` non `T` può `class` generare `struct`codice corretto per senza sapere se è un o un oggetto .</span><span class="sxs-lookup"><span data-stu-id="23b01-195">The result is that the compiler can't generate correct code for `T?` without knowing if `T` is a `class` or a `struct`.</span></span>

<span data-ttu-id="23b01-196">Ciò non significa che non è possibile utilizzare un tipo nullable (tipo di valore o tipo di riferimento) come argomento di tipo per un tipo generico chiuso.</span><span class="sxs-lookup"><span data-stu-id="23b01-196">This doesn't mean you can't use a nullable type (either value type or reference type) as the type argument for a closed generic type.</span></span> <span data-ttu-id="23b01-197">Entrambi `List<string?>` `List<int?>` e sono valide `List<T>`istanze di .</span><span class="sxs-lookup"><span data-stu-id="23b01-197">Both `List<string?>` and `List<int?>` are valid instantiations of `List<T>`.</span></span>

<span data-ttu-id="23b01-198">Ciò significa che non è `T?` possibile utilizzare in una classe generica o una dichiarazione di metodo senza vincoli.</span><span class="sxs-lookup"><span data-stu-id="23b01-198">What it does mean is that you can't use `T?` in a generic class or method declaration without constraints.</span></span> <span data-ttu-id="23b01-199">Ad esempio, <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> non verrà modificato `T?`in modo da restituire .</span><span class="sxs-lookup"><span data-stu-id="23b01-199">For example, <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> won't be changed to return `T?`.</span></span> <span data-ttu-id="23b01-200">È possibile superare questa `struct` limitazione aggiungendo il vincolo o `class` .</span><span class="sxs-lookup"><span data-stu-id="23b01-200">You can overcome this limitation by adding either the `struct` or `class` constraint.</span></span> <span data-ttu-id="23b01-201">Con uno di questi vincoli, il compilatore sa come generare codice per entrambi `T` e `T?`.</span><span class="sxs-lookup"><span data-stu-id="23b01-201">With either of those constraints, the compiler knows how to generate code for both `T` and `T?`.</span></span>

<span data-ttu-id="23b01-202">È possibile limitare i tipi utilizzati per un argomento di tipo generico come tipi non nullable.</span><span class="sxs-lookup"><span data-stu-id="23b01-202">You may want to restrict the types used for a generic type argument to be non-nullable types.</span></span> <span data-ttu-id="23b01-203">È possibile farlo aggiungendo `notnull` il vincolo su tale argomento di tipo.</span><span class="sxs-lookup"><span data-stu-id="23b01-203">You can do that by adding the `notnull` constraint on that type argument.</span></span> <span data-ttu-id="23b01-204">Quando viene applicato tale vincolo, l'argomento di tipo non deve essere un tipo nullable.</span><span class="sxs-lookup"><span data-stu-id="23b01-204">When that constraint is applied, the type argument must not be a nullable type.</span></span>
