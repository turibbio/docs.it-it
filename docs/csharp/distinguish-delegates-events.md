---
title: Distinzione di delegati ed eventi
description: Informazioni sulla differenza tra i delegati e gli eventi e su quando usare ognuna di queste funzionalità di .NET Core.
ms.date: 06/20/2016
ms.technology: csharp-fundamentals
ms.assetid: 0fdc8629-2fdb-4a7c-a433-5b9d04eaf911
ms.openlocfilehash: 4179330fe5e88da5d5034a150a057f63e31b178b
ms.sourcegitcommit: 961ec21c22d2f1d55c9cc8a7edf2ade1d1fd92e3
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/02/2020
ms.locfileid: "80588252"
---
# <a name="distinguishing-delegates-and-events"></a><span data-ttu-id="c0aa4-103">Distinzione di delegati ed eventi</span><span class="sxs-lookup"><span data-stu-id="c0aa4-103">Distinguishing Delegates and Events</span></span>

[<span data-ttu-id="c0aa4-104">Indietro</span><span class="sxs-lookup"><span data-stu-id="c0aa4-104">Previous</span></span>](modern-events.md)

<span data-ttu-id="c0aa4-105">Gli sviluppatori che non hanno familiarità con la piattaforma .NET Core spesso sono in difficoltà quando devono scegliere tra due tipi di progettazione, uno basato su `delegates` e l'altro su `events`.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-105">Developers that are new to the .NET Core platform often struggle when deciding between a design based on `delegates` and a design based on `events`.</span></span> <span data-ttu-id="c0aa4-106">Questo è un concetto difficile, poiché le due funzionalità del linguaggio sono molto simili.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-106">This is a difficult concept, because the two language features are very similar.</span></span> <span data-ttu-id="c0aa4-107">È persino possibile creare eventi usando il supporto del linguaggio per i delegati.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-107">Events are even built using the language support for delegates.</span></span>

<span data-ttu-id="c0aa4-108">Entrambi i tipi di progettazione consentono di usare scenari di associazione tardiva, in altre parole scenari in cui un componente comunica chiamando un metodo noto solo in runtime.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-108">They both offer a late binding scenario: they enable scenarios where a component communicates by calling a method that is only known at runtime.</span></span> <span data-ttu-id="c0aa4-109">Entrambi supportano metodi per sottoscrittori singoli e multipli.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-109">They both support single and multiple subscriber methods.</span></span> <span data-ttu-id="c0aa4-110">Questa funzionalità è nota anche come supporto singlecast e multicast.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-110">You may find this referred to as singlecast and multicast support.</span></span> <span data-ttu-id="c0aa4-111">Entrambi i tipi di progettazione usano una sintassi simile per l'aggiunta e la rimozione di gestori.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-111">They both support similar syntax for adding and removing handlers.</span></span> <span data-ttu-id="c0aa4-112">Per la chiamata dei metodi di generazione di eventi e di chiamata di delegati, infine, entrambi i tipi di progettazione usano esattamente la stessa sintassi.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-112">Finally, raising an event and calling a delegate use exactly the same method call syntax.</span></span> <span data-ttu-id="c0aa4-113">Supportano persino la stessa sintassi del metodo `Invoke()` con l'operatore `?.`.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-113">They even both support the same `Invoke()` method syntax for use with the `?.` operator.</span></span>

<span data-ttu-id="c0aa4-114">Con tutte queste analogie, è comprensibile avere difficoltà nel determinare quando usare ognuno dei due tipi di progettazione.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-114">With all those similarities, it is easy to have trouble determining when to use which.</span></span>

## <a name="listening-to-events-is-optional"></a><span data-ttu-id="c0aa4-115">L'ascolto di eventi è facoltativo</span><span class="sxs-lookup"><span data-stu-id="c0aa4-115">Listening to Events is Optional</span></span>

<span data-ttu-id="c0aa4-116">La considerazione più importante per determinare quale funzionalità del linguaggio usare è la necessità di un sottoscrittore associato.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-116">The most important consideration in determining which language feature to use is whether or not there must be an attached subscriber.</span></span> <span data-ttu-id="c0aa4-117">Se il codice deve chiamare il codice fornito dal sottoscrittore, è necessario usare una progettazione basata su delegati.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-117">If your code must call the code supplied by the subscriber, you should use a design based on delegates.</span></span> <span data-ttu-id="c0aa4-118">Se il codice è in grado di eseguire tutte le operazioni contenute senza chiamare alcun sottoscrittore, è necessario usare una progettazione basata su eventi.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-118">If your code can complete all its work without calling any subscribers, you should use a design based on events.</span></span>

<span data-ttu-id="c0aa4-119">Si considerino gli esempi compilati nel corso di questa sezione.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-119">Consider the examples built during this section.</span></span> <span data-ttu-id="c0aa4-120">Perché il codice con `List.Sort()` compilato sia in grado di ordinare correttamente gli elementi, deve essere dotato di una funzione di confronto.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-120">The code you built using `List.Sort()` must be given a comparer function in order to properly sort the elements.</span></span> <span data-ttu-id="c0aa4-121">Perché le query LINQ siano in grado di determinare quali elementi restituire, devono essere dotate di delegati.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-121">LINQ queries must be supplied with delegates in order to determine what elements to return.</span></span> <span data-ttu-id="c0aa4-122">In entrambi i casi è stata usata una progettazione compilata con delegati.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-122">Both used a design built with delegates.</span></span>

<span data-ttu-id="c0aa4-123">Si consideri l'evento `Progress`,</span><span class="sxs-lookup"><span data-stu-id="c0aa4-123">Consider the `Progress` event.</span></span> <span data-ttu-id="c0aa4-124">che segnala lo stato di un'attività.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-124">It reports progress on a task.</span></span>
<span data-ttu-id="c0aa4-125">L'attività continua indipendentemente dal fatto che siano presenti listener o meno.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-125">The task continues to proceed whether or not there are any listeners.</span></span>
<span data-ttu-id="c0aa4-126">Un altro esempio è rappresentato da `FileSearcher`,</span><span class="sxs-lookup"><span data-stu-id="c0aa4-126">The `FileSearcher` is another example.</span></span> <span data-ttu-id="c0aa4-127">che continua a cercare e trovare tutti i file specificati anche senza sottoscrittori di eventi associati.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-127">It would still search and find all the files that were sought, even with no event subscribers attached.</span></span>
<span data-ttu-id="c0aa4-128">I controlli UX continuano a funzionare correttamente, anche se non sono presenti sottoscrittori in ascolto degli eventi.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-128">UX controls still work correctly, even when there are no subscribers listening to the events.</span></span> <span data-ttu-id="c0aa4-129">Entrambi gli esempi usano progettazioni basate su eventi.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-129">They both use designs based on events.</span></span>

## <a name="return-values-require-delegates"></a><span data-ttu-id="c0aa4-130">Per la restituzione di valori sono necessari delegati</span><span class="sxs-lookup"><span data-stu-id="c0aa4-130">Return Values Require Delegates</span></span>

<span data-ttu-id="c0aa4-131">Un'altra considerazione riguarda il prototipo che si vuole usare per il metodo del delegato.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-131">Another consideration is the method prototype you would want for your delegate method.</span></span> <span data-ttu-id="c0aa4-132">Come si è visto, per i delegati usati per gli eventi il tipo restituito è void.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-132">As you've seen, the delegates used for events all have a void return type.</span></span> <span data-ttu-id="c0aa4-133">Si è visto anche che alcuni termini per la creazione di gestori eventi, invece, restituiscono informazioni alle origini eventi tramite la modifica di proprietà dell'oggetto argomento dell'evento.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-133">You've also seen that there are idioms to create event handlers that do pass information back to event sources through modifying properties of the event argument object.</span></span> <span data-ttu-id="c0aa4-134">Questi termini sono efficaci, ma non sono altrettanto naturali della restituzione di un valore da parte di un metodo.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-134">While these idioms do work, they are not as natural as returning a value from a method.</span></span>

<span data-ttu-id="c0aa4-135">Si tenga presente che spesso questi due tipi di euristica sono presenti entrambi: se il metodo del delegato restituisce un valore, è probabile che in qualche modo influisca sull'algoritmo.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-135">Notice that these two heuristics may often both be present: If your delegate method returns a value, it will likely impact the algorithm in some way.</span></span>

## <a name="events-have-private-invocation"></a><span data-ttu-id="c0aa4-136">Gli eventi hanno un'invocazione privata</span><span class="sxs-lookup"><span data-stu-id="c0aa4-136">Events Have Private Invocation</span></span>

<span data-ttu-id="c0aa4-137">Le classi diverse da quella in cui è contenuto un evento possono solo aggiungere e rimuovere listener di eventi; solo la classe contenente l'evento può richiamare l'evento.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-137">Classes other than the one in which an event is contained can only add and remove event listeners; only the class containing the event can invoke the event.</span></span> <span data-ttu-id="c0aa4-138">Gli eventi sono in genere membri di una classe pubblica.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-138">Events are typically public class members.</span></span>
<span data-ttu-id="c0aa4-139">In confronto, i delegati vengono spesso passati come parametri e archiviati come membri di classe privata, se vengono archiviati affatto.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-139">By comparison, delegates are often passed as parameters and stored as private class members, if they are stored at all.</span></span>

## <a name="event-listeners-often-have-longer-lifetimes"></a><span data-ttu-id="c0aa4-140">I listener di eventi hanno spesso una durata maggiore</span><span class="sxs-lookup"><span data-stu-id="c0aa4-140">Event Listeners Often Have Longer Lifetimes</span></span>

<span data-ttu-id="c0aa4-141">Questa è una giustificazione leggermente più debole.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-141">This is a slightly weaker justification.</span></span> <span data-ttu-id="c0aa4-142">È tuttavia possibile che le progettazioni basate su eventi siano più naturali se l'origine degli eventi genera eventi per un periodo di tempo duraturo.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-142">However, you may find that event-based designs are more natural when the event source will be raising events over a long period of time.</span></span> <span data-ttu-id="c0aa4-143">Esempi di ciò sono riscontrabili per controlli UX presenti in molti sistemi.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-143">You can see examples of this for UX controls on many systems.</span></span> <span data-ttu-id="c0aa4-144">Dopo la sottoscrizione di un evento, l'origine di questo può generare eventi per tutta la durata del programma.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-144">Once you subscribe to an event, the event source may raise events throughout the lifetime of the program.</span></span>
<span data-ttu-id="c0aa4-145">È possibile annullare la sottoscrizione di eventi quando questi non sono più necessari.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-145">(You can unsubscribe from events when you no longer need them.)</span></span>

<span data-ttu-id="c0aa4-146">Ciò contrasta con molte progettazioni basate su delegati, in cui un delegato viene usato come argomento per un metodo e non viene più usato dopo che il metodo ritorna.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-146">Contrast that with many delegate-based designs, where a delegate is used as an argument to a method, and the delegate is not used after that method returns.</span></span>

## <a name="evaluate-carefully"></a><span data-ttu-id="c0aa4-147">Valutare con attenzione</span><span class="sxs-lookup"><span data-stu-id="c0aa4-147">Evaluate Carefully</span></span>

<span data-ttu-id="c0aa4-148">Le considerazioni precedenti non rappresentano regole ferree</span><span class="sxs-lookup"><span data-stu-id="c0aa4-148">The above considerations are not hard and fast rules.</span></span> <span data-ttu-id="c0aa4-149">ma informazioni aggiuntive che consentono di stabilire la scelta più appropriata per il proprio caso specifico.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-149">Instead, they represent guidance that can help you decide which choice is best for your particular usage.</span></span> <span data-ttu-id="c0aa4-150">Date le analogie, è anche possibile eseguire un prototipo per entrambi i tipi di progettazione, per verificare quale risulterebbe più naturale usare.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-150">Because they are similar, you can even prototype both, and consider which would be more natural to work with.</span></span> <span data-ttu-id="c0aa4-151">Entrambi consentono di gestire in modo efficiente gli scenari di associazione tardiva.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-151">They both handle late binding scenarios well.</span></span> <span data-ttu-id="c0aa4-152">Usare quello che comunica meglio con il proprio progetto.</span><span class="sxs-lookup"><span data-stu-id="c0aa4-152">Use the one that communicates your design the best.</span></span>
