---
title: Metodi di estensione - Guida per programmatori C#
ms.date: 03/19/2020
helpviewer_keywords:
- methods [C#], adding to existing types
- extension methods [C#]
- methods [C#], extension
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
ms.openlocfilehash: 0b35ad523fc7f0949cb5243edbdc50cd3e927999
ms.sourcegitcommit: 99b153b93bf94d0fecf7c7bcecb58ac424dfa47c
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/25/2020
ms.locfileid: "80249220"
---
# <a name="extension-methods-c-programming-guide"></a><span data-ttu-id="f5fc5-102">Metodi di estensione (Guida per programmatori C#)</span><span class="sxs-lookup"><span data-stu-id="f5fc5-102">Extension Methods (C# Programming Guide)</span></span>

<span data-ttu-id="f5fc5-103">I metodi di estensione consentono di "aggiungere" metodi ai tipi esistenti senza creare un nuovo tipo derivato, ricompilare o modificare in altro modo il tipo originale.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-103">Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.</span></span> <span data-ttu-id="f5fc5-104">I metodi di estensione sono metodi statici, ma vengono chiamati come se fossero metodi di istanza sul tipo esteso.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-104">Extension methods are static methods, but they're called as if they were instance methods on the extended type.</span></span> <span data-ttu-id="f5fc5-105">Per il codice del client scritto in C, F e Visual Basic, non esiste alcuna differenza apparente tra la chiamata di un metodo di estensione e i metodi definiti in un tipo.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-105">For client code written in C#, F# and Visual Basic, there's no apparent difference between calling an extension method and the methods defined in a type.</span></span>

<span data-ttu-id="f5fc5-106">I metodi di estensione più comuni sono gli operatori <xref:System.Collections.IEnumerable?displayProperty=nameWithType> di <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> query standard LINQ che aggiungono funzionalità di query ai tipi e esistenti.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-106">The most common extension methods are the LINQ standard query operators that add query functionality to the existing <xref:System.Collections.IEnumerable?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="f5fc5-107">Per utilizzare gli operatori query standard, inserirli innanzitutto nell'ambito con una direttiva `using System.Linq`.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-107">To use the standard query operators, first bring them into scope with a `using System.Linq` directive.</span></span> <span data-ttu-id="f5fc5-108">In questo modo qualsiasi tipo che implementa <xref:System.Collections.Generic.IEnumerable%601> avrà apparentemente metodi di istanza quali <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>e così via.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-108">Then any type that implements <xref:System.Collections.Generic.IEnumerable%601> appears to have instance methods such as <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, and so on.</span></span> <span data-ttu-id="f5fc5-109">È possibile visualizzare questi metodi aggiuntivi con la funzionalità di completamento istruzioni di IntelliSense quando si digita "punto" dopo un'istanza di un tipo <xref:System.Collections.Generic.IEnumerable%601>, ad esempio <xref:System.Collections.Generic.List%601> o <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-109">You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an <xref:System.Collections.Generic.IEnumerable%601> type such as <xref:System.Collections.Generic.List%601> or <xref:System.Array>.</span></span>

### <a name="orderby-example"></a><span data-ttu-id="f5fc5-110">Esempio OrderBy</span><span class="sxs-lookup"><span data-stu-id="f5fc5-110">OrderBy Example</span></span>

<span data-ttu-id="f5fc5-111">Nell'esempio seguente viene illustrato come chiamare il metodo `OrderBy` dell'operatore query standard su una matrice di Integer.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-111">The following example shows how to call the standard query operator `OrderBy` method on an array of integers.</span></span> <span data-ttu-id="f5fc5-112">L'espressione tra parentesi è un'espressione lambda.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-112">The expression in parentheses is a lambda expression.</span></span> <span data-ttu-id="f5fc5-113">Molti operatori di query standard accettano espressioni lambda come parametri, ma questo non è un requisito per i metodi di estensione.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-113">Many standard query operators take lambda expressions as parameters, but this isn't a requirement for extension methods.</span></span> <span data-ttu-id="f5fc5-114">Per ulteriori informazioni, vedere [Espressioni lambda](../statements-expressions-operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="f5fc5-114">For more information, see [Lambda Expressions](../statements-expressions-operators/lambda-expressions.md).</span></span>

[!code-csharp[csProgGuideExtensionMethods#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#3)]

<span data-ttu-id="f5fc5-115">I metodi di estensione sono definiti come metodi statici, ma vengono chiamati utilizzando la sintassi del metodo di istanza.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-115">Extension methods are defined as static methods but are called by using instance method syntax.</span></span> <span data-ttu-id="f5fc5-116">Il primo parametro specifica il tipo su cui opera il metodo.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-116">Their first parameter specifies which type the method operates on.</span></span> <span data-ttu-id="f5fc5-117">Il parametro è preceduto dal modificatore [this.](../../language-reference/keywords/this.md)</span><span class="sxs-lookup"><span data-stu-id="f5fc5-117">The parameter is preceded by the [this](../../language-reference/keywords/this.md) modifier.</span></span> <span data-ttu-id="f5fc5-118">I metodi di estensione si trovano nell'ambito solo quando si importa in modo esplicito lo spazio dei nomi nel codice sorgente con una direttiva `using`.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-118">Extension methods are only in scope when you explicitly import the namespace into your source code with a `using` directive.</span></span>

<span data-ttu-id="f5fc5-119">Nell'esempio riportato di seguito viene illustrato un metodo di estensione definito per la classe <xref:System.String?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-119">The following example shows an extension method defined for the <xref:System.String?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="f5fc5-120">È definito all'interno di una classe statica non annidata e non generica:It's defined inside a non-nested, non-generic static class:</span><span class="sxs-lookup"><span data-stu-id="f5fc5-120">It's defined inside a non-nested, non-generic static class:</span></span>

[!code-csharp[csProgGuideExtensionMethods#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#4)]

<span data-ttu-id="f5fc5-121">Il metodo di estensione `WordCount` può essere inserito nell'ambito con questa direttiva `using`:</span><span class="sxs-lookup"><span data-stu-id="f5fc5-121">The `WordCount` extension method can be brought into scope with this `using` directive:</span></span>

```csharp
using ExtensionMethods;
```

<span data-ttu-id="f5fc5-122">Può inoltre essere chiamato da un'applicazione utilizzando questa sintassi:</span><span class="sxs-lookup"><span data-stu-id="f5fc5-122">And it can be called from an application by using this syntax:</span></span>

```csharp
string s = "Hello Extension Methods";
int i = s.WordCount();
```

<span data-ttu-id="f5fc5-123">Richiamare il metodo di estensione nel codice con la sintassi del metodo di istanza.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-123">You invoke the extension method in your code with instance method syntax.</span></span> <span data-ttu-id="f5fc5-124">Il linguaggio intermedio (IL) generato dal compilatore converte il codice in una chiamata al metodo statico.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-124">The intermediate language (IL) generated by the compiler translates your code into a call on the static method.</span></span> <span data-ttu-id="f5fc5-125">Il principio dell'incapsulamento non viene realmente violato.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-125">The principle of encapsulation is not really being violated.</span></span> <span data-ttu-id="f5fc5-126">I metodi di estensione non possono accedere alle variabili private nel tipo che stanno estendendo.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-126">Extension methods cannot access private variables in the type they are extending.</span></span>

<span data-ttu-id="f5fc5-127">Per ulteriori informazioni, vedere [Come implementare e chiamare un metodo](./how-to-implement-and-call-a-custom-extension-method.md)di estensione personalizzato .</span><span class="sxs-lookup"><span data-stu-id="f5fc5-127">For more information, see [How to implement and call a custom  extension method](./how-to-implement-and-call-a-custom-extension-method.md).</span></span>

<span data-ttu-id="f5fc5-128">In generale, probabilmente chiamerai i metodi di estensione molto più spesso rispetto all'implementazione di un proprio.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-128">In general, you'll probably be calling extension methods far more often than implementing your own.</span></span> <span data-ttu-id="f5fc5-129">Perché i metodi di estensione vengono chiamati utilizzando la sintassi del metodo di istanza, non è necessaria alcuna particolare conoscenza per utilizzarli dal codice client.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-129">Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code.</span></span> <span data-ttu-id="f5fc5-130">Per abilitare i metodi di estensione per un particolare tipo, aggiungere una direttiva `using` per lo spazio dei nomi nel quale sono definiti i metodi.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-130">To enable extension methods for a particular type, just add a `using` directive for the namespace in which the methods are defined.</span></span> <span data-ttu-id="f5fc5-131">Per utilizzare ad esempio gli operatori query standard, aggiungere questa direttiva `using` al codice:</span><span class="sxs-lookup"><span data-stu-id="f5fc5-131">For example, to use the standard query operators, add this `using` directive to your code:</span></span>

```csharp
using System.Linq;
```

<span data-ttu-id="f5fc5-132">Potrebbe anche essere necessario aggiungere un riferimento a System.Core.dll. Si noterà che gli operatori di query standard vengono ora <xref:System.Collections.Generic.IEnumerable%601> visualizzati in IntelliSense come metodi aggiuntivi disponibili per la maggior parte dei tipi.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-132">(You may also have to add a reference to System.Core.dll.) You'll notice that the standard query operators now appear in IntelliSense as additional methods available for most <xref:System.Collections.Generic.IEnumerable%601> types.</span></span>

## <a name="binding-extension-methods-at-compile-time"></a><span data-ttu-id="f5fc5-133">Associazione di metodi di estensione in fase di compilazione</span><span class="sxs-lookup"><span data-stu-id="f5fc5-133">Binding Extension Methods at Compile Time</span></span>

<span data-ttu-id="f5fc5-134">È possibile utilizzare metodi di estensione per estendere una classe o un'interfaccia, ma non per eseguirne l'override.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-134">You can use extension methods to extend a class or interface, but not to override them.</span></span> <span data-ttu-id="f5fc5-135">Un metodo di estensione con lo stesso nome e la stessa firma di un metodo di interfaccia o di classe non verrà mai chiamato.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-135">An extension method with the same name and signature as an interface or class method will never be called.</span></span> <span data-ttu-id="f5fc5-136">In fase di compilazione, i metodi di estensione hanno sempre una priorità più bassa dei metodi di istanza definiti nel tipo stesso.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-136">At compile time, extension methods always have lower priority than instance methods defined in the type itself.</span></span> <span data-ttu-id="f5fc5-137">In altre parole, se un tipo dispone di un metodo denominato `Process(int i)` e si dispone di un metodo di estensione con la stessa firma, il compilatore eseguirà sempre l'associazione al metodo di istanza.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-137">In other words, if a type has a method named `Process(int i)`, and you have an extension method with the same signature, the compiler will always bind to the instance method.</span></span> <span data-ttu-id="f5fc5-138">Quando il compilatore rileva una chiamata al metodo, cerca innanzitutto una corrispondenza nei metodi di istanza del tipo.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-138">When the compiler encounters a method invocation, it first looks for a match in the type's instance methods.</span></span> <span data-ttu-id="f5fc5-139">Se non viene trovata alcuna corrispondenza, cercherà eventuali metodi di estensione definiti per il tipo ed eseguirà l'associazione al primo metodo di estensione trovato.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-139">If no match is found, it will search for any extension methods that are defined for the type, and bind to the first extension method that it finds.</span></span> <span data-ttu-id="f5fc5-140">Nell'esempio seguente viene dimostrato come il compilatore determina a quale metodo di estensione o metodo di istanza eseguire l'associazione.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-140">The following example demonstrates how the compiler determines which extension method or instance method to bind to.</span></span>

## <a name="example"></a><span data-ttu-id="f5fc5-141">Esempio</span><span class="sxs-lookup"><span data-stu-id="f5fc5-141">Example</span></span>

<span data-ttu-id="f5fc5-142">Nell'esempio seguente vengono illustrate le regole che il compilatore C# segue nel determinare se associare una chiamata al metodo a un metodo di istanza sul tipo o a un metodo di estensione.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-142">The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method.</span></span> <span data-ttu-id="f5fc5-143">La classe `Extensions` statica contiene metodi di estensione definiti per qualsiasi tipo che implementa `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-143">The static class `Extensions` contains extension methods defined for any type that implements `IMyInterface`.</span></span> <span data-ttu-id="f5fc5-144">Le classi `A`, `B` e `C` implementano tutte l'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-144">Classes `A`, `B`, and `C` all implement the interface.</span></span>

<span data-ttu-id="f5fc5-145">Il metodo di estensione `MethodB` non viene mai chiamato perché il nome e la firma corrispondono esattamente a metodi già implementati dalle classi.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-145">The `MethodB` extension method is never called because its name and signature exactly match methods already implemented by the classes.</span></span>

<span data-ttu-id="f5fc5-146">Quando il compilatore non riesce a trovare un metodo di istanza con una firma corrispondente, verrà associato a un metodo di estensione corrispondente, se presente.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-146">When the compiler can't find an instance method with a matching signature, it will bind to a matching extension method if one exists.</span></span>

[!code-csharp[csProgGuideExtensionMethods#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#5)]

## <a name="common-usage-patterns"></a><span data-ttu-id="f5fc5-147">Modelli di utilizzo comuniCommon Usage Patterns</span><span class="sxs-lookup"><span data-stu-id="f5fc5-147">Common Usage Patterns</span></span>

### <a name="collection-functionality"></a><span data-ttu-id="f5fc5-148">Funzionalità di raccolta</span><span class="sxs-lookup"><span data-stu-id="f5fc5-148">Collection Functionality</span></span>

<span data-ttu-id="f5fc5-149">In passato, era comune creare "Classi di <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> raccolta" che implementavano l'interfaccia per un determinato tipo e contenevano funzionalità che fungevano da raccolte di quel tipo.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-149">In the past, it was common to create "Collection Classes" that implemented the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> interface for a given type and contained functionality that acted on collections of that type.</span></span> <span data-ttu-id="f5fc5-150">Anche se non c'è niente di sbagliato nella creazione di questo tipo <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>di oggetto insieme, la stessa funzionalità può essere ottenuta utilizzando un'estensione nel file .</span><span class="sxs-lookup"><span data-stu-id="f5fc5-150">While there's nothing wrong with creating this type of collection object, the same functionality can be achieved by using an extension on the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f5fc5-151">Le estensioni hanno il vantaggio di consentire la <xref:System.Array?displayProperty=nameWithType> funzionalità <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> da <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> chiamare da qualsiasi raccolta, ad esempio un o che implementa su quel tipo.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-151">Extensions have the advantage of allowing the functionality to be called from any collection such as an <xref:System.Array?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> that implements <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> on that type.</span></span> <span data-ttu-id="f5fc5-152">Un esempio di questo utilizzo di una matrice di Int32 è disponibile [in precedenza in questo articolo](#orderby-example).</span><span class="sxs-lookup"><span data-stu-id="f5fc5-152">An example of this using an Array of Int32 can be found [earlier in this article](#orderby-example).</span></span>

### <a name="layer-specific-functionality"></a><span data-ttu-id="f5fc5-153">Funzionalità specifiche del layer</span><span class="sxs-lookup"><span data-stu-id="f5fc5-153">Layer-Specific Functionality</span></span>

<span data-ttu-id="f5fc5-154">Quando si usa un'architettura Onion o un'altra progettazione di applicazioni a più livelli, è comune disporre di un set di entità di dominio o oggetti di trasferimento dati che possono essere utilizzati per comunicare oltre i limiti dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-154">When using an Onion Architecture or other layered application design, it's common to have a set of Domain Entities or Data Transfer Objects that can be used to communicate across application boundaries.</span></span> <span data-ttu-id="f5fc5-155">Questi oggetti in genere non contengono funzionalità o solo funzionalità minime che si applica a tutti i livelli dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-155">These objects generally contain no functionality, or only minimal functionality that applies to all layers of the application.</span></span> <span data-ttu-id="f5fc5-156">I metodi di estensione possono essere utilizzati per aggiungere funzionalità specifiche per ogni livello dell'applicazione senza caricare l'oggetto con metodi non necessari o desiderati in altri livelli.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-156">Extension methods can be used to add functionality that is specific to each application layer without loading the object down with methods not needed or wanted in other layers.</span></span>

```aspx-csharp
public class DomainEntity
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}

static class DomainEntityExtensions
{
    static string FullName(this DomainEntity value)
        => $"{value.FirstName} {value.LastName}";
}
```

### <a name="extending-predefined-types"></a><span data-ttu-id="f5fc5-157">Estensione dei tipi predefinitiExtending Predefined Types</span><span class="sxs-lookup"><span data-stu-id="f5fc5-157">Extending Predefined Types</span></span>

<span data-ttu-id="f5fc5-158">Anziché creare nuovi oggetti quando è necessario creare funzionalità riutilizzabili, è spesso possibile estendere un tipo esistente, ad esempio un tipo .NET Framework o CLR.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-158">Rather than creating new objects when reusable functionality needs to be created, we can often extend an existing type such as a .NET Framework or CLR type.</span></span> <span data-ttu-id="f5fc5-159">Ad esempio, se non si usano metodi di `Engine` estensione, è possibile creare un o `Query` una classe per eseguire il lavoro di esecuzione di una query su un SQL Server che può essere chiamato da più posizioni nel codice.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-159">As an example, if we don't use extension methods, we might create an `Engine` or `Query` class to do the work of executing a query on a SQL Server that may be called from multiple places in our code.</span></span> <span data-ttu-id="f5fc5-160">Tuttavia è possibile <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> estendere la classe utilizzando i metodi di estensione per eseguire la query da qualsiasi luogo abbiamo una connessione a un SQL Server.However we can instead extend the class using extension methods to perform that query from anywhere we have a connection to a SQL Server.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-160">However we can instead extend the <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> class using extension methods to perform that query from anywhere we have a connection to a SQL Server.</span></span> <span data-ttu-id="f5fc5-161">Altri esempi potrebbero essere l'aggiunta di funzionalità comuni alla <xref:System.String?displayProperty=nameWithType> classe, l'estensione delle funzionalità di elaborazione dati degli oggetti <xref:System.IO.File?displayProperty=nameWithType> e e <xref:System.IO.Stream?displayProperty=nameWithType> <xref:System.Exception?displayProperty=nameWithType> gli oggetti per funzionalità di gestione degli errori specifiche.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-161">Other examples might be to add common functionality to the <xref:System.String?displayProperty=nameWithType> class, extend the data processing capabilities of the <xref:System.IO.File?displayProperty=nameWithType> and <xref:System.IO.Stream?displayProperty=nameWithType> objects, and <xref:System.Exception?displayProperty=nameWithType> objects for specific error handling functionality.</span></span> <span data-ttu-id="f5fc5-162">Questi tipi di casi d'uso sono limitati solo dalla vostra immaginazione e buon senso.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-162">These types of use-cases are limited only by your imagination and good sense.</span></span>

<span data-ttu-id="f5fc5-163">L'estensione dei tipi `struct` predefiniti può essere difficile con i tipi perché vengono passati per valore ai metodi.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-163">Extending predefined types can be difficult with `struct` types because they're passed by value to methods.</span></span> <span data-ttu-id="f5fc5-164">Ciò significa che qualsiasi modifica alla struttura viene apportata a una copia della struttura.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-164">That means any changes to the struct are made to a copy of the struct.</span></span> <span data-ttu-id="f5fc5-165">Tali modifiche non sono visibili una volta terminato il metodo di estensione.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-165">Those changes aren't visible once the extension method exits.</span></span> <span data-ttu-id="f5fc5-166">A partire dalla versione 7.2 `ref` di C, è possibile aggiungere il modificatore al primo argomento di un metodo di estensione.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-166">Beginning with C# 7.2, you can add the `ref` modifier to the first argument of an extension method.</span></span> <span data-ttu-id="f5fc5-167">L'aggiunta del `ref` modificatore indica che il primo argomento viene passato per riferimento.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-167">Adding the `ref` modifier means the first argument is passed by reference.</span></span> <span data-ttu-id="f5fc5-168">In questo modo è possibile scrivere metodi di estensione che modificano lo stato dello struct da estendere.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-168">This enables you to write extension methods that change the state of the struct being extended.</span></span>

## <a name="general-guidelines"></a><span data-ttu-id="f5fc5-169">Linee guida generali</span><span class="sxs-lookup"><span data-stu-id="f5fc5-169">General Guidelines</span></span>

<span data-ttu-id="f5fc5-170">Mentre è ancora preferibile aggiungere funzionalità modificando il codice di un oggetto o derivando un nuovo tipo ogni volta che è ragionevole e possibile farlo, i metodi di estensione sono diventati un'opzione cruciale per la creazione di funzionalità riutilizzabili in .NET Ecosistema.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-170">While it's still considered preferable to add functionality by modifying an object's code or deriving a new type whenever it's reasonable and possible to do so, extension methods have become a crucial option for creating reusable functionality throughout the .NET ecosystem.</span></span> <span data-ttu-id="f5fc5-171">Per le occasioni in cui l'origine originale non è sotto il controllo dell'utente, quando un oggetto derivato è inappropriato o impossibile o quando la funzionalità non deve essere esposta oltre l'ambito applicabile, i metodi di estensione sono una scelta eccellente.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-171">For those occasions when the original source isn't under your control, when a derived object is inappropriate or impossible, or when the functionality shouldn't be exposed beyond its applicable scope, Extension methods are an excellent choice.</span></span>

<span data-ttu-id="f5fc5-172">Per ulteriori informazioni sui tipi derivati, vedere [ereditarietà](./inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="f5fc5-172">For more information on derived types, see [Inheritance](./inheritance.md).</span></span>

<span data-ttu-id="f5fc5-173">Quando si usa un metodo di estensione per estendere un tipo di cui non si è in controllo il codice sorgente, si corre il rischio che una modifica nell'implementazione del tipo provochi l'interruzione del metodo di estensione.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-173">When using an extension method to extend a type whose source code you aren't in control of, you run the risk that a change in the implementation of the type will cause your extension method to break.</span></span>

<span data-ttu-id="f5fc5-174">Se si implementano metodi di estensione per un determinato tipo, è importante tenere presente quanto segue:</span><span class="sxs-lookup"><span data-stu-id="f5fc5-174">If you do implement extension methods for a given type, remember the following points:</span></span>

- <span data-ttu-id="f5fc5-175">Un metodo di estensione non verrà mai chiamato se dispone della stessa firma di un metodo definito nel tipo.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-175">An extension method will never be called if it has the same signature as a method defined in the type.</span></span>
- <span data-ttu-id="f5fc5-176">I metodi di estensione vengono inseriti nell'ambito al livello dello spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-176">Extension methods are brought into scope at the namespace level.</span></span> <span data-ttu-id="f5fc5-177">Ad esempio, se si dispone di più classi statiche che contengono metodi di estensione in un singolo spazio dei nomi denominato `Extensions`, verranno tutti inseriti nell'ambito dalla `using Extensions;` direttiva .</span><span class="sxs-lookup"><span data-stu-id="f5fc5-177">For example, if you have multiple static classes that contain extension methods in a single namespace named `Extensions`, they'll all be brought into scope by the `using Extensions;` directive.</span></span>

<span data-ttu-id="f5fc5-178">Per una libreria di classi implementata, non è necessario utilizzare i metodi di estensione per evitare l'incremento del numero di versione di un assembly.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-178">For a class library that you implemented, you shouldn't use extension methods to avoid incrementing the version number of an assembly.</span></span> <span data-ttu-id="f5fc5-179">Se si desidera aggiungere funzionalità significative a una libreria per il quale si è proprietari del codice sorgente, è necessario seguire le linee guida standard di .NET Framework per il controllo delle versioni degli assembly.</span><span class="sxs-lookup"><span data-stu-id="f5fc5-179">If you want to add significant functionality to a library for which you own the source code, you should follow the standard .NET Framework guidelines for assembly versioning.</span></span> <span data-ttu-id="f5fc5-180">Per altre informazioni, vedere [Controllo delle versioni degli assembly](../../../standard/assembly/versioning.md).</span><span class="sxs-lookup"><span data-stu-id="f5fc5-180">For more information, see [Assembly Versioning](../../../standard/assembly/versioning.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="f5fc5-181">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="f5fc5-181">See also</span></span>

- [<span data-ttu-id="f5fc5-182">Guida alla programmazione in C</span><span class="sxs-lookup"><span data-stu-id="f5fc5-182">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="f5fc5-183">Esempi di programmazione parallela (sono inclusi molti metodi di estensione di esempio)</span><span class="sxs-lookup"><span data-stu-id="f5fc5-183">Parallel Programming Samples (these include many example extension methods)</span></span>](https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364)
- [<span data-ttu-id="f5fc5-184">Espressioni lambdaLambda Expressions</span><span class="sxs-lookup"><span data-stu-id="f5fc5-184">Lambda Expressions</span></span>](../statements-expressions-operators/lambda-expressions.md)
- [<span data-ttu-id="f5fc5-185">Cenni preliminari sugli operatori di query standard</span><span class="sxs-lookup"><span data-stu-id="f5fc5-185">Standard Query Operators Overview</span></span>](../concepts/linq/standard-query-operators-overview.md)
- [<span data-ttu-id="f5fc5-186">Regole di conversione per parametri Instance e relativo impatto</span><span class="sxs-lookup"><span data-stu-id="f5fc5-186">Conversion rules for Instance parameters and their impact</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/conversion-rules-for-instance-parameters-and-their-impact)
- [<span data-ttu-id="f5fc5-187">Interoperabilità dei metodi di estensione tra linguaggi</span><span class="sxs-lookup"><span data-stu-id="f5fc5-187">Extension methods Interoperability between languages</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-interoperability-between-languages)
- [<span data-ttu-id="f5fc5-188">Metodi di estensione e delegati sottoposti a currying</span><span class="sxs-lookup"><span data-stu-id="f5fc5-188">Extension methods and Curried Delegates</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-and-curried-delegates)
- [<span data-ttu-id="f5fc5-189">Associazione di metodi di estensione e segnalazione errori</span><span class="sxs-lookup"><span data-stu-id="f5fc5-189">Extension method Binding and Error reporting</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-method-binding-and-error-reporting)
