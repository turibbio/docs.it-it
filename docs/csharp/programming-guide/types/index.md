---
title: Tipi - Guida per programmatori C#
ms.date: 07/20/2015
helpviewer_keywords:
- value types [C#]
- reference types [C#]
- types [C#]
- C# language, data types
- common type system [C#]
- data types [C#]
- C# language, types
- strong typing [C#]
ms.assetid: f782d7cc-035e-4500-b1b1-36a9881130ad
ms.openlocfilehash: 1e0141ceafe4c3450b3f798463ddc62ea79f1b36
ms.sourcegitcommit: 27db07ffb26f76912feefba7b884313547410db5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 05/19/2020
ms.locfileid: "83615215"
---
# <a name="types-c-programming-guide"></a><span data-ttu-id="460c2-102">Tipi (Guida per programmatori C#)</span><span class="sxs-lookup"><span data-stu-id="460c2-102">Types (C# Programming Guide)</span></span>

## <a name="types-variables-and-values"></a><span data-ttu-id="460c2-103">Tipi, variabili e valori</span><span class="sxs-lookup"><span data-stu-id="460c2-103">Types, variables, and values</span></span>

<span data-ttu-id="460c2-104">C# è un linguaggio fortemente tipizzato.</span><span class="sxs-lookup"><span data-stu-id="460c2-104">C# is a strongly-typed language.</span></span> <span data-ttu-id="460c2-105">Ogni variabile e costante ha un tipo, così come ogni espressione che restituisce un valore.</span><span class="sxs-lookup"><span data-stu-id="460c2-105">Every variable and constant has a type, as does every expression that evaluates to a value.</span></span> <span data-ttu-id="460c2-106">Ogni dichiarazione di metodo specifica un nome, un numero di parametri, un tipo e un tipo (valore, riferimento o output) per ogni parametro di input e per il valore restituito.</span><span class="sxs-lookup"><span data-stu-id="460c2-106">Every method declaration specifies a name, number of parameters, and type and kind (value, reference, or output) for each input parameter and for the return value.</span></span> <span data-ttu-id="460c2-107">La libreria di classi .NET definisce un set di tipi numerici predefiniti, nonché tipi più complessi che rappresentano un'ampia gamma di costrutti logici, ad esempio il file system, le connessioni di rete, le raccolte e matrici di oggetti e le date.</span><span class="sxs-lookup"><span data-stu-id="460c2-107">The .NET class library defines a set of built-in numeric types as well as more complex types that represent a wide variety of logical constructs, such as the file system, network connections, collections and arrays of objects, and dates.</span></span> <span data-ttu-id="460c2-108">Un tipico programma C# usa tipi dalla libreria di classi e tipi definiti dall'utente che modellano i concetti specifici del dominio relativo al problema del programma.</span><span class="sxs-lookup"><span data-stu-id="460c2-108">A typical C# program uses types from the class library as well as user-defined types that model the concepts that are specific to the program's problem domain.</span></span>

<span data-ttu-id="460c2-109">Le informazioni archiviate in un tipo possono includere quanto segue:</span><span class="sxs-lookup"><span data-stu-id="460c2-109">The information stored in a type can include the following:</span></span>

- <span data-ttu-id="460c2-110">Lo spazio di archiviazione richiesto da una variabile del tipo.</span><span class="sxs-lookup"><span data-stu-id="460c2-110">The storage space that a variable of the type requires.</span></span>

- <span data-ttu-id="460c2-111">I valori minimi e massimi che può rappresentare.</span><span class="sxs-lookup"><span data-stu-id="460c2-111">The maximum and minimum values that it can represent.</span></span>

- <span data-ttu-id="460c2-112">I membri (metodi, campi, eventi e così via) in esso contenuti.</span><span class="sxs-lookup"><span data-stu-id="460c2-112">The members (methods, fields, events, and so on) that it contains.</span></span>

- <span data-ttu-id="460c2-113">Il tipo di base da cui eredita.</span><span class="sxs-lookup"><span data-stu-id="460c2-113">The base type it inherits from.</span></span>

- <span data-ttu-id="460c2-114">Il percorso in cui viene allocata la memoria per le variabili in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="460c2-114">The location where the memory for variables will be allocated at run time.</span></span>

- <span data-ttu-id="460c2-115">I tipi di operazioni consentite.</span><span class="sxs-lookup"><span data-stu-id="460c2-115">The kinds of operations that are permitted.</span></span>

<span data-ttu-id="460c2-116">Il compilatore usa le informazioni sul tipo per assicurarsi che tutte le operazioni eseguite nel codice siano *indipendenti dai tipi*.</span><span class="sxs-lookup"><span data-stu-id="460c2-116">The compiler uses type information to make sure that all operations that are performed in your code are *type safe*.</span></span> <span data-ttu-id="460c2-117">Se ad esempio si dichiara una variabile di tipo [int](../../language-reference/builtin-types/integral-numeric-types.md), il compilatore consente di usare la variabile anche in operazioni di addizione e sottrazione.</span><span class="sxs-lookup"><span data-stu-id="460c2-117">For example, if you declare a variable of type [int](../../language-reference/builtin-types/integral-numeric-types.md), the compiler allows you to use the variable in addition and subtraction operations.</span></span> <span data-ttu-id="460c2-118">Se si prova a eseguire le stesse operazioni su una variabile di tipo [bool](../../language-reference/builtin-types/bool.md), il compilatore genera un errore, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="460c2-118">If you try to perform those same operations on a variable of type [bool](../../language-reference/builtin-types/bool.md), the compiler generates an error, as shown in the following example:</span></span>

[!code-csharp[csProgGuideTypes#42](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsProgGuideTypes/CS/Class1.cs#42)]

> [!NOTE]
> <span data-ttu-id="460c2-119">Gli sviluppatori C e C++ devono tenere presente che, in C#, [bool](../../language-reference/builtin-types/bool.md) non è convertibile in [int](../../language-reference/builtin-types/integral-numeric-types.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-119">C and C++ developers, notice that in C#, [bool](../../language-reference/builtin-types/bool.md) is not convertible to [int](../../language-reference/builtin-types/integral-numeric-types.md).</span></span>

<span data-ttu-id="460c2-120">Il compilatore incorpora le informazioni sul tipo nel file eseguibile come metadati.</span><span class="sxs-lookup"><span data-stu-id="460c2-120">The compiler embeds the type information into the executable file as metadata.</span></span> <span data-ttu-id="460c2-121">Il Common Language Runtime (CLR) usa i metadati in fase di esecuzione per garantire una maggiore indipendenza dai tipi quando alloca e recupera la memoria.</span><span class="sxs-lookup"><span data-stu-id="460c2-121">The common language runtime (CLR) uses that metadata at run time to further guarantee type safety when it allocates and reclaims memory.</span></span>

### <a name="specifying-types-in-variable-declarations"></a><span data-ttu-id="460c2-122">Specifica dei tipi nelle dichiarazioni di variabile</span><span class="sxs-lookup"><span data-stu-id="460c2-122">Specifying types in variable declarations</span></span>

<span data-ttu-id="460c2-123">Quando si dichiara una variabile o una costante in un programma, è necessario specificarne il tipo oppure usare la parola chiave [var](../../language-reference/keywords/var.md) per consentire al compilatore di dedurre il tipo.</span><span class="sxs-lookup"><span data-stu-id="460c2-123">When you declare a variable or constant in a program, you must either specify its type or use the [var](../../language-reference/keywords/var.md) keyword to let the compiler infer the type.</span></span> <span data-ttu-id="460c2-124">L'esempio seguente illustra alcune dichiarazioni di variabili che usano sia tipi numerici incorporati sia tipi complessi definiti dall'utente:</span><span class="sxs-lookup"><span data-stu-id="460c2-124">The following example shows some variable declarations that use both built-in numeric types and complex user-defined types:</span></span>

[!code-csharp[csProgGuideTypes#36](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsProgGuideTypes/CS/Class1.cs#36)]

<span data-ttu-id="460c2-125">I tipi di parametri del metodo e i valori restituiti vengono specificati nella dichiarazione di metodo.</span><span class="sxs-lookup"><span data-stu-id="460c2-125">The types of method parameters and return values are specified in the method declaration.</span></span> <span data-ttu-id="460c2-126">La firma seguente illustra un metodo che richiede un [int](../../language-reference/builtin-types/integral-numeric-types.md) come argomento di input e restituisce una stringa:</span><span class="sxs-lookup"><span data-stu-id="460c2-126">The following signature shows a method that requires an [int](../../language-reference/builtin-types/integral-numeric-types.md) as an input argument and returns a string:</span></span>

[!code-csharp[csProgGuideTypes#35](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsProgGuideTypes/CS/Class1.cs#35)]

<span data-ttu-id="460c2-127">Una variabile dichiarata non può essere dichiarata una seconda volta con un tipo nuovo e non è possibile assegnare a tale variabile un valore non compatibile con il relativo tipo dichiarato.</span><span class="sxs-lookup"><span data-stu-id="460c2-127">After a variable is declared, it cannot be re-declared with a new type, and it cannot be assigned a value that is not compatible with its declared type.</span></span> <span data-ttu-id="460c2-128">Ad esempio, non è possibile dichiarare un valore [int](../../language-reference/builtin-types/integral-numeric-types.md) e quindi assegnargli un valore booleano `true` .</span><span class="sxs-lookup"><span data-stu-id="460c2-128">For example, you cannot declare an [int](../../language-reference/builtin-types/integral-numeric-types.md) and then assign it a Boolean value of `true`.</span></span> <span data-ttu-id="460c2-129">I valori possono tuttavia essere convertiti in altri tipi, ad esempio quando vengono assegnati a nuove variabili o passati come argomenti di metodo.</span><span class="sxs-lookup"><span data-stu-id="460c2-129">However, values can be converted to other types, for example when they are assigned to new variables or passed as method arguments.</span></span> <span data-ttu-id="460c2-130">Una *conversione del tipo* che non causa la perdita di dati viene eseguita automaticamente dal compilatore,</span><span class="sxs-lookup"><span data-stu-id="460c2-130">A *type conversion* that does not cause data loss is performed automatically by the compiler.</span></span> <span data-ttu-id="460c2-131">mentre una conversione che può causare la perdita di dati richiede un *cast* nel codice sorgente.</span><span class="sxs-lookup"><span data-stu-id="460c2-131">A conversion that might cause data loss requires a *cast* in the source code.</span></span>

<span data-ttu-id="460c2-132">Per altre informazioni, vedere [Cast e conversioni di tipi](./casting-and-type-conversions.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-132">For more information, see [Casting and Type Conversions](./casting-and-type-conversions.md).</span></span>

## <a name="built-in-types"></a><span data-ttu-id="460c2-133">Tipi incorporati</span><span class="sxs-lookup"><span data-stu-id="460c2-133">Built-in types</span></span>

<span data-ttu-id="460c2-134">Il linguaggio C# offre un set standard di tipi numerici incorporati per rappresentare numeri interi, valori a virgola mobile, espressioni booleane, caratteri di testo, valori decimali e altri tipi di dati.</span><span class="sxs-lookup"><span data-stu-id="460c2-134">C# provides a standard set of built-in numeric types to represent integers, floating point values, Boolean expressions, text characters, decimal values, and other types of data.</span></span> <span data-ttu-id="460c2-135">Sono anche disponibili tipi `string` e `object` incorporati,</span><span class="sxs-lookup"><span data-stu-id="460c2-135">There are also built-in `string` and `object` types.</span></span> <span data-ttu-id="460c2-136">Questi possono essere usati in qualsiasi programma C#.</span><span class="sxs-lookup"><span data-stu-id="460c2-136">These are available for you to use in any C# program.</span></span> <span data-ttu-id="460c2-137">Per l'elenco completo dei tipi incorporati, vedere [tipi incorporati](../../language-reference/builtin-types/built-in-types.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-137">For the complete list of the built-in types, see [Built-in types](../../language-reference/builtin-types/built-in-types.md).</span></span>

## <a name="custom-types"></a><span data-ttu-id="460c2-138">Tipi personalizzati</span><span class="sxs-lookup"><span data-stu-id="460c2-138">Custom types</span></span>

<span data-ttu-id="460c2-139">Usare i costrutti [struct](../../language-reference/builtin-types/struct.md), [class](../../language-reference/keywords/class.md), [interface](../../language-reference/keywords/interface.md) e [enum](../../language-reference/builtin-types/enum.md) per creare tipi personalizzati.</span><span class="sxs-lookup"><span data-stu-id="460c2-139">You use the [struct](../../language-reference/builtin-types/struct.md), [class](../../language-reference/keywords/class.md), [interface](../../language-reference/keywords/interface.md), and [enum](../../language-reference/builtin-types/enum.md) constructs to create your own custom types.</span></span> <span data-ttu-id="460c2-140">La libreria di classi .NET stessa è una raccolta di tipi personalizzati offerti da Microsoft che è possibile usare nelle proprie applicazioni.</span><span class="sxs-lookup"><span data-stu-id="460c2-140">The .NET class library itself is a collection of custom types provided by Microsoft that you can use in your own applications.</span></span> <span data-ttu-id="460c2-141">Per impostazione predefinita, i tipi più comunemente usati nella libreria di classi sono disponibili in qualsiasi programma C#,</span><span class="sxs-lookup"><span data-stu-id="460c2-141">By default, the most frequently used types in the class library are available in any C# program.</span></span> <span data-ttu-id="460c2-142">mentre altri diventano disponibili solo quando si aggiunge in modo esplicito un riferimento di progetto all'assembly in cui sono definiti.</span><span class="sxs-lookup"><span data-stu-id="460c2-142">Others become available only when you explicitly add a project reference to the assembly in which they are defined.</span></span> <span data-ttu-id="460c2-143">Nel momento in cui il compilatore ha un riferimento all'assembly, è possibile dichiarare variabili (e costanti) dei tipi dichiarati nell'assembly in codice sorgente.</span><span class="sxs-lookup"><span data-stu-id="460c2-143">After the compiler has a reference to the assembly, you can declare variables (and constants) of the types declared in that assembly in source code.</span></span> <span data-ttu-id="460c2-144">Per altre informazioni, vedere [Libreria di classi .NET](../../../standard/class-library-overview.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-144">For more information, see [.NET Class Library](../../../standard/class-library-overview.md).</span></span>

## <a name="the-common-type-system"></a><span data-ttu-id="460c2-145">Common Type System</span><span class="sxs-lookup"><span data-stu-id="460c2-145">The common type system</span></span>

<span data-ttu-id="460c2-146">È importante tenere presente due aspetti fondamentali del sistema dei tipi in .NET:</span><span class="sxs-lookup"><span data-stu-id="460c2-146">It is important to understand two fundamental points about the type system in .NET:</span></span>

- <span data-ttu-id="460c2-147">Supporta il principio di ereditarietà.</span><span class="sxs-lookup"><span data-stu-id="460c2-147">It supports the principle of inheritance.</span></span> <span data-ttu-id="460c2-148">I tipi possono derivare da altri tipi, denominati *tipi di base*.</span><span class="sxs-lookup"><span data-stu-id="460c2-148">Types can derive from other types, called *base types*.</span></span> <span data-ttu-id="460c2-149">Il tipo derivato eredita (con alcune limitazioni) metodi, proprietà e altri membri del tipo di base,</span><span class="sxs-lookup"><span data-stu-id="460c2-149">The derived type inherits (with some restrictions) the methods, properties, and other members of the base type.</span></span> <span data-ttu-id="460c2-150">che a sua volta può derivare da un altro tipo. In questo caso, il tipo derivato eredita i membri di entrambi i tipi di base nella gerarchia di ereditarietà.</span><span class="sxs-lookup"><span data-stu-id="460c2-150">The base type can in turn derive from some other type, in which case the derived type inherits the members of both base types in its inheritance hierarchy.</span></span> <span data-ttu-id="460c2-151">Tutti i tipi, inclusi i tipi numerici predefiniti, ad esempio <xref:System.Int32?displayProperty=nameWithType> (parola chiave C#: [int](../../language-reference/builtin-types/integral-numeric-types.md)), derivano in definitiva da un unico tipo di base, ovvero <xref:System.Object?displayProperty=nameWithType> (parola chiave C#: [object](../../language-reference/builtin-types/reference-types.md)).</span><span class="sxs-lookup"><span data-stu-id="460c2-151">All types, including built-in numeric types such as <xref:System.Int32?displayProperty=nameWithType> (C# keyword: [int](../../language-reference/builtin-types/integral-numeric-types.md)), derive ultimately from a single base type, which is <xref:System.Object?displayProperty=nameWithType> (C# keyword: [object](../../language-reference/builtin-types/reference-types.md)).</span></span> <span data-ttu-id="460c2-152">Questa gerarchia di tipi unificata prende il nome di [Common Type System](../../../standard/base-types/common-type-system.md) (CTS).</span><span class="sxs-lookup"><span data-stu-id="460c2-152">This unified type hierarchy is called the [Common Type System](../../../standard/base-types/common-type-system.md) (CTS).</span></span> <span data-ttu-id="460c2-153">Per altre informazioni sull'ereditarietà in C#, vedere [Ereditarietà](../classes-and-structs/inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-153">For more information about inheritance in C#, see [Inheritance](../classes-and-structs/inheritance.md).</span></span>

- <span data-ttu-id="460c2-154">Nel CTS ogni tipo è definito come *tipo valore* o *tipo riferimento*.</span><span class="sxs-lookup"><span data-stu-id="460c2-154">Each type in the CTS is defined as either a *value type* or a *reference type*.</span></span> <span data-ttu-id="460c2-155">In queste due categorie sono inclusi anche tutti i tipi personalizzati nella libreria di classi .NET e i tipi definiti dall'utente.</span><span class="sxs-lookup"><span data-stu-id="460c2-155">This includes all custom types in the .NET class library and also your own user-defined types.</span></span> <span data-ttu-id="460c2-156">I tipi definiti tramite la parola chiave [struct](../../language-reference/builtin-types/struct.md) sono tipi valore e tutti i tipi numerici incorporati sono tipi `structs`.</span><span class="sxs-lookup"><span data-stu-id="460c2-156">Types that you define by using the [struct](../../language-reference/builtin-types/struct.md) keyword are value types; all the built-in numeric types are `structs`.</span></span> <span data-ttu-id="460c2-157">I tipi definiti tramite la parola chiave [class](../../language-reference/keywords/class.md) sono tipi riferimento.</span><span class="sxs-lookup"><span data-stu-id="460c2-157">Types that you define by using the [class](../../language-reference/keywords/class.md) keyword are reference types.</span></span> <span data-ttu-id="460c2-158">I tipi di riferimento e i tipi di valore hanno regole diverse e un comportamento diverso in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="460c2-158">Reference types and value types have different compile-time rules, and different run-time behavior.</span></span>

<span data-ttu-id="460c2-159">La figura seguente illustra la relazione tra tipi valore e tipi riferimento nel CTS.</span><span class="sxs-lookup"><span data-stu-id="460c2-159">The following illustration shows the relationship between value types and reference types in the CTS.</span></span>

<span data-ttu-id="460c2-160">L'immagine seguente illustra tipi valore e tipi riferimento nel CTS:</span><span class="sxs-lookup"><span data-stu-id="460c2-160">The following image shows value types and reference types in the CTS:</span></span>

![Screenshot che illustra i tipi valore e i tipi riferimento nel CTS.](./media/index/value-reference-types-common-type-system.png)

> [!NOTE]
> <span data-ttu-id="460c2-162">È possibile osservare come i tipi usati con maggiore frequenza siano tutti organizzati nello spazio dei nomi <xref:System>.</span><span class="sxs-lookup"><span data-stu-id="460c2-162">You can see that the most commonly used types are all organized in the <xref:System> namespace.</span></span> <span data-ttu-id="460c2-163">L'inserimento di un tipo in uno spazio dei nomi, tuttavia, è indipendente dalla categoria a cui appartiene il tipo.</span><span class="sxs-lookup"><span data-stu-id="460c2-163">However, the namespace in which a type is contained has no relation to whether it is a value type or reference type.</span></span>

### <a name="value-types"></a><span data-ttu-id="460c2-164">Tipi valore</span><span class="sxs-lookup"><span data-stu-id="460c2-164">Value types</span></span>

<span data-ttu-id="460c2-165">I tipi valore derivano da <xref:System.ValueType?displayProperty=nameWithType>, che deriva da <xref:System.Object?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="460c2-165">Value types derive from <xref:System.ValueType?displayProperty=nameWithType>, which derives from <xref:System.Object?displayProperty=nameWithType>.</span></span> <span data-ttu-id="460c2-166">I tipi che derivano da <xref:System.ValueType?displayProperty=nameWithType> hanno un comportamento speciale in CLR.</span><span class="sxs-lookup"><span data-stu-id="460c2-166">Types that derive from <xref:System.ValueType?displayProperty=nameWithType> have special behavior in the CLR.</span></span> <span data-ttu-id="460c2-167">Le variabili dei tipi valore contengono direttamente i rispettivi valori, ovvero la memoria viene allocata inline nel contesto in cui è dichiarata la variabile.</span><span class="sxs-lookup"><span data-stu-id="460c2-167">Value type variables directly contain their values, which means that the memory is allocated inline in whatever context the variable is declared.</span></span> <span data-ttu-id="460c2-168">Non esiste un'allocazione heap o un overhead di Garbage Collection separato per le variabili dei tipi valore.</span><span class="sxs-lookup"><span data-stu-id="460c2-168">There is no separate heap allocation or garbage collection overhead for value-type variables.</span></span>

<span data-ttu-id="460c2-169">Esistono due categorie di tipi valore: [struct](../../language-reference/builtin-types/struct.md) e [enum](../../language-reference/builtin-types/enum.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-169">There are two categories of value types: [struct](../../language-reference/builtin-types/struct.md) and [enum](../../language-reference/builtin-types/enum.md).</span></span>

<span data-ttu-id="460c2-170">I tipi numerici incorporati sono struct i cui metodi e le cui proprietà sono accessibili dall'utente:</span><span class="sxs-lookup"><span data-stu-id="460c2-170">The built-in numeric types are structs, and they have properties and methods that you can access:</span></span>

```csharp
// Static method on type byte.
byte b = byte.MaxValue;
```

<span data-ttu-id="460c2-171">Ad essi, tuttavia, si dichiarano e si assegnano valori come se fossero tipi non aggregati semplici:</span><span class="sxs-lookup"><span data-stu-id="460c2-171">But you declare and assign values to them as if they were simple non-aggregate types:</span></span>

```csharp
byte num = 0xA;
int i = 5;
char c = 'Z';
```

<span data-ttu-id="460c2-172">I tipi valore sono *sealed*, ovvero non è possibile, ad esempio, derivare un tipo da <xref:System.Int32?displayProperty=nameWithType> e non è possibile definire uno struct da ereditare da uno struct o una classe definita dall'utente, poiché uno struct può ereditare solo da <xref:System.ValueType?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="460c2-172">Value types are *sealed*, which means, for example, that you cannot derive a type from <xref:System.Int32?displayProperty=nameWithType>, and you cannot define a struct to inherit from any user-defined class or struct because a struct can only inherit from <xref:System.ValueType?displayProperty=nameWithType>.</span></span> <span data-ttu-id="460c2-173">Un tipo struct può tuttavia implementare una o più interfacce.</span><span class="sxs-lookup"><span data-stu-id="460c2-173">However, a struct can implement one or more interfaces.</span></span> <span data-ttu-id="460c2-174">È possibile eseguire il cast di un tipo struct in qualsiasi tipo di interfaccia implementata. Questa operazione genera tuttavia una \*conversione boxing \* per eseguire il wrapping dello struct in un oggetto tipo riferimento sull'heap gestito.</span><span class="sxs-lookup"><span data-stu-id="460c2-174">You can cast a struct type to any interface type that it implements; this causes a *boxing* operation to wrap the struct inside a reference type object on the managed heap.</span></span> <span data-ttu-id="460c2-175">Le operazioni di conversione boxing si verificano quando si passa un tipo valore a un metodo che accetta <xref:System.Object?displayProperty=nameWithType> o qualsiasi tipo di interfaccia come parametro di input.</span><span class="sxs-lookup"><span data-stu-id="460c2-175">Boxing operations occur when you pass a value type to a method that takes a <xref:System.Object?displayProperty=nameWithType> or any interface type as an input parameter.</span></span> <span data-ttu-id="460c2-176">Per altre informazioni, vedere [Boxing e unboxing](./boxing-and-unboxing.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-176">For more information, see [Boxing and Unboxing](./boxing-and-unboxing.md).</span></span>

<span data-ttu-id="460c2-177">Usare la parola chiave [struct](../../language-reference/builtin-types/struct.md) per creare tipi valore personalizzati.</span><span class="sxs-lookup"><span data-stu-id="460c2-177">You use the [struct](../../language-reference/builtin-types/struct.md) keyword to create your own custom value types.</span></span> <span data-ttu-id="460c2-178">In genere, un tipo struct viene usato come contenitore per un piccolo set di variabili correlate, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="460c2-178">Typically, a struct is used as a container for a small set of related variables, as shown in the following example:</span></span>

[!code-csharp[csProgGuideObjects#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideObjects/CS/Objects.cs#1)]

<span data-ttu-id="460c2-179">Per ulteriori informazioni sugli struct, vedere [tipi di struttura](../../language-reference/builtin-types/struct.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-179">For more information about structs, see [Structure types](../../language-reference/builtin-types/struct.md).</span></span> <span data-ttu-id="460c2-180">Per ulteriori informazioni sui tipi di valore, vedere [tipi di valore](../../language-reference/builtin-types/value-types.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-180">For more information about value types, see [Value types](../../language-reference/builtin-types/value-types.md).</span></span>

<span data-ttu-id="460c2-181">L'altra categoria di tipi valore è [enum](../../language-reference/builtin-types/enum.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-181">The other category of value types is [enum](../../language-reference/builtin-types/enum.md).</span></span> <span data-ttu-id="460c2-182">Un tipo enum definisce un set di costanti integrali denominate.</span><span class="sxs-lookup"><span data-stu-id="460c2-182">An enum defines a set of named integral constants.</span></span> <span data-ttu-id="460c2-183">L'enumerazione <xref:System.IO.FileMode?displayProperty=nameWithType> nella libreria di classi .NET, ad esempio, contiene un set di valori interi costanti e denominati che specificano come deve essere aperto un file.</span><span class="sxs-lookup"><span data-stu-id="460c2-183">For example, the <xref:System.IO.FileMode?displayProperty=nameWithType> enumeration in the .NET class library contains a set of named constant integers that specify how a file should be opened.</span></span> <span data-ttu-id="460c2-184">L'enumerazione deve essere definita come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="460c2-184">It is defined as shown in the following example:</span></span>

[!code-csharp[csProgGuideTypes#44](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsProgGuideTypes/CS/Class1.cs#44)]

<span data-ttu-id="460c2-185">Il valore della costante `System.IO.FileMode.Create` è 2.</span><span class="sxs-lookup"><span data-stu-id="460c2-185">The `System.IO.FileMode.Create` constant has a value of 2.</span></span> <span data-ttu-id="460c2-186">I nomi, tuttavia, sono molto più significativi per gli utenti che leggono il codice sorgente e, quindi, è preferibile usare enumerazioni anziché valori letterali numerici costanti.</span><span class="sxs-lookup"><span data-stu-id="460c2-186">However, the name is much more meaningful for humans reading the source code, and for that reason it is better to use enumerations instead of constant literal numbers.</span></span> <span data-ttu-id="460c2-187">Per altre informazioni, vedere <xref:System.IO.FileMode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="460c2-187">For more information, see <xref:System.IO.FileMode?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="460c2-188">Tutte le enumerazioni ereditano da <xref:System.Enum?displayProperty=nameWithType>, che eredita da <xref:System.ValueType?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="460c2-188">All enums inherit from <xref:System.Enum?displayProperty=nameWithType>, which inherits from <xref:System.ValueType?displayProperty=nameWithType>.</span></span> <span data-ttu-id="460c2-189">Tutte le regole valide per i tipi struct sono valide anche per le enumerazioni.</span><span class="sxs-lookup"><span data-stu-id="460c2-189">All the rules that apply to structs also apply to enums.</span></span> <span data-ttu-id="460c2-190">Per altre informazioni sulle enumerazioni, vedere [tipi di enumerazione](../../language-reference/builtin-types/enum.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-190">For more information about enums, see [Enumeration types](../../language-reference/builtin-types/enum.md).</span></span>

### <a name="reference-types"></a><span data-ttu-id="460c2-191">Tipi riferimento</span><span class="sxs-lookup"><span data-stu-id="460c2-191">Reference types</span></span>

<span data-ttu-id="460c2-192">Un tipo definito come [classe](../../language-reference/keywords/class.md), [delegato](../../language-reference/builtin-types/reference-types.md), matrice o [interfaccia](../../language-reference/keywords/interface.md) è un *tipo riferimento*.</span><span class="sxs-lookup"><span data-stu-id="460c2-192">A type that is defined as a [class](../../language-reference/keywords/class.md), [delegate](../../language-reference/builtin-types/reference-types.md), array, or [interface](../../language-reference/keywords/interface.md) is a *reference type*.</span></span> <span data-ttu-id="460c2-193">In fase di esecuzione, quando si dichiara una variabile di un tipo riferimento, la variabile contiene il valore [null](../../language-reference/keywords/null.md) fino a quando non si crea in modo esplicito un oggetto usando l'operatore [new](../../language-reference/operators/new-operator.md) o fino a quando non le viene assegnato un oggetto creato altrove tramite `new`, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="460c2-193">At run time, when you declare a variable of a reference type, the variable contains the value [null](../../language-reference/keywords/null.md) until you explicitly create an object by using the [new](../../language-reference/operators/new-operator.md) operator, or assign it an object that has been created elsewhere by using `new`, as shown in the following example:</span></span>

```csharp
MyClass mc = new MyClass();
MyClass mc2 = mc;
```

<span data-ttu-id="460c2-194">Un'interfaccia deve essere inizializzata insieme a un oggetto classe che la implementa.</span><span class="sxs-lookup"><span data-stu-id="460c2-194">An interface must be initialized together with a class object that implements it.</span></span> <span data-ttu-id="460c2-195">Se `MyClass` implementa `IMyInterface`, si crea un'istanza di `IMyInterface`, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="460c2-195">If `MyClass` implements `IMyInterface`, you create an instance of `IMyInterface` as shown in the following example:</span></span>

```csharp
IMyInterface iface = new MyClass();
```

<span data-ttu-id="460c2-196">Quando viene creato l'oggetto, la memoria viene allocata nell'heap gestito e la variabile mantiene solo un riferimento al percorso dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="460c2-196">When the object is created, the memory is allocated on the managed heap, and the variable holds only a reference to the location of the object.</span></span> <span data-ttu-id="460c2-197">I tipi nell'heap gestito richiedono un overhead quando vengono allocati e recuperati dalla funzionalità di gestione automatica della memoria di CLR, nota come *Garbage Collection*.</span><span class="sxs-lookup"><span data-stu-id="460c2-197">Types on the managed heap require overhead both when they are allocated and when they are reclaimed by the automatic memory management functionality of the CLR, which is known as *garbage collection*.</span></span> <span data-ttu-id="460c2-198">La Garbage Collection, tuttavia, è anche altamente ottimizzata e, nella maggior parte degli scenari, non genera un problema di prestazioni.</span><span class="sxs-lookup"><span data-stu-id="460c2-198">However, garbage collection is also highly optimized, and in most scenarios it does not create a performance issue.</span></span> <span data-ttu-id="460c2-199">Per altre informazioni sulla Garbage Collection, vedere [Gestione automatica della memoria](../../../standard/automatic-memory-management.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-199">For more information about garbage collection, see [Automatic Memory Management](../../../standard/automatic-memory-management.md).</span></span>

<span data-ttu-id="460c2-200">Tutte le matrici sono tipi riferimento, anche se i relativi elementi sono tipi valore.</span><span class="sxs-lookup"><span data-stu-id="460c2-200">All arrays are reference types, even if their elements are value types.</span></span> <span data-ttu-id="460c2-201">Le matrici derivano in modo implicito dalla classe <xref:System.Array?displayProperty=nameWithType>, ma vengono dichiarate e usate con la sintassi semplificata fornita da C#, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="460c2-201">Arrays implicitly derive from the <xref:System.Array?displayProperty=nameWithType> class, but you declare and use them with the simplified syntax that is provided by C#, as shown in the following example:</span></span>

[!code-csharp[csProgGuideTypes#45](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsProgGuideTypes/CS/Class1.cs#45)]

<span data-ttu-id="460c2-202">I tipi riferimento supportano completamente l'ereditarietà.</span><span class="sxs-lookup"><span data-stu-id="460c2-202">Reference types fully support inheritance.</span></span> <span data-ttu-id="460c2-203">Quando si crea una classe, è possibile ereditare da qualsiasi altra interfaccia o classe non definita come [sealed](../../language-reference/keywords/sealed.md); altre classi, inoltre, possono ereditare dalla classe appena creata ed eseguire l'override dei metodi virtuali.</span><span class="sxs-lookup"><span data-stu-id="460c2-203">When you create a class, you can inherit from any other interface or class that is not defined as [sealed](../../language-reference/keywords/sealed.md), and other classes can inherit from your class and override your virtual methods.</span></span> <span data-ttu-id="460c2-204">Per altre informazioni su come creare classi personalizzate, vedere [Classi e struct](../classes-and-structs/index.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-204">For more information about how to create your own classes, see [Classes and Structs](../classes-and-structs/index.md).</span></span> <span data-ttu-id="460c2-205">Per altre informazioni sull'ereditarietà e sui metodi virtuali, vedere [Ereditarietà](../classes-and-structs/inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-205">For more information about inheritance and virtual methods, see [Inheritance](../classes-and-structs/inheritance.md).</span></span>

## <a name="types-of-literal-values"></a><span data-ttu-id="460c2-206">Tipi di valori letterali</span><span class="sxs-lookup"><span data-stu-id="460c2-206">Types of literal values</span></span>

<span data-ttu-id="460c2-207">In C# i valori letterali ricevono un tipo dal compilatore.</span><span class="sxs-lookup"><span data-stu-id="460c2-207">In C#, literal values receive a type from the compiler.</span></span> <span data-ttu-id="460c2-208">È possibile specificare come deve essere tipizzato un valore letterale numerico aggiungendo una lettera alla fine del numero.</span><span class="sxs-lookup"><span data-stu-id="460c2-208">You can specify how a numeric literal should be typed by appending a letter to the end of the number.</span></span> <span data-ttu-id="460c2-209">Per specificare, ad esempio, che il valore 4.56 deve essere considerato come un tipo float, aggiungere una "f" o una "F" dopo il numero: `4.56f`.</span><span class="sxs-lookup"><span data-stu-id="460c2-209">For example, to specify that the value 4.56 should be treated as a float, append an "f" or "F" after the number: `4.56f`.</span></span> <span data-ttu-id="460c2-210">Se non viene aggiunta alcuna lettera, il compilatore dedurrà un tipo per il valore letterale.</span><span class="sxs-lookup"><span data-stu-id="460c2-210">If no letter is appended, the compiler will infer a type for the literal.</span></span> <span data-ttu-id="460c2-211">Per ulteriori informazioni sui tipi che è possibile specificare con i suffissi di lettera, vedere [tipi numerici integrali](../../language-reference/builtin-types/integral-numeric-types.md) e [tipi numerici a virgola mobile](../../language-reference/builtin-types/floating-point-numeric-types.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-211">For more information about which types can be specified with letter suffixes, see [Integral numeric types](../../language-reference/builtin-types/integral-numeric-types.md) and [Floating-point numeric types](../../language-reference/builtin-types/floating-point-numeric-types.md).</span></span>

<span data-ttu-id="460c2-212">Poiché i valori letterali sono tipizzati e tutti i tipi derivano in ultima istanza da <xref:System.Object?displayProperty=nameWithType>, è possibile scrivere e compilare codice come il seguente:</span><span class="sxs-lookup"><span data-stu-id="460c2-212">Because literals are typed, and all types derive ultimately from <xref:System.Object?displayProperty=nameWithType>, you can write and compile code such as the following:</span></span>

[!code-csharp[csProgGuideTypes#37](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsProgGuideTypes/CS/Class1.cs#37)]

## <a name="generic-types"></a><span data-ttu-id="460c2-213">Tipi generici</span><span class="sxs-lookup"><span data-stu-id="460c2-213">Generic types</span></span>

<span data-ttu-id="460c2-214">Un tipo può essere dichiarato con uno o più *parametri di tipo* che agiscono da segnaposto per il tipo effettivo (*tipo concreto*) che il codice client specifica quando si crea un'istanza del tipo.</span><span class="sxs-lookup"><span data-stu-id="460c2-214">A type can be declared with one or more *type parameters* that serve as a placeholder for the actual type (the *concrete type*) that client code will provide when it creates an instance of the type.</span></span> <span data-ttu-id="460c2-215">Questi tipi sono definiti *tipi generici*.</span><span class="sxs-lookup"><span data-stu-id="460c2-215">Such types are called *generic types*.</span></span> <span data-ttu-id="460c2-216">Ad esempio, il tipo .NET <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> ha un parametro di tipo a cui per convenzione viene assegnato il nome *T*. Quando si crea un'istanza del tipo, si specifica il tipo degli oggetti che l'elenco conterrà, ad esempio, String:</span><span class="sxs-lookup"><span data-stu-id="460c2-216">For example, the .NET type <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> has one type parameter that by convention is given the name *T*. When you create an instance of the type, you specify the type of the objects that the list will contain, for example, string:</span></span>

```csharp
List<string> stringList = new List<string>();
stringList.Add("String example");
// compile time error adding a type other than a string:
stringList.Add(4);
```

<span data-ttu-id="460c2-217">L'uso del parametro di tipo consente di riutilizzare la stessa classe per contenere qualsiasi tipo di elemento senza dover convertire ogni elemento in [object](../../language-reference/builtin-types/reference-types.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-217">The use of the type parameter makes it possible to reuse the same class to hold any type of element, without having to convert each element to [object](../../language-reference/builtin-types/reference-types.md).</span></span> <span data-ttu-id="460c2-218">Le classi di raccolte generiche sono definite *raccolte fortemente tipizzate* perché il compilatore conosce il tipo specifico degli elementi della raccolta e può generare un errore in fase di compilazione se, ad esempio, si prova ad aggiungere un numero intero all'oggetto `stringList` nell'esempio precedente.</span><span class="sxs-lookup"><span data-stu-id="460c2-218">Generic collection classes are called *strongly-typed collections* because the compiler knows the specific type of the collection's elements and can raise an error at compile-time if, for example, you try to add an integer to the `stringList` object in the previous example.</span></span> <span data-ttu-id="460c2-219">Per altre informazioni, vedere [Generics](../generics/index.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-219">For more information, see [Generics](../generics/index.md).</span></span>

## <a name="implicit-types-anonymous-types-and-nullable-value-types"></a><span data-ttu-id="460c2-220">Tipi impliciti, tipi anonimi e tipi di valore Nullable</span><span class="sxs-lookup"><span data-stu-id="460c2-220">Implicit types, anonymous types, and nullable value types</span></span>

<span data-ttu-id="460c2-221">Come indicato in precedenza, è possibile tipizzare una variabile locale (ma non membri di classe) in modo implicito usando la parola chiave [var](../../language-reference/keywords/var.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-221">As stated previously, you can implicitly type a local variable (but not class members) by using the [var](../../language-reference/keywords/var.md) keyword.</span></span> <span data-ttu-id="460c2-222">Alla variabile viene comunque assegnato un tipo in fase di compilazione, specificato dal compilatore.</span><span class="sxs-lookup"><span data-stu-id="460c2-222">The variable still receives a type at compile time, but the type is provided by the compiler.</span></span> <span data-ttu-id="460c2-223">Per altre informazioni, vedere [Variabili locali tipizzate in modo implicito](../classes-and-structs/implicitly-typed-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-223">For more information, see [Implicitly Typed Local Variables](../classes-and-structs/implicitly-typed-local-variables.md).</span></span>

<span data-ttu-id="460c2-224">In alcuni casi non è consigliabile creare un tipo denominato per set semplici di valori correlati che non si intende archiviare o passare fuori dai limiti del metodo.</span><span class="sxs-lookup"><span data-stu-id="460c2-224">In some cases, it is inconvenient to create a named type for simple sets of related values that you do not intend to store or pass outside method boundaries.</span></span> <span data-ttu-id="460c2-225">A questo scopo è possibile creare *tipi anonimi*.</span><span class="sxs-lookup"><span data-stu-id="460c2-225">You can create *anonymous types* for this purpose.</span></span> <span data-ttu-id="460c2-226">Per ulteriori informazioni, vedere [tipi anonimi](../classes-and-structs/anonymous-types.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-226">For more information, see [Anonymous Types](../classes-and-structs/anonymous-types.md).</span></span>

<span data-ttu-id="460c2-227">I tipi valore comuni non possono avere un valore [null](../../language-reference/keywords/null.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-227">Ordinary value types cannot have a value of [null](../../language-reference/keywords/null.md).</span></span> <span data-ttu-id="460c2-228">È tuttavia possibile creare tipi valore nullable aggiungendo `?` dopo il tipo.</span><span class="sxs-lookup"><span data-stu-id="460c2-228">However, you can create nullable value types by affixing a `?` after the type.</span></span> <span data-ttu-id="460c2-229">Ad esempio, `int?` è un tipo `int` che può avere anche il valore [null](../../language-reference/keywords/null.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-229">For example, `int?` is an `int` type that can also have the value [null](../../language-reference/keywords/null.md).</span></span> <span data-ttu-id="460c2-230">I tipi di valore nullable sono istanze del tipo di struct generico <xref:System.Nullable%601?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="460c2-230">Nullable value types are instances of the generic struct type <xref:System.Nullable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="460c2-231">I tipi di valore nullable sono particolarmente utili quando si passano dati da e verso database in cui i valori numerici potrebbero essere null.</span><span class="sxs-lookup"><span data-stu-id="460c2-231">Nullable value types are especially useful when you are passing data to and from databases in which numeric values might be null.</span></span> <span data-ttu-id="460c2-232">Per altre informazioni, vedere [tipi di valore Nullable](../../language-reference/builtin-types/nullable-value-types.md).</span><span class="sxs-lookup"><span data-stu-id="460c2-232">For more information, see [Nullable value types](../../language-reference/builtin-types/nullable-value-types.md).</span></span>

## <a name="related-sections"></a><span data-ttu-id="460c2-233">Sezioni correlate</span><span class="sxs-lookup"><span data-stu-id="460c2-233">Related sections</span></span>

<span data-ttu-id="460c2-234">Per altre informazioni, vedere gli argomenti seguenti:</span><span class="sxs-lookup"><span data-stu-id="460c2-234">For more information, see the following topics:</span></span>

- [<span data-ttu-id="460c2-235">Cast e conversioni di tipi (C#)</span><span class="sxs-lookup"><span data-stu-id="460c2-235">Casting and Type Conversions</span></span>](./casting-and-type-conversions.md)

- [<span data-ttu-id="460c2-236">Boxing e unboxing</span><span class="sxs-lookup"><span data-stu-id="460c2-236">Boxing and Unboxing</span></span>](./boxing-and-unboxing.md)

- [<span data-ttu-id="460c2-237">Utilizzo del tipo dinamico</span><span class="sxs-lookup"><span data-stu-id="460c2-237">Using Type dynamic</span></span>](./using-type-dynamic.md)

- [<span data-ttu-id="460c2-238">Tipi di valore</span><span class="sxs-lookup"><span data-stu-id="460c2-238">Value Types</span></span>](../../language-reference/builtin-types/value-types.md)

- [<span data-ttu-id="460c2-239">Tipi di riferimento</span><span class="sxs-lookup"><span data-stu-id="460c2-239">Reference Types</span></span>](../../language-reference/keywords/reference-types.md)

- [<span data-ttu-id="460c2-240">Classi e struct</span><span class="sxs-lookup"><span data-stu-id="460c2-240">Classes and Structs</span></span>](../classes-and-structs/index.md)

- [<span data-ttu-id="460c2-241">Tipi anonimi</span><span class="sxs-lookup"><span data-stu-id="460c2-241">Anonymous Types</span></span>](../classes-and-structs/anonymous-types.md)

- [<span data-ttu-id="460c2-242">Generics</span><span class="sxs-lookup"><span data-stu-id="460c2-242">Generics</span></span>](../generics/index.md)

## <a name="c-language-specification"></a><span data-ttu-id="460c2-243">Specifiche del linguaggio C#</span><span class="sxs-lookup"><span data-stu-id="460c2-243">C# language specification</span></span>

[!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]

## <a name="see-also"></a><span data-ttu-id="460c2-244">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="460c2-244">See also</span></span>

- [<span data-ttu-id="460c2-245">Riferimenti per C#</span><span class="sxs-lookup"><span data-stu-id="460c2-245">C# Reference</span></span>](../../language-reference/index.md)
- [<span data-ttu-id="460c2-246">Guida per programmatori C#</span><span class="sxs-lookup"><span data-stu-id="460c2-246">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="460c2-247">Conversione dei tipi di dati XML</span><span class="sxs-lookup"><span data-stu-id="460c2-247">Conversion of XML Data Types</span></span>](../../../standard/data/xml/conversion-of-xml-data-types.md)
- [<span data-ttu-id="460c2-248">Tipi integrali</span><span class="sxs-lookup"><span data-stu-id="460c2-248">Integral types</span></span>](../../language-reference/builtin-types/integral-numeric-types.md)
