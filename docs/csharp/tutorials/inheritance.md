---
title: Ereditarietà in C#
description: Informazioni su come usare l'ereditarietà nelle applicazioni e nelle librerie C#.
ms.date: 07/05/2018
ms.technology: csharp-fundamentals
ms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31
ms.openlocfilehash: 8e24ad3e93dcd11f39ae979a3acda4c4ada13dc5
ms.sourcegitcommit: 03fec33630b46e78d5e81e91b40518f32c4bd7b5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 05/27/2020
ms.locfileid: "84007728"
---
# <a name="inheritance-in-c-and-net"></a><span data-ttu-id="521a0-103">Ereditarietà in C# e .NET</span><span class="sxs-lookup"><span data-stu-id="521a0-103">Inheritance in C# and .NET</span></span>

<span data-ttu-id="521a0-104">Questa esercitazione presenta l'ereditarietà in C#.</span><span class="sxs-lookup"><span data-stu-id="521a0-104">This tutorial introduces you to inheritance in C#.</span></span> <span data-ttu-id="521a0-105">L'ereditarietà è una caratteristica dei linguaggi di programmazione orientati a oggetti che consente di definire una classe di base con funzionalità specifiche (relative a dati e comportamento) e classi derivate che ereditano o eseguono l'override di tali funzionalità.</span><span class="sxs-lookup"><span data-stu-id="521a0-105">Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="521a0-106">Prerequisiti</span><span class="sxs-lookup"><span data-stu-id="521a0-106">Prerequisites</span></span>

<span data-ttu-id="521a0-107">In questa esercitazione si presuppone che sia stato installato il .NET Core SDK.</span><span class="sxs-lookup"><span data-stu-id="521a0-107">This tutorial assumes that you've installed the .NET Core SDK.</span></span> <span data-ttu-id="521a0-108">Visitare la pagina di [download di .NET Core](https://dotnet.microsoft.com/download) per scaricarlo.</span><span class="sxs-lookup"><span data-stu-id="521a0-108">Visit the [.NET Core Downloads](https://dotnet.microsoft.com/download) page to download it.</span></span> <span data-ttu-id="521a0-109">È necessario anche un editor di codice.</span><span class="sxs-lookup"><span data-stu-id="521a0-109">You also need a code editor.</span></span> <span data-ttu-id="521a0-110">In questa esercitazione viene usato [Visual Studio Code](https://code.visualstudio.com), ma è possibile usare qualsiasi editor di codice desiderato.</span><span class="sxs-lookup"><span data-stu-id="521a0-110">This tutorial uses [Visual Studio Code](https://code.visualstudio.com), although you can use any code editor of your choice.</span></span>

## <a name="running-the-examples"></a><span data-ttu-id="521a0-111">Esecuzione degli esempi</span><span class="sxs-lookup"><span data-stu-id="521a0-111">Running the examples</span></span>

<span data-ttu-id="521a0-112">Per creare ed eseguire gli esempi in questa esercitazione, viene usata l'utilità [dotnet](../../core/tools/dotnet.md) dalla riga di comando.</span><span class="sxs-lookup"><span data-stu-id="521a0-112">To create and run the examples in this tutorial, you use the [dotnet](../../core/tools/dotnet.md) utility from the command line.</span></span> <span data-ttu-id="521a0-113">Eseguire questi passaggi per ogni esempio:</span><span class="sxs-lookup"><span data-stu-id="521a0-113">Follow these steps for each example:</span></span>

1. <span data-ttu-id="521a0-114">Creare una directory per archiviare l'esempio.</span><span class="sxs-lookup"><span data-stu-id="521a0-114">Create a directory to store the example.</span></span>
1. <span data-ttu-id="521a0-115">Per creare un nuovo progetto.NET Core, immettere il comando [dotnet new console](../../core/tools/dotnet-new.md) al prompt dei comandi.</span><span class="sxs-lookup"><span data-stu-id="521a0-115">Enter the [dotnet new console](../../core/tools/dotnet-new.md) command at a command prompt to create a new .NET Core project.</span></span>
1. <span data-ttu-id="521a0-116">Copiare e incollare il codice dell'esempio nell'editor di codice.</span><span class="sxs-lookup"><span data-stu-id="521a0-116">Copy and paste the code from the example into your code editor.</span></span>
1. <span data-ttu-id="521a0-117">Per caricare o ripristinare le dipendenze del progetto, eseguire il comando [dotnet restore](../../core/tools/dotnet-restore.md) dalla riga di comando.</span><span class="sxs-lookup"><span data-stu-id="521a0-117">Enter the [dotnet restore](../../core/tools/dotnet-restore.md) command from the command line to load or restore the project's dependencies.</span></span>

   [!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

1. <span data-ttu-id="521a0-118">Per compilare ed eseguire l'esempio, immettere il comando [dotnet run](../../core/tools/dotnet-run.md).</span><span class="sxs-lookup"><span data-stu-id="521a0-118">Enter the [dotnet run](../../core/tools/dotnet-run.md) command to compile and execute the example.</span></span>

## <a name="background-what-is-inheritance"></a><span data-ttu-id="521a0-119">Informazioni generali: che cos'è l'ereditarietà?</span><span class="sxs-lookup"><span data-stu-id="521a0-119">Background: What is inheritance?</span></span>

<span data-ttu-id="521a0-120">Il concetto di *ereditarietà* è uno degli attributi fondamentali della programmazione orientata a oggetti.</span><span class="sxs-lookup"><span data-stu-id="521a0-120">*Inheritance* is one of the fundamental attributes of object-oriented programming.</span></span> <span data-ttu-id="521a0-121">L'ereditarietà consente di definire una classe figlio che riutilizza (eredita), estende o modifica il comportamento di una classe padre.</span><span class="sxs-lookup"><span data-stu-id="521a0-121">It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class.</span></span> <span data-ttu-id="521a0-122">La classe i cui membri vengono ereditati è denominata *classe di base*.</span><span class="sxs-lookup"><span data-stu-id="521a0-122">The class whose members are inherited is called the *base class*.</span></span> <span data-ttu-id="521a0-123">Quella che eredita i membri della classe di base è denominata *classe derivata*.</span><span class="sxs-lookup"><span data-stu-id="521a0-123">The class that inherits the members of the base class is called the *derived class*.</span></span>

<span data-ttu-id="521a0-124">C# e .NET supportano solo l'*ereditarietà singola*.</span><span class="sxs-lookup"><span data-stu-id="521a0-124">C# and .NET support *single inheritance* only.</span></span> <span data-ttu-id="521a0-125">Ciò significa che una classe può solo ereditare da una singola classe.</span><span class="sxs-lookup"><span data-stu-id="521a0-125">That is, a class can only inherit from a single class.</span></span> <span data-ttu-id="521a0-126">L'ereditarietà tuttavia è transitiva, pertanto è possibile definire una gerarchia di ereditarietà per un set di tipi.</span><span class="sxs-lookup"><span data-stu-id="521a0-126">However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types.</span></span> <span data-ttu-id="521a0-127">In altre parole, il tipo `D` può ereditare dal tipo `C`, che eredita dal tipo `B`, il quale eredita a sua volta dal tipo della classe di base `A`.</span><span class="sxs-lookup"><span data-stu-id="521a0-127">In other words, type `D` can inherit from type `C`, which inherits from type `B`, which inherits from the base class type `A`.</span></span> <span data-ttu-id="521a0-128">Poiché l'ereditarietà è transitiva, i membri del tipo `A` sono disponibili per il tipo `D`.</span><span class="sxs-lookup"><span data-stu-id="521a0-128">Because inheritance is transitive, the members of type `A` are available to type `D`.</span></span>

<span data-ttu-id="521a0-129">Non tutti i membri di una classe di base vengono ereditati dalle classi derivate.</span><span class="sxs-lookup"><span data-stu-id="521a0-129">Not all members of a base class are inherited by derived classes.</span></span> <span data-ttu-id="521a0-130">I membri seguenti non vengono ereditati:</span><span class="sxs-lookup"><span data-stu-id="521a0-130">The following members are not inherited:</span></span>

- <span data-ttu-id="521a0-131">[Costruttori statici](../programming-guide/classes-and-structs/static-constructors.md), che inizializzano i dati statici di una classe.</span><span class="sxs-lookup"><span data-stu-id="521a0-131">[Static constructors](../programming-guide/classes-and-structs/static-constructors.md), which initialize the static data of a class.</span></span>

- <span data-ttu-id="521a0-132">[Costruttori di istanze](../programming-guide/classes-and-structs/constructors.md), che vengono chiamati per creare una nuova istanza della classe.</span><span class="sxs-lookup"><span data-stu-id="521a0-132">[Instance constructors](../programming-guide/classes-and-structs/constructors.md), which you call to create a new instance of the class.</span></span> <span data-ttu-id="521a0-133">Ogni classe deve definire propri costruttori.</span><span class="sxs-lookup"><span data-stu-id="521a0-133">Each class must define its own constructors.</span></span>

- <span data-ttu-id="521a0-134">[Finalizzatori](../programming-guide/classes-and-structs/destructors.md), che vengono chiamati dal Garbage Collector di runtime per distruggere le istanze di una classe.</span><span class="sxs-lookup"><span data-stu-id="521a0-134">[Finalizers](../programming-guide/classes-and-structs/destructors.md), which are called by the runtime's garbage collector to destroy instances of a class.</span></span>

<span data-ttu-id="521a0-135">Tutti gli altri membri di una classe di base vengono ereditati dalle classi derivate, ma la loro visibilità dipende dall'accessibilità.</span><span class="sxs-lookup"><span data-stu-id="521a0-135">While all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility.</span></span> <span data-ttu-id="521a0-136">L'accessibilità di un membro ne determina la visibilità per le classi derivate, come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="521a0-136">A member's accessibility affects its visibility for derived classes as follows:</span></span>

- <span data-ttu-id="521a0-137">I membri [privati](../language-reference/keywords/private.md) sono visibili solo nelle classi derivate che sono annidate nella relativa classe di base.</span><span class="sxs-lookup"><span data-stu-id="521a0-137">[Private](../language-reference/keywords/private.md) members are visible only in derived classes that are nested in their base class.</span></span> <span data-ttu-id="521a0-138">In caso contrario, non sono visibili nelle classi derivate.</span><span class="sxs-lookup"><span data-stu-id="521a0-138">Otherwise, they are not visible in derived classes.</span></span> <span data-ttu-id="521a0-139">Nell'esempio seguente `A.B` è una classe annidata che deriva da `A` e `C` deriva da `A`.</span><span class="sxs-lookup"><span data-stu-id="521a0-139">In the following example, `A.B` is a nested class that derives from `A`, and `C` derives from `A`.</span></span> <span data-ttu-id="521a0-140">Il campo privato `A.value` è visibile in A.B.</span><span class="sxs-lookup"><span data-stu-id="521a0-140">The private `A.value` field is visible in A.B.</span></span> <span data-ttu-id="521a0-141">Se tuttavia si rimuovono i commenti dal metodo `C.GetValue` e si tenta di compilare l'esempio, verrà generato l'errore del compilatore CS0122: "'A.value' non è accessibile a causa del livello di protezione impostato".</span><span class="sxs-lookup"><span data-stu-id="521a0-141">However, if you remove the comments from the `C.GetValue` method and attempt to compile the example, it produces compiler error CS0122: "'A.value' is inaccessible due to its protection level."</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/private.cs#1)]

- <span data-ttu-id="521a0-142">I membri [protetti](../language-reference/keywords/protected.md) sono visibili solo nelle classi derivate.</span><span class="sxs-lookup"><span data-stu-id="521a0-142">[Protected](../language-reference/keywords/protected.md) members are visible only in derived classes.</span></span>

- <span data-ttu-id="521a0-143">I membri [interni](../language-reference/keywords/internal.md) sono visibili solo nelle classi derivate che si trovano nello stesso assembly della classe di base.</span><span class="sxs-lookup"><span data-stu-id="521a0-143">[Internal](../language-reference/keywords/internal.md) members are visible only in derived classes that are located in the same assembly as the base class.</span></span> <span data-ttu-id="521a0-144">Non sono visibili nelle classi derivate che si trovano in un assembly diverso dalla classe di base.</span><span class="sxs-lookup"><span data-stu-id="521a0-144">They are not visible in derived classes located in a different assembly from the base class.</span></span>

- <span data-ttu-id="521a0-145">I membri [pubblici](../language-reference/keywords/public.md) sono visibili nelle classi derivate e fanno parte dell'interfaccia pubblica della classe derivata.</span><span class="sxs-lookup"><span data-stu-id="521a0-145">[Public](../language-reference/keywords/public.md) members are visible in derived classes and are part of the derived class' public interface.</span></span> <span data-ttu-id="521a0-146">I membri pubblici ereditati possono essere chiamati come se fossero definiti nella classe derivata.</span><span class="sxs-lookup"><span data-stu-id="521a0-146">Public inherited members can be called just as if they are defined in the derived class.</span></span> <span data-ttu-id="521a0-147">Nell'esempio seguente la classe `A` definisce un metodo denominato `Method1` e la classe `B` eredita dalla classe `A`.</span><span class="sxs-lookup"><span data-stu-id="521a0-147">In the following example, class `A` defines a method named `Method1`, and class `B` inherits from class `A`.</span></span> <span data-ttu-id="521a0-148">Nell'esempio viene quindi chiamato `Method1` come se fosse un metodo di istanza in `B`.</span><span class="sxs-lookup"><span data-stu-id="521a0-148">The example then calls `Method1` as if it were an instance method on `B`.</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/basics.cs#1)]

<span data-ttu-id="521a0-149">Le classi derivate possono anche eseguire l'*override* dei membri ereditati fornendo un'implementazione alternativa.</span><span class="sxs-lookup"><span data-stu-id="521a0-149">Derived classes can also *override* inherited members by providing an alternate implementation.</span></span> <span data-ttu-id="521a0-150">Per poter eseguire l'override di un membro, il membro nella classe di base deve essere contrassegnato con la parola chiave [virtual](../language-reference/keywords/virtual.md).</span><span class="sxs-lookup"><span data-stu-id="521a0-150">In order to be able to override a member, the member in the base class must be marked with the [virtual](../language-reference/keywords/virtual.md) keyword.</span></span> <span data-ttu-id="521a0-151">Per impostazione predefinita, i membri della classe di base non sono contrassegnati come `virtual` e non possono essere sottoposti a override.</span><span class="sxs-lookup"><span data-stu-id="521a0-151">By default, base class members are not marked as `virtual` and cannot be overridden.</span></span> <span data-ttu-id="521a0-152">Se si prova a eseguire l'override di un membro non virtuale, viene generato l'errore del compilatore CS0506: "\<member> non può eseguire l'override del membro ereditato \<member> perché non è contrassegnato come virtual, abstract o override".</span><span class="sxs-lookup"><span data-stu-id="521a0-152">Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: "\<member> cannot override inherited member \<member> because it is not marked virtual, abstract, or override.</span></span>

```csharp
public class A
{
    public void Method1()
    {
        // Do something.
    }
}

public class B : A
{
    public override void Method1() // Generates CS0506.
    {
        // Do something else.
    }
}
```

<span data-ttu-id="521a0-153">In alcuni casi una classe derivata *deve* eseguire l'override dell'implementazione della classe di base.</span><span class="sxs-lookup"><span data-stu-id="521a0-153">In some cases, a derived class *must* override the base class implementation.</span></span> <span data-ttu-id="521a0-154">I membri della classe di base contrassegnati con la parola chiave [abstract](../language-reference/keywords/abstract.md) richiedono di essere sottoposti a override dalle classi derivate.</span><span class="sxs-lookup"><span data-stu-id="521a0-154">Base class members marked with the [abstract](../language-reference/keywords/abstract.md) keyword require that derived classes override them.</span></span> <span data-ttu-id="521a0-155">Se si prova a compilare l'esempio seguente, verrà generato l'errore del compilatore CS0534, "&lt;classe&gt; non implementa il membro astratto &lt;membro&gt; ereditato", perché la classe `B` non fornisce alcuna implementazione per `A.Method1`.</span><span class="sxs-lookup"><span data-stu-id="521a0-155">Attempting to compile the following example generates compiler error CS0534, "&lt;class&gt; does not implement inherited abstract member &lt;member&gt;", because class `B` provides no implementation for `A.Method1`.</span></span>

```csharp
public abstract class A
{
    public abstract void Method1();
}

public class B : A // Generates CS0534.
{
    public void Method3()
    {
        // Do something.
    }
}
```

<span data-ttu-id="521a0-156">L'ereditarietà si applica solo alle classi e alle interfacce.</span><span class="sxs-lookup"><span data-stu-id="521a0-156">Inheritance applies only to classes and interfaces.</span></span> <span data-ttu-id="521a0-157">Le altre categorie di tipi (struct, delegati ed enumerazioni) non supportano l'ereditarietà.</span><span class="sxs-lookup"><span data-stu-id="521a0-157">Other type categories (structs, delegates, and enums) do not support inheritance.</span></span> <span data-ttu-id="521a0-158">Per queste regole, se si prova a compilare il codice come nell'esempio seguente, verrà generato l'errore del compilatore CS0527: "Il tipo 'ValueType' nell'elenco delle interfacce non è un'interfaccia".</span><span class="sxs-lookup"><span data-stu-id="521a0-158">Because of these rules, attempting to compile code like the following example produces compiler error CS0527: "Type 'ValueType' in interface list is not an interface."</span></span> <span data-ttu-id="521a0-159">Il messaggio di errore indica che, sebbene sia possibile definire le interfacce implementate da un tipo struct, l'ereditarietà non è supportata.</span><span class="sxs-lookup"><span data-stu-id="521a0-159">The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.</span></span>

```csharp
using System;

public struct ValueStructure : ValueType // Generates CS0527.
{
}
```

## <a name="implicit-inheritance"></a><span data-ttu-id="521a0-160">Ereditarietà implicita</span><span class="sxs-lookup"><span data-stu-id="521a0-160">Implicit inheritance</span></span>

<span data-ttu-id="521a0-161">Oltre ai tipi da cui possono ereditare tramite l'ereditarietà singola, tutti i tipi nel sistema di tipi .NET ereditano in modo implicito da <xref:System.Object> o da un tipo derivato.</span><span class="sxs-lookup"><span data-stu-id="521a0-161">Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <xref:System.Object> or a type derived from it.</span></span> <span data-ttu-id="521a0-162">Le funzionalità comuni di <xref:System.Object> saranno disponibili per qualsiasi tipo.</span><span class="sxs-lookup"><span data-stu-id="521a0-162">The common functionality of <xref:System.Object> is available to any type.</span></span>

<span data-ttu-id="521a0-163">Per comprendere il significato dell'ereditarietà implicita, si definirà una nuova classe, `SimpleClass`, che è semplicemente una definizione di classe vuota:</span><span class="sxs-lookup"><span data-stu-id="521a0-163">To see what implicit inheritance means, let's define a new class, `SimpleClass`, that is simply an empty class definition:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#1)]

<span data-ttu-id="521a0-164">È quindi possibile usare la reflection, che consente di esaminare i metadati del tipo per ottenere informazioni su di esso, per generare un elenco dei membri che appartengono al tipo `SimpleClass`.</span><span class="sxs-lookup"><span data-stu-id="521a0-164">You can then use reflection (which lets you inspect a type's metadata to get information about that type) to get a list of the members that belong to the `SimpleClass` type.</span></span> <span data-ttu-id="521a0-165">Anche se non è stato definito alcun membro nella classe `SimpleClass`, l'output dell'esempio indica che ha effettivamente nove membri.</span><span class="sxs-lookup"><span data-stu-id="521a0-165">Although you haven't defined any members in your `SimpleClass` class, output from the example indicates that it actually has nine members.</span></span> <span data-ttu-id="521a0-166">Uno di questi è un costruttore senza parametri (o predefinito) fornito automaticamente per il tipo `SimpleClass` dal compilatore C#.</span><span class="sxs-lookup"><span data-stu-id="521a0-166">One of these members is a parameterless (or default) constructor that is automatically supplied for the `SimpleClass` type by the C# compiler.</span></span> <span data-ttu-id="521a0-167">I rimanenti otto sono membri di <xref:System.Object>, il tipo da cui ereditano in modo implicito tutte le classi e le interfacce nel sistema di tipi .NET.</span><span class="sxs-lookup"><span data-stu-id="521a0-167">The remaining eight are members of <xref:System.Object>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#2)]

<span data-ttu-id="521a0-168">L'ereditarietà implicita dalla classe <xref:System.Object> rende disponibili questi metodi per la classe `SimpleClass`:</span><span class="sxs-lookup"><span data-stu-id="521a0-168">Implicit inheritance from the <xref:System.Object> class makes these methods available to the `SimpleClass` class:</span></span>

- <span data-ttu-id="521a0-169">Il metodo pubblico `ToString`, che converte un oggetto `SimpleClass` nella relativa rappresentazione stringa, restituisce il nome di tipo completo.</span><span class="sxs-lookup"><span data-stu-id="521a0-169">The public `ToString` method, which converts a `SimpleClass` object to its string representation, returns the fully qualified type name.</span></span> <span data-ttu-id="521a0-170">In questo caso il metodo `ToString` restituisce la stringa "SimpleClass".</span><span class="sxs-lookup"><span data-stu-id="521a0-170">In this case, the `ToString` method returns the string "SimpleClass".</span></span>

- <span data-ttu-id="521a0-171">Tre metodi che verificano l'uguaglianza di due oggetti: il metodo pubblico di istanza `Equals(Object)`, il metodo statico pubblico `Equals(Object, Object)` e il metodo statico pubblico `ReferenceEquals(Object, Object)`.</span><span class="sxs-lookup"><span data-stu-id="521a0-171">Three methods that test for equality of two objects: the public instance `Equals(Object)` method, the public static `Equals(Object, Object)` method, and the public static `ReferenceEquals(Object, Object)` method.</span></span> <span data-ttu-id="521a0-172">Per impostazione predefinita, questi metodi verificano l'uguaglianza dei riferimenti. Ciò significa che, per essere uguali, due variabili di oggetto devono fare riferimento allo stesso oggetto.</span><span class="sxs-lookup"><span data-stu-id="521a0-172">By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.</span></span>

- <span data-ttu-id="521a0-173">Il metodo pubblico `GetHashCode`, che calcola un valore che consente di usare un'istanza del tipo nelle raccolte con hash.</span><span class="sxs-lookup"><span data-stu-id="521a0-173">The public `GetHashCode` method, which computes a value that allows an instance of the type to be used in hashed collections.</span></span>

- <span data-ttu-id="521a0-174">Il metodo pubblico `GetType`, che restituisce un oggetto <xref:System.Type> che rappresenta il tipo `SimpleClass`.</span><span class="sxs-lookup"><span data-stu-id="521a0-174">The public `GetType` method, which returns a <xref:System.Type> object that represents the `SimpleClass` type.</span></span>

- <span data-ttu-id="521a0-175">Il metodo protetto <xref:System.Object.Finalize%2A>, che è progettato per rilasciare le risorse non gestite prima che la memoria di un oggetto venga recuperata dal Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="521a0-175">The protected <xref:System.Object.Finalize%2A> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.</span></span>

- <span data-ttu-id="521a0-176">Il metodo protetto <xref:System.Object.MemberwiseClone%2A>, che crea un clone superficiale dell'oggetto corrente.</span><span class="sxs-lookup"><span data-stu-id="521a0-176">The protected <xref:System.Object.MemberwiseClone%2A> method, which creates a shallow clone of the current object.</span></span>

<span data-ttu-id="521a0-177">Grazie all'ereditarietà implicita, è possibile chiamare qualsiasi membro ereditato da un oggetto `SimpleClass` come se fosse effettivamente un membro definito nella classe `SimpleClass`.</span><span class="sxs-lookup"><span data-stu-id="521a0-177">Because of implicit inheritance, you can call any inherited member from a `SimpleClass` object just as if it was actually a member defined in the `SimpleClass` class.</span></span> <span data-ttu-id="521a0-178">Nell'esempio seguente viene chiamato il metodo `SimpleClass.ToString` che `SimpleClass` eredita da <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="521a0-178">For instance, the following example calls the `SimpleClass.ToString` method, which `SimpleClass` inherits from <xref:System.Object>.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass2.cs#1)]

<span data-ttu-id="521a0-179">Nella tabella seguente sono elencate le categorie di tipi che è possibile creare in C# e i tipi da cui ereditano in modo implicito.</span><span class="sxs-lookup"><span data-stu-id="521a0-179">The following table lists the categories of types that you can create in C# and the types from which they implicitly inherit.</span></span> <span data-ttu-id="521a0-180">Tramite l'ereditarietà ciascun tipo di base rende disponibile un set di membri diverso per i tipi derivati in modo implicito.</span><span class="sxs-lookup"><span data-stu-id="521a0-180">Each base type makes a different set of members available through inheritance to implicitly derived types.</span></span>

| <span data-ttu-id="521a0-181">Categoria di tipi</span><span class="sxs-lookup"><span data-stu-id="521a0-181">Type category</span></span> | <span data-ttu-id="521a0-182">Eredita in modo implicito da</span><span class="sxs-lookup"><span data-stu-id="521a0-182">Implicitly inherits from</span></span>                                                      |
| ------------- | ----------------------------------------------------------------------------- |
| <span data-ttu-id="521a0-183">classe</span><span class="sxs-lookup"><span data-stu-id="521a0-183">class</span></span>         | <xref:System.Object>                                                          |
| <span data-ttu-id="521a0-184">struct</span><span class="sxs-lookup"><span data-stu-id="521a0-184">struct</span></span>        | <span data-ttu-id="521a0-185"><xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="521a0-185"><xref:System.ValueType>, <xref:System.Object></span></span>                                 |
| <span data-ttu-id="521a0-186">enum</span><span class="sxs-lookup"><span data-stu-id="521a0-186">enum</span></span>          | <span data-ttu-id="521a0-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="521a0-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span></span>             |
| <span data-ttu-id="521a0-188">delegato</span><span class="sxs-lookup"><span data-stu-id="521a0-188">delegate</span></span>      | <span data-ttu-id="521a0-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="521a0-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span></span> |

## <a name="inheritance-and-an-is-a-relationship"></a><span data-ttu-id="521a0-190">Ereditarietà e relazione "è un"</span><span class="sxs-lookup"><span data-stu-id="521a0-190">Inheritance and an "is a" relationship</span></span>

<span data-ttu-id="521a0-191">In genere l'ereditarietà consente di esprimere una relazione "è un" tra una classe di base e una o più classi derivate, in cui le classi derivate sono versioni specializzate della classe di base. La classe derivata è un tipo della classe di base.</span><span class="sxs-lookup"><span data-stu-id="521a0-191">Ordinarily, inheritance is used to express an "is a" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class.</span></span> <span data-ttu-id="521a0-192">La classe `Publication` rappresenta ad esempio una pubblicazione di qualsiasi tipo e le classi `Book` e `Magazine` rappresentano tipi specifici di pubblicazioni.</span><span class="sxs-lookup"><span data-stu-id="521a0-192">For example, the `Publication` class represents a publication of any kind, and the `Book` and `Magazine` classes represent specific types of publications.</span></span>

> [!NOTE]
> <span data-ttu-id="521a0-193">Una classe o uno struct può implementare una o più interfacce.</span><span class="sxs-lookup"><span data-stu-id="521a0-193">A class or struct can implement one or more interfaces.</span></span> <span data-ttu-id="521a0-194">Anche se l'implementazione dell'interfaccia è spesso presentata come una soluzione alternativa all'ereditarietà singola o come modo per usare l'ereditarietà con struct, è stata ideata per esprimere una relazione diversa (una relazione "può fare") tra un'interfaccia e il relativo tipo di implementazione rispetto all'ereditarietà.</span><span class="sxs-lookup"><span data-stu-id="521a0-194">While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a "can do" relationship) between an interface and its implementing type than inheritance.</span></span> <span data-ttu-id="521a0-195">Un'interfaccia definisce un subset di funzionalità che rende disponibili per i tipi di implementazione, ad esempio le funzionalità per verificare l'uguaglianza, confrontare o ordinare gli oggetti, nonché supportare la formattazione e l'analisi in base alle impostazioni cultura.</span><span class="sxs-lookup"><span data-stu-id="521a0-195">An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.</span></span>

<span data-ttu-id="521a0-196">Si noti che "è un" esprime anche la relazione tra un tipo e un'istanza specifica di quel tipo.</span><span class="sxs-lookup"><span data-stu-id="521a0-196">Note that "is a" also expresses the relationship between a type and a specific instantiation of that type.</span></span> <span data-ttu-id="521a0-197">Nell'esempio seguente `Automobile` è una classe che ha tre proprietà univoche di sola lettura: `Make`, il produttore dell'automobile, `Model`, il tipo di automobile e `Year`, l'anno di produzione.</span><span class="sxs-lookup"><span data-stu-id="521a0-197">In the following example, `Automobile` is a class that has three unique read-only properties: `Make`, the manufacturer of the automobile; `Model`, the kind of automobile; and `Year`, its year of manufacture.</span></span> <span data-ttu-id="521a0-198">La classe `Automobile` include anche un costruttore i cui argomenti vengono assegnati ai valori delle proprietà ed esegue l'override del metodo <xref:System.Object.ToString%2A?displayProperty=nameWithType> per generare una stringa che identifica in modo univoco l'istanza `Automobile` anziché la classe `Automobile`.</span><span class="sxs-lookup"><span data-stu-id="521a0-198">Your `Automobile` class also has a constructor whose arguments are assigned to the property values, and it overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to produce a string that uniquely identifies the `Automobile` instance rather than the `Automobile` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#1)]

<span data-ttu-id="521a0-199">In questo caso è opportuno non fare affidamento sull'ereditarietà per rappresentare marche e modelli specifici di automobili.</span><span class="sxs-lookup"><span data-stu-id="521a0-199">In this case, you shouldn't rely on inheritance to represent specific car makes and models.</span></span> <span data-ttu-id="521a0-200">Non è ad esempio necessario definire un tipo `Packard` che rappresenta automobili prodotte dalla casa automobilistica Packard.</span><span class="sxs-lookup"><span data-stu-id="521a0-200">For example, you don't need to define a `Packard` type to represent automobiles manufactured by the Packard Motor Car Company.</span></span> <span data-ttu-id="521a0-201">È invece possibile rappresentarle creando un oggetto `Automobile` con i valori appropriati passati al costruttore della classe, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="521a0-201">Instead, you can represent them by creating an `Automobile` object with the appropriate values passed to its class constructor, as the following example does.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#2)]

<span data-ttu-id="521a0-202">È preferibile applicare una relazione "è un" basata sull'ereditarietà a una classe di base e a classi derivate che aggiungono altri membri alla classe di base o che richiedono funzionalità aggiuntive non presenti nella classe di base.</span><span class="sxs-lookup"><span data-stu-id="521a0-202">An is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.</span></span>

## <a name="designing-the-base-class-and-derived-classes"></a><span data-ttu-id="521a0-203">Progettazione della classe di base e delle classi derivate</span><span class="sxs-lookup"><span data-stu-id="521a0-203">Designing the base class and derived classes</span></span>

<span data-ttu-id="521a0-204">Si esaminerà ora il processo di progettazione della classe di base e delle relative classi derivate.</span><span class="sxs-lookup"><span data-stu-id="521a0-204">Let's look at the process of designing a base class and its derived classes.</span></span> <span data-ttu-id="521a0-205">In questa sezione si definirà una classe di base, `Publication` , che rappresenta una pubblicazione di qualsiasi tipo, ad esempio un libro, una rivista, un giornale, un journal, un articolo e così via. Si definirà anche una `Book` classe che deriva da `Publication` .</span><span class="sxs-lookup"><span data-stu-id="521a0-205">In this section, you'll define a base class, `Publication`, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. You'll also define a `Book` class that derives from `Publication`.</span></span> <span data-ttu-id="521a0-206">L'esempio può essere facilmente esteso alla definizione di altre classi derivate, ad esempio `Magazine`, `Journal`, `Newspaper` e `Article`.</span><span class="sxs-lookup"><span data-stu-id="521a0-206">You could easily extend the example to define other derived classes, such as `Magazine`, `Journal`, `Newspaper`, and `Article`.</span></span>

### <a name="the-base-publication-class"></a><span data-ttu-id="521a0-207">Classe di base Publication</span><span class="sxs-lookup"><span data-stu-id="521a0-207">The base Publication class</span></span>

<span data-ttu-id="521a0-208">Per progettare la classe `Publication`, è necessario prendere alcune decisioni di progettazione:</span><span class="sxs-lookup"><span data-stu-id="521a0-208">In designing your `Publication` class, you need to make several design decisions:</span></span>

- <span data-ttu-id="521a0-209">Quali membri includere nella classe di base `Publication` e se i membri `Publication` forniscono le implementazioni del metodo o se `Publication` è una classe di base astratta che funge da modello per le relative classi derivate.</span><span class="sxs-lookup"><span data-stu-id="521a0-209">What members to include in your base `Publication` class, and whether the `Publication` members provide method implementations or whether `Publication` is an abstract base class that serves as a template for its derived classes.</span></span>

  <span data-ttu-id="521a0-210">In questo caso la classe `Publication` fornirà le implementazioni del metodo.</span><span class="sxs-lookup"><span data-stu-id="521a0-210">In this case, the `Publication` class will provide method implementations.</span></span> <span data-ttu-id="521a0-211">La sezione [Progettazione di classi di base astratte e delle relative classi derivate](#abstract) contiene un esempio in cui viene usata una classe base astratta per definire i metodi di cui le classi derivate devono eseguire l'override.</span><span class="sxs-lookup"><span data-stu-id="521a0-211">The [Designing abstract base classes and their derived classes](#abstract) section contains an example that uses an abstract base class to define the methods that derived classes must override.</span></span> <span data-ttu-id="521a0-212">Le classi derivate possono fornire qualsiasi implementazione adatta al tipo derivato.</span><span class="sxs-lookup"><span data-stu-id="521a0-212">Derived classes are free to provide any implementation that is suitable for the derived type.</span></span>

  <span data-ttu-id="521a0-213">La possibilità di riutilizzare il codice, ovvero il fatto che più classi derivate condividano la dichiarazione e l'implementazione dei metodi della classe di base e non ne richiedano l'override, è un vantaggio delle classi di base non astratte.</span><span class="sxs-lookup"><span data-stu-id="521a0-213">The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes.</span></span> <span data-ttu-id="521a0-214">È quindi necessario aggiungere membri a `Publication` se è probabile che il relativo codice venga condiviso da alcuni o dalla maggior parte dei tipi specializzati `Publication`.</span><span class="sxs-lookup"><span data-stu-id="521a0-214">Therefore, you should add members to `Publication` if their code is likely to be shared by some or most specialized `Publication` types.</span></span> <span data-ttu-id="521a0-215">Se le implementazioni delle classi di base non vengono eseguite in modo efficiente, sarà necessario fornire implementazioni di membri pressoché identiche nelle classi derivate anziché una singola implementazione nella classe di base.</span><span class="sxs-lookup"><span data-stu-id="521a0-215">If you fail to provide base class implementations efficiently, you'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class.</span></span> <span data-ttu-id="521a0-216">La necessità di mantenere il codice duplicato in più posizioni è una potenziale fonte di bug.</span><span class="sxs-lookup"><span data-stu-id="521a0-216">The need to maintain duplicated code in multiple locations is a potential source of bugs.</span></span>

  <span data-ttu-id="521a0-217">Per ottimizzare il riutilizzo del codice e per creare una gerarchia di ereditarietà logica e intuitiva, è opportuno assicurarsi che nella classe `Publication` vengano inclusi solo i dati e le funzionalità comuni a tutte le pubblicazioni o alla maggior parte di esse.</span><span class="sxs-lookup"><span data-stu-id="521a0-217">Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, you want to be sure that you include in the `Publication` class only the data and functionality that is common to all or to most publications.</span></span> <span data-ttu-id="521a0-218">Le classi derivate implementano quindi i membri che sono univoci per i tipi di pubblicazione specifici che rappresentano.</span><span class="sxs-lookup"><span data-stu-id="521a0-218">Derived classes then implement members that are unique to the particular kinds of publication that they represent.</span></span>

- <span data-ttu-id="521a0-219">Fino a che punto estendere la gerarchia di classi.</span><span class="sxs-lookup"><span data-stu-id="521a0-219">How far to extend your class hierarchy.</span></span> <span data-ttu-id="521a0-220">È necessario decidere se si vuole sviluppare una gerarchia di tre o più classi, anziché semplicemente una classe di base e una o più classi derivate.</span><span class="sxs-lookup"><span data-stu-id="521a0-220">Do you want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes?</span></span> <span data-ttu-id="521a0-221">`Publication` può ad esempio essere una classe di base di `Periodical`, che a sua volta è una classe di base di `Magazine`, `Journal` e `Newspaper`.</span><span class="sxs-lookup"><span data-stu-id="521a0-221">For example, `Publication` could be a base class of `Periodical`, which in turn is a base class of `Magazine`, `Journal` and `Newspaper`.</span></span>

  <span data-ttu-id="521a0-222">Per questo esempio si userà la piccola gerarchia di una classe `Publication` e di una singola classe derivata `Book`.</span><span class="sxs-lookup"><span data-stu-id="521a0-222">For your example, you'll use the small hierarchy of a `Publication` class and a single derived class, `Book`.</span></span> <span data-ttu-id="521a0-223">È possibile estendere facilmente l'esempio per creare una serie di classi aggiuntive che derivano da `Publication` , ad esempio `Magazine` e `Article` .</span><span class="sxs-lookup"><span data-stu-id="521a0-223">You could easily extend the example to create a number of additional classes that derive from `Publication`, such as `Magazine` and `Article`.</span></span>

- <span data-ttu-id="521a0-224">Se è opportuno creare un'istanza della classe di base.</span><span class="sxs-lookup"><span data-stu-id="521a0-224">Whether it makes sense to instantiate the base class.</span></span> <span data-ttu-id="521a0-225">In caso contrario, è necessario applicare alla classe la parola chiave [abstract](../language-reference/keywords/abstract.md).</span><span class="sxs-lookup"><span data-stu-id="521a0-225">If it does not, you should apply the [abstract](../language-reference/keywords/abstract.md) keyword to the class.</span></span> <span data-ttu-id="521a0-226">Altrimenti è possibile creare un'istanza della classe `Publication` chiamando il relativo costruttore di classe.</span><span class="sxs-lookup"><span data-stu-id="521a0-226">Otherwise, your `Publication` class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="521a0-227">Se si prova a creare un'istanza di una classe contrassegnata con la parola chiave `abstract` da una chiamata diretta al costruttore della classe, il compilatore C# genera l'errore CS0144, "Non è possibile creare un'istanza della classe o dell'interfaccia astratta".</span><span class="sxs-lookup"><span data-stu-id="521a0-227">If an attempt is made to instantiate a class marked with the `abstract` keyword by a direct call to its class constructor, the C# compiler generates error CS0144, "Cannot create an instance of the abstract class or interface."</span></span> <span data-ttu-id="521a0-228">Se si prova a creare un'istanza della classe usando la reflection, il metodo di reflection genera un'eccezione <xref:System.MemberAccessException>.</span><span class="sxs-lookup"><span data-stu-id="521a0-228">If an attempt is made to instantiate the class by using reflection, the reflection method throws a <xref:System.MemberAccessException>.</span></span>

  <span data-ttu-id="521a0-229">Per impostazione predefinita, è possibile creare un'istanza della classe di base chiamando il relativo costruttore di classe.</span><span class="sxs-lookup"><span data-stu-id="521a0-229">By default, a base class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="521a0-230">Non è necessario definire in modo esplicito un costruttore di classe.</span><span class="sxs-lookup"><span data-stu-id="521a0-230">You do not have to explicitly define a class constructor.</span></span> <span data-ttu-id="521a0-231">Se non è presente un costruttore nel codice sorgente della classe di base, il compilatore C# ne fornisce automaticamente uno predefinito (senza parametri).</span><span class="sxs-lookup"><span data-stu-id="521a0-231">If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.</span></span>

  <span data-ttu-id="521a0-232">Per questo esempio, la classe `Publication` verrà contrassegnata come [abstract](../language-reference/keywords/abstract.md) in modo che non sia possibile crearne un'istanza.</span><span class="sxs-lookup"><span data-stu-id="521a0-232">For your example, you'll mark the `Publication` class as [abstract](../language-reference/keywords/abstract.md) so that it cannot be instantiated.</span></span>  <span data-ttu-id="521a0-233">Una classe `abstract` senza metodi `abstract` indica che questa classe rappresenta un concetto astratto condiviso tra diverse classi concrete (ad esempio `Book`, `Journal`).</span><span class="sxs-lookup"><span data-stu-id="521a0-233">An `abstract` class without any `abstract` methods indicates that this class represents an abstract concept that is shared among several concrete classes (like a `Book`, `Journal`).</span></span>

- <span data-ttu-id="521a0-234">Se le classi derivate devono ereditare l'implementazione della classe di base di un membro specifico, o se possono eseguire l'override dell'implementazione della classe di base, o ancora se devono fornire un'implementazione.</span><span class="sxs-lookup"><span data-stu-id="521a0-234">Whether derived classes must inherit the base class implementation of particular members, whether they have the option to override the base class implementation, or whether they must provide an implementation.</span></span> <span data-ttu-id="521a0-235">La parola chiave [abstract](../language-reference/keywords/abstract.md) si usa per forzare le classi derivate a fornire un'implementazione.</span><span class="sxs-lookup"><span data-stu-id="521a0-235">You use the [abstract](../language-reference/keywords/abstract.md) keyword to force derived classes to provide an implementation.</span></span> <span data-ttu-id="521a0-236">Usare la parola chiave [virtual](../language-reference/keywords/virtual.md) per consentire alle classi derivate di eseguire l'override di un metodo della classe di base.</span><span class="sxs-lookup"><span data-stu-id="521a0-236">You use the [virtual](../language-reference/keywords/virtual.md) keyword to allow derived classes to override a base class method.</span></span> <span data-ttu-id="521a0-237">Per impostazione predefinita, *non* è possibile eseguire l'override dei metodi definiti nella classe di base.</span><span class="sxs-lookup"><span data-stu-id="521a0-237">By default, methods defined in the base class are *not* overridable.</span></span>

  <span data-ttu-id="521a0-238">La classe `Publication` non ha metodi `abstract`, ma la classe stessa è `abstract`.</span><span class="sxs-lookup"><span data-stu-id="521a0-238">The `Publication` class does not have any `abstract` methods, but the class itself is `abstract`.</span></span>

- <span data-ttu-id="521a0-239">Se una classe derivata rappresenta la classe finale nella gerarchia di ereditarietà e non può essere usata come classe di base per altre classi derivate.</span><span class="sxs-lookup"><span data-stu-id="521a0-239">Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes.</span></span> <span data-ttu-id="521a0-240">Per impostazione predefinita, qualsiasi classe può essere usata come classe di base.</span><span class="sxs-lookup"><span data-stu-id="521a0-240">By default, any class can serve as a base class.</span></span> <span data-ttu-id="521a0-241">È possibile applicare la parola chiave [sealed](../language-reference/keywords/sealed.md) per indicare che una classe non può essere usata come classe di base per altre classi.</span><span class="sxs-lookup"><span data-stu-id="521a0-241">You can apply the [sealed](../language-reference/keywords/sealed.md) keyword to indicate that a class cannot serve as a base class for any additional classes.</span></span> <span data-ttu-id="521a0-242">Se si prova a stabilire una relazione di derivazione da una classe sealed, viene generato l'errore del compilatore CS0509, "non può derivare dal tipo sealed \<typeName>".</span><span class="sxs-lookup"><span data-stu-id="521a0-242">Attempting to derive from a sealed class generated compiler error CS0509, "cannot derive from sealed type \<typeName>".</span></span>

  <span data-ttu-id="521a0-243">Per esempio, contrassegnare la classe derivata come `sealed`.</span><span class="sxs-lookup"><span data-stu-id="521a0-243">For your example, you'll mark your derived class as `sealed`.</span></span>

<span data-ttu-id="521a0-244">L'esempio seguente illustra il codice sorgente della classe `Publication`, nonché un'enumerazione `PublicationType` restituita dalla proprietà `Publication.PublicationType`.</span><span class="sxs-lookup"><span data-stu-id="521a0-244">The following example shows the source code for the `Publication` class, as well as a `PublicationType` enumeration that is returned by the `Publication.PublicationType` property.</span></span> <span data-ttu-id="521a0-245">Oltre ai membri che eredita da <xref:System.Object>, la classe `Publication` definisce i membri univoci e gli override dei membri seguenti:</span><span class="sxs-lookup"><span data-stu-id="521a0-245">In addition to the members that it inherits from <xref:System.Object>, the `Publication` class defines the following unique members and member overrides:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#1)]

- <span data-ttu-id="521a0-246">Un costruttore</span><span class="sxs-lookup"><span data-stu-id="521a0-246">A constructor</span></span>

  <span data-ttu-id="521a0-247">Poiché la classe `Publication` è `abstract`, non è possibile crearne un'istanza direttamente dal codice, come nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="521a0-247">Because the `Publication` class is `abstract`, it cannot be instantiated directly from code like the following example:</span></span>

  ```csharp
  var publication = new Publication("Tiddlywinks for Experts", "Fun and Games",
                                    PublicationType.Book);
  ```

  <span data-ttu-id="521a0-248">Il relativo costruttore di istanze può essere tuttavia chiamato direttamente dai costruttori delle classi derivate, come illustrato dal codice sorgente della classe `Book`.</span><span class="sxs-lookup"><span data-stu-id="521a0-248">However, its instance constructor can be called directly from derived class constructors, as the source code for the `Book` class shows.</span></span>

- <span data-ttu-id="521a0-249">Due proprietà relative alla pubblicazione</span><span class="sxs-lookup"><span data-stu-id="521a0-249">Two publication-related properties</span></span>

  <span data-ttu-id="521a0-250">`Title` è una proprietà <xref:System.String> di sola lettura il cui valore viene fornito chiamando il costruttore `Publication`.</span><span class="sxs-lookup"><span data-stu-id="521a0-250">`Title` is a read-only <xref:System.String> property whose value is supplied by calling the `Publication` constructor.</span></span>

  <span data-ttu-id="521a0-251">`Pages` è una proprietà <xref:System.Int32> di lettura/scrittura che indica il numero totale di pagine contenute nella pubblicazione.</span><span class="sxs-lookup"><span data-stu-id="521a0-251">`Pages` is a read-write <xref:System.Int32> property that indicates how many total pages the publication has.</span></span> <span data-ttu-id="521a0-252">Il valore viene archiviato in un campo privato denominato `totalPages`.</span><span class="sxs-lookup"><span data-stu-id="521a0-252">The value is stored in a private field named `totalPages`.</span></span> <span data-ttu-id="521a0-253">Deve essere un numero positivo, altrimenti viene generata un'eccezione <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="521a0-253">It must be a positive number or an <xref:System.ArgumentOutOfRangeException> is thrown.</span></span>

- <span data-ttu-id="521a0-254">Membri relativi all'editore</span><span class="sxs-lookup"><span data-stu-id="521a0-254">Publisher-related members</span></span>

  <span data-ttu-id="521a0-255">Due proprietà di sola lettura, `Publisher` e `Type`.</span><span class="sxs-lookup"><span data-stu-id="521a0-255">Two read-only properties, `Publisher` and `Type`.</span></span> <span data-ttu-id="521a0-256">I valori sono forniti in origine tramite la chiamata al costruttore di classe `Publication`.</span><span class="sxs-lookup"><span data-stu-id="521a0-256">The values are originally supplied by the call to the `Publication` class constructor.</span></span>

- <span data-ttu-id="521a0-257">Membri relativi alla pubblicazione</span><span class="sxs-lookup"><span data-stu-id="521a0-257">Publishing-related members</span></span>

  <span data-ttu-id="521a0-258">Due metodi, `Publish` e `GetPublicationDate`, impostano e restituiscono la data di pubblicazione.</span><span class="sxs-lookup"><span data-stu-id="521a0-258">Two methods, `Publish` and `GetPublicationDate`, set and return the publication date.</span></span> <span data-ttu-id="521a0-259">Il metodo `Publish` imposta un flag privato `published` su `true` quando viene chiamato e assegna la data passata come argomento al campo privato `datePublished`.</span><span class="sxs-lookup"><span data-stu-id="521a0-259">The `Publish` method sets a private  `published` flag to `true` when it is called and assigns the date passed to it as an argument to the private `datePublished` field.</span></span> <span data-ttu-id="521a0-260">Il metodo `GetPublicationDate` restituisce la stringa "NYP" se il flag `published` è `false` e il valore del campo `datePublished` se è `true`.</span><span class="sxs-lookup"><span data-stu-id="521a0-260">The `GetPublicationDate` method returns the string "NYP" if the `published` flag is `false`, and the value of the `datePublished` field if it is `true`.</span></span>

- <span data-ttu-id="521a0-261">Membri relativi al copyright</span><span class="sxs-lookup"><span data-stu-id="521a0-261">Copyright-related members</span></span>

  <span data-ttu-id="521a0-262">Il metodo `Copyright` accetta come argomenti il nome del titolare del copyright e l'anno del copyright e li assegna alle proprietà `CopyrightName` e `CopyrightDate`.</span><span class="sxs-lookup"><span data-stu-id="521a0-262">The `Copyright` method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the `CopyrightName` and `CopyrightDate` properties.</span></span>

- <span data-ttu-id="521a0-263">Override del metodo `ToString`</span><span class="sxs-lookup"><span data-stu-id="521a0-263">An override of the `ToString` method</span></span>

  <span data-ttu-id="521a0-264">Se un tipo non esegue l'override del metodo <xref:System.Object.ToString%2A?displayProperty=nameWithType>, restituisce il nome completo del tipo, che è pressoché inutile per distinguere un'istanza da un'altra.</span><span class="sxs-lookup"><span data-stu-id="521a0-264">If a type does not override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another.</span></span> <span data-ttu-id="521a0-265">La classe `Publication` esegue l'override di <xref:System.Object.ToString%2A?displayProperty=nameWithType> per restituire il valore della proprietà `Title`.</span><span class="sxs-lookup"><span data-stu-id="521a0-265">The `Publication` class overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType> to return the value of the `Title` property.</span></span>

<span data-ttu-id="521a0-266">La figura seguente illustra la relazione tra la classe di base `Publication` e la relativa classe <xref:System.Object> ereditata in modo implicito.</span><span class="sxs-lookup"><span data-stu-id="521a0-266">The following figure illustrates the relationship between your base `Publication` class and its implicitly inherited <xref:System.Object> class.</span></span>

![Classi Object e Publication](media/publication-class.jpg)

### <a name="the-book-class"></a><span data-ttu-id="521a0-268">Classe `Book`</span><span class="sxs-lookup"><span data-stu-id="521a0-268">The `Book` class</span></span>

<span data-ttu-id="521a0-269">La classe `Book` rappresenta un libro come tipo specializzato di pubblicazione.</span><span class="sxs-lookup"><span data-stu-id="521a0-269">The `Book` class represents a book as a specialized type of publication.</span></span> <span data-ttu-id="521a0-270">L'esempio seguente illustra il codice sorgente della classe `Book`.</span><span class="sxs-lookup"><span data-stu-id="521a0-270">The following example shows the source code for the `Book` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#2)]

<span data-ttu-id="521a0-271">Oltre ai membri che eredita da `Publication`, la classe `Book` definisce i membri univoci e gli override dei membri seguenti:</span><span class="sxs-lookup"><span data-stu-id="521a0-271">In addition to the members that it inherits from `Publication`, the `Book` class defines the following unique members and member overrides:</span></span>

- <span data-ttu-id="521a0-272">Due costruttori</span><span class="sxs-lookup"><span data-stu-id="521a0-272">Two constructors</span></span>

  <span data-ttu-id="521a0-273">I due costruttori `Book` condividono tre parametri comuni.</span><span class="sxs-lookup"><span data-stu-id="521a0-273">The two `Book` constructors share three common parameters.</span></span> <span data-ttu-id="521a0-274">Due, *title* e *publisher*, corrispondono ai parametri del costruttore `Publication`.</span><span class="sxs-lookup"><span data-stu-id="521a0-274">Two, *title* and *publisher*, correspond to parameters of the `Publication` constructor.</span></span> <span data-ttu-id="521a0-275">Il terzo è *author*, che viene archiviato in una proprietà `Author` pubblica non modificabile.</span><span class="sxs-lookup"><span data-stu-id="521a0-275">The third is *author*, which is stored to a public immutable `Author` property.</span></span> <span data-ttu-id="521a0-276">Un costruttore include un parametro *isbn*, che viene archiviato nella proprietà automatica `ISBN`.</span><span class="sxs-lookup"><span data-stu-id="521a0-276">One constructor includes an *isbn* parameter, which is stored in the `ISBN` auto-property.</span></span>

  <span data-ttu-id="521a0-277">Il primo costruttore usa la parola chiave [this](../language-reference/keywords/this.md) per chiamare l'altro costruttore.</span><span class="sxs-lookup"><span data-stu-id="521a0-277">The first constructor uses the [this](../language-reference/keywords/this.md) keyword to call the other constructor.</span></span> <span data-ttu-id="521a0-278">Il concatenamento di costruttori è un modello comune nella definizione dei costruttori.</span><span class="sxs-lookup"><span data-stu-id="521a0-278">Constructor chaining is a common pattern in defining constructors.</span></span> <span data-ttu-id="521a0-279">I costruttori con meno parametri forniscono i valori predefiniti quando chiamano il costruttore con il maggior numero di parametri.</span><span class="sxs-lookup"><span data-stu-id="521a0-279">Constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.</span></span>

  <span data-ttu-id="521a0-280">Il secondo costruttore usa la parola chiave [base](../language-reference/keywords/base.md) per passare il titolo e il nome dell'editore al costruttore della classe di base.</span><span class="sxs-lookup"><span data-stu-id="521a0-280">The second constructor uses the [base](../language-reference/keywords/base.md) keyword to pass the title and publisher name to the base class constructor.</span></span> <span data-ttu-id="521a0-281">Se non si esegue una chiamata esplicita a un costruttore della classe di base nel codice sorgente, il compilatore C# effettua automaticamente una chiamata al costruttore della classe di base predefinito o senza parametri.</span><span class="sxs-lookup"><span data-stu-id="521a0-281">If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.</span></span>

- <span data-ttu-id="521a0-282">Una proprietà `ISBN` di sola lettura, che restituisce il numero ISBN (International Standard Book Number) dell'oggetto `Book`, un numero univoco a 10 o 13 cifre.</span><span class="sxs-lookup"><span data-stu-id="521a0-282">A read-only `ISBN` property, which returns the `Book` object's International Standard Book Number, a unique 10- or 13-digit number.</span></span> <span data-ttu-id="521a0-283">Il numero ISBN viene fornito come argomento a uno dei costruttori `Book`.</span><span class="sxs-lookup"><span data-stu-id="521a0-283">The ISBN is supplied as an argument to one of the `Book` constructors.</span></span> <span data-ttu-id="521a0-284">Il numero ISBN viene archiviato in un campo sottostante privato, che viene generato automaticamente dal compilatore.</span><span class="sxs-lookup"><span data-stu-id="521a0-284">The ISBN is stored in a private backing field, which is auto-generated by the compiler.</span></span>

- <span data-ttu-id="521a0-285">Una proprietà `Author` di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="521a0-285">A read-only `Author` property.</span></span> <span data-ttu-id="521a0-286">Il nome dell'autore viene fornito come argomento a entrambi i costruttori `Book` e viene archiviato nella proprietà.</span><span class="sxs-lookup"><span data-stu-id="521a0-286">The author name is supplied as an argument to both `Book` constructors and is stored in the property.</span></span>

- <span data-ttu-id="521a0-287">Due proprietà di sola lettura relative ai prezzi, `Price` e `Currency`.</span><span class="sxs-lookup"><span data-stu-id="521a0-287">Two read-only price-related properties, `Price` and `Currency`.</span></span> <span data-ttu-id="521a0-288">I relativi valori vengono forniti come argomenti in una chiamata al metodo `SetPrice`.</span><span class="sxs-lookup"><span data-stu-id="521a0-288">Their values are provided as arguments in a `SetPrice` method call.</span></span> <span data-ttu-id="521a0-289">La proprietà `Currency` è il simbolo di valuta ISO a tre cifre, ad esempio USD per il dollaro statunitense.</span><span class="sxs-lookup"><span data-stu-id="521a0-289">The `Currency` property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar).</span></span> <span data-ttu-id="521a0-290">I simboli di valuta ISO possono essere recuperati dalla proprietà <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A>.</span><span class="sxs-lookup"><span data-stu-id="521a0-290">ISO currency symbols can be retrieved from the <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> property.</span></span> <span data-ttu-id="521a0-291">Entrambe queste proprietà sono esternamente di sola lettura, ma possono essere entrambe impostate dal codice nella classe `Book`.</span><span class="sxs-lookup"><span data-stu-id="521a0-291">Both of these properties are externally read-only, but both can be set by code in the `Book` class.</span></span>

- <span data-ttu-id="521a0-292">Un metodo `SetPrice`, che imposta i valori delle proprietà `Price` e `Currency`.</span><span class="sxs-lookup"><span data-stu-id="521a0-292">A `SetPrice` method, which sets the values of the `Price` and `Currency` properties.</span></span> <span data-ttu-id="521a0-293">Questi valori vengono restituiti dalle stesse proprietà.</span><span class="sxs-lookup"><span data-stu-id="521a0-293">Those values are returned by those same properties.</span></span>

- <span data-ttu-id="521a0-294">Esegue l'override del metodo `ToString` ereditato da `Publication` e dei metodi <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> e <xref:System.Object.GetHashCode%2A> (ereditati da <xref:System.Object>).</span><span class="sxs-lookup"><span data-stu-id="521a0-294">Overrides to the `ToString` method (inherited from `Publication`) and the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> and <xref:System.Object.GetHashCode%2A> methods (inherited from <xref:System.Object>).</span></span>

  <span data-ttu-id="521a0-295">A meno che non venga sottoposto a override, il metodo <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> verifica l'uguaglianza dei riferimenti.</span><span class="sxs-lookup"><span data-stu-id="521a0-295">Unless it is overridden, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method tests for reference equality.</span></span> <span data-ttu-id="521a0-296">Ciò significa che due variabili di oggetto sono considerate uguali se fanno riferimento allo stesso oggetto.</span><span class="sxs-lookup"><span data-stu-id="521a0-296">That is, two object variables are considered to be equal if they refer to the same object.</span></span> <span data-ttu-id="521a0-297">Nella classe `Book`, d'altra parte, due oggetti `Book` sono considerati uguali se hanno lo stesso ISBN.</span><span class="sxs-lookup"><span data-stu-id="521a0-297">In the `Book` class, on the other hand, two `Book` objects should be equal if they have the same ISBN.</span></span>

  <span data-ttu-id="521a0-298">Quando si esegue l'override del metodo <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, è necessario eseguire l'override anche del metodo <xref:System.Object.GetHashCode%2A>, che restituisce un valore che verrà usato dal runtime per archiviare elementi in raccolte con hash e facilitarne così il recupero.</span><span class="sxs-lookup"><span data-stu-id="521a0-298">When you override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, you must also override the <xref:System.Object.GetHashCode%2A> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval.</span></span> <span data-ttu-id="521a0-299">Il codice hash deve restituire un valore coerente con il test di uguaglianza.</span><span class="sxs-lookup"><span data-stu-id="521a0-299">The hash code should return a value that's consistent with the test for equality.</span></span> <span data-ttu-id="521a0-300">Poiché <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> è stato sottoposto a override per restituire `true` se le proprietà ISBN di due oggetti `Book` sono uguali, si restituisce il codice hash calcolato chiamando il metodo <xref:System.String.GetHashCode%2A> della stringa restituita dalla proprietà `ISBN`.</span><span class="sxs-lookup"><span data-stu-id="521a0-300">Since you've overridden <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to return `true` if the ISBN properties of two `Book` objects are equal, you return the hash code computed by calling the <xref:System.String.GetHashCode%2A> method of the string returned by the `ISBN` property.</span></span>

<span data-ttu-id="521a0-301">La figura seguente illustra la relazione tra la classe `Book` e la relativa classe di base `Publication`.</span><span class="sxs-lookup"><span data-stu-id="521a0-301">The following figure illustrates the relationship between the `Book` class and `Publication`, its base class.</span></span>

![Classi Publication e Book](media/book-class.jpg)

<span data-ttu-id="521a0-303">È ora possibile creare un'istanza di un oggetto `Book`, richiamarne i membri univoci ed ereditati e passarla come argomento a un metodo che prevede un parametro di tipo `Publication` o `Book`, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="521a0-303">You can now instantiate a `Book` object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type `Publication` or of type `Book`, as the following example shows.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/use-publication.cs#1)]

## <a name="designing-abstract-base-classes-and-their-derived-classes"></a><span data-ttu-id="521a0-304">Progettazione di classi di base astratte e delle relative classi derivate</span><span class="sxs-lookup"><span data-stu-id="521a0-304">Designing abstract base classes and their derived classes</span></span>
<a name="abstract"></a>

<span data-ttu-id="521a0-305">Nell'esempio precedente si è definita una classe di base che fornisce un'implementazione per una serie di metodi per consentire alle classi derivate di condividere il codice.</span><span class="sxs-lookup"><span data-stu-id="521a0-305">In the previous example, you defined a base class that provided an implementation for a number of methods to allow derived classes to share code.</span></span> <span data-ttu-id="521a0-306">In molti casi, tuttavia, la classe di base non deve fornire un'implementazione.</span><span class="sxs-lookup"><span data-stu-id="521a0-306">In many cases, however, the base class is not expected to provide an implementation.</span></span> <span data-ttu-id="521a0-307">Al contrario, è una *classe astratta* che dichiara dei *metodi astratti* e funge da modello che definisce i membri che ogni classe derivata deve implementare.</span><span class="sxs-lookup"><span data-stu-id="521a0-307">Instead, the base class is an *abstract class* that declares *abstract methods*; it serves as a template that defines the members that each derived class must implement.</span></span> <span data-ttu-id="521a0-308">Per una classe di base astratta l'implementazione di ogni tipo derivato è in genere univoca per quel tipo.</span><span class="sxs-lookup"><span data-stu-id="521a0-308">Typically in an abstract base class, the implementation of each derived type is unique to that type.</span></span> <span data-ttu-id="521a0-309">La classe è stata contrassegnata con la parola chiave abstract perché non si è ritenuto logico creare un'istanza di un oggetto `Publication`, anche se la classe ha fornito implementazioni di funzionalità comuni alle pubblicazioni.</span><span class="sxs-lookup"><span data-stu-id="521a0-309">You marked the class with the abstract keyword because it made no sense to instantiate a `Publication` object, although the class did provide implementations of functionality common to publications.</span></span>

<span data-ttu-id="521a0-310">Ogni forma geometrica bidimensionale chiusa include ad esempio due proprietà: l'area, l'estensione interna della forma e il perimetro, ovvero la lunghezza totale dei bordi della forma.</span><span class="sxs-lookup"><span data-stu-id="521a0-310">For example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape.</span></span> <span data-ttu-id="521a0-311">La modalità di calcolo di queste proprietà dipende tuttavia completamente dalla forma specifica.</span><span class="sxs-lookup"><span data-stu-id="521a0-311">The way in which these properties are calculated, however, depends completely on the specific shape.</span></span> <span data-ttu-id="521a0-312">La formula per calcolare il perimetro (o circonferenza) di un cerchio è ad esempio diversa da quella usata per un triangolo.</span><span class="sxs-lookup"><span data-stu-id="521a0-312">The formula for calculating the perimeter (or circumference) of a circle, for example, is different from that of a triangle.</span></span> <span data-ttu-id="521a0-313">La classe `Shape` è una classe `abstract` con i metodi `abstract`.</span><span class="sxs-lookup"><span data-stu-id="521a0-313">The `Shape` class is an `abstract` class with `abstract` methods.</span></span> <span data-ttu-id="521a0-314">Ciò indica che le classi derivate condividono la stessa funzionalità, ma implementano questa funzionalità in modo diverso.</span><span class="sxs-lookup"><span data-stu-id="521a0-314">That indicates derived classes share the same functionality, but those derived classes implement that functionality differently.</span></span>

<span data-ttu-id="521a0-315">L'esempio seguente definisce una classe di base astratta denominata `Shape` che definisce due proprietà: `Area` e `Perimeter`.</span><span class="sxs-lookup"><span data-stu-id="521a0-315">The following example defines an abstract base class named `Shape` that defines two properties: `Area` and `Perimeter`.</span></span> <span data-ttu-id="521a0-316">Oltre a contrassegnare la classe con la parola chiave [abstract](../language-reference/keywords/abstract.md), si contrassegna con la parola chiave [abstract](../language-reference/keywords/abstract.md) anche ogni membro dell'istanza.</span><span class="sxs-lookup"><span data-stu-id="521a0-316">In addition to marking the class with the [abstract](../language-reference/keywords/abstract.md) keyword, each instance member is also marked with the [abstract](../language-reference/keywords/abstract.md) keyword.</span></span> <span data-ttu-id="521a0-317">In questo caso `Shape` esegue anche l'override del metodo <xref:System.Object.ToString%2A?displayProperty=nameWithType> per restituire il nome del tipo, anziché il nome completo.</span><span class="sxs-lookup"><span data-stu-id="521a0-317">In this case, `Shape` also overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the name of the type, rather than its fully qualified name.</span></span> <span data-ttu-id="521a0-318">Definisce inoltre due membri statici, `GetArea` e `GetPerimeter`, che consentono ai chiamanti di recuperare facilmente l'area e il perimetro di un'istanza di qualsiasi classe derivata.</span><span class="sxs-lookup"><span data-stu-id="521a0-318">And it defines two static members, `GetArea` and `GetPerimeter`, that allow callers to easily retrieve the area and perimeter of an instance of any derived class.</span></span> <span data-ttu-id="521a0-319">Quando si passa un'istanza di una classe derivata a uno di questi metodi, il runtime chiama l'override del metodo della classe derivata.</span><span class="sxs-lookup"><span data-stu-id="521a0-319">When you pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#1)]

<span data-ttu-id="521a0-320">È quindi possibile derivare da `Shape` alcune classi che rappresentano forme specifiche.</span><span class="sxs-lookup"><span data-stu-id="521a0-320">You can then derive some classes from `Shape` that represent specific shapes.</span></span> <span data-ttu-id="521a0-321">Nell'esempio seguente vengono definite tre classi, `Triangle`, `Rectangle` e `Circle`.</span><span class="sxs-lookup"><span data-stu-id="521a0-321">The following example defines three classes, `Triangle`, `Rectangle`, and `Circle`.</span></span> <span data-ttu-id="521a0-322">Ogni classe usa una formula univoca per calcolare l'area e il perimetro della forma specifica.</span><span class="sxs-lookup"><span data-stu-id="521a0-322">Each uses a formula unique for that particular shape to compute the area and perimeter.</span></span> <span data-ttu-id="521a0-323">Alcune classi derivate definiscono anche le proprietà, ad esempio `Rectangle.Diagonal` e `Circle.Diameter`, che sono univoche per la forma che rappresentano.</span><span class="sxs-lookup"><span data-stu-id="521a0-323">Some of the derived classes also define properties, such as `Rectangle.Diagonal` and `Circle.Diameter`, that are unique to the shape that they represent.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#2)]

<span data-ttu-id="521a0-324">Nell'esempio seguente vengono usati gli oggetti derivati da `Shape`.</span><span class="sxs-lookup"><span data-stu-id="521a0-324">The following example uses objects derived from `Shape`.</span></span> <span data-ttu-id="521a0-325">Viene creata un'istanza di una matrice di oggetti derivati da `Shape` e vengono chiamati i metodi statici della classe `Shape`, che esegue il wrapping dei valori restituiti della proprietà `Shape`.</span><span class="sxs-lookup"><span data-stu-id="521a0-325">It instantiates an array of objects derived from `Shape` and calls the static methods of the `Shape` class, which wraps return `Shape` property values.</span></span> <span data-ttu-id="521a0-326">Il runtime recupera i valori dalle proprietà dei tipi derivati sottoposte a override.</span><span class="sxs-lookup"><span data-stu-id="521a0-326">The runtime retrieves values from the overridden properties of the derived types.</span></span> <span data-ttu-id="521a0-327">Nell'esempio viene anche eseguito il cast di ogni oggetto `Shape` nella matrice al relativo tipo derivato e, se il cast ha esito positivo, vengono recuperate le proprietà di quella sottoclasse specifica di `Shape`.</span><span class="sxs-lookup"><span data-stu-id="521a0-327">The example also casts each `Shape` object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of `Shape`.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#3)]

## <a name="see-also"></a><span data-ttu-id="521a0-328">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="521a0-328">See also</span></span>

- [<span data-ttu-id="521a0-329">Classi e oggetti</span><span class="sxs-lookup"><span data-stu-id="521a0-329">Classes and objects</span></span>](../tour-of-csharp/classes-and-objects.md)
- [<span data-ttu-id="521a0-330">Ereditarietà (Guida per programmatori C#)</span><span class="sxs-lookup"><span data-stu-id="521a0-330">Inheritance (C# Programming Guide)</span></span>](../programming-guide/classes-and-structs/inheritance.md)
