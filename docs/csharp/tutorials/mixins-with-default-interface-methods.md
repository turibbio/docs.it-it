---
title: Creare tipi mixin utilizzando i metodi di interfaccia predefiniti
description: Utilizzando i membri di interfaccia predefiniti è possibile estendere le interfacce con implementazioni predefinite facoltative per gli implementatori.
ms.technology: csharp-advanced-concepts
ms.date: 10/04/2019
ms.openlocfilehash: ee0536ef51f9bea3e6851be23cc19fa28cc6916b
ms.sourcegitcommit: 07123a475af89b6da5bb6cc51ea40ab1e8a488f0
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/24/2020
ms.locfileid: "80134370"
---
# <a name="tutorial-mix-functionality-in-when-creating-classes-using-interfaces-with-default-interface-methods"></a><span data-ttu-id="5bc12-103">Esercitazione: Combinare funzionalità quando si creano classi utilizzando interfacce con metodi di interfaccia predefinitiTutorial: Mix functionality in when creating classes using interfaces with default interface methods</span><span class="sxs-lookup"><span data-stu-id="5bc12-103">Tutorial: Mix functionality in when creating classes using interfaces with default interface methods</span></span>

<span data-ttu-id="5bc12-104">A partire da C# 8.0 su .NET Core 3.0 è possibile definire un'implementazione quando si dichiara un membro di un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="5bc12-104">Beginning with C# 8.0 on .NET Core 3.0, you can define an implementation when you declare a member of an interface.</span></span> <span data-ttu-id="5bc12-105">Questa funzionalità offre nuove funzionalità in cui è possibile definire implementazioni predefinite per le funzionalità dichiarate nelle interfacce.</span><span class="sxs-lookup"><span data-stu-id="5bc12-105">This feature provides new capabilities where you can define default implementations for features declared in interfaces.</span></span> <span data-ttu-id="5bc12-106">Le classi possono scegliere quando eseguire l'override della funzionalità, quando utilizzare la funzionalità predefinita e quando non dichiarare il supporto per funzionalità discrete.</span><span class="sxs-lookup"><span data-stu-id="5bc12-106">Classes can pick when to override functionality, when to use the default functionality, and when not to declare support for discrete features.</span></span>

<span data-ttu-id="5bc12-107">In questa esercitazione si apprenderà come:</span><span class="sxs-lookup"><span data-stu-id="5bc12-107">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> * <span data-ttu-id="5bc12-108">Creare interfacce con implementazioni che descrivono funzionalità discrete.</span><span class="sxs-lookup"><span data-stu-id="5bc12-108">Create interfaces with implementations that describe discrete features.</span></span>
> * <span data-ttu-id="5bc12-109">Creare classi che utilizzano le implementazioni predefinite.</span><span class="sxs-lookup"><span data-stu-id="5bc12-109">Create classes that use the default implementations.</span></span>
> * <span data-ttu-id="5bc12-110">Creare classi che eseguono l'override di alcune o tutte le implementazioni predefinite.</span><span class="sxs-lookup"><span data-stu-id="5bc12-110">Create classes that override some or all of the default implementations.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="5bc12-111">Prerequisiti</span><span class="sxs-lookup"><span data-stu-id="5bc12-111">Prerequisites</span></span>

<span data-ttu-id="5bc12-112">È necessario configurare il computer per l'esecuzione di .NET Core, incluso il compilatore c'è 8.0.</span><span class="sxs-lookup"><span data-stu-id="5bc12-112">You’ll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="5bc12-113">È disponibile il compilatore di C'è 8.0 a partire da [Visual Studio 2019 versione 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019)o [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download/dotnet-core) o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="5bc12-113">The C# 8.0 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019), or the [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download/dotnet-core) or later.</span></span>

## <a name="limitations-of-extension-methods"></a><span data-ttu-id="5bc12-114">Limitazioni dei metodi di estensione</span><span class="sxs-lookup"><span data-stu-id="5bc12-114">Limitations of extension methods</span></span>

<span data-ttu-id="5bc12-115">Un modo per implementare il comportamento che viene visualizzato come parte di un'interfaccia consiste nel definire [i metodi](../programming-guide/classes-and-structs/extension-methods.md) di estensione che forniscono il comportamento predefinito.</span><span class="sxs-lookup"><span data-stu-id="5bc12-115">One way you can implement behavior that appears as part of an interface is to define [extension methods](../programming-guide/classes-and-structs/extension-methods.md) that provide the default behavior.</span></span> <span data-ttu-id="5bc12-116">Le interfacce dichiarano un set minimo di membri fornendo allo stesso tempo un'area di superficie maggiore per qualsiasi classe che implementa tale interfaccia.</span><span class="sxs-lookup"><span data-stu-id="5bc12-116">Interfaces declare a minimum set of members while providing a greater surface area for any class that implements that interface.</span></span> <span data-ttu-id="5bc12-117">Ad esempio, i <xref:System.Linq.Enumerable> metodi di estensione in forniscono l'implementazione per qualsiasi sequenza come origine di una query LINQ.</span><span class="sxs-lookup"><span data-stu-id="5bc12-117">For example, the extension methods in <xref:System.Linq.Enumerable> provide the implementation for any sequence to be the source of a LINQ query.</span></span>

<span data-ttu-id="5bc12-118">I metodi di estensione vengono risolti in fase di compilazione, utilizzando il tipo dichiarato della variabile.</span><span class="sxs-lookup"><span data-stu-id="5bc12-118">Extension methods are resolved at compile time, using the declared type of the variable.</span></span> <span data-ttu-id="5bc12-119">Le classi che implementano l'interfaccia possono fornire un'implementazione migliore per qualsiasi metodo di estensione.</span><span class="sxs-lookup"><span data-stu-id="5bc12-119">Classes that implement the interface can provide a better implementation for any extension method.</span></span> <span data-ttu-id="5bc12-120">Le dichiarazioni di variabili devono corrispondere al tipo di implementazione per consentire al compilatore di scegliere tale implementazione.</span><span class="sxs-lookup"><span data-stu-id="5bc12-120">Variable declarations must match the implementing type to enable the compiler to choose that implementation.</span></span> <span data-ttu-id="5bc12-121">Quando il tipo in fase di compilazione corrisponde all'interfaccia, le chiamate al metodo resolve nel metodo di estensione.</span><span class="sxs-lookup"><span data-stu-id="5bc12-121">When the compile-time type matches the interface, method calls resolve to the extension method.</span></span> <span data-ttu-id="5bc12-122">Un altro problema con i metodi di estensione è che tali metodi sono accessibili ovunque la classe contenente i metodi di estensione è accessibile.</span><span class="sxs-lookup"><span data-stu-id="5bc12-122">Another concern with extension methods is that those methods are accessible wherever the class containing the extension methods is accessible.</span></span> <span data-ttu-id="5bc12-123">Le classi non possono dichiarare se devono o non devono fornire funzionalità dichiarate nei metodi di estensione.</span><span class="sxs-lookup"><span data-stu-id="5bc12-123">Classes cannot declare if they should or should not provide features declared in extension methods.</span></span>

<span data-ttu-id="5bc12-124">A partire dalla versione 8.0 di C, è possibile dichiarare le implementazioni predefinite come metodi di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="5bc12-124">Starting with C# 8.0, you can declare the default implementations as interface methods.</span></span> <span data-ttu-id="5bc12-125">Quindi, ogni classe utilizza automaticamente l'implementazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="5bc12-125">Then, every class automatically uses the default implementation.</span></span> <span data-ttu-id="5bc12-126">Qualsiasi classe che può fornire un'implementazione migliore può eseguire l'override della definizione del metodo di interfaccia con un algoritmo migliore.</span><span class="sxs-lookup"><span data-stu-id="5bc12-126">Any class that can provide a better implementation can override the interface method definition with a better algorithm.</span></span> <span data-ttu-id="5bc12-127">In un certo senso, questa tecnica suona simile a come è possibile utilizzare [i metodi](../programming-guide/classes-and-structs/extension-methods.md)di estensione .</span><span class="sxs-lookup"><span data-stu-id="5bc12-127">In one sense, this technique sounds similar to how you could use [extension methods](../programming-guide/classes-and-structs/extension-methods.md).</span></span>

<span data-ttu-id="5bc12-128">In questo articolo verrà illustrato come le implementazioni predefinite dell'interfaccia consentono nuovi scenari.</span><span class="sxs-lookup"><span data-stu-id="5bc12-128">In this article, you'll learn how default interface implementations enable new scenarios.</span></span>

## <a name="design-the-application"></a><span data-ttu-id="5bc12-129">Progettare l'applicazione</span><span class="sxs-lookup"><span data-stu-id="5bc12-129">Design the application</span></span>

<span data-ttu-id="5bc12-130">Si consideri un'applicazione di domotica.</span><span class="sxs-lookup"><span data-stu-id="5bc12-130">Consider a home automation application.</span></span> <span data-ttu-id="5bc12-131">Probabilmente hai molti tipi diversi di luci e indicatori che potrebbero essere utilizzati in tutta la casa.</span><span class="sxs-lookup"><span data-stu-id="5bc12-131">You probably have many different types of lights and indicators that could be used throughout the house.</span></span> <span data-ttu-id="5bc12-132">Ogni luce deve supportare le API per attivarle e disattivarle e per segnalare lo stato corrente.</span><span class="sxs-lookup"><span data-stu-id="5bc12-132">Every light must support APIs to turn them on and off, and to report the current state.</span></span> <span data-ttu-id="5bc12-133">Alcune luci e indicatori possono supportare altre funzionalità, ad esempio:</span><span class="sxs-lookup"><span data-stu-id="5bc12-133">Some lights and indicators may support other features, such as:</span></span>

- <span data-ttu-id="5bc12-134">Accendere la luce, quindi spegnerla dopo un timer.</span><span class="sxs-lookup"><span data-stu-id="5bc12-134">Turn light on, then turn it off after a timer.</span></span>
- <span data-ttu-id="5bc12-135">Lampeggiare la luce per un certo periodo di tempo.</span><span class="sxs-lookup"><span data-stu-id="5bc12-135">Blink the light for a period of time.</span></span>

<span data-ttu-id="5bc12-136">Alcune di queste funzionalità estese potrebbero essere emulate nei dispositivi che supportano il set minimo.</span><span class="sxs-lookup"><span data-stu-id="5bc12-136">Some of these extended capabilities could be emulated in devices that support the minimal set.</span></span> <span data-ttu-id="5bc12-137">Ciò indica fornire un'implementazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="5bc12-137">That indicates providing a default implementation.</span></span> <span data-ttu-id="5bc12-138">Per i dispositivi con più funzionalità incorporate, il software del dispositivo utilizzerebbe le funzionalità native.</span><span class="sxs-lookup"><span data-stu-id="5bc12-138">For those devices that have more capabilities built in, the device software would use the native capabilities.</span></span> <span data-ttu-id="5bc12-139">Per altre luci, è possibile scegliere di implementare l'interfaccia e utilizzare l'implementazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="5bc12-139">For other lights, they could choose to implement the interface and use the default implementation.</span></span>

<span data-ttu-id="5bc12-140">I membri di interfaccia predefiniti sono una soluzione migliore per questo scenario rispetto ai metodi di estensione.</span><span class="sxs-lookup"><span data-stu-id="5bc12-140">Default interface members is a better solution for this scenario than extension methods.</span></span> <span data-ttu-id="5bc12-141">Gli autori di classi possono controllare quali interfacce scegliere di implementare.</span><span class="sxs-lookup"><span data-stu-id="5bc12-141">Class authors can control which interfaces they choose to implement.</span></span> <span data-ttu-id="5bc12-142">Le interfacce che scelgono sono disponibili come metodi.</span><span class="sxs-lookup"><span data-stu-id="5bc12-142">Those interfaces they choose are available as methods.</span></span> <span data-ttu-id="5bc12-143">Inoltre, poiché i metodi di interfaccia predefiniti sono virtuali per impostazione predefinita, l'invio del metodo sceglie sempre l'implementazione nella classe.</span><span class="sxs-lookup"><span data-stu-id="5bc12-143">In addition, because default interface methods are virtual by default, the method dispatch always chooses the implementation in the class.</span></span>

<span data-ttu-id="5bc12-144">Creiamo il codice per dimostrare queste differenze.</span><span class="sxs-lookup"><span data-stu-id="5bc12-144">Let's create the code to demonstrate these differences.</span></span>

## <a name="create-interfaces"></a><span data-ttu-id="5bc12-145">Creare interfacce</span><span class="sxs-lookup"><span data-stu-id="5bc12-145">Create interfaces</span></span>

<span data-ttu-id="5bc12-146">Iniziare creando l'interfaccia che definisce il comportamento per tutte le luci:</span><span class="sxs-lookup"><span data-stu-id="5bc12-146">Start by creating the interface that defines the behavior for all lights:</span></span>

[!code-csharp[Declare base interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetILightInterfaceV1)]

<span data-ttu-id="5bc12-147">Un dispositivo di illuminazione overhead di base potrebbe implementare questa interfaccia come illustrato nel codice seguente:A basic overhead light fixture might implement this interface as shown in the following code:</span><span class="sxs-lookup"><span data-stu-id="5bc12-147">A basic overhead light fixture might implement this interface as shown in the following code:</span></span>

[!code-csharp[First overhead light](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetOverheadLightV1)]

<span data-ttu-id="5bc12-148">In questa esercitazione il codice non gestisce i dispositivi IoT, ma emula tali attività scrivendo messaggi nella console.</span><span class="sxs-lookup"><span data-stu-id="5bc12-148">In this tutorial, the code doesn't drive IoT devices, but emulates those activities by writing messages to the console.</span></span> <span data-ttu-id="5bc12-149">È possibile esplorare il codice senza automatizzare la vostra casa.</span><span class="sxs-lookup"><span data-stu-id="5bc12-149">You can explore the code without automating your house.</span></span>

<span data-ttu-id="5bc12-150">Successivamente, definiamo l'interfaccia per una luce che può spegnersi automaticamente dopo un timeout:</span><span class="sxs-lookup"><span data-stu-id="5bc12-150">Next, let's define the interface for a light that can automatically turn off after a timeout:</span></span>

[!code-csharp[pure Timer interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetPureTimerInterface)]

<span data-ttu-id="5bc12-151">È possibile aggiungere un'implementazione di base alla luce dell'overhead, `virtual` ma una soluzione migliore consiste nel modificare questa definizione di interfaccia per fornire un'implementazione predefinita:You could add a basic implementation to the overhead light, but a better solution is to modify this interface definition to provide a default implementation:</span><span class="sxs-lookup"><span data-stu-id="5bc12-151">You could add a basic implementation to the overhead light, but a better solution is to modify this interface definition to provide a `virtual` default implementation:</span></span>

[!code-csharp[Timer interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ITimerLight.cs?name=SnippetTimerLightFinal)]

<span data-ttu-id="5bc12-152">Aggiungendo tale modifica, `OverheadLight` la classe può implementare la funzione timer dichiarando il supporto per l'interfaccia:By adding that change, the class can implement the timer function by declaring support for the interface:</span><span class="sxs-lookup"><span data-stu-id="5bc12-152">By adding that change, the `OverheadLight` class can implement the timer function by declaring support for the interface:</span></span>

```csharp
public class OverheadLight : ITimerLight { }
```

<span data-ttu-id="5bc12-153">Un tipo di luce diverso può supportare un protocollo più sofisticato.</span><span class="sxs-lookup"><span data-stu-id="5bc12-153">A different light type may support a more sophisticated protocol.</span></span> <span data-ttu-id="5bc12-154">Può fornire la propria `TurnOnFor`implementazione per , come illustrato nel codice seguente:</span><span class="sxs-lookup"><span data-stu-id="5bc12-154">It can provide its own implementation for `TurnOnFor`, as shown in the following code:</span></span>

[!code-csharp[Override the timer function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/HalogenLight.cs?name=SnippetHalogenLight)]

<span data-ttu-id="5bc12-155">A differenza dell'override `TurnOnFor` `HalogenLight` dei metodi della classe virtuale, la dichiarazione di nella classe non utilizza la `override` parola chiave .</span><span class="sxs-lookup"><span data-stu-id="5bc12-155">Unlike overriding virtual class methods, the declaration of `TurnOnFor` in the `HalogenLight` class does not use the `override` keyword.</span></span>

## <a name="mix-and-match-capabilities"></a><span data-ttu-id="5bc12-156">Funzionalità di miscelare e abbinare</span><span class="sxs-lookup"><span data-stu-id="5bc12-156">Mix and match capabilities</span></span>

<span data-ttu-id="5bc12-157">I vantaggi dei metodi di interfaccia predefiniti diventano più chiari man mano che si introducono funzionalità più avanzate.</span><span class="sxs-lookup"><span data-stu-id="5bc12-157">The advantages of default interface methods become clearer as you introduce more advanced capabilities.</span></span> <span data-ttu-id="5bc12-158">L'utilizzo delle interfacce consente di combinare e abbinare le funzionalità.</span><span class="sxs-lookup"><span data-stu-id="5bc12-158">Using interfaces enables you to mix and match capabilities.</span></span> <span data-ttu-id="5bc12-159">Consente inoltre a ogni autore di classi di scegliere tra l'implementazione predefinita e un'implementazione personalizzata.</span><span class="sxs-lookup"><span data-stu-id="5bc12-159">It also enables each class author to choose between the default implementation and a custom implementation.</span></span> <span data-ttu-id="5bc12-160">Aggiungiamo un'interfaccia con un'implementazione predefinita per una luce lampeggiante:Let's add an interface with a default implementation for a blinking light:</span><span class="sxs-lookup"><span data-stu-id="5bc12-160">Let's add an interface with a default implementation for a blinking light:</span></span>

[!code-csharp[Define the blinking light interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/IBlinkingLight.cs?name=SnippetBlinkingLight)]

<span data-ttu-id="5bc12-161">L'implementazione predefinita consente a qualsiasi luce di lampeggiare.</span><span class="sxs-lookup"><span data-stu-id="5bc12-161">The default implementation enables any light to blink.</span></span> <span data-ttu-id="5bc12-162">La luce dell'overhead può aggiungere funzionalità timer e lampeggiante utilizzando l'implementazione predefinita:The overhead light can add both timer and blink capabilities using the default implementation:</span><span class="sxs-lookup"><span data-stu-id="5bc12-162">The overhead light can add both timer and blink capabilities using the default implementation:</span></span>

[!code-csharp[Use the default blink function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/OverheadLight.cs?name=SnippetOverheadLight)]

<span data-ttu-id="5bc12-163">Un nuovo tipo `LEDLight` di luce, supporta sia la funzione timer che la funzione lampeggiante direttamente.</span><span class="sxs-lookup"><span data-stu-id="5bc12-163">A new light type, the `LEDLight` supports both the timer function and the blink function directly.</span></span> <span data-ttu-id="5bc12-164">Questo stile di `ITimerLight` luce `IBlinkingLight` implementa entrambe le `Blink` interfacce e esegue l'override del metodo:</span><span class="sxs-lookup"><span data-stu-id="5bc12-164">This light style implements both the `ITimerLight` and `IBlinkingLight` interfaces, and overrides the `Blink` method:</span></span>

[!code-csharp[Override the blink function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/LEDLight.cs?name=SnippetLEDLight)]

<span data-ttu-id="5bc12-165">Un `ExtraFancyLight` potrebbe supportare direttamente le funzioni lampeggiante e timer:</span><span class="sxs-lookup"><span data-stu-id="5bc12-165">An `ExtraFancyLight` might support both blink and timer functions directly:</span></span>

[!code-csharp[Override the blink and timer function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ExtraFancyLight.cs?name=SnippetExtraFancyLight)]

<span data-ttu-id="5bc12-166">Il `HalogenLight` creato in precedenza non supporta l'lampeggiamento.</span><span class="sxs-lookup"><span data-stu-id="5bc12-166">The `HalogenLight` you created earlier doesn't support blinking.</span></span> <span data-ttu-id="5bc12-167">Quindi, non aggiungere `IBlinkingLight` l'oggetto all'elenco delle interfacce supportate.</span><span class="sxs-lookup"><span data-stu-id="5bc12-167">So, don't add the `IBlinkingLight` to the list of its supported interfaces.</span></span>

## <a name="detect-the-light-types-using-pattern-matching"></a><span data-ttu-id="5bc12-168">Rilevare i tipi di luce utilizzando criteri di ricerca</span><span class="sxs-lookup"><span data-stu-id="5bc12-168">Detect the light types using pattern matching</span></span>

<span data-ttu-id="5bc12-169">Successivamente, scriviamo del codice di test.</span><span class="sxs-lookup"><span data-stu-id="5bc12-169">Next, let's write some test code.</span></span> <span data-ttu-id="5bc12-170">È possibile utilizzare la funzionalità di [criteri di ricerca](../pattern-matching.md) di C , per determinare le funzionalità di una luce esaminando le interfacce supportate.</span><span class="sxs-lookup"><span data-stu-id="5bc12-170">You can make use of C#'s [pattern matching](../pattern-matching.md) feature to determine a light's capabilities by examining which interfaces it supports.</span></span>  <span data-ttu-id="5bc12-171">Il metodo seguente esercita le funzionalità supportate di ogni luce:</span><span class="sxs-lookup"><span data-stu-id="5bc12-171">The following method exercises the supported capabilities of each light:</span></span>

[!code-csharp[Test a light's capabilities](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/Program.cs?name=SnippetTestLightFunctions)]

<span data-ttu-id="5bc12-172">Il codice seguente `Main` nel metodo crea ogni tipo di luce in sequenza e verifica tale luce:The following code in your method creates each light type in sequence and tests that light:</span><span class="sxs-lookup"><span data-stu-id="5bc12-172">The following code in your `Main` method creates each light type in sequence and tests that light:</span></span>

[!code-csharp[Test a light's capabilities](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/Program.cs?name=SnippetMainMethod)]

## <a name="how-the-compiler-determines-best-implementation"></a><span data-ttu-id="5bc12-173">Come il compilatore determina la migliore implementazione</span><span class="sxs-lookup"><span data-stu-id="5bc12-173">How the compiler determines best implementation</span></span>

<span data-ttu-id="5bc12-174">Questo scenario mostra un'interfaccia di base senza implementazioni.</span><span class="sxs-lookup"><span data-stu-id="5bc12-174">This scenario shows a base interface without any implementations.</span></span> <span data-ttu-id="5bc12-175">L'aggiunta di `ILight` un metodo nell'interfaccia introduce nuove complessità.</span><span class="sxs-lookup"><span data-stu-id="5bc12-175">Adding a method into the `ILight` interface introduces new complexities.</span></span> <span data-ttu-id="5bc12-176">Le regole del linguaggio che regolano i metodi di interfaccia predefiniti riducono al minimo l'effetto sulle classi concrete che implementano più interfacce derivate.</span><span class="sxs-lookup"><span data-stu-id="5bc12-176">The language rules governing default interface methods minimize the effect on the concrete classes that implement multiple derived interfaces.</span></span> <span data-ttu-id="5bc12-177">Cerchiamo di migliorare l'interfaccia originale con un nuovo metodo per mostrare come che cambia il suo utilizzo.</span><span class="sxs-lookup"><span data-stu-id="5bc12-177">Let's enhance the original interface with a new method to show how that changes its use.</span></span> <span data-ttu-id="5bc12-178">Ogni indicatore luminoso può segnalare il suo stato di alimentazione come un valore enumerato:</span><span class="sxs-lookup"><span data-stu-id="5bc12-178">Every indicator light can report its power status as an enumerated value:</span></span>

[!code-csharp[Enumeration for power status](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ILight.cs?name=SnippetPowerStatus)]

<span data-ttu-id="5bc12-179">L'implementazione predefinita non presuppone alimentazione:The default implementation assumes no power:</span><span class="sxs-lookup"><span data-stu-id="5bc12-179">The default implementation assumes no power:</span></span>

[!code-csharp[Report a default power status](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ILight.cs?name=SnippetILightInterface)]

<span data-ttu-id="5bc12-180">Queste modifiche vengono compilate `ExtraFancyLight` correttamente, anche `ILight` se dichiara il `ITimerLight` supporto `IBlinkingLight`per l'interfaccia ed entrambe le interfacce derivate e .</span><span class="sxs-lookup"><span data-stu-id="5bc12-180">These changes compile cleanly, even though the `ExtraFancyLight` declares support for the `ILight` interface and both derived interfaces, `ITimerLight` and `IBlinkingLight`.</span></span> <span data-ttu-id="5bc12-181">C'è solo un'implementazione "più vicina" dichiarata nell'interfaccia. `ILight`</span><span class="sxs-lookup"><span data-stu-id="5bc12-181">There's only one "closest" implementation declared in the `ILight` interface.</span></span> <span data-ttu-id="5bc12-182">Qualsiasi classe che ha dichiarato un override diventerebbe l'implementazione "più vicina".</span><span class="sxs-lookup"><span data-stu-id="5bc12-182">Any class that declared an override would become the one "closest" implementation.</span></span> <span data-ttu-id="5bc12-183">Sono stati illustrati esempi nelle classi precedenti che hanno eseguito l'override dei membri di altre interfacce derivate.</span><span class="sxs-lookup"><span data-stu-id="5bc12-183">You saw examples in the preceding classes that overrode the members of other derived interfaces.</span></span>

<span data-ttu-id="5bc12-184">Evitare di eseguire l'override dello stesso metodo in più interfacce derivate.</span><span class="sxs-lookup"><span data-stu-id="5bc12-184">Avoid overriding the same method in multiple derived interfaces.</span></span> <span data-ttu-id="5bc12-185">In questo modo viene creata una chiamata al metodo ambigua ogni volta che una classe implementa entrambe le interfacce derivate.</span><span class="sxs-lookup"><span data-stu-id="5bc12-185">Doing so creates an ambiguous method call whenever a class implements both derived interfaces.</span></span> <span data-ttu-id="5bc12-186">Il compilatore non è in grado di scegliere un singolo metodo migliore, pertanto genera un errore.</span><span class="sxs-lookup"><span data-stu-id="5bc12-186">The compiler can't pick a single better method so it issues an error.</span></span> <span data-ttu-id="5bc12-187">Ad esempio, se `IBlinkingLight` `ITimerLight` sia il `PowerStatus`e `OverheadLight` implementato un override di , sarà necessario fornire un override più specifico.</span><span class="sxs-lookup"><span data-stu-id="5bc12-187">For example, if both the `IBlinkingLight` and `ITimerLight` implemented an override of `PowerStatus`, the `OverheadLight` would need to provide a more specific override.</span></span> <span data-ttu-id="5bc12-188">In caso contrario, il compilatore non può scegliere tra le implementazioni nelle due interfacce derivate.</span><span class="sxs-lookup"><span data-stu-id="5bc12-188">Otherwise, the compiler can't pick between the implementations in the two derived interfaces.</span></span> <span data-ttu-id="5bc12-189">In genere è possibile evitare questa situazione mantenendo le definizioni di interfaccia piccole e focalizzate su una funzionalità.</span><span class="sxs-lookup"><span data-stu-id="5bc12-189">You can usually avoid this situation by keeping interface definitions small and focused on one feature.</span></span> <span data-ttu-id="5bc12-190">In questo scenario, ogni capacità di una luce è la propria interfaccia; più interfacce vengono ereditate solo dalle classi.</span><span class="sxs-lookup"><span data-stu-id="5bc12-190">In this scenario, each capability of a light is its own interface; multiple interfaces are only inherited by classes.</span></span>

<span data-ttu-id="5bc12-191">In questo esempio viene illustrato uno scenario in cui è possibile definire funzionalità discrete che possono essere mescolate in classi.</span><span class="sxs-lookup"><span data-stu-id="5bc12-191">This sample shows one scenario where you can define discrete features that can be mixed into classes.</span></span> <span data-ttu-id="5bc12-192">Dichiarare qualsiasi set di funzionalità supportate dichiarando quali interfacce supporta una classe.</span><span class="sxs-lookup"><span data-stu-id="5bc12-192">You declare any set of supported functionality by declaring which interfaces a class supports.</span></span> <span data-ttu-id="5bc12-193">L'utilizzo di metodi di interfaccia predefinita virtuali consente alle classi di utilizzare o definire un'implementazione diversa per uno o tutti i metodi di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="5bc12-193">The use of virtual default interface methods enables classes to use or define a different implementation for any or all the interface methods.</span></span> <span data-ttu-id="5bc12-194">Questa funzionalità del linguaggio offre nuovi modi per modellare i sistemi reali che si stanno creando.</span><span class="sxs-lookup"><span data-stu-id="5bc12-194">This language capability provides new ways to model the real-world systems you're building.</span></span> <span data-ttu-id="5bc12-195">I metodi di interfaccia predefiniti forniscono un modo più chiaro per esprimere le classi correlate che possono combinare e abbinare funzionalità diverse utilizzando implementazioni virtuali di tali funzionalità.</span><span class="sxs-lookup"><span data-stu-id="5bc12-195">Default interface methods provide a clearer way to express related classes that may mix and match different features using virtual implementations of those capabilities.</span></span>
