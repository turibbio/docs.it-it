---
title: Generare e usare flussi asincroni
description: Questa esercitazione avanzata Mostra come generare e utilizzare flussi asincroni. I flussi asincroni rappresentano un metodo più naturale per lavorare con sequenze di dati che possono essere generate in modo asincrono.
ms.date: 02/10/2019
ms.technology: csharp-async
ms.custom: mvc
ms.openlocfilehash: fd9fed3469d18c919102640df7bb501b116f5e0e
ms.sourcegitcommit: 9a4488a3625866335e83a20da5e9c5286b1f034c
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 05/15/2020
ms.locfileid: "83420370"
---
# <a name="tutorial-generate-and-consume-async-streams-using-c-80-and-net-core-30"></a><span data-ttu-id="1d818-104">Esercitazione: generare e utilizzare flussi asincroni con C# 8,0 e .NET Core 3,0</span><span class="sxs-lookup"><span data-stu-id="1d818-104">Tutorial: Generate and consume async streams using C# 8.0 and .NET Core 3.0</span></span>

<span data-ttu-id="1d818-105">C# 8,0 introduce **flussi asincroni**, che modellano un'origine di flusso di dati.</span><span class="sxs-lookup"><span data-stu-id="1d818-105">C# 8.0 introduces **async streams**, which model a streaming source of data.</span></span> <span data-ttu-id="1d818-106">I flussi di dati spesso recuperano o generano elementi in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="1d818-106">Data streams often retrieve or generate elements asynchronously.</span></span> <span data-ttu-id="1d818-107">I flussi asincroni si basano sulle nuove interfacce introdotte in .NET Standard 2,1.</span><span class="sxs-lookup"><span data-stu-id="1d818-107">Async streams rely on new interfaces introduced in .NET Standard 2.1.</span></span> <span data-ttu-id="1d818-108">Queste interfacce sono supportate in .NET Core 3,0 e versioni successive.</span><span class="sxs-lookup"><span data-stu-id="1d818-108">These interfaces are supported in .NET Core 3.0 and later.</span></span> <span data-ttu-id="1d818-109">Forniscono un modello di programmazione naturale per le origini dati del flusso asincrono.</span><span class="sxs-lookup"><span data-stu-id="1d818-109">They provide a natural programming model for asynchronous streaming data sources.</span></span>

<span data-ttu-id="1d818-110">In questa esercitazione si apprenderà come:</span><span class="sxs-lookup"><span data-stu-id="1d818-110">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="1d818-111">Creare un'origine dati che genera una sequenza di elementi di dati in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="1d818-111">Create a data source that generates a sequence of data elements asynchronously.</span></span>
> - <span data-ttu-id="1d818-112">Utilizzare tale origine dati in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="1d818-112">Consume that data source asynchronously.</span></span>
> - <span data-ttu-id="1d818-113">Supporta l'annullamento e i contesti acquisiti per i flussi asincroni.</span><span class="sxs-lookup"><span data-stu-id="1d818-113">Support cancellation and captured contexts for asynchronous streams.</span></span>
> - <span data-ttu-id="1d818-114">Riconoscere quando la nuova interfaccia e l'origine dati sono da preferire rispetto alle sequenze di dati sincrone precedenti.</span><span class="sxs-lookup"><span data-stu-id="1d818-114">Recognize when the new interface and data source are preferred to earlier synchronous data sequences.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="1d818-115">Prerequisiti</span><span class="sxs-lookup"><span data-stu-id="1d818-115">Prerequisites</span></span>

<span data-ttu-id="1d818-116">È necessario configurare il computer per l'esecuzione di .NET Core, incluso il compilatore C# 8,0.</span><span class="sxs-lookup"><span data-stu-id="1d818-116">You'll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="1d818-117">Il compilatore C# 8 è disponibile a partire da [Visual Studio 2019 versione 16,3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) o [.NET Core 3,0 SDK](https://dotnet.microsoft.com/download).</span><span class="sxs-lookup"><span data-stu-id="1d818-117">The C# 8 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) or [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download).</span></span>

<span data-ttu-id="1d818-118">È necessario creare un [token di accesso di GitHub](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) per poter accedere all'endpoint GraphQL di GitHub.</span><span class="sxs-lookup"><span data-stu-id="1d818-118">You'll need to create a [GitHub access token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) so that you can access the GitHub GraphQL endpoint.</span></span> <span data-ttu-id="1d818-119">Selezionare le autorizzazioni seguenti per il token di accesso di GitHub:</span><span class="sxs-lookup"><span data-stu-id="1d818-119">Select the following permissions for your GitHub Access Token:</span></span>

- <span data-ttu-id="1d818-120">repo:status</span><span class="sxs-lookup"><span data-stu-id="1d818-120">repo:status</span></span>
- <span data-ttu-id="1d818-121">public_repo</span><span class="sxs-lookup"><span data-stu-id="1d818-121">public_repo</span></span>

<span data-ttu-id="1d818-122">Salvare il token di accesso in un luogo sicuro in modo da poterlo usare per ottenere l'accesso all'endpoint dell'API GitHub.</span><span class="sxs-lookup"><span data-stu-id="1d818-122">Save the access token in a safe place so you can use it to gain access to the GitHub API endpoint.</span></span>

> [!WARNING]
> <span data-ttu-id="1d818-123">Mantenere protetto il token di accesso personale.</span><span class="sxs-lookup"><span data-stu-id="1d818-123">Keep your personal access token secure.</span></span> <span data-ttu-id="1d818-124">Qualsiasi software con il token di accesso personale può effettuare chiamate API GitHub tramite i diritti di accesso.</span><span class="sxs-lookup"><span data-stu-id="1d818-124">Any software with your personal access token could make GitHub API calls using your access rights.</span></span>

<span data-ttu-id="1d818-125">Per questa esercitazione si presuppone che l'utente abbia familiarità con C# e .NET, inclusa l'interfaccia della riga di comando di .NET Core o Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="1d818-125">This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.</span></span>

## <a name="run-the-starter-application"></a><span data-ttu-id="1d818-126">Eseguire l'applicazione iniziale</span><span class="sxs-lookup"><span data-stu-id="1d818-126">Run the starter application</span></span>

<span data-ttu-id="1d818-127">È possibile ottenere il codice per l'applicazione iniziale usata in questa esercitazione dal repository [DotNet/docs](https://github.com/dotnet/docs) nella cartella [CSharp/Tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/docs/csharp/tutorials/snippets/generate-consume-asynchronous-streams/start) .</span><span class="sxs-lookup"><span data-stu-id="1d818-127">You can get the code for the starter application used in this tutorial from the [dotnet/docs](https://github.com/dotnet/docs) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/docs/csharp/tutorials/snippets/generate-consume-asynchronous-streams/start) folder.</span></span>

<span data-ttu-id="1d818-128">L'applicazione iniziale è un'applicazione console che usa l'interfaccia [GraphQL di GitHub](https://developer.github.com/v4/) per recuperare i problemi recenti scritti nel repository [dotnet/docs](https://github.com/dotnet/docs).</span><span class="sxs-lookup"><span data-stu-id="1d818-128">The starter application is a console application that uses the [GitHub GraphQL](https://developer.github.com/v4/) interface to retrieve recent issues written in the [dotnet/docs](https://github.com/dotnet/docs) repository.</span></span> <span data-ttu-id="1d818-129">Per iniziare, esaminare il codice seguente per il metodo `Main` dell'app iniziale:</span><span class="sxs-lookup"><span data-stu-id="1d818-129">Start by looking at the following code for the starter app `Main` method:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetStarterAppMain" :::

<span data-ttu-id="1d818-130">È possibile impostare una variabile di ambiente `GitHubKey` per il token di accesso personale oppure è possibile sostituire l'ultimo argomento nella chiamata a `GenEnvVariable` con il token di accesso personale.</span><span class="sxs-lookup"><span data-stu-id="1d818-130">You can either set a `GitHubKey` environment variable to your personal access token, or you can replace the last argument in the call to `GenEnvVariable` with your personal access token.</span></span> <span data-ttu-id="1d818-131">Non inserire il codice di accesso nel codice sorgente se si condividerà l'origine con altri utenti.</span><span class="sxs-lookup"><span data-stu-id="1d818-131">Don't put your access code in source code if you'll be sharing the source with others.</span></span> <span data-ttu-id="1d818-132">Non caricare mai i codici di accesso in un repository di origine condivisa.</span><span class="sxs-lookup"><span data-stu-id="1d818-132">Never upload access codes to a shared source repository.</span></span>

<span data-ttu-id="1d818-133">Dopo aver creato il client di GitHub, il codice in `Main` crea un oggetto di segnalazione dello stato e un token di annullamento.</span><span class="sxs-lookup"><span data-stu-id="1d818-133">After creating the GitHub client, the code in `Main` creates a progress reporting object and a cancellation token.</span></span> <span data-ttu-id="1d818-134">Dopo aver creato questi oggetti, `Main` chiama `runPagedQueryAsync` per recuperare i 250 problemi creati più di recente.</span><span class="sxs-lookup"><span data-stu-id="1d818-134">Once those objects are created, `Main` calls `runPagedQueryAsync` to retrieve the most recent 250 created issues.</span></span> <span data-ttu-id="1d818-135">Al termine di tale attività, vengono visualizzati i risultati.</span><span class="sxs-lookup"><span data-stu-id="1d818-135">After that task has finished, the results are displayed.</span></span>

<span data-ttu-id="1d818-136">Quando si esegue l'applicazione iniziale, è possibile notare alcuni aspetti importanti della modalità di esecuzione di questa applicazione.</span><span class="sxs-lookup"><span data-stu-id="1d818-136">When you run the starter application, you can make some important observations about how this application runs.</span></span>  <span data-ttu-id="1d818-137">Lo stato viene segnalato per ogni pagina restituita da GitHub.</span><span class="sxs-lookup"><span data-stu-id="1d818-137">You'll see progress reported for each page returned from GitHub.</span></span> <span data-ttu-id="1d818-138">È possibile notare una notevole pausa prima che GitHub restituisca ogni nuova pagina di problemi.</span><span class="sxs-lookup"><span data-stu-id="1d818-138">You can observe a noticeable pause before GitHub returns each new page of issues.</span></span> <span data-ttu-id="1d818-139">Infine, i problemi vengono visualizzati solo dopo aver recuperato tutte e 10 le pagine da GitHub.</span><span class="sxs-lookup"><span data-stu-id="1d818-139">Finally, the issues are displayed only after all 10 pages have been retrieved from GitHub.</span></span>

## <a name="examine-the-implementation"></a><span data-ttu-id="1d818-140">Esaminare l'implementazione</span><span class="sxs-lookup"><span data-stu-id="1d818-140">Examine the implementation</span></span>

<span data-ttu-id="1d818-141">L'implementazione spiega il comportamento evidenziato nella sezione precedente.</span><span class="sxs-lookup"><span data-stu-id="1d818-141">The implementation reveals why you observed the behavior discussed in the previous section.</span></span> <span data-ttu-id="1d818-142">Esaminare il codice per `runPagedQueryAsync`:</span><span class="sxs-lookup"><span data-stu-id="1d818-142">Examine the code for `runPagedQueryAsync`:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetRunPagedQuery" :::

<span data-ttu-id="1d818-143">Concentrarsi sull'algoritmo per la suddivisione in pagine e sulla struttura asincrona del codice precedente.</span><span class="sxs-lookup"><span data-stu-id="1d818-143">Let's concentrate on the paging algorithm and async structure of the preceding code.</span></span> <span data-ttu-id="1d818-144">È possibile consultare la [documentazione di GitHub GraphQL](https://developer.github.com/v4/guides/) per informazioni dettagliate sull'API GraphQL di GitHub. Il `runPagedQueryAsync` metodo enumera i problemi dalla più recente alla meno recente.</span><span class="sxs-lookup"><span data-stu-id="1d818-144">(You can consult the [GitHub GraphQL documentation](https://developer.github.com/v4/guides/) for details on the GitHub GraphQL API.) The `runPagedQueryAsync` method enumerates the issues from most recent to oldest.</span></span> <span data-ttu-id="1d818-145">Richiede 25 problemi per ogni pagina ed esamina la struttura `pageInfo` della risposta per continuare con la pagina precedente.</span><span class="sxs-lookup"><span data-stu-id="1d818-145">It requests 25 issues per page and examines the `pageInfo` structure of the response to continue with the previous page.</span></span> <span data-ttu-id="1d818-146">Viene rispettato il supporto della suddivisione in pagine standard di GraphQL per le risposte a più pagine.</span><span class="sxs-lookup"><span data-stu-id="1d818-146">That follows GraphQL's standard paging support for multi-page responses.</span></span> <span data-ttu-id="1d818-147">La risposta include un oggetto `pageInfo` che include un valore `hasPreviousPages` e un valore `startCursor` usato per richiedere la pagina precedente.</span><span class="sxs-lookup"><span data-stu-id="1d818-147">The response includes a `pageInfo` object that includes a `hasPreviousPages` value and a `startCursor` value used to request the previous page.</span></span> <span data-ttu-id="1d818-148">I problemi sono nella matrice `nodes`.</span><span class="sxs-lookup"><span data-stu-id="1d818-148">The issues are in the `nodes` array.</span></span> <span data-ttu-id="1d818-149">Il metodo `runPagedQueryAsync` aggiunge questi nodi in una matrice che contiene tutti i risultati da tutte le pagine.</span><span class="sxs-lookup"><span data-stu-id="1d818-149">The `runPagedQueryAsync` method appends these nodes to an array that contains all the results from all pages.</span></span>

<span data-ttu-id="1d818-150">Dopo il recupero e il ripristino di una pagina di risultati, `runPagedQueryAsync` segnala lo stato e verifica se è presente una richiesta di annullamento.</span><span class="sxs-lookup"><span data-stu-id="1d818-150">After retrieving and restoring a page of results, `runPagedQueryAsync` reports progress and checks for cancellation.</span></span> <span data-ttu-id="1d818-151">In caso affermativo, `runPagedQueryAsync` genera un'eccezione <xref:System.OperationCanceledException>.</span><span class="sxs-lookup"><span data-stu-id="1d818-151">If cancellation has been requested, `runPagedQueryAsync` throws an <xref:System.OperationCanceledException>.</span></span>

<span data-ttu-id="1d818-152">Esistono diversi elementi in questo codice che possono essere migliorati.</span><span class="sxs-lookup"><span data-stu-id="1d818-152">There are several elements in this code that can be improved.</span></span> <span data-ttu-id="1d818-153">Soprattutto, `runPagedQueryAsync` deve allocare spazio di archiviazione per tutti i problemi restituiti.</span><span class="sxs-lookup"><span data-stu-id="1d818-153">Most importantly, `runPagedQueryAsync` must allocate storage for all the issues returned.</span></span> <span data-ttu-id="1d818-154">Questo esempio si arresta dopo 250 problemi, perché il recupero di tutti i problemi richiede molta più memoria per archiviare tutti i problemi recuperati.</span><span class="sxs-lookup"><span data-stu-id="1d818-154">This sample stops at 250 issues because retrieving all open issues would require much more memory to store all the retrieved issues.</span></span> <span data-ttu-id="1d818-155">I protocolli per supportare i report sullo stato di avanzamento e l'annullamento rendono più difficile la comprensione dell'algoritmo durante la prima lettura.</span><span class="sxs-lookup"><span data-stu-id="1d818-155">The protocols for supporting progress reports and cancellation make the algorithm harder to understand on its first reading.</span></span> <span data-ttu-id="1d818-156">Sono necessari più tipi e API.</span><span class="sxs-lookup"><span data-stu-id="1d818-156">More types and APIs are involved.</span></span> <span data-ttu-id="1d818-157">È necessario tenere traccia delle comunicazioni tramite <xref:System.Threading.CancellationTokenSource> e il relativo oggetto associato <xref:System.Threading.CancellationToken> per comprendere dove viene richiesto l'annullamento e dove viene concesso.</span><span class="sxs-lookup"><span data-stu-id="1d818-157">You must trace the communications through the <xref:System.Threading.CancellationTokenSource> and its associated <xref:System.Threading.CancellationToken> to understand where cancellation is requested and where it's granted.</span></span>

## <a name="async-streams-provide-a-better-way"></a><span data-ttu-id="1d818-158">I flussi asincroni sono più efficaci</span><span class="sxs-lookup"><span data-stu-id="1d818-158">Async streams provide a better way</span></span>

<span data-ttu-id="1d818-159">I flussi asincroni e il supporto del linguaggio associato offrono una risposta a tutte queste problematiche.</span><span class="sxs-lookup"><span data-stu-id="1d818-159">Async streams and the associated language support address all those concerns.</span></span> <span data-ttu-id="1d818-160">Il codice che genera la sequenza può ora usare `yield return` per restituire gli elementi in un metodo dichiarato con il modificatore `async`.</span><span class="sxs-lookup"><span data-stu-id="1d818-160">The code that generates the sequence can now use `yield return` to return elements in a method that was declared with the `async` modifier.</span></span> <span data-ttu-id="1d818-161">È possibile utilizzare un flusso asincrono con un ciclo `await foreach`, proprio come si utilizza qualsiasi sequenza con un ciclo `foreach`.</span><span class="sxs-lookup"><span data-stu-id="1d818-161">You can consume an async stream using an `await foreach` loop just as you consume any sequence using a `foreach` loop.</span></span>

<span data-ttu-id="1d818-162">Queste nuove funzionalità del linguaggio dipendono da tre nuove interfacce aggiunte a .NET 2.1 Standard e implementate in .NET Core 3.0:</span><span class="sxs-lookup"><span data-stu-id="1d818-162">These new language features depend on three new interfaces added to .NET Standard 2.1 and implemented in .NET Core 3.0:</span></span>

- <xref:System.Collections.Generic.IAsyncEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IAsyncEnumerator%601?displayProperty=nameWithType>
- <xref:System.IAsyncDisposable?displayProperty=nameWithType>

<span data-ttu-id="1d818-163">Queste tre interfacce dovrebbero risultare familiari alla maggior parte degli sviluppatori C#.</span><span class="sxs-lookup"><span data-stu-id="1d818-163">These three interfaces should be familiar to most C# developers.</span></span> <span data-ttu-id="1d818-164">Il comportamento è simile a quello delle relative controparti sincrone:</span><span class="sxs-lookup"><span data-stu-id="1d818-164">They behave in a manner similar to their synchronous counterparts:</span></span>

- <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IEnumerator%601?displayProperty=nameWithType>
- <xref:System.IDisposable?displayProperty=nameWithType>

<span data-ttu-id="1d818-165">Un tipo che potrebbe essere poco noto è <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1d818-165">One type that may be unfamiliar is <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1d818-166">Lo struct `ValueTask` fornisce un'API simile alla classe <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1d818-166">The `ValueTask` struct provides a similar API to the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="1d818-167">`ValueTask` viene usato in queste interfacce per motivi di prestazioni.</span><span class="sxs-lookup"><span data-stu-id="1d818-167">`ValueTask` is used in these interfaces for performance reasons.</span></span>

## <a name="convert-to-async-streams"></a><span data-ttu-id="1d818-168">Convertire in flussi asincroni</span><span class="sxs-lookup"><span data-stu-id="1d818-168">Convert to async streams</span></span>

<span data-ttu-id="1d818-169">A questo punto, il metodo `runPagedQueryAsync` verrà convertito per generare un flusso asincrono.</span><span class="sxs-lookup"><span data-stu-id="1d818-169">Next, convert the `runPagedQueryAsync` method to generate an async stream.</span></span> <span data-ttu-id="1d818-170">In primo luogo, modificare la firma di `runPagedQueryAsync` per restituire `IAsyncEnumerable<JToken>` e rimuovere il token di annullamento e gli oggetti di stato dall'elenco di parametri, come illustrato nel codice seguente:</span><span class="sxs-lookup"><span data-stu-id="1d818-170">First, change the signature of `runPagedQueryAsync` to return an `IAsyncEnumerable<JToken>`, and remove the cancellation token and progress objects from the parameter list as shown in the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetUpdateSignature" :::

<span data-ttu-id="1d818-171">Il codice iniziale elabora ogni pagina quando viene recuperata, come illustrato nel codice seguente:</span><span class="sxs-lookup"><span data-stu-id="1d818-171">The starter code processes each page as the page is retrieved, as shown in the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetProcessPage" :::

<span data-ttu-id="1d818-172">Sostituire queste tre righe con il codice seguente:</span><span class="sxs-lookup"><span data-stu-id="1d818-172">Replace those three lines with the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetYieldReturnPage" :::

<span data-ttu-id="1d818-173">È anche possibile rimuovere la dichiarazione di `finalResults` più indietro in questo metodo e l'istruzione `return` che segue il ciclo modificato.</span><span class="sxs-lookup"><span data-stu-id="1d818-173">You can also remove the declaration of `finalResults` earlier in this method and the `return` statement that follows the loop you modified.</span></span>

<span data-ttu-id="1d818-174">Sono state completate le modifiche per generare un flusso asincrono.</span><span class="sxs-lookup"><span data-stu-id="1d818-174">You've finished the changes to generate an async stream.</span></span> <span data-ttu-id="1d818-175">Il metodo finito dovrebbe essere simile al codice seguente:</span><span class="sxs-lookup"><span data-stu-id="1d818-175">The finished method should resemble the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetGenerateAsyncStream" :::

<span data-ttu-id="1d818-176">Verrà ora modificato il codice che utilizza la raccolta per utilizzare il flusso asincrono.</span><span class="sxs-lookup"><span data-stu-id="1d818-176">Next, you change the code that consumes the collection to consume the async stream.</span></span> <span data-ttu-id="1d818-177">Trovare il codice seguente in `Main` che elabora la raccolta dei problemi:</span><span class="sxs-lookup"><span data-stu-id="1d818-177">Find the following code in `Main` that processes the collection of issues:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetEnumerateOldStyle" :::

<span data-ttu-id="1d818-178">Sostituire il codice con il ciclo `await foreach` seguente:</span><span class="sxs-lookup"><span data-stu-id="1d818-178">Replace that code with the following `await foreach` loop:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetEnumerateAsyncStream" :::

<span data-ttu-id="1d818-179">La nuova interfaccia <xref:System.Collections.Generic.IAsyncEnumerator%601> deriva da <xref:System.IAsyncDisposable> .</span><span class="sxs-lookup"><span data-stu-id="1d818-179">The new interface <xref:System.Collections.Generic.IAsyncEnumerator%601> derives from <xref:System.IAsyncDisposable>.</span></span> <span data-ttu-id="1d818-180">Ciò significa che il ciclo precedente eliminerà in modo asincrono il flusso al termine del ciclo.</span><span class="sxs-lookup"><span data-stu-id="1d818-180">That means the preceding loop will asynchronously dispose the stream when the loop finishes.</span></span> <span data-ttu-id="1d818-181">Si supponga che il ciclo appaia come il codice seguente:</span><span class="sxs-lookup"><span data-stu-id="1d818-181">You can imagine the loop looks like the following code:</span></span>

```csharp
int num = 0;
var enumerator = runPagedQueryAsync(client, PagedIssueQuery, "docs").GetEnumeratorAsync();
try
{
    while (await enumerator.MoveNextAsync())
    {
        var issue = enumerator.Current;
        Console.WriteLine(issue);
        Console.WriteLine($"Received {++num} issues in total");
    }
} finally
{
    if (enumerator != null)
        await enumerator.DisposeAsync();
}
```

<span data-ttu-id="1d818-182">Per impostazione predefinita, gli elementi del flusso vengono elaborati nel contesto acquisito.</span><span class="sxs-lookup"><span data-stu-id="1d818-182">By default, stream elements are processed in the captured context.</span></span> <span data-ttu-id="1d818-183">Se si desidera disabilitare l'acquisizione del contesto, utilizzare il <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType> metodo di estensione.</span><span class="sxs-lookup"><span data-stu-id="1d818-183">If you want to disable capturing of the context, use the <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType> extension method.</span></span> <span data-ttu-id="1d818-184">Per ulteriori informazioni sui contesti di sincronizzazione e sull'acquisizione del contesto corrente, vedere l'articolo sull' [utilizzo del modello asincrono basato su attività](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="1d818-184">For more information about synchronization contexts and capturing the current context, see the article on [consuming the Task-based asynchronous pattern](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>

<span data-ttu-id="1d818-185">I flussi asincroni supportano l'annullamento utilizzando lo stesso protocollo di altri `async` metodi.</span><span class="sxs-lookup"><span data-stu-id="1d818-185">Async streams support cancellation using the same protocol as other `async` methods.</span></span> <span data-ttu-id="1d818-186">Per supportare l'annullamento, modificare la firma per il metodo iteratore asincrono come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="1d818-186">You would modify the signature for the async iterator method as follows to support cancellation:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetGenerateWithCancellation" :::

<span data-ttu-id="1d818-187">L' <xref:System.Runtime.CompilerServices.EnumeratorCancellationAttribute?dipslayProperty=nameWithType> attributo induce il compilatore a generare il codice per il <xref:System.Collections.Generic.IAsyncEnumerator%601> che rende il token passato a `GetAsyncEnumerator` Visible al corpo dell'iteratore asincrono come tale argomento.</span><span class="sxs-lookup"><span data-stu-id="1d818-187">The <xref:System.Runtime.CompilerServices.EnumeratorCancellationAttribute?dipslayProperty=nameWithType> attribute causes the compiler to generate code for the <xref:System.Collections.Generic.IAsyncEnumerator%601> that makes the token passed to `GetAsyncEnumerator` visible to the body of the async iterator as that argument.</span></span> <span data-ttu-id="1d818-188">All'interno `runQueryAsync` di, è possibile esaminare lo stato del token e annullare ulteriori operazioni, se richiesto.</span><span class="sxs-lookup"><span data-stu-id="1d818-188">Inside `runQueryAsync`, you could examine the state of the token and cancel further work if requested.</span></span>

<span data-ttu-id="1d818-189">Usare un altro metodo di estensione, <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.WithCancellation%2A> , per passare il token di annullamento al flusso asincrono.</span><span class="sxs-lookup"><span data-stu-id="1d818-189">You use another extension method, <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.WithCancellation%2A>, to pass the cancellation token to the async stream.</span></span> <span data-ttu-id="1d818-190">Modificare il ciclo enumerando i problemi come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="1d818-190">You would modify the loop enumerating the issues as follows:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetEnumerateWithCancellation" :::

<span data-ttu-id="1d818-191">È possibile ottenere il codice per l'esercitazione completata dal repository [DotNet/docs](https://github.com/dotnet/docs) nella cartella [CSharp/Tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/docs/csharp/tutorials/snippets/generate-consume-asynchronous-streams/finished) .</span><span class="sxs-lookup"><span data-stu-id="1d818-191">You can get the code for the finished tutorial from the [dotnet/docs](https://github.com/dotnet/docs) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/docs/csharp/tutorials/snippets/generate-consume-asynchronous-streams/finished) folder.</span></span>

## <a name="run-the-finished-application"></a><span data-ttu-id="1d818-192">Eseguire l'applicazione completata</span><span class="sxs-lookup"><span data-stu-id="1d818-192">Run the finished application</span></span>

<span data-ttu-id="1d818-193">Eseguire di nuovo l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="1d818-193">Run the application again.</span></span> <span data-ttu-id="1d818-194">Confrontare il comportamento con il comportamento dell'applicazione iniziale.</span><span class="sxs-lookup"><span data-stu-id="1d818-194">Contrast its behavior with the behavior of the starter application.</span></span> <span data-ttu-id="1d818-195">La prima pagina di risultati viene enumerata non appena è disponibile.</span><span class="sxs-lookup"><span data-stu-id="1d818-195">The first page of results is enumerated as soon as it's available.</span></span> <span data-ttu-id="1d818-196">Esiste una pausa osservabile quando viene richiesta e recuperata ogni nuova pagina, poi i risultati della pagina successiva vengono enumerati rapidamente.</span><span class="sxs-lookup"><span data-stu-id="1d818-196">There's an observable pause as each new page is requested and retrieved, then the next page's results are quickly enumerated.</span></span> <span data-ttu-id="1d818-197">Il blocco `try` / `catch` non è necessario per gestire l'annullamento: il chiamante può interrompere l'enumerazione della raccolta.</span><span class="sxs-lookup"><span data-stu-id="1d818-197">The `try` / `catch` block isn't needed to handle cancellation: the caller can stop enumerating the collection.</span></span> <span data-ttu-id="1d818-198">Lo stato viene segnalato in modo chiaro perché il flusso asincrono genera i risultati quando viene scaricata ogni pagina.</span><span class="sxs-lookup"><span data-stu-id="1d818-198">Progress is clearly reported because the async stream generates results as each page is downloaded.</span></span> <span data-ttu-id="1d818-199">Lo stato di ogni problema restituito è facilmente incluso nel `await foreach` ciclo.</span><span class="sxs-lookup"><span data-stu-id="1d818-199">The status for each issue returned is seamlessly included in the `await foreach` loop.</span></span> <span data-ttu-id="1d818-200">Non è necessario un oggetto callback per tenere traccia dello stato di avanzamento.</span><span class="sxs-lookup"><span data-stu-id="1d818-200">You don't need a callback object to track progress.</span></span>

<span data-ttu-id="1d818-201">È possibile notare miglioramenti per l'uso della memoria esaminando il codice.</span><span class="sxs-lookup"><span data-stu-id="1d818-201">You can see improvements in memory use by examining the code.</span></span> <span data-ttu-id="1d818-202">Non è più necessario allocare una raccolta per archiviare tutti i risultati prima che vengano enumerati.</span><span class="sxs-lookup"><span data-stu-id="1d818-202">You no longer need to allocate a collection to store all the results before they're enumerated.</span></span> <span data-ttu-id="1d818-203">Il chiamante può determinare come utilizzare i risultati e se è necessaria una raccolta di archiviazione.</span><span class="sxs-lookup"><span data-stu-id="1d818-203">The caller can determine how to consume the results and if a storage collection is needed.</span></span>

<span data-ttu-id="1d818-204">Eseguire sia l'applicazione iniziale che quella finita per osservare in autonomia le differenze tra le implementazioni.</span><span class="sxs-lookup"><span data-stu-id="1d818-204">Run both the starter and finished applications and you can observe the differences between the implementations for yourself.</span></span> <span data-ttu-id="1d818-205">Al termine, è possibile eliminare il token di accesso di GitHub creato all'inizio di questa esercitazione.</span><span class="sxs-lookup"><span data-stu-id="1d818-205">You can delete the GitHub access token you created when you started this tutorial after you've finished.</span></span> <span data-ttu-id="1d818-206">Se un utente malintenzionato riesce ad accedere al token, potrebbe ottenere l'accesso alle a API di GitHub usando le credenziali.</span><span class="sxs-lookup"><span data-stu-id="1d818-206">If an attacker gained access to that token, they could access GitHub APIs using your credentials.</span></span>
