### YamlMime:Tutorial
title: Esplorare C# 6- C# Interactive - Esercitazione su C#
metadata:
  title: 'Esplorare C# 6: provare le nuove funzionalità in C# 6 in modo interattivo, usando il browser'
  description: In questa esercitazione si userà il browser per esplorare C# 6 in modo interattivo. Si esamineranno i nuovi che è possibile usare con C# 6 che rendono il codice più conciso e leggibile.
  audience: Developer
  level: intermediate
  ms.date: 12/11/2018
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: 6a1662c3ef4acdde19d6833a797768f45c723aca
  ms.sourcegitcommit: f87ad41b8e62622da126aa928f7640108c4eff98
  ms.translationtype: MT
  ms.contentlocale: it-IT
  ms.lasthandoff: 04/07/2020
  ms.locfileid: "80805894"
items:
- durationInMinutes: 1
  content: >
    Questa esercitazione consente di esplorare C# 6 in modo interattivo, usando il browser per scrivere codice C# e visualizzare i risultati della compilazione e dell'esecuzione del codice. L'esercitazione contiene una serie di lezioni che modificano le procedure C# precedenti, in modo da usare le nuove funzionalità, più concise, del linguaggio C# 6. Il resto di questo articolo offre una panoramica di ognuna di queste funzionalità, con un collegamento per esplorare ciascuna di esse più in dettaglio.
- title: Abilitazione dei tipi di sola lettura tramite le proprietà automatiche
  durationInMinutes: 2
  content: "Due miglioramenti alla sintassi delle proprietà automatiche rendono più semplice l'uso di tali proprietà in più punti all'interno del codice: le proprietà automatiche di sola lettura e gli inizializzatori di proprietà automatiche. Si consideri questo piccolo programma:\n\n[!code-csharp[Starter](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-starter/Program.cs)]  \n\n    \n Attivare la modalità focale e copiare il codice precedente nella finestra interattiva C#. Selezionare *quindi Esegui* per visualizzare le operazioni eseguite dal codice. `AllCaps` ha l'effetto indesiderato di modificare i valori della proprietà e di restituire la stringa in caratteri maiuscoli. L'autore della classe `Person` voleva che le stringhe `FirstName` e `LastName` fossero di sola lettura. Con C# 6 è possibile rendere chiara tale finalità. Rimuovere `private set` da entrambe le proprietà per creare una proprietà automatica di sola lettura. Selezionare *Esegui* per verificare che il `FirstName` `LastName` compilatore individua le due posizioni in cui le proprietà e vengono modificate quando non avrebbero dovuto essere. È possibile modificare il metodo `AllCaps` come indicato nel codice seguente per correggere l'errore del compilatore:\n\n```csharp\npublic string AllCaps()\n{\n  return ToString().ToUpper();\n}\n```\n\nUsando questa nuova sintassi, il compilatore assicura che le proprietà non siano modificabili.\n"
- title: Inizializzare campi sottostanti per le proprietà automatiche
  durationInMinutes: 1
  content: "La nuova sintassi del linguaggio C# 6 consente di usare inizializzatori per le proprietà automatiche. Questa funzione diventa più importante man mano che le classi sviluppano nuove funzionalità. Aggiungere alla classe `Person` una proprietà MiddleName e un nuovo costruttore che accetta tre stringhe:\n\n[!code-csharp[MiddleName](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-finished/Program.cs#MiddleName)]  \n\nL'assegnazione alla proprietà `MiddleName` è un inizializzatore che inizializza il campo sottostante generato dal compilatore per il secondo nome.\n"
- title: Membri con corpo di espressione
  durationInMinutes: 2
  content: >
    I membri con corpo di espressione offrono una sintassi leggera per metodi leggeri. La classe `Person` contiene due ottimi candidati per tale funzione. Esaminare la dichiarazione di `ToString`:


    ```csharp

    public override string ToString()

    {
        return FirstName + " " + LastName;
    }

    ```


    Sostituire la dichiarazione di `ToString` con il codice seguente:


    ```csharp

    public override string ToString() => FirstName + " " + LastName;

    ```


    Provare la stessa operazione con il metodo `AllCaps`. Si tratta di un piccolo miglioramento, ma quando viene usato con criterio consente di creare codice molto più leggibile, soprattutto per gli oggetti DTO (Data Transfer Object) e per altri tipi con comportamento minimo.
- title: Importazione di una classe singola
  durationInMinutes: 2
  content: "Se in tutto il codice si usano più volte metodi statici di una classe indicando ogni volta il nome della classe, il codice diventa di difficile comprensione. La classe `Person` attualmente importa lo spazio dei nomi `System`, anche se viene usato solo il metodo <xref:System.Console?displayProperty=nameWithType>. Modificare l'istruzione `using` come segue:\n\n[!code-csharp[MiddleName](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-finished/Program.cs#UsingStatic)]  \n\nL'istruzione `static using` diventa più utile nei programmi più grandi che fanno ampio [`string`](xref:System.String) uso <xref:System.Math?displayProperty=nameWithType> di una singola classe con molti metodi statici, come la classe o la classe.\n"
- title: Formato stringa più efficiente
  durationInMinutes: 2
  content: "C# 6 contiene una nuova sintassi per la composizione di stringhe da una stringa e di espressioni incorporate che vengono valutate per produrre altri valori stringa. È possibile modificare i metodi `ToString` e `AllCaps` in modo da usare la sintassi seguente:\n\n[!code-csharp[StringInterpolation](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-finished/Program.cs#StringInterpolation)]  \n\nAnziché argomenti posizionali, tra `{` e `}` si scrivono direttamente espressioni C#. È possibile eseguire la stessa operazione per il metodo `Main`. Sostituire il codice esistente con quello seguente:\n\n[!code-csharp[InterpolationMain](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-finished/Program.cs#InterpolationMain)]  \n\nIn queste espressioni è possibile includere più variabili. Si inizierà modificando un nuovo esempio per illustrare altre espressioni utilizzabili con l'interpolazione di stringhe. Incollare il codice seguente nella finestra interattiva nel metodo `Main`:\n\n[!code-csharp[Phrases](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-finished/Program.cs#Phrases)]  \nChe utilizza LINQ, quindi è necessario aggiungere la seguente istruzione using all'inizio della finestra interattiva:\n\n```csharp\nusing System.Linq;\n```\n\nÈ possibile rimuovere la variabile locale `average` ed eseguire il calcolo nell'ambito dell'espressione stringa interpolata. Sostituire le ultime due righe con il codice seguente:\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average()}\");\n```\n\nEseguendo l'esempio precedente si può vedere che l'output per `Average` ha più posizioni decimali del necessario. La sintassi di interpolazione delle stringhe supporta tutte le stringhe di formato disponibili usando i metodi di formattazione precedenti. Specificare la stringa di formato tra parentesi graffe. Aggiungere `:` dopo l'espressione da formattare:\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average():F2}\");\n```\n"
- title: Controlli Null semplici e rapidi
  durationInMinutes: 2
  content: "L'operatore `?.` (operatore condizionale Null) rende più semplice scrivere logica che tenga conto dei valori `null` in modo trasparente, senza controlli `if` aggiuntivi. Per esplorare questa funzionalità, iniziare copiando il codice seguente nella finestra interattiva e provarlo:\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n      string s = null;\n      Console.WriteLine(s.Length);\n    }\n}\n```\n\nQuando si esegue l'esempio, viene generata un'eccezione <xref:System.NullReferenceException>. Sostituire l'operatore di accesso ai membri `.` con l'**operatore condizionale Null**:\n\n```csharp\nConsole.WriteLine(s?.Length);\n``` \n\nDopo questa modifica, non si ottiene alcun output, perché il risultato di `s?.Length` è `int?`, mentre il risultato di `s.Length` è `int`. In this example, l'evento `s?.Length` è `null`. `?.` restituisce `null` se l'operando sinistro è `null`. L'operatore `?.` restituisce un tipo nullable per tale tipo, sia per i tipi di valore che per i tipi di riferimento non nullable. Oltre a `?.`, per l'accesso a una matrice o a un indicizzatore è possibile usare `?[]`. Provare il codice seguente nella finestra interattiva:\n\n ```csharp\n char? c = s?[0];\n Console.WriteLine(c.HasValue);\n ```\n\n È possibile combinare più operatori condizionali in un'unica espressione. Un operando sinistro `null` genera un risultato `null`, rendendo più semplice evitare clausole if annidate per accedere a membri di membri. Provare ad esempio il codice seguente nella finestra interattiva:\n\n ```csharp\n string s = null;\n bool? hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext();\n Console.WriteLine(hasMore.HasValue);\n ```\n\n È possibile semplificare l'esempio precedente usando l'**operatore di unione Null** per specificare un valore predefinito:\n\n ```csharp\n bool hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext() ?? false;\n Console.WriteLine(hasMore);\n ```\n\n L'**operatore condizionale Null** rende più semplice scrivere codice con una logica di base chiara eseguendo nello stesso tempo il test dei valori `null`.\n"
- title: Filtri eccezioni
  durationInMinutes: 2
  content: "I filtri eccezioni consentono di intercettare un'eccezione in base a una condizione. Un uso tipico consiste nel creare un metodo di filtro che registra le eccezioni ma non le gestisce mai. Un filtro eccezioni è un'espressione booleana il cui valore è `true` quando la clausola `catch` deve essere eseguita e `false` quando l'eccezione non deve essere intercettata dalla clausola `catch`. Provare il codice seguente nella finestra interattiva: registra il tipo di eccezione e il messaggio nella console. Restituisce `false`, che indica che l'eccezione non può essere gestita. Provare il programma nella finestra interattiva.\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        try \n        {\n            string s = null;\n            Console.WriteLine(s.Length);\n\n        } catch (Exception e) when (LogException(e))\n        {\n        }\n        Console.WriteLine(\"Exception must have been handled\");\n    }\n\n    private static bool LogException(Exception e)\n    {\n        Console.WriteLine($\"\\tIn the log routine. Caught {e.GetType()}\");\n        Console.WriteLine($\"\\tMessage: {e.Message}\");\n        return false;\n    }\n}\n```\n\nDovrebbe essere visualizzato il messaggio dal metodo `LogException`, seguito dal messaggio di eccezione predefinito. A titolo di esperimento, modificare l'istruzione `return false` in `return true` e rieseguirla. L'eccezione viene ora intercettata e il programma viene eseguito fino al completamento.\n\nOltre che negli scenari di registrazione, i filtri eccezioni possono essere particolarmente utili quando l'azione da intraprendere viene determinata da una proprietà dell'eccezione. È ad esempio possibile esaminare in dettaglio l'eccezione <xref:System.AggregateException> per vedere quali sono le eccezioni al suo interno ed eseguire un'azione appropriata a seconda dell'eccezione.\n"
- title: Uso di nameof
  durationInMinutes: 2
  content: "L'operatore `nameof` restituisce il nome di una variabile, di un tipo o del membro di un tipo. Per vedere come funziona, provare il codice seguente nella finestra interattiva:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Console.WriteLine(nameof(System.String));\n        int j = 5;\n        Console.WriteLine(nameof(j));\n        List<string> names = new List<string>();\n        Console.WriteLine(nameof(names));\n    }\n}\n```\n\nL'output corrisponde al nome della variabile o del tipo. Anche se si specifica il nome completo del tipo (ad esempio `System.String`) l'operatore `nameof` restituisce il nome non qualificato. Questa funzionalità è particolarmente utile quando è necessario convertire il nome di un parametro o di una proprietà in una stringa, ad esempio quando si acquisisce il nome di un argomento per la generazione di un'eccezione <xref:System.ArgumentNullException> o <xref:System.ArgumentException>, o quando si acquisisce il nome di una proprietà modificata durante l'implementazione di <xref:System.ComponentModel.INotifyPropertyChanged>. \n"
- title: Nuova sintassi di inizializzazione degli oggetti
  durationInMinutes: 2
  content: "La sintassi dell'inizializzatore di oggetto supporta ora l'inizializzazione di *indicizzatori* e di proprietà e campi. Questa novità consente di inizializzare dizionari e altri tipi in modo più semplice. Iniziare con un dizionario. Eseguire il codice seguente nella finestra interattiva:\n\n```csharp\nvar messages = new Dictionary<int, string>\n{\n    [404] = \"Page not Found\",\n    [302] = \"Page moved, but left a forwarding address.\",\n    [500] = \"The web server can't come out to play today.\"\n};\n\nConsole.WriteLine(messages[302]);\n```\n\nQuesta sintassi, che imposta un valore in un indicizzatore, può essere usata per qualsiasi tipo con funzione di accesso set accessibile in un indicizzatore.\n\nUna seconda modifica rende più semplice abilitare la sintassi dell'inizializzatore per i tipi che rappresentano le sequenze. È possibile usare gli inizializzatori di insieme in qualsiasi classe che implementa <xref:System.Collections.IEnumerable> e ha un metodo `Add` accessibile pubblicamente. Il metodo `Add` può ora essere anche un metodo di estensione. \n\nL'esempio seguente illustra uno scenario per questa sintassi. Viene creata una classe `Path` che implementa `IEnumerable<Point3D>` e ha un metodo per aggiungere punti che accettano tre argomenti. La classe `Extensions` crea un altro metodo `Add` per aggiungere un nuovo punto dai relativi tre componenti. Questo esempio non viene attualmente eseguito in modo interattivo a causa delle limitazioni nell'ambiente.\n\n```csharp\npublic class Path : IEnumerable<Point3D>\n{\n    private List<Point3D> points = new List<Point3D>();\n    public IEnumerator<Point3D> GetEnumerator() => points.GetEnumerator();\n    IEnumerator IEnumerable.GetEnumerator() => points.GetEnumerator();\n\n    public void Add(Point3D pt) => points.Add(pt);\n}\n\npublic static class Extensions\n{\n    public static void Add(this Path path, double x, double y, double z) => path.Add(new Point3D(x, y, z));\n}\n```\n"
- content: L'esplorazione delle nuove funzionalità del linguaggio C# 6 è stata completata. È ora possibile provare tali funzionalità autonomamente nelle proprie applicazioni.
