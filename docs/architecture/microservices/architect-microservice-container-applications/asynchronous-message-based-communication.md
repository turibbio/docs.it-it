---
title: Comunicazione asincrona basata su messaggi
description: Architettura di microservizi .NET per applicazioni .NET in contenitori | La comunicazione asincrona basata su messaggi è un concetto essenziale nell'architettura dei microservizi, perché è il modo migliore per mantenere i microservizi al contempo indipendenti uno dall'altro e sincronizzati.
ms.date: 09/20/2018
ms.openlocfilehash: 476e42ccb39374c2bb50f22e41f60c10c563dc66
ms.sourcegitcommit: ee5b798427f81237a3c23d1fd81fff7fdc21e8d3
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 05/28/2020
ms.locfileid: "84144344"
---
# <a name="asynchronous-message-based-communication"></a><span data-ttu-id="a49ef-103">Comunicazione asincrona basata su messaggi</span><span class="sxs-lookup"><span data-stu-id="a49ef-103">Asynchronous message-based communication</span></span>

<span data-ttu-id="a49ef-104">La messaggistica asincrona e la comunicazione basata su eventi sono fondamentali per la propagazione delle modifiche tra più microservizi e i modelli di dominio correlati.</span><span class="sxs-lookup"><span data-stu-id="a49ef-104">Asynchronous messaging and event-driven communication are critical when propagating changes across multiple microservices and their related domain models.</span></span> <span data-ttu-id="a49ef-105">Come accennato in precedenza nella sezione relativa a microservizi e contesti delimitati, i modelli (utente, cliente, prodotto, account e così via) possono avere diversi significati per differenti microservizi o contesti delimitati.</span><span class="sxs-lookup"><span data-stu-id="a49ef-105">As mentioned earlier in the discussion microservices and Bounded Contexts (BCs), models (User, Customer, Product, Account, etc.) can mean different things to different microservices or BCs.</span></span> <span data-ttu-id="a49ef-106">Ciò significa che, quando si verificano modifiche, è necessario un sistema per riconciliare le modifiche tra i diversi modelli.</span><span class="sxs-lookup"><span data-stu-id="a49ef-106">That means that when changes occur, you need some way to reconcile changes across the different models.</span></span> <span data-ttu-id="a49ef-107">Una soluzione è coerenza finale e la comunicazione basata su eventi in base alla messaggistica asincrona.</span><span class="sxs-lookup"><span data-stu-id="a49ef-107">A solution is eventual consistency and event-driven communication based on asynchronous messaging.</span></span>

<span data-ttu-id="a49ef-108">Quando si utilizza la messaggistica, i processi comunicano mediante lo scambio di messaggi in modalità asincrona.</span><span class="sxs-lookup"><span data-stu-id="a49ef-108">When using messaging, processes communicate by exchanging messages asynchronously.</span></span> <span data-ttu-id="a49ef-109">Un client esegue un comando o una richiesta a un servizio mediante l'invio di un messaggio al servizio.</span><span class="sxs-lookup"><span data-stu-id="a49ef-109">A client makes a command or a request to a service by sending it a message.</span></span> <span data-ttu-id="a49ef-110">Se il servizio deve rispondere, invia un messaggio diverso al client.</span><span class="sxs-lookup"><span data-stu-id="a49ef-110">If the service needs to reply, it sends a different message back to the client.</span></span> <span data-ttu-id="a49ef-111">Poiché si tratta di una comunicazione basata su messaggi, il client presuppone che la risposta non verrà ricevuta immediatamente e che potrebbe non essere ricevuta alcuna risposta.</span><span class="sxs-lookup"><span data-stu-id="a49ef-111">Since it's a message-based communication, the client assumes that the reply won't be received immediately, and that there might be no response at all.</span></span>

<span data-ttu-id="a49ef-112">Un messaggio è composto da un'intestazione (metadati come informazioni di identificazione o di sicurezza) e un corpo.</span><span class="sxs-lookup"><span data-stu-id="a49ef-112">A message is composed by a header (metadata such as identification or security information) and a body.</span></span> <span data-ttu-id="a49ef-113">I messaggi in genere vengono inviati tramite protocolli asincroni come AMQP.</span><span class="sxs-lookup"><span data-stu-id="a49ef-113">Messages are usually sent through asynchronous protocols like AMQP.</span></span>

<span data-ttu-id="a49ef-114">L'infrastruttura preferita per questo tipo di comunicazione nella community dei microservizi è un broker di messaggi leggero, diverso dai broker e dagli agenti di orchestrazione di grandi dimensioni usati in SOA.</span><span class="sxs-lookup"><span data-stu-id="a49ef-114">The preferred infrastructure for this type of communication in the microservices community is a lightweight message broker, which is different than the large brokers and orchestrators used in SOA.</span></span> <span data-ttu-id="a49ef-115">In un broker di messaggi leggero, l'infrastruttura in genere opera solo come un broker di messaggi, con implementazioni semplici come RabbitMQ o un bus di servizio scalabile nel cloud come il bus di servizio di Azure.</span><span class="sxs-lookup"><span data-stu-id="a49ef-115">In a lightweight message broker, the infrastructure is typically "dumb," acting only as a message broker, with simple implementations such as RabbitMQ or a scalable service bus in the cloud like Azure Service Bus.</span></span> <span data-ttu-id="a49ef-116">In questo scenario la maggior parte dell'elaborazione "intelligente" viene eseguita negli endpoint che producono e usano i messaggi, ovvero nei microservizi.</span><span class="sxs-lookup"><span data-stu-id="a49ef-116">In this scenario, most of the "smart" thinking still lives in the endpoints that are producing and consuming messages-that is, in the microservices.</span></span>

<span data-ttu-id="a49ef-117">Un'altra regola che è consigliabile provare a seguire il più possibile consiste nell'usare solo la messaggistica asincrona tra i servizi interni e impiegare la comunicazione sincrona (ad esempio, HTTP) solo dalle app client ai servizi front-end (gateway API e il primo livello di microservizi).</span><span class="sxs-lookup"><span data-stu-id="a49ef-117">Another rule you should try to follow, as much as possible, is to use only asynchronous messaging between the internal services, and to use synchronous communication (such as HTTP) only from the client apps to the front-end services (API Gateways plus the first level of microservices).</span></span>

<span data-ttu-id="a49ef-118">Esistono due tipi di comunicazione per la messaggistica asincrona: comunicazione basata su messaggi con singolo destinatario e comunicazione basata su messaggi con più destinatari.</span><span class="sxs-lookup"><span data-stu-id="a49ef-118">There are two kinds of asynchronous messaging communication: single receiver message-based communication, and multiple receivers message-based communication.</span></span> <span data-ttu-id="a49ef-119">Nelle sezioni seguenti vengono offerte informazioni dettagliate in proposito.</span><span class="sxs-lookup"><span data-stu-id="a49ef-119">The following sections provide details about them.</span></span>

## <a name="single-receiver-message-based-communication"></a><span data-ttu-id="a49ef-120">Comunicazione basata su messaggi con singolo destinatario</span><span class="sxs-lookup"><span data-stu-id="a49ef-120">Single-receiver message-based communication</span></span>

<span data-ttu-id="a49ef-121">La comunicazione basata su messaggi con singolo destinatario implica che sia presente una comunicazione punto a punto che recapita un messaggio a uno e uno solo dei consumer che eseguono la lettura del canale e che il messaggio venga elaborato una sola volta.</span><span class="sxs-lookup"><span data-stu-id="a49ef-121">Message-based asynchronous communication with a single receiver means there's point-to-point communication that delivers a message to exactly one of the consumers that's reading from the channel, and that the message is processed just once.</span></span> <span data-ttu-id="a49ef-122">Esistono tuttavia casi speciali.</span><span class="sxs-lookup"><span data-stu-id="a49ef-122">However, there are special situations.</span></span> <span data-ttu-id="a49ef-123">Ad esempio, in un sistema cloud che tenta di eseguire automaticamente il ripristino dagli errori, lo stesso messaggio potrebbe essere inviato più volte.</span><span class="sxs-lookup"><span data-stu-id="a49ef-123">For instance, in a cloud system that tries to automatically recover from failures, the same message could be sent multiple times.</span></span> <span data-ttu-id="a49ef-124">A causa di problemi di rete o altri errori, il client deve essere in grado di ripetere l'invio dei messaggi e il server deve implementare un'operazione idempotente, in modo da elaborare un particolare messaggio una sola volta.</span><span class="sxs-lookup"><span data-stu-id="a49ef-124">Due to network or other failures, the client has to be able to retry sending messages, and the server has to implement an operation to be idempotent in order to process a particular message just once.</span></span>

<span data-ttu-id="a49ef-125">La comunicazione basata su messaggi con singolo destinatario è particolarmente adatta per l'invio di comandi asincroni da un microservizio all'altro, come mostrato nella figura 4-18 che illustra questo approccio.</span><span class="sxs-lookup"><span data-stu-id="a49ef-125">Single-receiver message-based communication is especially well suited for sending asynchronous commands from one microservice to another as shown in Figure 4-18 that illustrates this approach.</span></span>

<span data-ttu-id="a49ef-126">Una volta che si iniziano a inviare comunicazioni basate su messaggi (con comandi o eventi), è consigliabile evitare di combinare la comunicazione basata su messaggi con la comunicazione HTTP sincrona.</span><span class="sxs-lookup"><span data-stu-id="a49ef-126">Once you start sending message-based communication (either with commands or events), you should avoid mixing message-based communication with synchronous HTTP communication.</span></span>

![Un singolo microservizio che riceve un messaggio asincrono](./media/asynchronous-message-based-communication/single-receiver-message-based-communication.png)

<span data-ttu-id="a49ef-128">**Figura 4-18**.</span><span class="sxs-lookup"><span data-stu-id="a49ef-128">**Figure 4-18**.</span></span> <span data-ttu-id="a49ef-129">Un singolo microservizio che riceve un messaggio asincrono</span><span class="sxs-lookup"><span data-stu-id="a49ef-129">A single microservice receiving an asynchronous message</span></span>

<span data-ttu-id="a49ef-130">Si noti che quando i comandi provengono da applicazioni client, possono essere implementati come comandi sincroni HTTP.</span><span class="sxs-lookup"><span data-stu-id="a49ef-130">Note that when the commands come from client applications, they can be implemented as HTTP synchronous commands.</span></span> <span data-ttu-id="a49ef-131">Usare comandi basati su messaggi quando è necessaria una maggiore scalabilità o quando si è già in un processo aziendale basato su messaggi.</span><span class="sxs-lookup"><span data-stu-id="a49ef-131">You should use message-based commands when you need higher scalability or when you're already in a message-based business process.</span></span>

## <a name="multiple-receivers-message-based-communication"></a><span data-ttu-id="a49ef-132">Comunicazione basata su messaggi con più destinatari</span><span class="sxs-lookup"><span data-stu-id="a49ef-132">Multiple-receivers message-based communication</span></span>

<span data-ttu-id="a49ef-133">Come approccio più flessibile, è anche possibile usare un meccanismo di pubblicazione/sottoscrizione, in modo da rendere disponibile la comunicazione dal mittente per microservizi sottoscrittori aggiuntivi o applicazioni esterne.</span><span class="sxs-lookup"><span data-stu-id="a49ef-133">As a more flexible approach, you might also want to use a publish/subscribe mechanism so that your communication from the sender will be available to additional subscriber microservices or to external applications.</span></span> <span data-ttu-id="a49ef-134">Questo pertanto consente di seguire il [principio aperto/chiuso](https://en.wikipedia.org/wiki/Open/closed_principle) nel servizio di invio.</span><span class="sxs-lookup"><span data-stu-id="a49ef-134">Thus, it helps you to follow the [open/closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) in the sending service.</span></span> <span data-ttu-id="a49ef-135">In questo modo, sarà possibile aggiungere ulteriori sottoscrittori in futuro senza dover modificare il servizio del mittente.</span><span class="sxs-lookup"><span data-stu-id="a49ef-135">That way, additional subscribers can be added in the future without the need to modify the sender service.</span></span>

<span data-ttu-id="a49ef-136">Quando si usa una comunicazione basata su pubblicazione/sottoscrizione, è possibile usare un'interfaccia di bus di eventi per pubblicare gli eventi per qualsiasi sottoscrittore.</span><span class="sxs-lookup"><span data-stu-id="a49ef-136">When you use a publish/subscribe communication, you might be using an event bus interface to publish events to any subscriber.</span></span>

## <a name="asynchronous-event-driven-communication"></a><span data-ttu-id="a49ef-137">Comunicazione asincrona basata su eventi</span><span class="sxs-lookup"><span data-stu-id="a49ef-137">Asynchronous event-driven communication</span></span>

<span data-ttu-id="a49ef-138">Quando si usa la comunicazione asincrona basata su eventi, un microservizio pubblica un evento di integrazione quando accade qualcosa all'interno del proprio dominio e un altro microservizio deve rilevare tale evento, ad esempio una variazione di prezzo in un microservizio per un catalogo prodotti.</span><span class="sxs-lookup"><span data-stu-id="a49ef-138">When using asynchronous event-driven communication, a microservice publishes an integration event when something happens within its domain and another microservice needs to be aware of it, like a price change in a product catalog microservice.</span></span> <span data-ttu-id="a49ef-139">Ulteriori microservizi eseguono la sottoscrizione agli eventi in modo da poterli ricevere in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="a49ef-139">Additional microservices subscribe to the events so they can receive them asynchronously.</span></span> <span data-ttu-id="a49ef-140">In questo caso, i destinatari potrebbero aggiornare le proprie entità di dominio, causando la pubblicazione di altri eventi di integrazione.</span><span class="sxs-lookup"><span data-stu-id="a49ef-140">When that happens, the receivers might update their own domain entities, which can cause more integration events to be published.</span></span> <span data-ttu-id="a49ef-141">Questo sistema di pubblicazione/sottoscrizione viene in genere eseguito usando un'implementazione di un bus di eventi.</span><span class="sxs-lookup"><span data-stu-id="a49ef-141">This publish/subscribe system is usually performed by using an implementation of an event bus.</span></span> <span data-ttu-id="a49ef-142">Il bus di eventi può essere progettato come un'astrazione o un'interfaccia, con l'API necessaria per sottoscrivere o annullare la sottoscrizione a eventi e per pubblicare eventi.</span><span class="sxs-lookup"><span data-stu-id="a49ef-142">The event bus can be designed as an abstraction or interface, with the API that's needed to subscribe or unsubscribe to events and to publish events.</span></span> <span data-ttu-id="a49ef-143">Il bus di eventi può anche avere uno o più implementazioni basate su qualsiasi broker tra processi e di messaggistica, ad esempio una coda di messaggi o un bus di servizio che supporta la comunicazione asincrona e un modello di pubblicazione/sottoscrizione.</span><span class="sxs-lookup"><span data-stu-id="a49ef-143">The event bus can also have one or more implementations based on any inter-process and messaging broker, like a messaging queue or service bus that supports asynchronous communication and a publish/subscribe model.</span></span>

<span data-ttu-id="a49ef-144">Se un sistema usa la coerenza finale definita dagli eventi di integrazione, è consigliabile rendere questo approccio completamente chiaro per l'utente finale.</span><span class="sxs-lookup"><span data-stu-id="a49ef-144">If a system uses eventual consistency driven by integration events, it's recommended that this approach is made completely clear to the end user.</span></span> <span data-ttu-id="a49ef-145">Il sistema non deve usare un approccio che simula gli eventi di integrazione, come ad esempio SignalR o il polling dei sistemi dal client.</span><span class="sxs-lookup"><span data-stu-id="a49ef-145">The system shouldn't use an approach that mimics integration events, like SignalR or polling systems from the client.</span></span> <span data-ttu-id="a49ef-146">L'utente finale e il titolare dell'azienda devono prevedere esplicitamente la coerenza finale nel sistema e tenere presente che in molti casi l'azienda non ha alcun problema con questo approccio, purché venga esplicitato.</span><span class="sxs-lookup"><span data-stu-id="a49ef-146">The end user and the business owner have to explicitly embrace eventual consistency in the system and realize that in many cases the business doesn't have any problem with this approach, as long as it's explicit.</span></span> <span data-ttu-id="a49ef-147">Questo è importante perché gli utenti potrebbero aspettarsi di visualizzare alcuni risultati immediatamente e ciò potrebbe non avvenire con la coerenza finale.</span><span class="sxs-lookup"><span data-stu-id="a49ef-147">This is important because users might expect to see some results immediately and this might not happen with eventual consistency.</span></span>

<span data-ttu-id="a49ef-148">Come accennato in precedenza nella sezione [Problemi e soluzioni per la gestione dei dati distribuiti](distributed-data-management.md), è possibile usare gli eventi di integrazione per implementare attività aziendali che interessano più microservizi.</span><span class="sxs-lookup"><span data-stu-id="a49ef-148">As noted earlier in the [Challenges and solutions for distributed data management](distributed-data-management.md) section, you can use integration events to implement business tasks that span multiple microservices.</span></span> <span data-ttu-id="a49ef-149">In questo modo, si otterrà la coerenza finale tra tali servizi.</span><span class="sxs-lookup"><span data-stu-id="a49ef-149">Thus, you'll have eventual consistency between those services.</span></span> <span data-ttu-id="a49ef-150">Una transazione con coerenza finale è costituita da un insieme di azioni distribuite.</span><span class="sxs-lookup"><span data-stu-id="a49ef-150">An eventually consistent transaction is made up of a collection of distributed actions.</span></span> <span data-ttu-id="a49ef-151">A ogni azione, il microservizio correlato aggiorna un'entità di dominio e pubblica un altro evento di integrazione che genera l'azione successiva all'interno della stessa attività aziendale end-to-end.</span><span class="sxs-lookup"><span data-stu-id="a49ef-151">At each action, the related microservice updates a domain entity and publishes another integration event that raises the next action within the same end-to-end business task.</span></span>

<span data-ttu-id="a49ef-152">Un aspetto importante è che potrebbe essere necessario comunicare con più microservizi sottoscritti allo stesso evento.</span><span class="sxs-lookup"><span data-stu-id="a49ef-152">An important point is that you might want to communicate to multiple microservices that are subscribed to the same event.</span></span> <span data-ttu-id="a49ef-153">A tale scopo, è possibile usare la messaggistica con pubblicazione/sottoscrizione in base alla comunicazione basata su eventi, come illustrato nella figura 4-19.</span><span class="sxs-lookup"><span data-stu-id="a49ef-153">To do so, you can use publish/subscribe messaging based on event-driven communication, as shown in Figure 4-19.</span></span> <span data-ttu-id="a49ef-154">Questo meccanismo di pubblicazione/sottoscrizione non è esclusivo per l'architettura dei microservizi.</span><span class="sxs-lookup"><span data-stu-id="a49ef-154">This publish/subscribe mechanism isn't exclusive to the microservice architecture.</span></span> <span data-ttu-id="a49ef-155">È simile al modo in cui devono comunicare i [contesti delimitati](https://martinfowler.com/bliki/BoundedContext.html) in DDD o al modo in cui si propagano gli aggiornamenti dal database di scrittura al database di lettura nello schema di architettura [separazione di responsabilità per query e comandi (CQRS, Command and Query Responsibility Segregation)](https://martinfowler.com/bliki/CQRS.html).</span><span class="sxs-lookup"><span data-stu-id="a49ef-155">It's similar to the way [Bounded Contexts](https://martinfowler.com/bliki/BoundedContext.html) in DDD should communicate, or to the way you propagate updates from the write database to the read database in the [Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) architecture pattern.</span></span> <span data-ttu-id="a49ef-156">L'obiettivo è ottenere la coerenza finale tra più origini dati in tutto il sistema distribuito.</span><span class="sxs-lookup"><span data-stu-id="a49ef-156">The goal is to have eventual consistency between multiple data sources across your distributed system.</span></span>

![Diagramma che mostra le comunicazioni asincrone basate su eventi.](./media/asynchronous-message-based-communication/asynchronous-event-driven-communication.png)

<span data-ttu-id="a49ef-158">**Figura 4-19**.</span><span class="sxs-lookup"><span data-stu-id="a49ef-158">**Figure 4-19**.</span></span> <span data-ttu-id="a49ef-159">Comunicazione di messaggi asincrona basata su eventi</span><span class="sxs-lookup"><span data-stu-id="a49ef-159">Asynchronous event-driven message communication</span></span>

<span data-ttu-id="a49ef-160">Nella comunicazione asincrona basata su evento un microservizio pubblica eventi in un bus di eventi a cui più microservizi possono eseguire la sottoscrizione per ricevere notifiche ed eseguire operazioni.</span><span class="sxs-lookup"><span data-stu-id="a49ef-160">In asynchronous event-driven communication one microservice publishes events to an event bus and many microservices can subscribe to it, to get notified and act on it.</span></span> <span data-ttu-id="a49ef-161">L'implementazione determina il protocollo da usare per le comunicazioni di messaggi basate su eventi.</span><span class="sxs-lookup"><span data-stu-id="a49ef-161">Your implementation will determine what protocol to use for event-driven, message-based communications.</span></span> <span data-ttu-id="a49ef-162">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) può consentire di realizzare comunicazioni in coda affidabili.</span><span class="sxs-lookup"><span data-stu-id="a49ef-162">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) can help achieve reliable queued communication.</span></span>

<span data-ttu-id="a49ef-163">Quando si usa un bus di eventi, è possibile usare un livello di astrazione (ad esempio, un'interfaccia di bus di eventi) basato su un'implementazione correlata nelle classi con codice che usa l'API da un broker di messaggi come [RabbitMQ](https://www.rabbitmq.com/) o un bus di servizio come il [bus di servizio di Azure con argomenti](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span><span class="sxs-lookup"><span data-stu-id="a49ef-163">When you use an event bus, you might want to use an abstraction level (like an event bus interface) based on a related implementation in classes with code using the API from a message broker like [RabbitMQ](https://www.rabbitmq.com/) or a service bus like [Azure Service Bus with Topics](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="a49ef-164">In alternativa, è possibile usare un bus di servizio di livello superiore come NServiceBus, MassTransit o Brighter per articolare il bus di eventi e il sistema di pubblicazione/sottoscrizione.</span><span class="sxs-lookup"><span data-stu-id="a49ef-164">Alternatively, you might want to use a higher-level service bus like NServiceBus, MassTransit, or Brighter to articulate your event bus and publish/subscribe system.</span></span>

## <a name="a-note-about-messaging-technologies-for-production-systems"></a><span data-ttu-id="a49ef-165">Nota sulle tecnologie di messaggistica per i sistemi di produzione</span><span class="sxs-lookup"><span data-stu-id="a49ef-165">A note about messaging technologies for production systems</span></span>

<span data-ttu-id="a49ef-166">Le tecnologie di messaggistica disponibili per l'implementazione del bus di eventi astratto sono a livelli diversi.</span><span class="sxs-lookup"><span data-stu-id="a49ef-166">The messaging technologies available for implementing your abstract event bus are at different levels.</span></span> <span data-ttu-id="a49ef-167">Ad esempio, prodotti come RabbitMQ (un trasporto di broker di messaggi) e il bus di servizio di Azure sono a un livello inferiore rispetto ad altri prodotti come NServiceBus, MassTransit o Brighter, che possono essere usati in aggiunta a RabbitMQ e al bus di servizio di Azure.</span><span class="sxs-lookup"><span data-stu-id="a49ef-167">For instance, products like RabbitMQ (a messaging broker transport) and Azure Service Bus sit at a lower level than other products like, NServiceBus, MassTransit, or Brighter, which can work on top of RabbitMQ and Azure Service Bus.</span></span> <span data-ttu-id="a49ef-168">La scelta dipende dal numero di funzionalità a livello di applicazione e dalla quantità di scalabilità predefinita necessaria per l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a49ef-168">Your choice depends on how many rich features at the application level and out-of-the-box scalability you need for your application.</span></span> <span data-ttu-id="a49ef-169">Per implementare solo un modello di prova del bus di eventi per l'ambiente di sviluppo, come nell'esempio eShopOnContainers, potrebbe essere sufficiente una semplice implementazione su RabbitMQ eseguito in un contenitore Docker.</span><span class="sxs-lookup"><span data-stu-id="a49ef-169">For implementing just a proof-of-concept event bus for your development environment, as it was done in the eShopOnContainers sample, a simple implementation on top of RabbitMQ running on a Docker container might be enough.</span></span>

<span data-ttu-id="a49ef-170">Tuttavia, per i sistemi di produzione e mission-critical che necessitano di una scalabilità molto elevata, può essere opportuno valutare il bus di servizio di Azure.</span><span class="sxs-lookup"><span data-stu-id="a49ef-170">However, for mission-critical and production systems that need hyper-scalability, you might want to evaluate Azure Service Bus.</span></span> <span data-ttu-id="a49ef-171">Per astrazioni e funzionalità di alto livello che semplificano lo sviluppo di applicazioni distribuite, è consigliabile valutare altri bus di servizio commerciali e open source, come NServiceBus, MassTransit e Brighter.</span><span class="sxs-lookup"><span data-stu-id="a49ef-171">For high-level abstractions and features that make the development of distributed applications easier, we recommend that you evaluate other commercial and open-source service buses, such as NServiceBus, MassTransit, and Brighter.</span></span> <span data-ttu-id="a49ef-172">Naturalmente, è possibile creare funzionalità personalizzate per il bus di servizio su tecnologie di livello inferiore come RabbitMQ e Docker.</span><span class="sxs-lookup"><span data-stu-id="a49ef-172">Of course, you can build your own service-bus features on top of lower-level technologies like RabbitMQ and Docker.</span></span> <span data-ttu-id="a49ef-173">Un'attività tanto complessa potrebbe tuttavia avere dei costi troppo elevati per un'applicazione aziendale personalizzata.</span><span class="sxs-lookup"><span data-stu-id="a49ef-173">But that plumbing work might cost too much for a custom enterprise application.</span></span>

## <a name="resiliently-publishing-to-the-event-bus"></a><span data-ttu-id="a49ef-174">Pubblicazione resiliente per il bus di eventi</span><span class="sxs-lookup"><span data-stu-id="a49ef-174">Resiliently publishing to the event bus</span></span>

<span data-ttu-id="a49ef-175">Un problema durante l'implementazione di un'architettura basata su eventi per più microservizi è come aggiornare in modo atomico lo stato nel microservizio originale, pubblicando al tempo stesso in modo resiliente l'evento di integrazione correlato nel bus di eventi, in qualche modo basato sulle transazioni.</span><span class="sxs-lookup"><span data-stu-id="a49ef-175">A challenge when implementing an event-driven architecture across multiple microservices is how to atomically update state in the original microservice while resiliently publishing its related integration event into the event bus, somehow based on transactions.</span></span> <span data-ttu-id="a49ef-176">Ecco alcuni modi per eseguire questa operazione, anche se potrebbero essere adottati anche altri approcci.</span><span class="sxs-lookup"><span data-stu-id="a49ef-176">The following are a few ways to accomplish this, although there could be additional approaches as well.</span></span>

- <span data-ttu-id="a49ef-177">Uso di una coda transazionale (basata su DTC) come MSMQ.</span><span class="sxs-lookup"><span data-stu-id="a49ef-177">Using a transactional (DTC-based) queue like MSMQ.</span></span> <span data-ttu-id="a49ef-178">Questo, tuttavia, è un approccio di tipo legacy.</span><span class="sxs-lookup"><span data-stu-id="a49ef-178">(However, this is a legacy approach.)</span></span>

- <span data-ttu-id="a49ef-179">Uso dell'[estrazione del log delle transazioni](https://www.scoop.it/t/sql-server-transaction-log-mining).</span><span class="sxs-lookup"><span data-stu-id="a49ef-179">Using [transaction log mining](https://www.scoop.it/t/sql-server-transaction-log-mining).</span></span>

- <span data-ttu-id="a49ef-180">Uso dello schema [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing) completo.</span><span class="sxs-lookup"><span data-stu-id="a49ef-180">Using full [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing) pattern.</span></span>

- <span data-ttu-id="a49ef-181">Uso dello [schema Outbox](https://www.kamilgrzybek.com/design/the-outbox-pattern/): una tabella di database transazionale come una coda di messaggi che sarà la base per un componente per la creazione di eventi, che crea l'evento e lo pubblica.</span><span class="sxs-lookup"><span data-stu-id="a49ef-181">Using the [Outbox pattern](https://www.kamilgrzybek.com/design/the-outbox-pattern/): a transactional database table as a message queue that will be the base for an event-creator component that would create the event and publish it.</span></span>

<span data-ttu-id="a49ef-182">Altri aspetti da considerare quando si usa la comunicazione asincrona sono l'idempotenza dei messaggi e la deduplicazione dei messaggi.</span><span class="sxs-lookup"><span data-stu-id="a49ef-182">Additional topics to consider when using asynchronous communication are message idempotence and message deduplication.</span></span> <span data-ttu-id="a49ef-183">Questi argomenti sono trattati nella sezione [Implementazione della comunicazione basata su eventi tra microservizi (eventi di integrazione)](../multi-container-microservice-net-applications/integration-event-based-microservice-communications.md) più avanti in questa guida.</span><span class="sxs-lookup"><span data-stu-id="a49ef-183">These topics are covered in the section [Implementing event-based communication between microservices (integration events)](../multi-container-microservice-net-applications/integration-event-based-microservice-communications.md) later in this guide.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="a49ef-184">Risorse aggiuntive</span><span class="sxs-lookup"><span data-stu-id="a49ef-184">Additional resources</span></span>

- <span data-ttu-id="a49ef-185">**Messaggistica basata su eventi** </span><span class="sxs-lookup"><span data-stu-id="a49ef-185">**Event Driven Messaging** </span></span>\
  <https://soapatterns.org/design_patterns/event_driven_messaging>

- <span data-ttu-id="a49ef-186">**Canale di pubblicazione/sottoscrizione** </span><span class="sxs-lookup"><span data-stu-id="a49ef-186">**Publish/Subscribe Channel** </span></span>\
  <https://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html>

- <span data-ttu-id="a49ef-187">**UDI. CQRS chiarificato** </span><span class="sxs-lookup"><span data-stu-id="a49ef-187">**Udi Dahan. Clarified CQRS** </span></span>\
  <https://udidahan.com/2009/12/09/clarified-cqrs/>

- <span data-ttu-id="a49ef-188">**Separazione di responsabilità per query e comandi (CQRS)** </span><span class="sxs-lookup"><span data-stu-id="a49ef-188">**Command and Query Responsibility Segregation (CQRS)** </span></span>\
  <https://docs.microsoft.com/azure/architecture/patterns/cqrs>

- <span data-ttu-id="a49ef-189">**Comunicazione tra contesti delimitati** </span><span class="sxs-lookup"><span data-stu-id="a49ef-189">**Communicating Between Bounded Contexts** </span></span>\
  <https://docs.microsoft.com/previous-versions/msp-n-p/jj591572(v=pandp.10)>

- <span data-ttu-id="a49ef-190">**Coerenza finale** </span><span class="sxs-lookup"><span data-stu-id="a49ef-190">**Eventual consistency** </span></span>\
  <https://en.wikipedia.org/wiki/Eventual_consistency>

- <span data-ttu-id="a49ef-191">**Jimmy Bogard. Refactoring per la resilienza: valutazione dell'accoppiamento** </span><span class="sxs-lookup"><span data-stu-id="a49ef-191">**Jimmy Bogard. Refactoring Towards Resilience: Evaluating Coupling** </span></span>\
  <https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/>

> [!div class="step-by-step"]
> <span data-ttu-id="a49ef-192">[Precedente](communication-in-microservice-architecture.md) 
>  [Avanti](maintain-microservice-apis.md)</span><span class="sxs-lookup"><span data-stu-id="a49ef-192">[Previous](communication-in-microservice-architecture.md)
[Next](maintain-microservice-apis.md)</span></span>
