---
title: Implementazione di un modello di dominio del microservizio con .NET Core
description: Architettura di microservizi .NET per applicazioni .NET incluse in contenitori | Informazioni dettagliate sull'implementazione di un modello di dominio orientato a DDD.
ms.date: 10/08/2018
ms.openlocfilehash: 24f700b371d998cf99cbcf260a5278d797cb39d4
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/09/2020
ms.locfileid: "80988427"
---
# <a name="implement-a-microservice-domain-model-with-net-core"></a><span data-ttu-id="3e99b-103">Implementare un modello di dominio del microservizio con .NET Core</span><span class="sxs-lookup"><span data-stu-id="3e99b-103">Implement a microservice domain model with .NET Core</span></span>

<span data-ttu-id="3e99b-104">La sezione precedente ha illustrato i principi e gli schemi fondamentali per la progettazione di un modello di dominio.</span><span class="sxs-lookup"><span data-stu-id="3e99b-104">In the previous section, the fundamental design principles and patterns for designing a domain model were explained.</span></span> <span data-ttu-id="3e99b-105">È giunto ora il momento di esplorare i possibili modi per implementare il modello di dominio usando .NET Core (normale codice C\#) e EF Core.</span><span class="sxs-lookup"><span data-stu-id="3e99b-105">Now it is time to explore possible ways to implement the domain model by using .NET Core (plain C\# code) and EF Core.</span></span> <span data-ttu-id="3e99b-106">Si noti che il modello di dominio sarà costituito semplicemente dal codice:</span><span class="sxs-lookup"><span data-stu-id="3e99b-106">Note that your domain model will be composed simply of your code.</span></span> <span data-ttu-id="3e99b-107">avrà i requisiti del modello EF Core, ma non vere dipendenze su EF.</span><span class="sxs-lookup"><span data-stu-id="3e99b-107">It will have just the EF Core model requirements, but not real dependencies on EF.</span></span> <span data-ttu-id="3e99b-108">Il modello di dominio non deve contenere dipendenze rigide o riferimenti a EF Core né a nessun altro ORM.</span><span class="sxs-lookup"><span data-stu-id="3e99b-108">You should not have hard dependencies or references to EF Core or any other ORM in your domain model.</span></span>

## <a name="domain-model-structure-in-a-custom-net-standard-library"></a><span data-ttu-id="3e99b-109">Struttura del modello di dominio in una libreria .NET Standard personalizzata</span><span class="sxs-lookup"><span data-stu-id="3e99b-109">Domain model structure in a custom .NET Standard Library</span></span>

<span data-ttu-id="3e99b-110">L'organizzazione della cartella usata per l'applicazione di riferimento eShopOnContainers dimostra il modello DDD per l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="3e99b-110">The folder organization used for the eShopOnContainers reference application demonstrates the DDD model for the application.</span></span> <span data-ttu-id="3e99b-111">Un'organizzazione della cartella differente potrebbe comunicare in maniera più chiara le scelte di progettazione effettuate per la propria applicazione.</span><span class="sxs-lookup"><span data-stu-id="3e99b-111">You might find that a different folder organization more clearly communicates the design choices made for your application.</span></span> <span data-ttu-id="3e99b-112">Come si vede nella figura 7-10, nel modello di dominio di ordinamento sono presenti due aggregazioni: l'aggregazione order e l'aggregazione buyer.</span><span class="sxs-lookup"><span data-stu-id="3e99b-112">As you can see in Figure 7-10, in the ordering domain model there are two aggregates, the order aggregate and the buyer aggregate.</span></span> <span data-ttu-id="3e99b-113">Ogni aggregazione è un gruppo di entità di dominio e oggetti valore, anche se è possibile avere un aggregato costituito da una singola entità di dominio (radice dell'aggregazione o entità radice).</span><span class="sxs-lookup"><span data-stu-id="3e99b-113">Each aggregate is a group of domain entities and value objects, although you could have an aggregate composed of a single domain entity (the aggregate root or root entity) as well.</span></span>

:::image type="complex" source="./media/net-core-microservice-domain-model/ordering-microservice-container.png" alt-text="Screenshot del progetto Ordering.Domain in Esplora soluzioni.":::
<span data-ttu-id="3e99b-115">Nella visualizzazione Esplora soluzioni per il progetto Ordering.Domain appare la cartella AggregatesModel contenente le cartelle BuyerAggregate e OrderAggregate, ognuna delle quali contiene le proprie classi di entità, i file di oggetti valore e così via.</span><span class="sxs-lookup"><span data-stu-id="3e99b-115">The Solution Explorer view for the Ordering.Domain project, showing the AggregatesModel folder containing the BuyerAggregate and OrderAggregate folders, each one containing it's entity classes, value object files and so on.</span></span>
:::image-end:::

<span data-ttu-id="3e99b-116">**Figura 7-10**.</span><span class="sxs-lookup"><span data-stu-id="3e99b-116">**Figure 7-10**.</span></span> <span data-ttu-id="3e99b-117">Struttura del modello di dominio per il microservizio degli ordini in eShopOnContainers</span><span class="sxs-lookup"><span data-stu-id="3e99b-117">Domain model structure for the ordering microservice in eShopOnContainers</span></span>

<span data-ttu-id="3e99b-118">In più, il livello del modello di dominio include i contratti del repository (interfacce) che rappresentano i requisiti dell'infrastruttura del modello di dominio.</span><span class="sxs-lookup"><span data-stu-id="3e99b-118">Additionally, the domain model layer includes the repository contracts (interfaces) that are the infrastructure requirements of your domain model.</span></span> <span data-ttu-id="3e99b-119">In altre parole, queste interfacce indicano quali repository e metodi devono essere implementati dal livello infrastruttura.</span><span class="sxs-lookup"><span data-stu-id="3e99b-119">In other words, these interfaces express what repositories and the methods the infrastructure layer must implement.</span></span> <span data-ttu-id="3e99b-120">È fondamentale che l'implementazione dei repository venga inserita all'esterno del livello del modello di dominio, nella libreria a livello di infrastruttura, in modo che il livello del modello di dominio non sia "contaminato" dall'API o dalle classi delle tecnologie dell'infrastruttura, ad esempio Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="3e99b-120">It is critical that the implementation of the repositories be placed outside of the domain model layer, in the infrastructure layer library, so the domain model layer is not "contaminated" by API or classes from infrastructure technologies, like Entity Framework.</span></span>

<span data-ttu-id="3e99b-121">È inoltre possibile visualizzare una cartella [SeedWork](https://martinfowler.com/bliki/Seedwork.html) che contiene classi di base personalizzate che è possibile utilizzare come base per le entità di dominio e gli oggetti valore, in modo da non disporre di codice ridondante nella classe di oggetti di ogni dominio.</span><span class="sxs-lookup"><span data-stu-id="3e99b-121">You can also see a [SeedWork](https://martinfowler.com/bliki/Seedwork.html) folder that contains custom base classes that you can use as a base for your domain entities and value objects, so you do not have redundant code in each domain's object class.</span></span>

## <a name="structure-aggregates-in-a-custom-net-standard-library"></a><span data-ttu-id="3e99b-122">Strutturare aggregazioni in una libreria .NET Standard personalizzata</span><span class="sxs-lookup"><span data-stu-id="3e99b-122">Structure aggregates in a custom .NET Standard library</span></span>

<span data-ttu-id="3e99b-123">Per aggregazione si intende un cluster di oggetti dominio raggruppati in modo da corrispondere alla coerenza delle transazioni.</span><span class="sxs-lookup"><span data-stu-id="3e99b-123">An aggregate refers to a cluster of domain objects grouped together to match transactional consistency.</span></span> <span data-ttu-id="3e99b-124">Tali oggetti possono essere istanze di entità (una delle quali è la radice di aggregazione o l'entità radice) oltre agli eventuali oggetti valore aggiuntivi.</span><span class="sxs-lookup"><span data-stu-id="3e99b-124">Those objects could be instances of entities (one of which is the aggregate root or root entity) plus any additional value objects.</span></span>

<span data-ttu-id="3e99b-125">Per coerenza delle transazioni si intende garantire che un'aggregazione sia coerente e aggiornata al termine di un'azione di business.</span><span class="sxs-lookup"><span data-stu-id="3e99b-125">Transactional consistency means that an aggregate is guaranteed to be consistent and up to date at the end of a business action.</span></span> <span data-ttu-id="3e99b-126">Ad esempio, l'aggregazione order dal modello di dominio del microservizio degli ordini eShopOnContainers è composta come illustrato nella figura 7-11.</span><span class="sxs-lookup"><span data-stu-id="3e99b-126">For example, the order aggregate from the eShopOnContainers ordering microservice domain model is composed as shown in Figure 7-11.</span></span>

:::image type="complex" source="./media/net-core-microservice-domain-model/vs-solution-explorer-order-aggregate.png" alt-text="Screenshot della cartella OrderAggregate e delle relative classi.":::
<span data-ttu-id="3e99b-128">Una visualizzazione dettagliata della cartella OrderAggregate: Address.cs è un oggetto valore, IOrderRepository è un'interfaccia di repository, Order.cs è una radice di aggregazione, OrderItem.cs è un'entità figlio e OrderStatus.cs è una classe di enumerazione.</span><span class="sxs-lookup"><span data-stu-id="3e99b-128">A detailed view of the OrderAggregate folder: Address.cs is a value object, IOrderRepository is a repo interface, Order.cs is an aggregate root, OrderItem.cs is a child entity, and OrderStatus.cs is an enumeration class.</span></span>
:::image-end:::

<span data-ttu-id="3e99b-129">**Figura 7-11**.</span><span class="sxs-lookup"><span data-stu-id="3e99b-129">**Figure 7-11**.</span></span> <span data-ttu-id="3e99b-130">Aggregazione order nella soluzione Visual Studio</span><span class="sxs-lookup"><span data-stu-id="3e99b-130">The order aggregate in Visual Studio solution</span></span>

<span data-ttu-id="3e99b-131">Se si apre uno dei file in una cartella di aggregazione, si può vedere se è contrassegnato come classe di base o interfaccia personalizzata, come entità o oggetto valore, secondo l'implementazione nella cartella [SeedWork](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Services/Ordering/Ordering.Domain/SeedWork).</span><span class="sxs-lookup"><span data-stu-id="3e99b-131">If you open any of the files in an aggregate folder, you can see how it is marked as either a custom base class or interface, like entity or value object, as implemented in the [SeedWork](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Services/Ordering/Ordering.Domain/SeedWork) folder.</span></span>

## <a name="implement-domain-entities-as-poco-classes"></a><span data-ttu-id="3e99b-132">Implementare entità di dominio come classi POCO</span><span class="sxs-lookup"><span data-stu-id="3e99b-132">Implement domain entities as POCO classes</span></span>

<span data-ttu-id="3e99b-133">Per implementare un modello di dominio in .NET è sufficiente creare classi POCO che implementano le entità di dominio.</span><span class="sxs-lookup"><span data-stu-id="3e99b-133">You implement a domain model in .NET by creating POCO classes that implement your domain entities.</span></span> <span data-ttu-id="3e99b-134">Nell'esempio seguente, la classe Order è definita come entità e anche come radice di aggregazione.</span><span class="sxs-lookup"><span data-stu-id="3e99b-134">In the following example, the Order class is defined as an entity and also as an aggregate root.</span></span> <span data-ttu-id="3e99b-135">Visto che la classe Order deriva dalla classe base Entity, è possibile riutilizzare il codice comune correlato alle entità.</span><span class="sxs-lookup"><span data-stu-id="3e99b-135">Because the Order class derives from the Entity base class, it can reuse common code related to entities.</span></span> <span data-ttu-id="3e99b-136">Tenere presente che queste classi base e interfacce sono definite dall'utente nel progetto del modello di dominio, così come il codice, ma non il codice dell'infrastruttura da un ORM come EF.</span><span class="sxs-lookup"><span data-stu-id="3e99b-136">Bear in mind that these base classes and interfaces are defined by you in the domain model project, so it is your code, not infrastructure code from an ORM like EF.</span></span>

```csharp
// COMPATIBLE WITH ENTITY FRAMEWORK CORE 2.0
// Entity is a custom base class with the ID
public class Order : Entity, IAggregateRoot
{
    private DateTime _orderDate;
    public Address Address { get; private set; }
    private int? _buyerId;

    public OrderStatus OrderStatus { get; private set; }
    private int _orderStatusId;

    private string _description;
    private int? _paymentMethodId;

    private readonly List<OrderItem> _orderItems;
    public IReadOnlyCollection<OrderItem> OrderItems => _orderItems;

    public Order(string userId, Address address, int cardTypeId, string cardNumber, string cardSecurityNumber,
            string cardHolderName, DateTime cardExpiration, int? buyerId = null, int? paymentMethodId = null)
    {
        _orderItems = new List<OrderItem>();
        _buyerId = buyerId;
        _paymentMethodId = paymentMethodId;
        _orderStatusId = OrderStatus.Submitted.Id;
        _orderDate = DateTime.UtcNow;
        Address = address;

        // ...Additional code ...
    }

    public void AddOrderItem(int productId, string productName,
                            decimal unitPrice, decimal discount,
                            string pictureUrl, int units = 1)
    {
        //...
        // Domain rules/logic for adding the OrderItem to the order
        // ...

        var orderItem = new OrderItem(productId, productName, unitPrice, discount, pictureUrl, units);

        _orderItems.Add(orderItem);

    }
    // ...
    // Additional methods with domain rules/logic related to the Order aggregate
    // ...
}
```

<span data-ttu-id="3e99b-137">È importante notare che questa è un'entità di dominio implementata come classe POCO,</span><span class="sxs-lookup"><span data-stu-id="3e99b-137">It is important to note that this is a domain entity implemented as a POCO class.</span></span> <span data-ttu-id="3e99b-138">che non ha alcuna dipendenza diretta da Entity Framework Core o qualsiasi altro framework dell'infrastruttura.</span><span class="sxs-lookup"><span data-stu-id="3e99b-138">It does not have any direct dependency on Entity Framework Core or any other infrastructure framework.</span></span> <span data-ttu-id="3e99b-139">Questa implementazione è come deve essere in DDD, solo codice C\# che implementa un modello di dominio.</span><span class="sxs-lookup"><span data-stu-id="3e99b-139">This implementation is as it should be in DDD, just C\# code implementing a domain model.</span></span>

<span data-ttu-id="3e99b-140">La classe è anche decorata con un'interfaccia denominata IAggregateRoot.</span><span class="sxs-lookup"><span data-stu-id="3e99b-140">In addition, the class is decorated with an interface named IAggregateRoot.</span></span> <span data-ttu-id="3e99b-141">Tale interfaccia vuota, talvolta detta *interfaccia dei marcatori*, viene usata solo per indicare che questa classe di entità è anche una radice di aggregazione.</span><span class="sxs-lookup"><span data-stu-id="3e99b-141">That interface is an empty interface, sometimes called a *marker interface*, that is used just to indicate that this entity class is also an aggregate root.</span></span>

<span data-ttu-id="3e99b-142">Un'interfaccia dei marcatori viene talvolta considerata come antipattern; tuttavia, è anche un modo corretto di contrassegnare una classe, in special modo quando l'interfaccia potrebbe essere in evoluzione.</span><span class="sxs-lookup"><span data-stu-id="3e99b-142">A marker interface is sometimes considered as an anti-pattern; however, it is also a clean way to mark a class, especially when that interface might be evolving.</span></span> <span data-ttu-id="3e99b-143">L'altra scelta per il marcatore potrebbe essere un attributo, ma è più rapido visualizzare la classe base (Entity) accanto all'interfaccia IAggregate invece di inserire un marcatore di attributo Aggregate sopra la classe.</span><span class="sxs-lookup"><span data-stu-id="3e99b-143">An attribute could be the other choice for the marker, but it is quicker to see the base class (Entity) next to the IAggregate interface instead of putting an Aggregate attribute marker above the class.</span></span> <span data-ttu-id="3e99b-144">In ogni caso, è una questione di preferenza.</span><span class="sxs-lookup"><span data-stu-id="3e99b-144">It is a matter of preferences, in any case.</span></span>

<span data-ttu-id="3e99b-145">La presenza di una radice di aggregazione significa che la maggior parte del codice relativo alla coerenza e alle regole business delle entità dell'aggregazione deve essere implementata come metodi nella classe radice di aggregazione Order (ad esempio, AddOrderItem quando si aggiunge un oggetto OrderItem all'aggregazione).</span><span class="sxs-lookup"><span data-stu-id="3e99b-145">Having an aggregate root means that most of the code related to consistency and business rules of the aggregate's entities should be implemented as methods in the Order aggregate root class (for example, AddOrderItem when adding an OrderItem object to the aggregate).</span></span> <span data-ttu-id="3e99b-146">Non è consigliabile creare o aggiornare oggetti OrderItem in maniera indipendente o diretta; la classe AggregateRoot deve mantenere il controllo e la coerenza di qualsiasi operazione di aggiornamento rispetto alle entità figlio.</span><span class="sxs-lookup"><span data-stu-id="3e99b-146">You should not create or update OrderItems objects independently or directly; the AggregateRoot class must keep control and consistency of any update operation against its child entities.</span></span>

## <a name="encapsulate-data-in-the-domain-entities"></a><span data-ttu-id="3e99b-147">Incapsulare i dati nelle entità di dominio</span><span class="sxs-lookup"><span data-stu-id="3e99b-147">Encapsulate data in the Domain Entities</span></span>

<span data-ttu-id="3e99b-148">Un problema comune nei modelli di entità è che espongono le proprietà di navigazione della raccolta come tipi elenco accessibili pubblicamente.</span><span class="sxs-lookup"><span data-stu-id="3e99b-148">A common problem in entity models is that they expose collection navigation properties as publicly accessible list types.</span></span> <span data-ttu-id="3e99b-149">In questo modo gli sviluppatori collaboratori possono modificare il contenuto di questi tipi di raccolta, che possono ignorare importanti regole di business relative alla raccolta, lasciando eventualmente l'oggetto in uno stato non valido.</span><span class="sxs-lookup"><span data-stu-id="3e99b-149">This allows any collaborator developer to manipulate the contents of these collection types, which may bypass important business rules related to the collection, possibly leaving the object in an invalid state.</span></span> <span data-ttu-id="3e99b-150">La soluzione consiste nell'esporre l'accesso in sola lettura alle raccolte correlate e nel fornire in modo esplicito i metodi che definiscono i modi in cui i client possono modificarle.</span><span class="sxs-lookup"><span data-stu-id="3e99b-150">The solution to this is to expose read-only access to related collections and explicitly provide methods that define ways in which clients can manipulate them.</span></span>

<span data-ttu-id="3e99b-151">Nel codice precedente molti attributi sono di sola lettura o privati e possono essere aggiornati solo dai metodi della classe, quindi qualsiasi aggiornamento tiene conto delle invarianti del dominio aziendale e della logica specificata all'interno dei metodi delle classi.</span><span class="sxs-lookup"><span data-stu-id="3e99b-151">In the previous code, note that many attributes are read-only or private and are only updatable by the class methods, so any update considers business domain invariants and logic specified within the class methods.</span></span>

<span data-ttu-id="3e99b-152">Ad esempio, seguendo gli schemi DDD, **non* è* consigliabile\*\* eseguire le operazioni seguenti da qualsiasi metodo del gestore dei comandi o classe del livello dell'applicazione (in realtà per l'utente deve essere impossibile eseguire questa operazione):</span><span class="sxs-lookup"><span data-stu-id="3e99b-152">For example, following DDD patterns, **you should *not* do the following** from any command handler method or application layer class (actually, it should be impossible for you to do so):</span></span>

```csharp
// WRONG ACCORDING TO DDD PATTERNS – CODE AT THE APPLICATION LAYER OR
// COMMAND HANDLERS
// Code in command handler methods or Web API controllers
//... (WRONG) Some code with business logic out of the domain classes ...
OrderItem myNewOrderItem = new OrderItem(orderId, productId, productName,
    pictureUrl, unitPrice, discount, units);

//... (WRONG) Accessing the OrderItems collection directly from the application layer // or command handlers
myOrder.OrderItems.Add(myNewOrderItem);
//...
```

<span data-ttu-id="3e99b-153">In questo caso, il metodo Add è semplicemente un'operazione di aggiunta di dati, con accesso diretto alla raccolta OrderItems.</span><span class="sxs-lookup"><span data-stu-id="3e99b-153">In this case, the Add method is purely an operation to add data, with direct access to the OrderItems collection.</span></span> <span data-ttu-id="3e99b-154">Di conseguenza, la maggior parte della logica di dominio, delle regole o delle convalide correlate a tale operazione con le entità figlio verrà distribuita tra il livello dell'applicazione (gestori di comandi e controller API Web).</span><span class="sxs-lookup"><span data-stu-id="3e99b-154">Therefore, most of the domain logic, rules, or validations related to that operation with the child entities will be spread across the application layer (command handlers and Web API controllers).</span></span>

<span data-ttu-id="3e99b-155">Se si aggira la radice di aggregazione, questa non può garantire le sue invarianti, la sua validità o la sua coerenza.</span><span class="sxs-lookup"><span data-stu-id="3e99b-155">If you go around the aggregate root, the aggregate root cannot guarantee its invariants, its validity, or its consistency.</span></span> <span data-ttu-id="3e99b-156">Si finirà con l'avere blocchi di codice complicati o codice script transazionale.</span><span class="sxs-lookup"><span data-stu-id="3e99b-156">Eventually you will have spaghetti code or transactional script code.</span></span>

<span data-ttu-id="3e99b-157">Per seguire i pattern DDD, le entità non devono avere setter pubblici in nessuna proprietà di entità.</span><span class="sxs-lookup"><span data-stu-id="3e99b-157">To follow DDD patterns, entities must not have public setters in any entity property.</span></span> <span data-ttu-id="3e99b-158">Le modifiche in un'entità devono essere causate da metodi espliciti con linguaggio universale esplicito sulla modifica in esecuzione nell'entità.</span><span class="sxs-lookup"><span data-stu-id="3e99b-158">Changes in an entity should be driven by explicit methods with explicit ubiquitous language about the change they are performing in the entity.</span></span>

<span data-ttu-id="3e99b-159">Le raccolte all'interno dell'entità (ad esempio, gli elementi dell'ordine) devono essere proprietà di sola lettura (il metodo AsReadOnly descritto più avanti).</span><span class="sxs-lookup"><span data-stu-id="3e99b-159">Furthermore, collections within the entity (like the order items) should be read-only properties (the AsReadOnly method explained later).</span></span> <span data-ttu-id="3e99b-160">Dovrebbe essere possibile eseguire l'aggiornamento solo dall'interno dei metodi della classe radice dell'aggregazione o dei metodi dell'entità figlio.</span><span class="sxs-lookup"><span data-stu-id="3e99b-160">You should be able to update it only from within the aggregate root class methods or the child entity methods.</span></span>

<span data-ttu-id="3e99b-161">Come si può vedere nel codice per la radice di aggregazione Order, tutti i setter devono essere privati o almeno di sola lettura esternamente, in modo che qualsiasi operazione sui dati dell'entità o sulle relative entità figlio deve essere eseguita tramite i metodi nella classe di entità.</span><span class="sxs-lookup"><span data-stu-id="3e99b-161">As you can see in the code for the Order aggregate root, all setters should be private or at least read-only externally, so that any operation against the entity's data or its child entities has to be performed through methods in the entity class.</span></span> <span data-ttu-id="3e99b-162">In tal modo viene mantenuta la coerenza in modo controllato e orientato agli oggetti anziché implementare codice script transazionale.</span><span class="sxs-lookup"><span data-stu-id="3e99b-162">This maintains consistency in a controlled and object-oriented way instead of implementing transactional script code.</span></span>

<span data-ttu-id="3e99b-163">Il frammento di codice seguente illustra il modo corretto per codificare l'attività di aggiunta di un oggetto OrderItem all'aggregazione Order.</span><span class="sxs-lookup"><span data-stu-id="3e99b-163">The following code snippet shows the proper way to code the task of adding an OrderItem object to the Order aggregate.</span></span>

```csharp
// RIGHT ACCORDING TO DDD--CODE AT THE APPLICATION LAYER OR COMMAND HANDLERS
// The code in command handlers or WebAPI controllers, related only to application stuff
// There is NO code here related to OrderItem object's business logic
myOrder.AddOrderItem(productId, productName, pictureUrl, unitPrice, discount, units);

// The code related to OrderItem params validations or domain rules should
// be WITHIN the AddOrderItem method.

//...
```

<span data-ttu-id="3e99b-164">In questo frammento di codice, la maggior parte delle convalide o della logica relative alla creazione di un oggetto OrderItem sarà sotto il controllo della radice di aggregazione Order, nel metodo AddOrderItem, soprattutto le convalide e la logica correlate agli altri elementi nell'aggregazione.</span><span class="sxs-lookup"><span data-stu-id="3e99b-164">In this snippet, most of the validations or logic related to the creation of an OrderItem object will be under the control of the Order aggregate root—in the AddOrderItem method—especially validations and logic related to other elements in the aggregate.</span></span> <span data-ttu-id="3e99b-165">Ad esempio, si potrebbe ottenere lo stesso prodotto come risultato di più chiamate a AddOrderItem.</span><span class="sxs-lookup"><span data-stu-id="3e99b-165">For instance, you might get the same product item as the result of multiple calls to AddOrderItem.</span></span> <span data-ttu-id="3e99b-166">In quel metodo, è possibile esaminare i prodotti e consolidarli in un singolo oggetto OrderItem con diverse unità.</span><span class="sxs-lookup"><span data-stu-id="3e99b-166">In that method, you could examine the product items and consolidate the same product items into a single OrderItem object with several units.</span></span> <span data-ttu-id="3e99b-167">Se sono presenti importi di sconto differenti, ma l'ID prodotto è lo stesso, si applicherebbe molto probabilmente lo sconto maggiore.</span><span class="sxs-lookup"><span data-stu-id="3e99b-167">Additionally, if there are different discount amounts but the product ID is the same, you would likely apply the higher discount.</span></span> <span data-ttu-id="3e99b-168">Questo principio si applica a qualsiasi altra logica di dominio per l'oggetto OrderItem.</span><span class="sxs-lookup"><span data-stu-id="3e99b-168">This principle applies to any other domain logic for the OrderItem object.</span></span>

<span data-ttu-id="3e99b-169">Anche la nuova operazione OrderItem(params) sarà controllata ed eseguita dal metodo AddOrderItem dalla radice di aggregazione Order.</span><span class="sxs-lookup"><span data-stu-id="3e99b-169">In addition, the new OrderItem(params) operation will also be controlled and performed by the AddOrderItem method from the Order aggregate root.</span></span> <span data-ttu-id="3e99b-170">Di conseguenza, la maggior parte della logica o delle convalide correlate a tale operazione (in particolare tutto ciò che influisce sulla coerenza tra altre entità figlio) verrà eseguita in un'unica posizione nell'ambito della radice di aggregazione,</span><span class="sxs-lookup"><span data-stu-id="3e99b-170">Therefore, most of the logic or validations related to that operation (especially anything that impacts the consistency between other child entities) will be in a single place within the aggregate root.</span></span> <span data-ttu-id="3e99b-171">cioè lo scopo principale dello schema della radice di aggregazione.</span><span class="sxs-lookup"><span data-stu-id="3e99b-171">That is the ultimate purpose of the aggregate root pattern.</span></span>

<span data-ttu-id="3e99b-172">Quando si usa Entity Framework Core 1.1 o versioni successive, un'entità DDD può essere espressa meglio perché consente di [eseguire il mapping ai campi](https://docs.microsoft.com/ef/core/modeling/backing-field) oltre alle proprietà.</span><span class="sxs-lookup"><span data-stu-id="3e99b-172">When you use Entity Framework Core 1.1 or later, a DDD entity can be better expressed because it allows [mapping to fields](https://docs.microsoft.com/ef/core/modeling/backing-field) in addition to properties.</span></span> <span data-ttu-id="3e99b-173">Ciò è utile quando si proteggono le raccolte di entità figlio oppure oggetti valore.</span><span class="sxs-lookup"><span data-stu-id="3e99b-173">This is useful when protecting collections of child entities or value objects.</span></span> <span data-ttu-id="3e99b-174">Con questa funzionalità avanzata, è possibile usare i semplici campi privati anziché le proprietà e implementare gli aggiornamenti della raccolta di campi nei metodi pubblici e fornire l'accesso di sola lettura usando il metodo AsReadOnly.</span><span class="sxs-lookup"><span data-stu-id="3e99b-174">With this enhancement, you can use simple private fields instead of properties and you can implement any update to the field collection in public methods and provide read-only access through the AsReadOnly method.</span></span>

<span data-ttu-id="3e99b-175">In DDD, aggiornare l'entità usando solo i metodi nell'entità (o costruttore) per controllare qualsiasi invariante e la coerenza dei dati, dunque le proprietà sono definite solo con una funzione di accesso Get.</span><span class="sxs-lookup"><span data-stu-id="3e99b-175">In DDD you want to update the entity only through methods in the entity (or the constructor) in order to control any invariant and the consistency of the data, so properties are defined only with a get accessor.</span></span> <span data-ttu-id="3e99b-176">Le proprietà sono supportate da campi privati.</span><span class="sxs-lookup"><span data-stu-id="3e99b-176">The properties are backed by private fields.</span></span> <span data-ttu-id="3e99b-177">I membri privati sono accessibili solo dall'interno della classe.</span><span class="sxs-lookup"><span data-stu-id="3e99b-177">Private members can only be accessed from within the class.</span></span> <span data-ttu-id="3e99b-178">Tuttavia, esiste un'eccezione: questi campi devono essere impostati anche in EF Core, in modo che venga restituito l'oggetto con i valori appropriati.</span><span class="sxs-lookup"><span data-stu-id="3e99b-178">However, there one exception: EF Core needs to set these fields as well (so it can return the object with the proper values).</span></span>

### <a name="map-properties-with-only-get-accessors-to-the-fields-in-the-database-table"></a><span data-ttu-id="3e99b-179">Mappare le proprietà solo con funzioni di accesso Get ai campi nella tabella di database</span><span class="sxs-lookup"><span data-stu-id="3e99b-179">Map properties with only get accessors to the fields in the database table</span></span>

<span data-ttu-id="3e99b-180">Il mapping delle proprietà alle colonne della tabella di database non è responsabilità del dominio, ma parte del livello di persistenza dell'infrastruttura.</span><span class="sxs-lookup"><span data-stu-id="3e99b-180">Mapping properties to database table columns is not a domain responsibility but part of the infrastructure and persistence layer.</span></span> <span data-ttu-id="3e99b-181">Ne facciamo cenno in questa sede in modo che il lettore sia al corrente delle nuove funzionalità disponibili in EF Core 1.1 o versioni successive in relazione a come è possibile modellare le entità.</span><span class="sxs-lookup"><span data-stu-id="3e99b-181">We mention this here just so you are aware of the new capabilities in EF Core 1.1 or later related to how you can model entities.</span></span> <span data-ttu-id="3e99b-182">Altre informazioni su questo argomento sono illustrate nella sezione dedicata a infrastruttura e persistenza.</span><span class="sxs-lookup"><span data-stu-id="3e99b-182">Additional details on this topic are explained in the infrastructure and persistence section.</span></span>

<span data-ttu-id="3e99b-183">Quando si usa Entity Framework Core 1.0 o versione successiva, all'interno di DbContext è necessario eseguire il mapping delle proprietà che sono definite solo con getter ai campi effettivi nella tabella di database.</span><span class="sxs-lookup"><span data-stu-id="3e99b-183">When you use EF Core 1.0 or later, within the DbContext you need to map the properties that are defined only with getters to the actual fields in the database table.</span></span> <span data-ttu-id="3e99b-184">Questa operazione viene eseguita con il metodo HasField della classe PropertyBuilder.</span><span class="sxs-lookup"><span data-stu-id="3e99b-184">This is done with the HasField method of the PropertyBuilder class.</span></span>

### <a name="map-fields-without-properties"></a><span data-ttu-id="3e99b-185">Mappare i campi senza proprietà</span><span class="sxs-lookup"><span data-stu-id="3e99b-185">Map fields without properties</span></span>

<span data-ttu-id="3e99b-186">Con la funzionalità in EF Core 1.1 o versione successiva per eseguire il mapping di colonne ai campi, è anche possibile non usare le proprietà.</span><span class="sxs-lookup"><span data-stu-id="3e99b-186">With the feature in EF Core 1.1 or later to map columns to fields, it is also possible to not use properties.</span></span> <span data-ttu-id="3e99b-187">In alternativa, è possibile solo mappare le colonne da una tabella ai campi.</span><span class="sxs-lookup"><span data-stu-id="3e99b-187">Instead, you can just map columns from a table to fields.</span></span> <span data-ttu-id="3e99b-188">Un caso di uso comune per questo oggetto è rappresentati dai campi privati per uno stato interno che non devono essere accessibili dall'esterno dell'entità.</span><span class="sxs-lookup"><span data-stu-id="3e99b-188">A common use case for this is private fields for an internal state that does not need to be accessed from outside the entity.</span></span>

<span data-ttu-id="3e99b-189">Ad esempio, nell'esempio di codice OrderAggregate precedente, sono presenti diversi campi privati, ad esempio il campo `_paymentMethodId`, che non hanno alcuna proprietà correlata per un getter o un setter.</span><span class="sxs-lookup"><span data-stu-id="3e99b-189">For example, in the preceding OrderAggregate code example, there are several private fields, like the  `_paymentMethodId` field, that have no related property for either a setter or getter.</span></span> <span data-ttu-id="3e99b-190">Tale campo potrebbe anche essere calcolato all'interno della logica di business dell'ordine e utilizzato dai metodi dell'ordine, ma deve essere mantenuto anche nel database.</span><span class="sxs-lookup"><span data-stu-id="3e99b-190">That field could also be calculated within the order's business logic and used from the order's methods, but it needs to be persisted in the database as well.</span></span> <span data-ttu-id="3e99b-191">Dunque, in EF Core (dalla versione 1.1) c'è un modo per eseguire il mapping di un campo senza una proprietà correlata a una colonna nel database.</span><span class="sxs-lookup"><span data-stu-id="3e99b-191">So in EF Core (since v1.1) there is a way to map a field without a related property to a column in the database.</span></span> <span data-ttu-id="3e99b-192">Anche questo è illustrato nella sezione [Livello infrastruttura](ddd-oriented-microservice.md#the-infrastructure-layer) di questa guida.</span><span class="sxs-lookup"><span data-stu-id="3e99b-192">This is also explained in the [Infrastructure layer](ddd-oriented-microservice.md#the-infrastructure-layer) section of this guide.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="3e99b-193">Risorse aggiuntive</span><span class="sxs-lookup"><span data-stu-id="3e99b-193">Additional resources</span></span>

- <span data-ttu-id="3e99b-194">**Vaughn Vernon. Modellazione di aggregazioni con DDD ed Entity Framework.**</span><span class="sxs-lookup"><span data-stu-id="3e99b-194">**Vaughn Vernon. Modeling Aggregates with DDD and Entity Framework.**</span></span> <span data-ttu-id="3e99b-195">Si osservi che *non* si tratta di Entity Framework Core.</span><span class="sxs-lookup"><span data-stu-id="3e99b-195">Note that this is *not* Entity Framework Core.</span></span> \
  <https://kalele.io/blog-posts/modeling-aggregates-with-ddd-and-entity-framework/>

- <span data-ttu-id="3e99b-196">**Julie Lerman. Punti dati - Codifica per la progettazione basata su dominio: suggerimenti per gli sviluppatori incentrati sui datiData Points - Coding for Domain-Driven Design: Tips for Data-Focused Devs** </span><span class="sxs-lookup"><span data-stu-id="3e99b-196">**Julie Lerman. Data Points - Coding for Domain-Driven Design: Tips for Data-Focused Devs** </span></span>\
  <https://docs.microsoft.com/archive/msdn-magazine/2013/august/data-points-coding-for-domain-driven-design-tips-for-data-focused-devs>

- <span data-ttu-id="3e99b-197">**Udi Dahan. Come creare modelli di dominio completamente incapsulatiHow to create fully encapsulated Domain Models** </span><span class="sxs-lookup"><span data-stu-id="3e99b-197">**Udi Dahan. How to create fully encapsulated Domain Models** </span></span>\
  <http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/>

> [!div class="step-by-step"]
> <span data-ttu-id="3e99b-198">[Successivo](microservice-domain-model.md)
> [precedente](seedwork-domain-model-base-classes-interfaces.md)</span><span class="sxs-lookup"><span data-stu-id="3e99b-198">[Previous](microservice-domain-model.md)
[Next](seedwork-domain-model-base-classes-interfaces.md)</span></span>
