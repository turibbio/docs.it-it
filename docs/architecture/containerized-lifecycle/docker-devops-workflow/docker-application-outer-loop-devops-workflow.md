---
title: Passaggi nel flusso di lavoro DevOps del ciclo esterno per un'applicazione Docker
description: Informazioni sui passaggi del "ciclo esterno" del flusso di lavoro DevOps
ms.date: 02/15/2019
ms.openlocfilehash: fdda1b6a2deb08ed97867583fcc8048d4dba880c
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/09/2020
ms.locfileid: "80988973"
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="ddb5e-103">Passaggi nel flusso di lavoro DevOps del ciclo esterno per un'applicazione Docker</span><span class="sxs-lookup"><span data-stu-id="ddb5e-103">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="ddb5e-104">La figura 5-1 mostra una rappresentazione end-to-end dei passaggi che comprendono il flusso di lavoro del ciclo esterno DevOps.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-104">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span> <span data-ttu-id="ddb5e-105">Mostra il "ciclo esterno" di DevOps.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-105">It shows the "outer loop" of DevOps.</span></span> <span data-ttu-id="ddb5e-106">Quando viene eseguito il push del codice al repository, viene avviata una pipeline di integrazione continua, quindi viene attivata la pipeline di distribuzione continua nella quale viene distribuita l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-106">When code is pushed to the repo, a CI pipeline is started, then begins the CD pipeline, where the application gets deployed.</span></span> <span data-ttu-id="ddb5e-107">La metrica registrata dalle applicazioni distribuite viene reinserita nel carico di lavoro di sviluppo, in cui si svolge il "ciclo interno", pertanto i team di sviluppo hanno a disposizione dati reali per soddisfare le esigenze dell'organizzazione e degli utenti finali.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-107">Metrics collected from deployed applications are fed back into the development workload, where the "inner loop" occurs, so development teams have actual data to respond to user and business needs.</span></span>

![Diagramma che mostra i 6 passaggi del flusso di lavoro del ciclo esterno DevOps.](./media/docker-application-outer-loop-devops-workflow/overview-dev-ops-outter-loop-workflow.png)

<span data-ttu-id="ddb5e-109">**Figura 5-1**.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-109">**Figure 5-1**.</span></span> <span data-ttu-id="ddb5e-110">Flusso di lavoro del ciclo esterno DevOps per le applicazioni Docker con strumenti Microsoft</span><span class="sxs-lookup"><span data-stu-id="ddb5e-110">DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="ddb5e-111">Di seguito verrà esaminato ognuno di questi passaggi in maggior dettaglio.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-111">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="ddb5e-112">Passaggio 1: Flusso di lavoro di sviluppo del ciclo internoStep 1: Inner-loop development workflow</span><span class="sxs-lookup"><span data-stu-id="ddb5e-112">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="ddb5e-113">Questo passaggio è illustrato in dettaglio nel capitolo 4. Tuttavia, per ricapitolare, questo è il punto in cui inizia il ciclo esterno, il momento in cui lo sviluppatore esegue il push del codice al sistema di gestione del controllo del codice sorgente (ad esempio Git) che avvia le azioni della pipeline di integrazione continua.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-113">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-azure-devops-services-and-git"></a><span data-ttu-id="ddb5e-114">Passaggio 2: Integrazione e gestione del controllo del codice sorgente con i servizi DevOps e Git di AzureStep 2: Source-Code Control integration and management with Azure DevOps Services and Git</span><span class="sxs-lookup"><span data-stu-id="ddb5e-114">Step 2: Source-Code Control integration and management with Azure DevOps Services and Git</span></span>

<span data-ttu-id="ddb5e-115">Per questo passaggio è necessario avere un sistema di controllo delle versioni per raccogliere una versione consolidata di tutto il codice proveniente da diversi sviluppatori del team.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-115">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="ddb5e-116">Sebbene il controllo del codice sorgente (SCC) e la gestione del codice sorgente possano sembrare attività scontate alla maggior parte degli sviluppatori, quando si creano applicazioni Docker in un ciclo di vita DevOps è importante sottolineare che le immagini Docker non devono essere inviate con l'applicazione direttamente al registro Docker globale, ad esempio al Registro Azure Container o a Docker Hub, dal computer dello sviluppatore.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-116">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it's critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="ddb5e-117">Al contrario, le immagini Docker che devono essere rilasciate e distribuite negli ambienti di produzione devono essere create esclusivamente nel codice sorgente che viene integrato nella pipeline di compilazione o integrazione continua basata sul repository del codice sorgente, ad esempio Git.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-117">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that's being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="ddb5e-118">Le immagini locali generate dagli sviluppatori dovrebbero essere usate solo dagli sviluppatori durante i test nei propri computer.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-118">The local images, generated by developers, should just be used by them when testing within their own machines.</span></span> <span data-ttu-id="ddb5e-119">Per questa ragione è fondamentale avere la pipeline DevOps attivata dal codice di controllo del codice sorgente.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-119">That's why it's critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="ddb5e-120">Azure DevOps Services e Team Foundation Server supportano Git e il controllo della versione di Team Foundation.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-120">Azure DevOps Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="ddb5e-121">È possibile scegliere una delle due opzioni e usarla per un'esperienza Microsoft end-to-end.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-121">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="ddb5e-122">Tuttavia, è anche possibile gestire il codice in repository esterni, ad esempio GitHub, repository Git locali o Subversion, ed essere ancora in grado di connettersi e ottenere il codice come punto di partenza della pipeline di integrazione continua DevOps.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-122">However, you also can manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-azure-devops-services-and-docker"></a><span data-ttu-id="ddb5e-123">Passaggio 3: Creare, CI, integrare e testare con i servizi DevOps di Azure e DockerStep 3: Build, CI, Integrate, and Test with Azure DevOps Services and Docker</span><span class="sxs-lookup"><span data-stu-id="ddb5e-123">Step 3: Build, CI, Integrate, and Test with Azure DevOps Services and Docker</span></span>

<span data-ttu-id="ddb5e-124">L'integrazione continua rappresenta oggi uno standard per il test e la distribuzione dei software moderni.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-124">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="ddb5e-125">La soluzione Docker mantiene una netta separazione delle problematiche tra il team di sviluppo e il team operazioni.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-125">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="ddb5e-126">L'immutabilità delle immagini Docker assicura una distribuzione ripetibile tra ciò che viene sviluppato, testato tramite l'integrazione continua ed eseguito in produzione.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-126">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="ddb5e-127">Il motore Docker distribuito nei portatili degli sviluppatori e nell'infrastruttura di test rende i contenitori portatili tra gli ambienti.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-127">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="ddb5e-128">Ora che si dispone di un sistema di controllo delle versioni cui è stato inviato il codice corretto, è necessario un *servizio di compilazione* per prelevare il codice ed eseguire la compilazione globale e i test.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-128">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="ddb5e-129">Il flusso di lavoro interno per questo passaggio (integrazione continua, compilazione, test) prevede la costruzione di una pipeline di integrazione continua che include il repository del codice (Git e così via), il server di compilazione (Azure DevOps Services), il motore Docker e un registro Docker.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-129">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Azure DevOps Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="ddb5e-130">È possibile usare Azure DevOps Services come base per la creazione delle applicazioni e l'impostazione della pipeline di integrazione continua e per la pubblicazione degli "artefatti" della compilazione in un "repository degli artefatti", descritte nel passaggio successivo.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-130">You can use Azure DevOps Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="ddb5e-131">Quando si usa Docker per la distribuzione, gli "artefatti finali" da distribuire sono immagini Docker con l'applicazione o i servizi incorporati.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-131">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="ddb5e-132">Queste immagini vengono sottoposte a push o vengono pubblicate in un *registro Docker*, ovvero un repository privato simile a quelli di Registro Azure Container o un repository pubblico come il registro Docker Hub solitamente usato per le immagini di base ufficiali.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-132">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="ddb5e-133">Ecco il concetto di base: la pipeline CI verrà avviata da un commit in un repository SCC come Git.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-133">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="ddb5e-134">Il commit fa in modo che Azure DevOps Services esegua un processo di compilazione all'interno di un contenitore Docker e, al termine del processo, esegue il push di un'immagine Docker nel registro Docker, come illustrato nella figura 5-2.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-134">The commit will cause Azure DevOps Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span> <span data-ttu-id="ddb5e-135">La prima parte del ciclo esterno prevede i passaggi da 1 a 3, dal codice, eseguire, eseguire il debug e convalidare, quindi il codice repo fino al passaggio di compilazione e test CI.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-135">The first part of the outer loop involves steps 1 to 3, from code, run, debug and validate, then the code repo up to the build and test CI step.</span></span>

![Diagramma che mostra i tre passaggi coinvolti nel flusso di lavoro CI.](./media/docker-application-outer-loop-devops-workflow/continuous-integration-steps.png)

<span data-ttu-id="ddb5e-137">**Figura 5-2**.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-137">**Figure 5-2**.</span></span> <span data-ttu-id="ddb5e-138">Passaggi previsti nell'integrazione continua</span><span class="sxs-lookup"><span data-stu-id="ddb5e-138">The steps involved in CI</span></span>

<span data-ttu-id="ddb5e-139">Di seguito sono elencati i passaggi del flusso di lavoro di integrazione continua di base con Docker e Azure DevOps Services:</span><span class="sxs-lookup"><span data-stu-id="ddb5e-139">Here are the basic CI workflow steps with Docker and Azure DevOps Services:</span></span>

1. <span data-ttu-id="ddb5e-140">Lo sviluppatore esegue il push di un commit in un repository di controllo del codice sorgente (Git o Azure DevOps Services, GitHub e così via).</span><span class="sxs-lookup"><span data-stu-id="ddb5e-140">The developer pushes a commit to an SCC repository (Git/Azure DevOps Services, GitHub, etc.).</span></span>

2. <span data-ttu-id="ddb5e-141">Se si usa Azure DevOps Services o Git, l'integrazione continua è incorporata, ovvero è sufficiente selezionare una casella di controllo in Azure DevOps Services.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-141">If you're using Azure DevOps Services or Git, CI is built in, which means that it's as simple as selecting a check box in Azure DevOps Services.</span></span> <span data-ttu-id="ddb5e-142">Se si usa un controllo del codice sorgente esterno, come GitHub, `webhook` segnala a Azure DevOps Services l'aggiornamento o il push in Git o GitHub.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-142">If you're using an external SCC (like GitHub), a `webhook` will notify Azure DevOps Services of the update or push to Git/GitHub.</span></span>

3. <span data-ttu-id="ddb5e-143">Azure DevOps Services esegue il pull del repository di controllo del codice sorgente contenente il Dockerfile che descrive l'immagine e il codice dell'applicazione e del test.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-143">Azure DevOps Services pulls the SCC repository, including the Dockerfile describing the image, as well as the application and test code.</span></span>

4. <span data-ttu-id="ddb5e-144">Azure DevOps Services compila un'immagine Docker e assegna all'immagine un'etichetta con il numero di build.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-144">Azure DevOps Services builds a Docker image and labels it with a build number.</span></span>

5. <span data-ttu-id="ddb5e-145">Azure DevOps Services crea un'istanza del contenitore Docker all'interno dell'host Docker di cui è stato effettuato il provisioning ed esegue i test appropriati.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-145">Azure DevOps Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6. <span data-ttu-id="ddb5e-146">Se i test hanno esito positivo, viene innanzitutto assegnata all'immagine un'etichetta con un nome significativo a indicare che si tratta di una build verificata, (ad esempio "/1.0.0" oppure qualsiasi altra etichetta) e viene quindi eseguito il push dell'immagine nel registro Docker (Docker Hub, Registro Azure Container, DTR e così via)</span><span class="sxs-lookup"><span data-stu-id="ddb5e-146">If the tests are successful, the image is first relabeled to a meaningful name so that you know it's a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-azure-devops-services-and-the-docker-extension-for-azure-devops-services"></a><span data-ttu-id="ddb5e-147">Implementazione della pipeline di integrazione continua con Azure DevOps Services e l'estensione Docker per Azure DevOps Services</span><span class="sxs-lookup"><span data-stu-id="ddb5e-147">Implementing the CI pipeline with Azure DevOps Services and the Docker extension for Azure DevOps Services</span></span>

<span data-ttu-id="ddb5e-148">Visual Studio Azure DevOps Services contiene modelli di compilazione e versione che è possibile usare nella pipeline CI/CD con cui le immagini Docker vengono compilate, ne viene eseguito il push in un registro Docker autenticato, vengono eseguite oppure vengono eseguite altre operazioni offerte dall'interfaccia della riga di comando Docker.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-148">Visual Studio Azure DevOps Services contains Build & Release Templates that you can use in your CI/CD pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="ddb5e-149">Azure DevOps Services aggiunge anche un'attività Docker Compose che consente di compilare, eseguire il push ed eseguire applicazioni Docker con più contenitori oppure eseguire altre operazioni offerte dall'interfaccia della riga di comando Docker Compose, come illustrato nella figura 5-3.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-149">It also adds a Docker Compose task that you can use to build, push, and run multi-container Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![Screenshot of the Docker CI pipeline in Azure DevOps.](./media/docker-application-outer-loop-devops-workflow/docker-ci-pipeline-azure-devops.png)

<span data-ttu-id="ddb5e-151">**Figura 5-3**.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-151">**Figure 5-3**.</span></span> <span data-ttu-id="ddb5e-152">Pipeline di integrazione continua di Docker in Azure DevOps Services con modelli di compilazione e versione e attività associate.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-152">The Docker CI pipeline in Azure DevOps Services including Build & Release Templates and associated tasks.</span></span>

<span data-ttu-id="ddb5e-153">È possibile usare i modelli e le attività per costruire gli artefatti CI/CD per la compilazione, il test e la distribuzione in Azure Service Fabric, nel servizio Azure Kubernetes e offerte simili.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-153">You can use these templates and tasks to construct your CI/CD artifacts to Build / Test and Deploy in Azure Service Fabric, Azure Kubernetes Service, and similar offerings.</span></span>

<span data-ttu-id="ddb5e-154">Con queste attività di Visual Studio Team Services, un host o una macchina virtuale Linux-Docker compilata di cui è stato effettuato il provisioning in Azure e il registro Docker desiderato (Registro Azure Container, Docker Hub, un DTR Docker privato o un altro registro Docker) è possibile assemblare la propria pipeline di integrazione continua Docker in un modo molto coerente.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-154">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="ddb5e-155">***Requisiti:***</span><span class="sxs-lookup"><span data-stu-id="ddb5e-155">***Requirements:***</span></span>

- <span data-ttu-id="ddb5e-156">Azure DevOps Services oppure, per le installazioni locali, Team Foundation Server 2015 Update 3 o versioni successive.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-156">Azure DevOps Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

- <span data-ttu-id="ddb5e-157">Un agente Azure DevOps Services con i file binari Docker.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-157">An Azure DevOps Services agent that has the Docker binaries.</span></span>

  <span data-ttu-id="ddb5e-158">Un modo semplice per creare uno di questi agenti consiste nell'usare Docker per eseguire un contenitore basato sull'immagine Docker dell'agente Azure DevOps Services.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-158">An easy way to create one of these agents is to use Docker to run a container based on the Azure DevOps Services agent Docker image.</span></span>

> [!INFORMATION]<span data-ttu-id="ddb5e-159"> Per altre informazioni su come assemblare un pipeline di integrazione continua Docker di Azure DevOps Services e visualizzare le procedure dettagliate, visitare i siti seguenti:</span><span class="sxs-lookup"><span data-stu-id="ddb5e-159"> To read more about assembling an Azure DevOps Services Docker CI pipeline and view the walkthroughs, visit these sites:</span></span>
>
> - <span data-ttu-id="ddb5e-160">Esecuzione di un agente Visual Studio Team Services (ora Azure DevOps Services) come contenitore Docker: </span><span class="sxs-lookup"><span data-stu-id="ddb5e-160">Running a Visual Studio Team Services (Now Azure DevOps Services) agent as a Docker container: </span></span>\
>   <https://hub.docker.com/_/microsoft-azure-pipelines-vsts-agent>
>
> - <span data-ttu-id="ddb5e-161">Compilazione di immagini Linux Docker di .NET Core con Azure DevOps Services: </span><span class="sxs-lookup"><span data-stu-id="ddb5e-161">Building .NET Core Linux Docker images with Azure DevOps Services: </span></span>\
>   <https://docs.microsoft.com/archive/blogs/stevelasker/building-net-core-linux-docker-images-with-visual-studio-team-services>
>
> - <span data-ttu-id="ddb5e-162">Creazione di un computer di compilazione Visual Studio Team Service basato su Linux con il supporto Docker: </span><span class="sxs-lookup"><span data-stu-id="ddb5e-162">Building a Linux-based Visual Studio Team Service build machine with Docker support: </span></span>\
>   <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support>

### <a name="integrate-test-and-validate-multi-container-docker-applications"></a><span data-ttu-id="ddb5e-163">Integrare, testare e convalidare applicazioni Docker con più contenitori</span><span class="sxs-lookup"><span data-stu-id="ddb5e-163">Integrate, test, and validate multi-container Docker applications</span></span>

<span data-ttu-id="ddb5e-164">In genere, la maggior parte delle applicazioni Docker sono composte da più contenitori anziché da un singolo contenitore.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-164">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="ddb5e-165">Un buon esempio è un'applicazione orientata ai microservizi con un contenitore per ogni microservizio.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-165">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="ddb5e-166">Tuttavia, anche senza seguire rigorosamente i modelli di approccio dei microservizi, è probabile che l'applicazione Docker sia composta da più contenitori o servizi.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-166">But, even without strictly following the microservices approach patterns, it's probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="ddb5e-167">Di conseguenza, dopo aver compilato i contenitori dell'applicazione nella pipeline di integrazione continua, è necessario anche distribuire, integrare e testare l'applicazione nel suo complesso con tutti i contenitori all'interno di un host Docker di integrazione o in un cluster di test in cui vengono distribuiti i contenitori.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-167">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="ddb5e-168">Se si usa un singolo host, è possibile usare i comandi Docker, ad esempio docker-compose, per compilare e distribuire i contenitori correlati per testare e convalidare l'ambiente Docker in una singola macchina virtuale.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-168">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="ddb5e-169">Se si usa invece un cluster di agenti di orchestrazione come DC/OS, Kubernetes o Docker Swarm, è necessario distribuire i contenitori tramite un meccanismo o un agente di orchestrazione diverso, a seconda del cluster o dell'utilità di pianificazione selezionata.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-169">But, if you're working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="ddb5e-170">Di seguito sono riportati diversi tipi di test che è possibile eseguire su contenitori Docker:</span><span class="sxs-lookup"><span data-stu-id="ddb5e-170">The following are several types of tests that you can run against Docker containers:</span></span>

- <span data-ttu-id="ddb5e-171">Unit test per i contenitori Docker</span><span class="sxs-lookup"><span data-stu-id="ddb5e-171">Unit tests for Docker containers</span></span>

- <span data-ttu-id="ddb5e-172">Gruppi di test di applicazioni o microservizi correlati</span><span class="sxs-lookup"><span data-stu-id="ddb5e-172">Testing groups of interrelated applications or microservices</span></span>

- <span data-ttu-id="ddb5e-173">Test in ambiente di produzione e versioni "canary"</span><span class="sxs-lookup"><span data-stu-id="ddb5e-173">Test in production and "canary" releases</span></span>

<span data-ttu-id="ddb5e-174">È importante tenere presente che durante l'esecuzione dei test di integrazione e funzionali, i test devono essere eseguiti dall'esterno dei contenitori.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-174">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="ddb5e-175">I test non sono contenuti e non vengono eseguiti nei contenitori da distribuire poiché i contenitori sono basati su immagini statiche che corrisponderebbero esattamente a quelle in distribuzione nell'ambiente di produzione.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-175">Tests are not contained or run in the containers you're deploying, because the containers are based on static images that should be exactly like the ones you'll be deploying to production.</span></span>

<span data-ttu-id="ddb5e-176">Per il test di scenari più avanzati come quelli con più cluster (cluster di test, cluster di staging e cluster di produzione) può essere utile pubblicare le immagini in un registro per poterle testare nei diversi cluster.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-176">A practical option when testing more advanced scenarios, like including several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry, so it can be tested in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="ddb5e-177">Eseguire il push dell'immagine Docker dell'applicazione personalizzata nel registro Docker globale</span><span class="sxs-lookup"><span data-stu-id="ddb5e-177">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="ddb5e-178">Dopo aver testato e convalidato le immagini Docker è possibile assegnare un tag e pubblicarle nel registro Docker.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-178">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="ddb5e-179">Il registro Docker è un elemento fondamentale del ciclo di vita dell'applicazione Docker poiché rappresenta la posizione centrale in cui viene archiviato il test personalizzato (chiamato anche "immagini verificate") da distribuire negli ambienti di controllo di qualità e produzione.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-179">The Docker registry is a critical piece in the Docker application life cycle because it's the central place where you store your custom test (also known as "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="ddb5e-180">Analogamente al codice dell'applicazione archiviato nel repository di controllo del codice sorgente (Git e così via) che rappresenta la "fonte della verità", il registro Docker è la "fonte della verità" per l'applicazione binaria o i bit da distribuire negli ambienti di controllo di qualità e produzione.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-180">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="ddb5e-181">In genere si preferisce archiviare i repository privati per le immagini personalizzate in un repository privato in Registro Azure Container o in un registro locale come Docker Trusted Registry oppure in un registro pubblico sul cloud con accesso limitato (come Docker Hub), sebbene in quest'ultimo caso se il codice non è open source è necessario fidarsi della sicurezza del fornitore.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-181">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="ddb5e-182">In entrambi i casi, il metodo usato è simile e basato sul comando `docker push`, come illustrato nella figura 5-4.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-182">Either way, the method you use is similar and is based on the `docker push` command, as shown in Figure 5-4.</span></span>

![Diagramma che mostra il push di immagini personalizzate in un registro contenitori.](./media/docker-application-outer-loop-devops-workflow/docker-push-custom-images.png)

<span data-ttu-id="ddb5e-184">**Figura 5-4**.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-184">**Figure 5-4**.</span></span> <span data-ttu-id="ddb5e-185">Pubblicazione di immagini personalizzate nel registro Docker</span><span class="sxs-lookup"><span data-stu-id="ddb5e-185">Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="ddb5e-186">Nel passaggio 3, per l'integrazione e il test (CI) è possibile pubblicare le immagini Docker risultati in un registro privato o pubblico.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-186">In step 3, for building integration and testing (CI) you might publish the resulting docker images to a private or public registry.</span></span> <span data-ttu-id="ddb5e-187">I fornitori di cloud offrono diversi registri Docker come Registro Azure Container, il registro contenitori di Amazon Web Services, Google Container Registry, Quay Registry e così via.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-187">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="ddb5e-188">Usando le attività Docker è possibile eseguire il push di un set di immagini di servizio definito da un file `docker-compose.yml`, con più tag, in un registro Docker autenticato (come Registro Azure Container), come illustrato nella figura 5-5.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-188">Using the Docker tasks, you can push a set of service images defined by a `docker-compose.yml` file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![Screenshot che mostra il passaggio per pubblicare immagini in un Registro di sistema.](./media/docker-application-outer-loop-devops-workflow/publish-custom-image-to-docker-registry.png)

<span data-ttu-id="ddb5e-190">**Figura 5-5**.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-190">**Figure 5-5**.</span></span> <span data-ttu-id="ddb5e-191">Uso di Azure DevOps Services per la pubblicazione di immagini personalizzate in un registro Docker</span><span class="sxs-lookup"><span data-stu-id="ddb5e-191">Using Azure DevOps Services to publishing custom images to a Docker Registry</span></span>

> [!INFORMATION]<span data-ttu-id="ddb5e-192"> Per altre informazioni su Registro Azure Container, vedere <https://aka.ms/azurecontainerregistry>.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-192"> For more information about Azure Container Registry, see <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="ddb5e-193">Passaggio 4: CD, distribuzioneStep 4: CD, Deploy</span><span class="sxs-lookup"><span data-stu-id="ddb5e-193">Step 4: CD, Deploy</span></span>

<span data-ttu-id="ddb5e-194">L'immutabilità delle immagini Docker assicura una distribuzione ripetibile con ciò che viene sviluppato, testato tramite l'integrazione continua ed eseguito in produzione.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-194">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="ddb5e-195">Dopo aver pubblicato le immagini Docker dell'applicazione nel registro Docker pubblico o privato è possibile distribuirle in più ambienti (produzione, controllo di qualità, staging e così via) dalla pipeline di distribuzione continua usando le attività della pipeline Azure DevOps Services oppure la gestione del rilascio di Azure DevOps Services.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-195">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Azure DevOps Services pipeline tasks or Azure DevOps Services Release Management.</span></span>

<span data-ttu-id="ddb5e-196">A questo punto, tuttavia, la procedura varia a seconda del tipo di applicazione Docker da distribuire.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-196">However, at this point it depends on what kind of Docker application you're deploying.</span></span> <span data-ttu-id="ddb5e-197">La distribuzione di un'applicazione semplice in termini di composizione e distribuzione come un'applicazione monolitica costituita da alcuni contenitori o servizi e distribuita su pochi server o macchine virtuali è diversa dalla distribuzione di un'applicazione complessa come un'applicazione orientata ai microservizi con capacità di iperscalabilità.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-197">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="ddb5e-198">Questi due scenari sono descritti nelle sezioni seguenti.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-198">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="ddb5e-199">Distribuzione di applicazioni Docker composte in più ambienti Docker</span><span class="sxs-lookup"><span data-stu-id="ddb5e-199">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="ddb5e-200">Verrà descritto per primo lo scenario meno complesso: la distribuzione in host Docker semplici (macchine virtuali o server) in un unico ambiente o in più ambienti (controllo di qualità, staging e produzione).</span><span class="sxs-lookup"><span data-stu-id="ddb5e-200">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="ddb5e-201">In questo scenario la pipeline di distribuzione continua può usare internamente docker-compose (dalle attività di distribuzione di Azure DevOps Services) per distribuire le applicazioni Docker con il relativo set di contenitori o servizi, come illustrato nella figura 5-6.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-201">In this scenario, internally your CD pipeline can use docker-compose (from your Azure DevOps Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![Diagramma che mostra il passaggio di distribuzione del CD in tre ambienti.](./media/docker-application-outer-loop-devops-workflow/deploy-app-containers-to-docker-host-environments.png)

<span data-ttu-id="ddb5e-203">**Figura 5-6**.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-203">**Figure 5-6**.</span></span> <span data-ttu-id="ddb5e-204">Distribuzione dei contenitori dell'applicazione nel registro ambienti host di Docker</span><span class="sxs-lookup"><span data-stu-id="ddb5e-204">Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="ddb5e-205">La figura 5-7 illustra come connettere l'integrazione continua di compilazione ad ambienti di controllo di qualità/test tramite Azure DevOps Services facendo clic su Docker Compose nella finestra di dialogo Aggiungi attività.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-205">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Azure DevOps Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="ddb5e-206">Tuttavia, durante la distribuzione in ambienti di staging o produzione si usano in genere le funzionalità di gestione del rilascio per la gestione di più ambienti, ad esempio degli ambienti di controllo di qualità, staging e produzione.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-206">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="ddb5e-207">Se si esegue la distribuzione in singoli host Docker, si usa l'attività "Docker Compose" di Azure DevOps Services che richiama il comando `docker-compose up` in background.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-207">If you're deploying to single Docker hosts, it is using the Azure DevOps Services "Docker Compose" task (which is invoking the `docker-compose up` command under the hood).</span></span> <span data-ttu-id="ddb5e-208">Se si esegue la distribuzione nel servizio Azure Kubernetes, viene usata l'attività Distribuzione di Docker, come descritto nella sezione seguente.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-208">If you're deploying to Azure Kubernetes Service (AKS), it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![Screenshot della finestra di dialogo Aggiungi attività dell'attività Componi docker.](./media/docker-application-outer-loop-devops-workflow/add-tasks-docker-compose.png)

<span data-ttu-id="ddb5e-210">**Figura 5-7**.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-210">**Figure 5-7**.</span></span> <span data-ttu-id="ddb5e-211">Aggiunta di un'attività Docker Compose in una pipeline Azure DevOps Services</span><span class="sxs-lookup"><span data-stu-id="ddb5e-211">Adding a Docker Compose task in an Azure DevOps Services pipeline</span></span>

<span data-ttu-id="ddb5e-212">Quando si crea una versione in Azure DevOps Services è necessario un set di artefatti di input.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-212">When you create a release in Azure DevOps Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="ddb5e-213">Questi artefatti devono essere immutabili per la durata della versione, in tutti gli ambienti.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-213">These artifacts are intended to be immutable for the lifetime of the release, across all environments.</span></span> <span data-ttu-id="ddb5e-214">Quando si inseriscono i contenitori, gli artefatti di input identificano le immagini in un registro per la distribuzione.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-214">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="ddb5e-215">A seconda del modo in cui vengono identificate queste immagini, non ne è garantita immutabilità per tutta la durata della versione, in particolare quando si fa riferimento a `myimage:latest` da un file `docker-compose`.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-215">Depending on how these images are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference `myimage:latest` from a `docker-compose` file.</span></span>

<span data-ttu-id="ddb5e-216">I modelli di Azure DevOps Services consentono di creare artefatti di compilazione contenenti i codici hash dell'immagine del registro specifici che identificano in modo univoco lo stesso binario immagine.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-216">The Azure DevOps Services templates give you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="ddb5e-217">Si tratta degli elementi che si vuole usare come input per una versione.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-217">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-azure-devops-services-release-management"></a><span data-ttu-id="ddb5e-218">Gestione dei rilasci per gli ambienti Docker tramite la gestione del rilascio di Azure DevOps Services</span><span class="sxs-lookup"><span data-stu-id="ddb5e-218">Managing releases to Docker environments by using Azure DevOps Services Release Management</span></span>

<span data-ttu-id="ddb5e-219">Usando i modelli di Azure DevOps Services è possibile compilare una nuova immagine, pubblicarla in un registro Docker, eseguirla su host Linux o Windows e usare comandi, ad esempio `docker-compose`, per distribuire più contenitori come applicazione completa, il tutto tramite le funzionalità di gestione del rilascio di Azure DevOps Services progettate per più ambienti, come illustrato nella figura 5-8.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-219">Through the Azure DevOps Services templates, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as `docker-compose` to deploy multiple containers as an entire application, all through the Azure DevOps Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![Screenshot che mostra la configurazione delle versioni di composizione Docker.](./media/docker-application-outer-loop-devops-workflow/configure-docker-compose-release.png)

<span data-ttu-id="ddb5e-221">**Figura 5-8**.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-221">**Figure 5-8**.</span></span> <span data-ttu-id="ddb5e-222">Configurazione delle attività Docker Compose di Azure DevOps Services dalla gestione del rilascio di Azure DevOps Services</span><span class="sxs-lookup"><span data-stu-id="ddb5e-222">Configuring Azure DevOps Services Docker Compose tasks from Azure DevOps Services Release Management</span></span>

<span data-ttu-id="ddb5e-223">Tenere presente che lo scenario illustrato nella figura 5-6 e implementato nella figura 5-8 è uno scenario semplice (la distribuzione viene eseguita in host Docker e macchine virtuali singoli con un contenitore o istanza per ogni immagine) che probabilmente verrà usato solo per scenari di sviluppo o test.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-223">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is a simple one (it's deploying to single Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="ddb5e-224">Nella maggior parte degli scenari di produzione si preferisce disporre di disponibilità elevata e di una scalabilità facile da gestire con un bilanciamento del carico su più nodi, server e macchine virtuali e "failover intelligenti" in modo che se si verifica un errore in un server o in un nodo, i relativi servizi e contenitori vengano spostati in un altro server o un'altra macchina virtuale host.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-224">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="ddb5e-225">In quel caso saranno necessarie tecnologie più avanzate, ad esempio cluster di contenitori, agenti di orchestrazione e utilità di pianificazione.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-225">In that case, you need more advanced technologies such as container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="ddb5e-226">Di conseguenza, la distribuzione nei cluster avviene gestendo gli scenari avanzati descritti nella sezione seguente.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-226">Thus, the way to deploy to those clusters is by handling the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-docker-applications-to-docker-clusters"></a><span data-ttu-id="ddb5e-227">Distribuzione di applicazioni Docker in cluster Docker</span><span class="sxs-lookup"><span data-stu-id="ddb5e-227">Deploying Docker applications to Docker clusters</span></span>

<span data-ttu-id="ddb5e-228">Le applicazioni distribuite richiedono risorse di calcolo distribuite.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-228">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="ddb5e-229">Per avere capacità a livello di produzione, è necessario avere capacità di clustering che offrono scalabilità e disponibilità elevate basate su risorse in pool.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-229">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and high availability based on pooled resources.</span></span>

<span data-ttu-id="ddb5e-230">Sebbene sia possibile distribuire i contenitori manualmente in questo tipo di cluster da uno strumento dell'interfaccia della riga di comando o un'interfaccia utente Web, è consigliabile riservare questo tipo di lavoro manuale per individuare operazioni di test o gestione delle distribuzioni come scalabilità o monitoraggio.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-230">You could deploy containers manually to those clusters from a CLI tool or a web UI, but you should reserve that kind of manual work to spot deployment testing or management purposes like scaling-out or monitoring.</span></span>

<span data-ttu-id="ddb5e-231">Dal punto di vista della distribuzione continua, in particolare di Azure DevOps Services, è possibile eseguire attività specifiche per la distribuzione dagli ambienti di gestione del rilascio di Azure DevOps Services che eseguiranno la distribuzione delle applicazioni aggiunte a contenitori in cluster distribuiti nel servizio contenitore, come illustrato nella figura 5-9.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-231">From a CD point of view, and Azure DevOps Services specifically, you can run specially made deployment tasks from your Azure DevOps Services Release Management environments that will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![Diagramma che mostra il passaggio di distribuzione del CD che distribuisce agli agenti di orchestrazione.](./media/docker-application-outer-loop-devops-workflow/cd-deploy-to-orchestrators.png)

<span data-ttu-id="ddb5e-233">**Figura 5-9**.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-233">**Figure 5-9**.</span></span> <span data-ttu-id="ddb5e-234">Distribuzione di applicazioni distribuite nel servizio contenitore</span><span class="sxs-lookup"><span data-stu-id="ddb5e-234">Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="ddb5e-235">Inizialmente, durante la distribuzione in determinati cluster o agenti di orchestrazione, venivano in genere usati script e meccanismi di distribuzione specifici per ogni agente di orchestrazione (Kubernetes e Service Fabric hanno meccanismi di distribuzione diversi) anziché lo strumento `docker-compose` più semplice e facile da usare basato sul file di definizione `docker-compose.yml`.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-235">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Kubernetes and Service Fabric have different deployment mechanisms) instead of the simpler and easy-to-use `docker-compose` tool based on the `docker-compose.yml` definition file.</span></span> <span data-ttu-id="ddb5e-236">Tuttavia, grazie all'attività Distribuisci Docker servizi DevOps di Azure, illustrata nella Figura 5-10, `docker-compose.yml` è ora anche possibile distribuire agli agenti `docker-compose.yml` di orchestrazione supportati usando semplicemente il file familiare perché lo strumento esegue automaticamente tale "traduzione" (dal file al formato richiesto dall'agente di orchestrazione).</span><span class="sxs-lookup"><span data-stu-id="ddb5e-236">However, thanks to the Azure DevOps Services Docker Deploy task, shown in Figure 5-10, you now also can deploy to the supported orchestrators by just using your familiar `docker-compose.yml` file because the tool performs that "translation" for you (from your `docker-compose.yml` file to the format needed by the orchestrator).</span></span>

![Screenshot che mostra l'attività Distribuisci a Kubernetes.](./media/docker-application-outer-loop-devops-workflow/add-deploy-to-kubernetes-task.png)

<span data-ttu-id="ddb5e-238">**Figura 5-10**.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-238">**Figure 5-10**.</span></span> <span data-ttu-id="ddb5e-239">Aggiunta dell'attività Distribuisci in Kubernetes all'ambiente</span><span class="sxs-lookup"><span data-stu-id="ddb5e-239">Adding the Deploy to Kubernetes task to your Environment</span></span>

<span data-ttu-id="ddb5e-240">La figura 5-11 illustra come modificare l'attività Distribuisci in Kubernetes con le sezioni disponibili per la configurazione.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-240">Figure 5-11 demonstrates how you can edit the Deploy to Kubernetes task with the sections available for configuration.</span></span> <span data-ttu-id="ddb5e-241">Questa attività recupera le immagini Docker personalizzate pronte all'uso da distribuire come contenitori nel cluster.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-241">This is the task that will retrieve your ready-to-use custom Docker images to be deployed as containers in the cluster.</span></span>

![Screenshot che mostra la configurazione dell'attività Distribuisci in Kubernetes.](./media/docker-application-outer-loop-devops-workflow/edit-deploy-to-kubernetes-task.png)

<span data-ttu-id="ddb5e-243">**Figura 5-11**.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-243">**Figure 5-11**.</span></span> <span data-ttu-id="ddb5e-244">Definizione dell'attività Distribuzione di Docker con distribuzione in DC/OS di ACS</span><span class="sxs-lookup"><span data-stu-id="ddb5e-244">Docker Deploy task definition deploying to ACS DC/OS</span></span>

> [!INFORMATION]<span data-ttu-id="ddb5e-245"> Per altre informazioni sulla pipeline di distribuzione continua con Azure DevOps Services e Docker, visitare <https://azure.microsoft.com/services/devops/pipelines></span><span class="sxs-lookup"><span data-stu-id="ddb5e-245"> To read more about the CD pipeline with Azure DevOps Services and Docker, visit <https://azure.microsoft.com/services/devops/pipelines></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="ddb5e-246">Passaggio 5: Eseguire e gestire</span><span class="sxs-lookup"><span data-stu-id="ddb5e-246">Step 5: Run and manage</span></span>

<span data-ttu-id="ddb5e-247">Poiché l'esecuzione e la gestione di applicazioni a livello di produzione aziendale sono una questione della massima importanza e considerato il tipo di operazioni e gli utenti che operano a quel livello (operazioni IT) e l'enorme ambito di quest'area, l'intero capitolo successivo è dedicato a questi argomenti.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-247">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, the entire next chapter is devoted to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="ddb5e-248">Passaggio 6: Monitorare e diagnosticare</span><span class="sxs-lookup"><span data-stu-id="ddb5e-248">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="ddb5e-249">Questo argomento è trattato anche nel capitolo successivo come parte delle attività eseguite dal settore IT nei sistemi di produzione. È importante tuttavia sottolineare che le informazioni dettagliate ottenute in questo passaggio devono essere inviate al team di sviluppo per consentire un miglioramento continuo dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-249">This topic also is covered in the next chapter as part of the tasks that IT performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="ddb5e-250">Da questo punto di vista, è anche parte di DevOps, sebbene le attività e le operazioni vengano in genere eseguite dal settore IT.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-250">From that point of view, it's also part of DevOps, although the tasks and operations are commonly performed by IT.</span></span>

<span data-ttu-id="ddb5e-251">Soltanto al completamento del monitoraggio e della diagnostica in DevOps, il team di sviluppo esegue i processi di monitoraggio e analisi negli ambienti di test o beta.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-251">Only when monitoring and diagnostics are 100% within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="ddb5e-252">Questa operazione viene eseguita tramite l'esecuzione di test di carico o monitorando gli ambienti beta o di controllo di qualità in cui i beta tester provano a usare le nuove versioni.</span><span class="sxs-lookup"><span data-stu-id="ddb5e-252">This is done either by performing load testing or by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="ddb5e-253">[Successivo](index.md)
>[precedente](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span><span class="sxs-lookup"><span data-stu-id="ddb5e-253">[Previous](index.md)
[Next](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span></span>
