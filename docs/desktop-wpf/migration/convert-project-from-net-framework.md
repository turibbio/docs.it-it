---
title: Migrazione di app WPF a .NET Core 3,0
description: Informazioni su come eseguire la migrazione di un'app Windows Presentation Foundation (WPF) a .NET Core 3,0.
author: mjrousos
ms.date: 09/12/2019
ms.author: mikerou
ms.openlocfilehash: ccd2fc5a49d9c2d31c693e48099732614b568c7b
ms.sourcegitcommit: 1cb64b53eb1f253e6a3f53ca9510ef0be1fd06fe
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/29/2020
ms.locfileid: "82507455"
---
# <a name="migrating-wpf-apps-to-net-core"></a><span data-ttu-id="b26a3-103">Migrazione di app WPF a .NET Core</span><span class="sxs-lookup"><span data-stu-id="b26a3-103">Migrating WPF apps to .NET Core</span></span>

<span data-ttu-id="b26a3-104">Questo articolo illustra i passaggi necessari per eseguire la migrazione di un'app Windows Presentation Foundation (WPF) da .NET Framework a .NET Core 3,0.</span><span class="sxs-lookup"><span data-stu-id="b26a3-104">This article covers the steps necessary to migrate a Windows Presentation Foundation (WPF) app from .NET Framework to .NET Core 3.0.</span></span> <span data-ttu-id="b26a3-105">Se non si ha un'app WPF a disposizione per la porta, ma si vuole provare il processo, è possibile usare l'app **Bean trader** di esempio disponibile in [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span><span class="sxs-lookup"><span data-stu-id="b26a3-105">If you don't have a WPF app on hand to port, but would like to try out the process, you can use the **Bean Trader** sample app available on [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span></span> <span data-ttu-id="b26a3-106">L'app originale (destinazione .NET Framework 4.7.2) è disponibile nella cartella NetFx\BeanTraderClient.</span><span class="sxs-lookup"><span data-stu-id="b26a3-106">The original app (targeting .NET Framework 4.7.2) is available in the NetFx\BeanTraderClient folder.</span></span> <span data-ttu-id="b26a3-107">Prima di tutto verranno illustrati i passaggi necessari per la portabilità delle app in generale e verranno illustrate le modifiche specifiche che si applicano all'esempio **Bean trader** .</span><span class="sxs-lookup"><span data-stu-id="b26a3-107">First we'll explain the steps necessary to port apps in general, and then we'll walk through the specific changes that apply to the **Bean Trader** sample.</span></span>

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

<span data-ttu-id="b26a3-108">Per eseguire la migrazione a .NET Core, è prima di tutto necessario:</span><span class="sxs-lookup"><span data-stu-id="b26a3-108">To migrate to .NET Core, you must first:</span></span>

01. <span data-ttu-id="b26a3-109">Comprendere e aggiornare le dipendenze NuGet:</span><span class="sxs-lookup"><span data-stu-id="b26a3-109">Understand and update NuGet dependencies:</span></span>

    01. <span data-ttu-id="b26a3-110">Aggiornare le dipendenze NuGet per `<PackageReference>` usare il formato.</span><span class="sxs-lookup"><span data-stu-id="b26a3-110">Upgrade NuGet dependencies to use the `<PackageReference>` format.</span></span>
    01. <span data-ttu-id="b26a3-111">Esaminare le dipendenze NuGet di primo livello per la compatibilità con .NET Core o .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="b26a3-111">Review top-level NuGet dependencies for .NET Core or .NET Standard compatibility.</span></span>
    01. <span data-ttu-id="b26a3-112">Aggiornare i pacchetti NuGet a versioni più recenti.</span><span class="sxs-lookup"><span data-stu-id="b26a3-112">Upgrade NuGet packages to newer versions.</span></span>
    01. <span data-ttu-id="b26a3-113">Usare [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) per comprendere le dipendenze di .NET.</span><span class="sxs-lookup"><span data-stu-id="b26a3-113">Use the [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) to understand .NET dependencies.</span></span>

01. <span data-ttu-id="b26a3-114">Migrare il file di progetto nel nuovo formato di tipo SDK:</span><span class="sxs-lookup"><span data-stu-id="b26a3-114">Migrate the project file to the new SDK-style format:</span></span>

    01. <span data-ttu-id="b26a3-115">Scegliere se destinare sia a .NET Core sia a .NET Framework o solo a .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-115">Choose whether to target both .NET Core and .NET Framework, or only .NET Core.</span></span>
    01. <span data-ttu-id="b26a3-116">Copiare gli elementi e le proprietà del file di progetto pertinenti nel nuovo file di progetto.</span><span class="sxs-lookup"><span data-stu-id="b26a3-116">Copy relevant project file properties and items to the new project file.</span></span>

01. <span data-ttu-id="b26a3-117">Risolvere i problemi di compilazione:</span><span class="sxs-lookup"><span data-stu-id="b26a3-117">Fix build issues:</span></span>

    01. <span data-ttu-id="b26a3-118">Aggiungere un riferimento al pacchetto [Microsoft. Windows. Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) .</span><span class="sxs-lookup"><span data-stu-id="b26a3-118">Add a reference to the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) package.</span></span>
    01. <span data-ttu-id="b26a3-119">Trovare e correggere le differenze a livello di API.</span><span class="sxs-lookup"><span data-stu-id="b26a3-119">Find and fix API-level differences.</span></span>
    01. <span data-ttu-id="b26a3-120">Rimuovere le sezioni di *app. config* `appSettings` diverse `connectionStrings`da o.</span><span class="sxs-lookup"><span data-stu-id="b26a3-120">Remove *app.config* sections other than `appSettings` or `connectionStrings`.</span></span>
    01. <span data-ttu-id="b26a3-121">Rigenerare il codice generato, se necessario.</span><span class="sxs-lookup"><span data-stu-id="b26a3-121">Regenerate generated code, if necessary.</span></span>

01. <span data-ttu-id="b26a3-122">Test di runtime:</span><span class="sxs-lookup"><span data-stu-id="b26a3-122">Runtime testing:</span></span>

    01. <span data-ttu-id="b26a3-123">Verificare che l'app portata funzioni come previsto.</span><span class="sxs-lookup"><span data-stu-id="b26a3-123">Confirm the ported app works as expected.</span></span>
    01. <span data-ttu-id="b26a3-124">Prestare attenzione <xref:System.NotSupportedException> alle eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b26a3-124">Beware of <xref:System.NotSupportedException> exceptions.</span></span>

## <a name="about-the-sample"></a><span data-ttu-id="b26a3-125">Informazioni sull'esempio</span><span class="sxs-lookup"><span data-stu-id="b26a3-125">About the sample</span></span>

<span data-ttu-id="b26a3-126">Questo articolo fa riferimento all' [app Bean trader di esempio](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) perché usa un'ampia gamma di dipendenze simili a quelle che possono avere le app WPF reali.</span><span class="sxs-lookup"><span data-stu-id="b26a3-126">This article references the [Bean Trader sample app](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) because it uses a variety of dependencies similar to those that real-world WPF apps might have.</span></span> <span data-ttu-id="b26a3-127">L'app non è di grandi dimensioni, ma è concepita come un passaggio da "Hello World" in termini di complessità.</span><span class="sxs-lookup"><span data-stu-id="b26a3-127">The app isn't large, but is meant to be a step up from 'Hello World' in terms of complexity.</span></span> <span data-ttu-id="b26a3-128">L'app illustra alcuni problemi che possono verificarsi durante il trasferimento di app reali.</span><span class="sxs-lookup"><span data-stu-id="b26a3-128">The app demonstrates some issues users may encounter while porting real apps.</span></span> <span data-ttu-id="b26a3-129">L'app comunica con un servizio WCF, in modo che venga eseguita correttamente, sarà anche necessario eseguire il progetto BeanTraderServer (disponibile nello stesso repository GitHub) e assicurarsi che la configurazione di BeanTraderClient punti all'endpoint corretto.</span><span class="sxs-lookup"><span data-stu-id="b26a3-129">The app communicates with a WCF service, so for it to run properly, you'll also need to run the BeanTraderServer project (available in the same GitHub repository) and make sure the BeanTraderClient configuration points to the correct endpoint.</span></span> <span data-ttu-id="b26a3-130">Per impostazione predefinita, nell'esempio si presuppone che il server sia in esecuzione nello stesso *http://localhost:8090*computer in, che sarà true se si avvia BeanTraderServer localmente.</span><span class="sxs-lookup"><span data-stu-id="b26a3-130">(By default, the sample assumes the server is running on the same machine at *http://localhost:8090*, which will be true if you launch BeanTraderServer locally.)</span></span>

<span data-ttu-id="b26a3-131">Tenere presente che questa applicazione di esempio ha lo scopo di illustrare le soluzioni e le soluzioni di porting di .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-131">Keep in mind that this sample app is meant to demonstrate .NET Core porting challenges and solutions.</span></span> <span data-ttu-id="b26a3-132">Non è progettato per illustrare le procedure consigliate per WPF.</span><span class="sxs-lookup"><span data-stu-id="b26a3-132">It's not meant to demonstrate WPF best practices.</span></span> <span data-ttu-id="b26a3-133">In realtà, include deliberatamente alcuni anti-modelli per assicurarsi di affrontare almeno un paio di problemi interessanti durante il trasferimento.</span><span class="sxs-lookup"><span data-stu-id="b26a3-133">In fact, it deliberately includes some anti-patterns to make sure you come across at least a couple of interesting challenges while porting.</span></span>

## <a name="getting-ready"></a><span data-ttu-id="b26a3-134">Preparazione</span><span class="sxs-lookup"><span data-stu-id="b26a3-134">Getting ready</span></span>

<span data-ttu-id="b26a3-135">Il problema principale della migrazione di un'app .NET Framework a .NET Core è che le dipendenze possono funzionare in modo diverso o non.</span><span class="sxs-lookup"><span data-stu-id="b26a3-135">The primary challenge of migrating a .NET Framework app to .NET Core is that its dependencies may work differently or not at all.</span></span> <span data-ttu-id="b26a3-136">La migrazione è molto più semplice rispetto a quella usata. molti pacchetti NuGet ora hanno come destinazione .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="b26a3-136">Migration is much easier than it used to be; many NuGet packages now target .NET Standard.</span></span> <span data-ttu-id="b26a3-137">A partire da .NET Core 2,0, le aree di superficie .NET Framework e .NET Core sono diventate simili.</span><span class="sxs-lookup"><span data-stu-id="b26a3-137">Starting with .NET Core 2.0, the .NET Framework and .NET Core surface areas have become similar.</span></span> <span data-ttu-id="b26a3-138">Anche in questo caso, vengono mantenute alcune differenze (sia per il supporto dei pacchetti NuGet che nelle API .NET disponibili).</span><span class="sxs-lookup"><span data-stu-id="b26a3-138">Even so, some differences (both in support from NuGet packages and in available .NET APIs) remain.</span></span> <span data-ttu-id="b26a3-139">Il primo passaggio della migrazione consiste nel rivedere le dipendenze dell'app e verificare che i riferimenti siano in un formato facilmente migrabile a .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-139">The first step in migrating is to review the app's dependencies and make sure references are in a format that's easily migrated to .NET Core.</span></span>

### <a name="upgrade-to-packagereference-nuget-references"></a><span data-ttu-id="b26a3-140">Aggiornare i `<PackageReference>` riferimenti a NuGet</span><span class="sxs-lookup"><span data-stu-id="b26a3-140">Upgrade to `<PackageReference>` NuGet references</span></span>

<span data-ttu-id="b26a3-141">I progetti di .NET Framework precedenti in genere elencano le dipendenze NuGet in un file *packages. config* .</span><span class="sxs-lookup"><span data-stu-id="b26a3-141">Older .NET Framework projects typically list their NuGet dependencies in a *packages.config* file.</span></span> <span data-ttu-id="b26a3-142">Il nuovo formato di file di progetto in stile SDK fa riferimento [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) ai pacchetti NuGet come elementi nel file csproj, anziché in un file di configurazione separato.</span><span class="sxs-lookup"><span data-stu-id="b26a3-142">The new SDK-style project file format references NuGet packages as [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) elements in the csproj file itself rather than in a separate config file.</span></span>

<span data-ttu-id="b26a3-143">Quando si esegue la migrazione, sono disponibili due `<PackageReference>`vantaggi per l'uso di riferimenti in stile:</span><span class="sxs-lookup"><span data-stu-id="b26a3-143">When migrating, there are two advantages to using `<PackageReference>`-style references:</span></span>

- <span data-ttu-id="b26a3-144">Questo è lo stile del riferimento NuGet necessario per il nuovo file di progetto .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-144">This is the style of NuGet reference that is required for the new .NET Core project file.</span></span> <span data-ttu-id="b26a3-145">Se si usa `<PackageReference>`già, gli elementi del file di progetto possono essere copiati e incollati direttamente nel nuovo progetto.</span><span class="sxs-lookup"><span data-stu-id="b26a3-145">If you're already using `<PackageReference>`, those project file elements can be copied and pasted directly into the new project.</span></span>
- <span data-ttu-id="b26a3-146">A differenza di un file Packages. `<PackageReference>` config, gli elementi fanno riferimento solo alle dipendenze di livello superiore da cui il progetto dipende direttamente.</span><span class="sxs-lookup"><span data-stu-id="b26a3-146">Unlike a packages.config file, `<PackageReference>` elements only refer to the top-level dependencies that your project depends on directly.</span></span> <span data-ttu-id="b26a3-147">Tutti gli altri pacchetti NuGet transitivi verranno determinati in fase di ripristino e registrati nel file obj\project.assets.JSON generato automaticamente.</span><span class="sxs-lookup"><span data-stu-id="b26a3-147">All other transitive NuGet packages will be determined at restore time and recorded in the autogenerated obj\project.assets.json file.</span></span> <span data-ttu-id="b26a3-148">In questo modo è molto più semplice determinare le dipendenze del progetto, che risulta utile quando si determina se le dipendenze necessarie funzioneranno o meno in .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-148">This makes it much easier to determine what dependencies your project has, which is useful when determining whether the necessary dependencies will work on .NET Core or not.</span></span>

<span data-ttu-id="b26a3-149">Il primo passaggio per eseguire la migrazione di un'app .NET Framework a .NET Core consiste nell'aggiornarlo per l'uso `<PackageReference>` dei riferimenti NuGet.</span><span class="sxs-lookup"><span data-stu-id="b26a3-149">The first step to migrating a .NET Framework app to .NET Core is to update it to use `<PackageReference>` NuGet references.</span></span> <span data-ttu-id="b26a3-150">Visual Studio rende questa operazione semplice.</span><span class="sxs-lookup"><span data-stu-id="b26a3-150">Visual Studio makes this simple.</span></span> <span data-ttu-id="b26a3-151">È sufficiente fare clic con il pulsante destro del mouse sul file *packages. config* del progetto in **Esplora soluzioni**di Visual Studio, quindi selezionare **Esegui la migrazione di Packages. config a PackageReference**.</span><span class="sxs-lookup"><span data-stu-id="b26a3-151">Just right-click the project's *packages.config* file in Visual Studio's **Solution Explorer**, and then select **Migrate packages.config to PackageReference**.</span></span>

![Aggiornamento a PackageReference](./media/convert-project-from-net-framework/package-reference-migration.png)

<span data-ttu-id="b26a3-153">Viene visualizzata una finestra di dialogo che mostra le dipendenze NuGet di primo livello calcolate e chiede quali altri pacchetti NuGet devono essere promossi a livello superiore.</span><span class="sxs-lookup"><span data-stu-id="b26a3-153">A dialog appears showing calculated top-level NuGet dependencies and asking which other NuGet packages should be promoted to top-level.</span></span> <span data-ttu-id="b26a3-154">Nessuno di questi altri pacchetti deve essere di primo livello per l'esempio Bean trader, quindi è possibile deselezionare tutte le caselle.</span><span class="sxs-lookup"><span data-stu-id="b26a3-154">None of these other packages need to be top-level for the Bean Trader sample, so you can uncheck all of those boxes.</span></span> <span data-ttu-id="b26a3-155">Quindi, fare clic su **OK** e il file *packages. config* verrà rimosso e `<PackageReference>` gli elementi verranno aggiunti al file di progetto.</span><span class="sxs-lookup"><span data-stu-id="b26a3-155">Then, click **Ok** and the *packages.config* file is removed and `<PackageReference>` elements are added to the project file.</span></span>

<span data-ttu-id="b26a3-156">`<PackageReference>`i riferimenti di tipo non archiviano i pacchetti NuGet localmente in una cartella di pacchetti.</span><span class="sxs-lookup"><span data-stu-id="b26a3-156">`<PackageReference>`-style references don't store NuGet packages locally in a packages folder.</span></span> <span data-ttu-id="b26a3-157">Sono invece archiviati globalmente come ottimizzazione.</span><span class="sxs-lookup"><span data-stu-id="b26a3-157">Instead, they're stored globally as an optimization.</span></span> <span data-ttu-id="b26a3-158">Al termine della migrazione, modificare il file csproj e rimuovere tutti `<Analyzer>` gli elementi che fanno riferimento agli analizzatori che in precedenza provengono da *.. Directory \Packages* .</span><span class="sxs-lookup"><span data-stu-id="b26a3-158">After the migration completes, edit the csproj file and remove any `<Analyzer>` elements referring to the analyzers that previously came from the *..\packages* directory.</span></span> <span data-ttu-id="b26a3-159">Nessun problema; Poiché sono ancora presenti i riferimenti ai pacchetti NuGet, gli analizzatori verranno inclusi nel progetto.</span><span class="sxs-lookup"><span data-stu-id="b26a3-159">Don't worry; since you still have the NuGet package references, the analyzers will be included in the project.</span></span> <span data-ttu-id="b26a3-160">È sufficiente pulire i vecchi elementi di tipo `<Analyzer>` Packages. config.</span><span class="sxs-lookup"><span data-stu-id="b26a3-160">You just need to clean up the old packages.config-style `<Analyzer>` elements.</span></span>

### <a name="review-nuget-packages"></a><span data-ttu-id="b26a3-161">Esaminare i pacchetti NuGet</span><span class="sxs-lookup"><span data-stu-id="b26a3-161">Review NuGet packages</span></span>

<span data-ttu-id="b26a3-162">Ora che è possibile visualizzare i pacchetti NuGet di primo livello da cui dipende il progetto, è possibile verificare se tali pacchetti sono disponibili in .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-162">Now that you can see the top-level NuGet packages that the project depends on, you can review whether those packages are available on .NET Core.</span></span> <span data-ttu-id="b26a3-163">È possibile determinare se un pacchetto supporta .NET Core osservando le relative dipendenze in [NuGet.org](https://www.nuget.org/). Il sito [fuget.org](https://www.fuget.org/) creato dalla community Mostra queste informazioni in primo piano nella parte superiore della pagina delle informazioni sul pacchetto.</span><span class="sxs-lookup"><span data-stu-id="b26a3-163">You can determine whether a package supports .NET Core by looking at its dependencies on [nuget.org](https://www.nuget.org/). The community-created [fuget.org](https://www.fuget.org/) site shows this information prominently at the top of the package information page.</span></span>

<span data-ttu-id="b26a3-164">Quando la destinazione è .NET Core 3,0, tutti i pacchetti destinati a .NET Core o .NET Standard dovrebbero funzionare (poiché .NET Core implementa la superficie di attacco .NET Standard).</span><span class="sxs-lookup"><span data-stu-id="b26a3-164">When targeting .NET Core 3.0, any packages targeting .NET Core or .NET Standard should work (since .NET Core implements the .NET Standard surface area).</span></span> <span data-ttu-id="b26a3-165">In alcuni casi, la versione specifica di un pacchetto usato non sarà destinata a .NET Core o .NET Standard, ma saranno disponibili versioni più recenti.</span><span class="sxs-lookup"><span data-stu-id="b26a3-165">In some cases, the specific version of a package that's used won't target .NET Core or .NET Standard, but newer versions will.</span></span> <span data-ttu-id="b26a3-166">In questo caso, è consigliabile eseguire l'aggiornamento alla versione più recente del pacchetto.</span><span class="sxs-lookup"><span data-stu-id="b26a3-166">In this case, you should consider upgrading to the latest version of the package.</span></span>

<span data-ttu-id="b26a3-167">È anche possibile usare i pacchetti destinati a .NET Framework, ma ciò comporta un certo rischio.</span><span class="sxs-lookup"><span data-stu-id="b26a3-167">You can use packages targeting .NET Framework, as well, but that introduces some risk.</span></span> <span data-ttu-id="b26a3-168">Sono consentite le dipendenze di .NET Core per .NET Framework perché .NET Core e .NET Framework aree di attacco sono sufficientemente simili che *spesso* tali dipendenze funzionano.</span><span class="sxs-lookup"><span data-stu-id="b26a3-168">.NET Core to .NET Framework dependencies are allowed because .NET Core and .NET Framework surface areas are similar enough that such dependencies *often* work.</span></span> <span data-ttu-id="b26a3-169">Tuttavia, se il pacchetto tenta di usare un'API .NET che non è presente in .NET Core, si verificherà un'eccezione di Runtime.</span><span class="sxs-lookup"><span data-stu-id="b26a3-169">However, if the package tries to use a .NET API that isn't present in .NET Core, you'll encounter a runtime exception.</span></span> <span data-ttu-id="b26a3-170">Per questo motivo, è consigliabile fare riferimento ai pacchetti .NET Framework solo quando non sono disponibili altre opzioni e comprendere che questa operazione impone un carico di test.</span><span class="sxs-lookup"><span data-stu-id="b26a3-170">Because of that, you should only reference .NET Framework packages when no other options are available and understand that doing so imposes a test burden.</span></span>

<span data-ttu-id="b26a3-171">Se sono presenti pacchetti a cui si fa riferimento che non sono destinati a .NET Core o .NET Standard, è necessario considerare altre alternative:</span><span class="sxs-lookup"><span data-stu-id="b26a3-171">If there are packages referenced that don't target .NET Core or .NET Standard, you'll have to think about other alternatives:</span></span>

- <span data-ttu-id="b26a3-172">Sono presenti altri pacchetti simili che è possibile usare in alternativa?</span><span class="sxs-lookup"><span data-stu-id="b26a3-172">Are there other similar packages that can be used instead?</span></span> <span data-ttu-id="b26a3-173">Talvolta gli autori NuGet pubblicano un separatore. Versioni di base delle librerie destinate specificamente a .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-173">Sometimes NuGet authors publish separate '.Core' versions of their libraries specifically targeting .NET Core.</span></span> <span data-ttu-id="b26a3-174">I pacchetti della libreria Enterprise sono un esempio della pubblicazione della community ". NetCore "alternative.</span><span class="sxs-lookup"><span data-stu-id="b26a3-174">Enterprise Library packages are an example of the community publishing ".NetCore" alternatives.</span></span> <span data-ttu-id="b26a3-175">In altri casi, gli SDK più recenti per un servizio specifico (talvolta con nomi di pacchetto diversi) sono disponibili per .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="b26a3-175">In other cases, newer SDKs for a particular service (sometimes with different package names) are available for .NET Standard.</span></span> <span data-ttu-id="b26a3-176">Se non sono disponibili alternative, è possibile continuare a usare i pacchetti di destinazione .NET Framework, tenendo presente che è necessario testarli accuratamente una volta in esecuzione in .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-176">If no alternatives are available, you can proceed using the .NET Framework-targeted packages, bearing in mind that you'll need to test them thoroughly once running on .NET Core.</span></span>

<span data-ttu-id="b26a3-177">L'esempio Bean trader presenta le seguenti dipendenze NuGet di primo livello:</span><span class="sxs-lookup"><span data-stu-id="b26a3-177">The Bean Trader sample has the following top-level NuGet dependencies:</span></span>

- [<span data-ttu-id="b26a3-178">**Castle. Windsor, versione 4.1.1**</span><span class="sxs-lookup"><span data-stu-id="b26a3-178">**Castle.Windsor, version 4.1.1**</span></span>](https://www.castleproject.org/projects/windsor/)  

  <span data-ttu-id="b26a3-179">Questo pacchetto è destinato a .NET Standard 1,6, quindi funziona in .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-179">This package targets .NET Standard 1.6, so it works on .NET Core.</span></span>

- [<span data-ttu-id="b26a3-180">**Microsoft. CodeAnalysis. FxCopAnalyzers, versione 2.6.3**</span><span class="sxs-lookup"><span data-stu-id="b26a3-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, version 2.6.3**</span></span>](https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/2.6.3)  
  <span data-ttu-id="b26a3-181">Si tratta di un metapacchetto, quindi non è immediatamente ovvio quali sono le piattaforme supportate, ma la [documentazione](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indica che la versione più recente (2.9.2) funzionerà sia per .NET Framework sia per .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-181">This is a meta-package, so it's not immediately obvious which platforms it supports, but [documentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indicates that its newest version (2.9.2) will work for both .NET Framework and .NET Core.</span></span>

- [<span data-ttu-id="b26a3-182">**Nito. AsyncEx, versione 4.0.1**</span><span class="sxs-lookup"><span data-stu-id="b26a3-182">**Nito.AsyncEx, version 4.0.1**</span></span>](https://www.nuget.org/packages/Nito.AsyncEx/4.0.1)  

  <span data-ttu-id="b26a3-183">Questo pacchetto non è destinato a .NET Core, ma è la versione più recente di 5,0.</span><span class="sxs-lookup"><span data-stu-id="b26a3-183">This package doesn't target .NET Core, but the newer 5.0 version does.</span></span> <span data-ttu-id="b26a3-184">Si tratta di un'operazione comune durante la migrazione perché molti pacchetti NuGet hanno aggiunto .NET Standard supporto di recente, ma le versioni precedenti del progetto avranno come destinazione solo .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b26a3-184">This is common when migrating because many NuGet packages have added .NET Standard support recently, but older project versions will only target .NET Framework.</span></span> <span data-ttu-id="b26a3-185">Se la differenza di versione è solo una differenza di versione secondaria, spesso è facile eseguire l'aggiornamento alla versione più recente.</span><span class="sxs-lookup"><span data-stu-id="b26a3-185">If the version difference is only a minor version difference, it's often easy to upgrade to the newer version.</span></span> <span data-ttu-id="b26a3-186">Poiché si tratta di una modifica di versione principale, è necessario eseguire un aggiornamento prudente poiché potrebbero verificarsi modifiche di rilievo nel pacchetto.</span><span class="sxs-lookup"><span data-stu-id="b26a3-186">Because this is a major version change, you need to be cautious upgrading since there could be breaking changes in the package.</span></span> <span data-ttu-id="b26a3-187">Tuttavia, esiste un percorso positivo.</span><span class="sxs-lookup"><span data-stu-id="b26a3-187">There is a path forward, though, which is good.</span></span>

- [<span data-ttu-id="b26a3-188">**MahApps. metro, versione 1.6.5**</span><span class="sxs-lookup"><span data-stu-id="b26a3-188">**MahApps.Metro, version 1.6.5**</span></span>](https://www.nuget.org/packages/MahApps.Metro/1.6.5)  

  <span data-ttu-id="b26a3-189">Anche questo pacchetto non è destinato a .NET Core, ma dispone di una versione non definitiva più recente (2,0-Alpha).</span><span class="sxs-lookup"><span data-stu-id="b26a3-189">This package also doesn't target .NET Core, but has a newer pre-release (2.0-alpha) that does.</span></span> <span data-ttu-id="b26a3-190">Anche in questo caso, è necessario esaminare le modifiche di rilievo, ma il pacchetto più recente è incoraggiante.</span><span class="sxs-lookup"><span data-stu-id="b26a3-190">Again, you have to look out for breaking changes, but the newer package is encouraging.</span></span>

<span data-ttu-id="b26a3-191">Le dipendenze NuGet dell'esempio Bean trader sono tutte destinate .NET Standard/. NET Core o hanno versioni più recenti, quindi è improbabile che si verifichino problemi di blocco.</span><span class="sxs-lookup"><span data-stu-id="b26a3-191">The Bean Trader sample's NuGet dependencies all either target .NET Standard/.NET Core or have newer versions that do, so there are unlikely to be any blocking issues here.</span></span>

### <a name="upgrade-nuget-packages"></a><span data-ttu-id="b26a3-192">Aggiornare i pacchetti NuGet</span><span class="sxs-lookup"><span data-stu-id="b26a3-192">Upgrade NuGet packages</span></span>

<span data-ttu-id="b26a3-193">Se possibile, è consigliabile aggiornare le versioni di tutti i pacchetti che hanno come destinazione solo .NET Core o .NET Standard con versioni più recenti in questa fase (con il progetto ancora destinato .NET Framework) per individuare e risolvere le modifiche di rilievo in anticipo.</span><span class="sxs-lookup"><span data-stu-id="b26a3-193">If possible, it would be good to upgrade the versions of any packages that only target .NET Core or .NET Standard with more recent versions at this point (with the project still targeting .NET Framework) to discover and address any breaking changes early.</span></span>

<span data-ttu-id="b26a3-194">Se non si apportano modifiche sostanziali alla versione .NET Framework esistente dell'app, questo può attendere fino a quando non si dispone di un nuovo file di progetto destinato a .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-194">If you would rather not make any material changes to the existing .NET Framework version of the app, this can wait until you have a new project file targeting .NET Core.</span></span> <span data-ttu-id="b26a3-195">Tuttavia, l'aggiornamento dei pacchetti NuGet a versioni compatibili con .NET Core in anticipo rende ancora più semplice il processo di migrazione dopo aver creato il nuovo file di progetto e ridotto il numero di differenze tra le versioni .NET Framework e .NET Core dell'app.</span><span class="sxs-lookup"><span data-stu-id="b26a3-195">However, upgrading the NuGet packages to .NET Core-compatible versions ahead of time makes the migration process even easier once you create the new project file and reduces the number of differences between the .NET Framework and .NET Core versions of the app.</span></span>

<span data-ttu-id="b26a3-196">Con l'esempio Bean trader, tutti gli aggiornamenti necessari possono essere resi facilmente (usando Gestione pacchetti NuGet di Visual Studio) con un'unica eccezione: l'aggiornamento da **MahApps. metro 1.6.5** a **2,0** rivela modifiche di rilievo correlate alle API di gestione dei temi e degli accenti.</span><span class="sxs-lookup"><span data-stu-id="b26a3-196">With the Bean Trader sample, all of the necessary upgrades can be made easily (using Visual Studio's NuGet package manager) with one exception: upgrading from **MahApps.Metro 1.6.5** to **2.0** reveals breaking changes related to theme and accent management APIs.</span></span>

<span data-ttu-id="b26a3-197">Idealmente, l'app verrà aggiornata in modo da usare la versione più recente del pacchetto (poiché è più probabile che funzioni in .NET Core).</span><span class="sxs-lookup"><span data-stu-id="b26a3-197">Ideally, the app would be updated to use the newer version of the package (since that is more likely to work on .NET Core).</span></span> <span data-ttu-id="b26a3-198">In alcuni casi, tuttavia, potrebbe non essere fattibile.</span><span class="sxs-lookup"><span data-stu-id="b26a3-198">In some cases, however, that may not be feasible.</span></span> <span data-ttu-id="b26a3-199">In questi casi, non aggiornare **MahApps. metro** perché le modifiche necessarie sono non semplici e questa esercitazione è incentrata sulla migrazione a .NET Core 3, non a **MahApps. metro 2.**</span><span class="sxs-lookup"><span data-stu-id="b26a3-199">In these cases, don't upgrade **MahApps.Metro** because the necessary changes are non-trivial and this tutorial focuses on migrating to .NET Core 3, not to **MahApps.Metro 2.**</span></span> <span data-ttu-id="b26a3-200">Si tratta anche di una dipendenza a basso rischio .NET Framework perché l'app Bean trader esercita solo una piccola parte di **MahApps. metro**.</span><span class="sxs-lookup"><span data-stu-id="b26a3-200">Also, this is a low-risk .NET Framework dependency because the Bean Trader app only exercises a small part of **MahApps.Metro**.</span></span> <span data-ttu-id="b26a3-201">Naturalmente, sarà necessario eseguire test per verificare che tutti gli elementi funzionino al termine della migrazione.</span><span class="sxs-lookup"><span data-stu-id="b26a3-201">It will, of course, require testing to make sure everything's working once the migration is complete.</span></span> <span data-ttu-id="b26a3-202">Se si trattasse di uno scenario reale, sarebbe opportuno archiviare un problema per tenere traccia del lavoro per passare a **MahApps. metro** versione 2,0, perché la migrazione non è ora in ritardo con un debito tecnico.</span><span class="sxs-lookup"><span data-stu-id="b26a3-202">If this were a real-world scenario, it would be good to file an issue to track the work to move to **MahApps.Metro** version 2.0 since not doing the migration now leaves behind some technical debt.</span></span>

<span data-ttu-id="b26a3-203">Una volta aggiornati i pacchetti NuGet con le versioni recenti, `<PackageReference>` il gruppo di elementi nel file di progetto Bean trader sample dovrebbe essere simile al seguente.</span><span class="sxs-lookup"><span data-stu-id="b26a3-203">Once the NuGet packages are updated to recent versions, the `<PackageReference>` item group in the Bean Trader sample's project file should look like this.</span></span>

```xml
<ItemGroup>
  <PackageReference Include="Castle.Windsor">
    <Version>4.1.1</Version>
  </PackageReference>
  <PackageReference Include="MahApps.Metro">
    <Version>1.6.5</Version>
  </PackageReference>
  <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers">
    <Version>2.9.2</Version>
  </PackageReference>
  <PackageReference Include="Nito.AsyncEx">
    <Version>5.0.0</Version>
  </PackageReference>
</ItemGroup>
```

### <a name="net-framework-portability-analysis"></a><span data-ttu-id="b26a3-204">Analisi della portabilità .NET Framework</span><span class="sxs-lookup"><span data-stu-id="b26a3-204">.NET Framework portability analysis</span></span>

<span data-ttu-id="b26a3-205">Quando si comprende lo stato delle dipendenze NuGet del progetto, l'elemento successivo da considerare è .NET Framework le dipendenze dell'API.</span><span class="sxs-lookup"><span data-stu-id="b26a3-205">Once you understand the state of your project's NuGet dependencies, the next thing to consider is .NET Framework API dependencies.</span></span> <span data-ttu-id="b26a3-206">Lo strumento [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) è utile per comprendere quali API .NET il progetto utilizza sono disponibili su altre piattaforme .NET.</span><span class="sxs-lookup"><span data-stu-id="b26a3-206">The [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) tool is useful for understanding which of the .NET APIs your project uses are available on other .NET platforms.</span></span>

<span data-ttu-id="b26a3-207">Lo strumento è un plug-in di [Visual Studio](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), uno [strumento da riga di comando](https://github.com/Microsoft/dotnet-apiport/releases)o incluso in una [semplice GUI](https://github.com/Microsoft/dotnet-apiport-ui), che semplifica le opzioni.</span><span class="sxs-lookup"><span data-stu-id="b26a3-207">The tool comes as a [Visual Studio plugin](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), a [command-line tool](https://github.com/Microsoft/dotnet-apiport/releases), or wrapped in a [simple GUI](https://github.com/Microsoft/dotnet-apiport-ui), which simplifies its options.</span></span> <span data-ttu-id="b26a3-208">Per altre informazioni sull'uso di .NET Portability Analyzer (porta API), vedere il post di Blog relativo al [porting di applicazioni desktop per .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) .</span><span class="sxs-lookup"><span data-stu-id="b26a3-208">You can read more about using the .NET Portability Analyzer (API Port) using the GUI in the [Porting desktop apps to .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog post.</span></span> <span data-ttu-id="b26a3-209">Se si preferisce usare la riga di comando, i passaggi necessari sono i seguenti:</span><span class="sxs-lookup"><span data-stu-id="b26a3-209">If you prefer to use the command line, the necessary steps are:</span></span>

1. <span data-ttu-id="b26a3-210">Scaricare [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) , se non è già presente.</span><span class="sxs-lookup"><span data-stu-id="b26a3-210">Download the [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) if you don't already have it.</span></span>
1. <span data-ttu-id="b26a3-211">Assicurarsi che l'app .NET Framework venga compilata correttamente. Questa è una valida idea prima della migrazione indipendentemente dal fatto.</span><span class="sxs-lookup"><span data-stu-id="b26a3-211">Make sure the .NET Framework app to be ported builds successfully (this is a good idea prior to migration regardless).</span></span>
1. <span data-ttu-id="b26a3-212">Eseguire la porta API con una riga di comando simile alla seguente.</span><span class="sxs-lookup"><span data-stu-id="b26a3-212">Run API Port with a command line like this.</span></span>

    ```console
    ApiPort.exe analyze -f <PathToBeanTraderBinaries> -r html -r excel -t ".NET Core"
    ```

    <span data-ttu-id="b26a3-213">L' `-f` argomento specifica il percorso contenente i binari da analizzare.</span><span class="sxs-lookup"><span data-stu-id="b26a3-213">The `-f` argument specifies the path containing the binaries to analyze.</span></span> <span data-ttu-id="b26a3-214">L' `-r` argomento specifica il formato del file di output desiderato.</span><span class="sxs-lookup"><span data-stu-id="b26a3-214">The `-r` argument specifies which output file format you want.</span></span> <span data-ttu-id="b26a3-215">L' `-t` argomento specifica la piattaforma .NET in base a cui analizzare l'utilizzo dell'API.</span><span class="sxs-lookup"><span data-stu-id="b26a3-215">The `-t` argument specifies which .NET platform to analyze API usage against.</span></span> <span data-ttu-id="b26a3-216">In questo caso, si vuole usare .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-216">In this case, you want .NET Core.</span></span>

<span data-ttu-id="b26a3-217">Quando si apre il report HTML, nella prima sezione vengono elencati tutti i file binari analizzati e la percentuale delle API .NET che usano sono disponibili nella piattaforma di destinazione.</span><span class="sxs-lookup"><span data-stu-id="b26a3-217">When you open the HTML report, the first section will list all of the analyzed binaries and what percentage of the .NET APIs they use are available on the targeted platform.</span></span> <span data-ttu-id="b26a3-218">La percentuale non è significativa da sola.</span><span class="sxs-lookup"><span data-stu-id="b26a3-218">The percentage is not meaningful by itself.</span></span> <span data-ttu-id="b26a3-219">Ciò che è più utile è vedere le API specifiche mancanti.</span><span class="sxs-lookup"><span data-stu-id="b26a3-219">What's more useful is to see the specific APIs that are missing.</span></span> <span data-ttu-id="b26a3-220">A tale scopo, selezionare un nome di assembly o scorrere verso il basso fino ai rapporti per singoli assembly.</span><span class="sxs-lookup"><span data-stu-id="b26a3-220">To do that, either select an assembly name or scroll down to the reports for individual assemblies.</span></span>

<span data-ttu-id="b26a3-221">Concentrarsi sugli assembly per i quali si è proprietari del codice sorgente.</span><span class="sxs-lookup"><span data-stu-id="b26a3-221">Focus on the assemblies that you own the source code for.</span></span> <span data-ttu-id="b26a3-222">Nel report Bean trader ApiPort, ad esempio, sono elencati molti file binari, ma la maggior parte di essi appartengono a pacchetti NuGet.</span><span class="sxs-lookup"><span data-stu-id="b26a3-222">In the Bean Trader ApiPort report, for example, there are many binaries listed, but most of them belong to NuGet packages.</span></span> <span data-ttu-id="b26a3-223">`Castle.Windsor`Mostra che dipende da alcune API System. Web mancanti in .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-223">`Castle.Windsor` shows that it depends on some System.Web APIs that are missing in .NET Core.</span></span> <span data-ttu-id="b26a3-224">Questo non è un problema perché in precedenza è `Castle.Windsor` stato verificato che supporta .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-224">This isn't a concern because you previously verified that `Castle.Windsor` supports .NET Core.</span></span> <span data-ttu-id="b26a3-225">È comune che i pacchetti NuGet dispongano di binari diversi per l'uso con diverse piattaforme .NET, quindi se la versione `Castle.Windsor` .NET Framework di USA API System. Web o meno, è irrilevante, purché il pacchetto sia destinato anche .NET standard o .NET Core (operazione eseguita).</span><span class="sxs-lookup"><span data-stu-id="b26a3-225">It is common for NuGet packages to have different binaries for use with different .NET platforms, so whether the .NET Framework version of `Castle.Windsor` uses System.Web APIs or not is irrelevant as long as the package also targets .NET Standard or .NET Core (which it does).</span></span>

<span data-ttu-id="b26a3-226">Con l'esempio Bean trader, l'unico file binario che è necessario prendere in considerazione è **BeanTraderClient** e il report mostra che mancano solo due API `System.ServiceModel.ClientBase<T>.Close` .NET `System.ServiceModel.ClientBase<T>.Open`: e.</span><span class="sxs-lookup"><span data-stu-id="b26a3-226">With the Bean Trader sample, the only binary that you need to consider is **BeanTraderClient** and the report shows that only two .NET APIs are missing: `System.ServiceModel.ClientBase<T>.Close` and `System.ServiceModel.ClientBase<T>.Open`.</span></span>

![Report sulla portabilità di BeanTraderClient](./media/convert-project-from-net-framework/portability-report.png)

<span data-ttu-id="b26a3-228">È improbabile che si verifichino problemi di blocco perché le API client WCF sono (per lo più) supportate in .NET Core, quindi è necessario che siano disponibili alternative per queste API centrali.</span><span class="sxs-lookup"><span data-stu-id="b26a3-228">These are unlikely to be blocking issues because WCF Client APIs are (mostly) supported on .NET Core, so there must be alternatives available for these central APIs.</span></span> <span data-ttu-id="b26a3-229">In realtà, osservando `System.ServiceModel`la superficie di attacco di .NET Core <https://apisof.net>(usando), si noterà che in .NET Core sono disponibili alternative asincrone.</span><span class="sxs-lookup"><span data-stu-id="b26a3-229">In fact, looking at `System.ServiceModel`'s .NET Core surface area (using <https://apisof.net>), you see that there are async alternatives in .NET Core instead.</span></span>

<span data-ttu-id="b26a3-230">In base a questo report e all'analisi delle dipendenze NuGet precedente, sembra che non siano presenti problemi principali per la migrazione dell'esempio Bean trader a .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-230">Based on this report and the previous NuGet dependency analysis, it looks like there should be no major issues migrating the Bean Trader sample to .NET Core.</span></span> <span data-ttu-id="b26a3-231">Si è pronti per il passaggio successivo in cui verrà avviata la migrazione.</span><span class="sxs-lookup"><span data-stu-id="b26a3-231">You're ready for the next step in which you'll actually start the migration.</span></span>

## <a name="migrating-the-project-file"></a><span data-ttu-id="b26a3-232">Migrazione del file di progetto</span><span class="sxs-lookup"><span data-stu-id="b26a3-232">Migrating the project file</span></span>

<span data-ttu-id="b26a3-233">Se l'app non usa il nuovo [formato di file di progetto in stile SDK](../../core/tools/csproj.md), sarà necessario un nuovo file di progetto per la destinazione di .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-233">If your app isn't using the new [SDK-style project file format](../../core/tools/csproj.md), you'll need a new project file to target .NET Core.</span></span> <span data-ttu-id="b26a3-234">È possibile sostituire il file csproj esistente o, se si preferisce che il progetto esistente rimanga intatto nello stato corrente, è possibile aggiungere un nuovo file csproj destinato a .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-234">You can replace the existing csproj file or, if you prefer to keep the existing project untouched in its current state, you can add a new csproj file targeting .NET Core.</span></span> <span data-ttu-id="b26a3-235">È possibile compilare versioni dell'app per .NET Framework e .NET Core con un singolo file di progetto in stile SDK con [multi-targeting](../../standard/library-guidance/cross-platform-targeting.md) (specificando `<TargetFrameworks>` più destinazioni).</span><span class="sxs-lookup"><span data-stu-id="b26a3-235">You can build versions of the app for .NET Framework and .NET Core with a single SDK-style project file with [multi-targeting](../../standard/library-guidance/cross-platform-targeting.md) (specifying multiple `<TargetFrameworks>` targets).</span></span>

<span data-ttu-id="b26a3-236">Per creare il nuovo file di progetto, è possibile creare un nuovo progetto WPF in Visual Studio o usare `dotnet new wpf` il comando in una directory temporanea per generare il file di progetto e quindi copiarlo o rinominarlo nella posizione corretta.</span><span class="sxs-lookup"><span data-stu-id="b26a3-236">To create the new project file, you can create a new WPF project in Visual Studio or use the `dotnet new wpf` command in a temporary directory to generate the project file and then copy/rename it to the correct location.</span></span> <span data-ttu-id="b26a3-237">È disponibile anche uno strumento creato dalla community, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), che consente di automatizzare parte della migrazione dei file di progetto.</span><span class="sxs-lookup"><span data-stu-id="b26a3-237">There is also a community-created tool, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), that can automate some of the project file migration.</span></span> <span data-ttu-id="b26a3-238">Lo strumento è utile, ma necessita ancora di un uomo per esaminare i risultati per assicurarsi che tutti i dettagli della migrazione siano corretti.</span><span class="sxs-lookup"><span data-stu-id="b26a3-238">The tool is helpful but still needs a human to review the results to make sure all the details of the migration are correct.</span></span> <span data-ttu-id="b26a3-239">Una particolare area che lo strumento non gestisce in modo ottimale è la migrazione dei pacchetti NuGet dai file *packages. config* .</span><span class="sxs-lookup"><span data-stu-id="b26a3-239">One particular area that the tool doesn't handle optimally is migrating NuGet packages from *packages.config* files.</span></span> <span data-ttu-id="b26a3-240">Se lo strumento viene eseguito in un file di progetto che usa ancora un file *packages. config* per fare riferimento ai pacchetti NuGet `<PackageReference>` , eseguirà automaticamente la migrazione `<PackageReference>` agli elementi, ma aggiungerà elementi per *tutti* i pacchetti anziché solo quelli di primo livello.</span><span class="sxs-lookup"><span data-stu-id="b26a3-240">If the tool runs on a project file that still uses a *packages.config* file to reference NuGet packages, it will migrate to `<PackageReference>` elements automatically, but will add `<PackageReference>` elements for *all* of the packages instead of just top-level ones.</span></span> <span data-ttu-id="b26a3-241">Se è già stata eseguita la migrazione`<PackageReference>` a elementi con Visual Studio (come è stato fatto in questo esempio), lo strumento può essere utile per il resto della conversione.</span><span class="sxs-lookup"><span data-stu-id="b26a3-241">If you have already migrated to`<PackageReference>` elements with Visual Studio (as you've done in this sample), then the tool can help with the rest of the conversion.</span></span> <span data-ttu-id="b26a3-242">Come Scott Hanselr consiglia nel [suo post di Blog sulla migrazione dei file csproj](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), il porting manuale è educativo e fornisce risultati migliori se si dispone solo di alcuni progetti da trasferire.</span><span class="sxs-lookup"><span data-stu-id="b26a3-242">Like Scott Hanselman recommends in [his blog post on migrating csproj files](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), porting by hand is educational and will give better results if you only have a few projects to port.</span></span> <span data-ttu-id="b26a3-243">Tuttavia, se si esegue il porting di dozzine o centinaia di file di progetto, uno strumento come [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017) può essere una guida.</span><span class="sxs-lookup"><span data-stu-id="b26a3-243">But if you're porting dozens or hundreds of project files, then a tool like [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017) can be a help.</span></span>

<span data-ttu-id="b26a3-244">Per creare un nuovo file di progetto per l'esempio Bean trader, `dotnet new wpf` eseguire in una directory temporanea e spostare il file con *estensione csproj* generato nella cartella *BeanTraderClient* e rinominarlo **BeanTraderClient. Core. csproj**.</span><span class="sxs-lookup"><span data-stu-id="b26a3-244">To create a new project file for the Bean Trader sample, run `dotnet new wpf` in a temporary directory and move the generated *.csproj* file into the *BeanTraderClient* folder and rename it **BeanTraderClient.Core.csproj**.</span></span>

<span data-ttu-id="b26a3-245">Poiché il nuovo formato del file di progetto include automaticamente i file C#, i file *resx* e i file XAML che trova in o sotto la relativa directory, il file di progetto è già quasi completo.</span><span class="sxs-lookup"><span data-stu-id="b26a3-245">Because the new project file format automatically includes C# files, *resx* files, and XAML files that it finds in or under its directory, the project file is already almost complete!</span></span> <span data-ttu-id="b26a3-246">Per completare la migrazione, aprire i file di progetto vecchi e nuovi side-by-side ed esaminare quello precedente per verificare se è necessario eseguire la migrazione di tutte le informazioni in esso contenute.</span><span class="sxs-lookup"><span data-stu-id="b26a3-246">To finish the migration, open the old and new project files side-by-side and look through the old one to see if any information it contains needs to be migrated.</span></span> <span data-ttu-id="b26a3-247">Nel caso di esempio Bean trader, gli elementi seguenti devono essere copiati nel nuovo progetto:</span><span class="sxs-lookup"><span data-stu-id="b26a3-247">In the Bean Trader sample case, the following items should be copied to the new project:</span></span>

- <span data-ttu-id="b26a3-248">Tutte `<RootNamespace>`le `<AssemblyName>`proprietà, `<ApplicationIcon>` e devono essere copiate.</span><span class="sxs-lookup"><span data-stu-id="b26a3-248">The `<RootNamespace>`, `<AssemblyName>`, and `<ApplicationIcon>` properties should all be copied.</span></span>

- <span data-ttu-id="b26a3-249">È anche necessario aggiungere una `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` proprietà al nuovo file di progetto perché l'esempio Bean trader include attributi a livello di assembly (ad `[AssemblyTitle]`esempio) in un file AssemblyInfo.cs.</span><span class="sxs-lookup"><span data-stu-id="b26a3-249">You also need to add a `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` property to the new project file since the Bean Trader sample includes assembly-level attributes (like `[AssemblyTitle]`) in an AssemblyInfo.cs file.</span></span> <span data-ttu-id="b26a3-250">Per impostazione predefinita, i nuovi progetti in stile SDK genereranno automaticamente questi attributi in base alle proprietà nel file csproj.</span><span class="sxs-lookup"><span data-stu-id="b26a3-250">By default, new SDK-style projects will autogenerate these attributes based on properties in the csproj file.</span></span> <span data-ttu-id="b26a3-251">Poiché non si vuole che questo avvenga in questo caso (gli attributi generati automaticamente sono in conflitto con quelli di AssemblyInfo.cs), si disabilitano gli attributi generati `<GenerateAssemblyInfo>`automaticamente con.</span><span class="sxs-lookup"><span data-stu-id="b26a3-251">Because you don't want that to happen in this case (the autogenerated attributes would conflict with those from AssemblyInfo.cs), you disable the autogenerated attributes with `<GenerateAssemblyInfo>`.</span></span>

- <span data-ttu-id="b26a3-252">Sebbene i file *resx* vengano automaticamente inclusi come risorse incorporate `<Resource>` , non sono presenti altri elementi come le immagini.</span><span class="sxs-lookup"><span data-stu-id="b26a3-252">Although *resx* files are automatically included as embedded resources, other `<Resource>` items like images are not.</span></span> <span data-ttu-id="b26a3-253">Copiare quindi gli `<Resource>` elementi per incorporare i file di immagine e icona.</span><span class="sxs-lookup"><span data-stu-id="b26a3-253">So, copy the `<Resource>` elements for embedding image and icon files.</span></span> <span data-ttu-id="b26a3-254">È possibile semplificare i riferimenti png a una singola riga usando il nuovo supporto del formato di file di progetto per i modelli `<Resource Include="**\*.png" />`glob:.</span><span class="sxs-lookup"><span data-stu-id="b26a3-254">You can simplify the png references to a single line by using the new project file format's support for globbing patterns: `<Resource Include="**\*.png" />`.</span></span>

- <span data-ttu-id="b26a3-255">Analogamente `<None>` , gli elementi vengono inclusi automaticamente, ma non vengono copiati nella directory di output per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="b26a3-255">Similarly, `<None>` items are included automatically, but they aren't copied to the output directory, by default.</span></span> <span data-ttu-id="b26a3-256">Poiché il progetto Bean trader include un `<None>` elemento che *viene* copiato nella directory di output (usando `PreserveNewest` i comportamenti), è necessario aggiornare l'elemento popolato `<None>` automaticamente per il file, come indicato di seguito.</span><span class="sxs-lookup"><span data-stu-id="b26a3-256">Because the Bean Trader project includes a `<None>` item that *is* copied to the output directory (using `PreserveNewest` behaviors), you need to update the automatically populated `<None>` item for that file, like this.</span></span>

  ```xml
  <None Update="BeanTrader.pfx">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
  ```

- <span data-ttu-id="b26a3-257">L'esempio Bean trader include un file XAML (default. Accent. Xaml) come `Content` (anziché come `Page`) perché i temi e gli accenti definiti in questo file vengono caricati dal codice XAML del file in fase di esecuzione, anziché incorporarli nell'app stessa.</span><span class="sxs-lookup"><span data-stu-id="b26a3-257">The Bean Trader sample includes a XAML file (Default.Accent.xaml) as `Content` (rather than as a `Page`) because themes and accents defined in this file are loaded from the file's XAML at runtime, rather than being embedded in the app itself.</span></span> <span data-ttu-id="b26a3-258">Tuttavia, il nuovo sistema di progetto include automaticamente questo `<Page>`file, poiché si tratta di un file XAML.</span><span class="sxs-lookup"><span data-stu-id="b26a3-258">The new project system automatically includes this file as a `<Page>`, however, since it's a XAML file.</span></span> <span data-ttu-id="b26a3-259">Quindi, è necessario rimuovere il file XAML come pagina (`<Page Remove="**\Default.Accent.xaml" />`) e aggiungerlo come contenuto.</span><span class="sxs-lookup"><span data-stu-id="b26a3-259">So, you need to both remove the XAML file as a page (`<Page Remove="**\Default.Accent.xaml" />`) and add it as content.</span></span>

  ```xml
  <Content Include="Resources\Themes\Default.Accent.xaml">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </Content>
  ```

- <span data-ttu-id="b26a3-260">Infine, aggiungere i `<ItemGroup>` riferimenti NuGet copiando con tutti gli `<PackageReference>` elementi.</span><span class="sxs-lookup"><span data-stu-id="b26a3-260">Finally, add NuGet references by copying the `<ItemGroup>` with all the `<PackageReference>` elements.</span></span> <span data-ttu-id="b26a3-261">Se in precedenza non sono stati aggiornati i pacchetti NuGet alle versioni compatibili con .NET Core, è possibile farlo ora che i riferimenti al pacchetto si trovano in un progetto specifico di .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-261">If you hadn't previously upgraded the NuGet packages to .NET Core-compatible versions, you could do that now that the package references are in a .NET Core-specific project.</span></span>

<span data-ttu-id="b26a3-262">A questo punto, dovrebbe essere possibile aggiungere il nuovo progetto alla soluzione BeanTrader e aprirlo in Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="b26a3-262">At this point, it should be possible to add the new project to the BeanTrader solution and open it in Visual Studio.</span></span> <span data-ttu-id="b26a3-263">Il progetto dovrebbe essere corretto in **Esplora soluzioni**e `dotnet restore BeanTraderClient.Core.csproj` dovrebbe ripristinare correttamente i pacchetti (con due avvisi previsti correlati alla versione di MahApps. metro che si sta usando come destinazione .NET Framework).</span><span class="sxs-lookup"><span data-stu-id="b26a3-263">The project should look correct in **Solution Explorer**, and `dotnet restore BeanTraderClient.Core.csproj` should successfully restore packages (with two expected warnings related to the MahApps.Metro version you're using targeting .NET Framework).</span></span>

<span data-ttu-id="b26a3-264">Sebbene sia possibile conservare entrambi i file di progetto side-by-Side (e potrebbe essere anche auspicabile se si vuole creare il progetto precedente esattamente com'era), questo complica il processo di migrazione (i due progetti proveranno a usare le stesse cartelle bin e obj) e in genere non sono necessari.</span><span class="sxs-lookup"><span data-stu-id="b26a3-264">Although it's possible to keep both project files side-by-side (and may even be desirable if you want to keep building the old project exactly as it was), it complicates the migration process (the two projects will try to use the same bin and obj folders) and usually isn't necessary.</span></span> <span data-ttu-id="b26a3-265">Se si vuole compilare per le destinazioni .NET Core e .NET Framework, è possibile sostituire la `<TargetFramework>netcoreapp3.0</TargetFramework>` proprietà nel nuovo file di progetto con. `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>`</span><span class="sxs-lookup"><span data-stu-id="b26a3-265">If you want to build for both .NET Core and .NET Framework targets, you can replace the `<TargetFramework>netcoreapp3.0</TargetFramework>` property in the new project file with `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` instead.</span></span> <span data-ttu-id="b26a3-266">Per l'esempio Bean trader, eliminare il vecchio file di progetto (BeanTraderClient. csproj) perché non è più necessario.</span><span class="sxs-lookup"><span data-stu-id="b26a3-266">For the Bean Trader sample, delete the old project file (BeanTraderClient.csproj) since it's no longer needed.</span></span> <span data-ttu-id="b26a3-267">Se si preferisce tenere entrambi i file di progetto, assicurarsi di fare in modo che vengano compilati in diversi percorsi di output e intermedi di output.</span><span class="sxs-lookup"><span data-stu-id="b26a3-267">If you prefer to keep both project files, be sure to have them build to different output and intermediate output paths.</span></span>

## <a name="fix-build-issues"></a><span data-ttu-id="b26a3-268">Risolvere i problemi di compilazione</span><span class="sxs-lookup"><span data-stu-id="b26a3-268">Fix build issues</span></span>

<span data-ttu-id="b26a3-269">Il terzo passaggio del processo di porting consiste nell'ottenere il progetto da compilare.</span><span class="sxs-lookup"><span data-stu-id="b26a3-269">The third step of the porting process is getting the project to build.</span></span> <span data-ttu-id="b26a3-270">Alcune app vengono già compilate correttamente dopo la conversione del file di progetto in un progetto di tipo SDK.</span><span class="sxs-lookup"><span data-stu-id="b26a3-270">Some apps will already build successfully once the project file is converted to an SDK-style project.</span></span> <span data-ttu-id="b26a3-271">Se questo è il caso dell'app, congratulazioni!</span><span class="sxs-lookup"><span data-stu-id="b26a3-271">If that's the case for your app, congratulations!</span></span> <span data-ttu-id="b26a3-272">È possibile procedere al passaggio 4.</span><span class="sxs-lookup"><span data-stu-id="b26a3-272">You can go on to Step 4.</span></span> <span data-ttu-id="b26a3-273">Altre app necessiteranno di alcuni aggiornamenti per crearli per .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-273">Other apps will need some updates to get them building for .NET Core.</span></span> <span data-ttu-id="b26a3-274">Se si tenta di eseguire `dotnet build` il progetto di esempio Bean trader, ad esempio (o di compilarlo in Visual Studio), si verificano molti errori, ma si otterranno rapidamente corretti.</span><span class="sxs-lookup"><span data-stu-id="b26a3-274">If you try to run `dotnet build` on the Bean Trader sample project now, for example, (or build it in Visual Studio), there will be many errors, but you'll get them fixed quickly.</span></span>

### <a name="systemservicemodel-references-and-microsoftwindowscompatibility"></a><span data-ttu-id="b26a3-275">System. ServiceModel References e Microsoft. Windows. Compatibility</span><span class="sxs-lookup"><span data-stu-id="b26a3-275">System.ServiceModel references and Microsoft.Windows.Compatibility</span></span>

<span data-ttu-id="b26a3-276">Una fonte comune di errori mancano riferimenti per le API disponibili per .NET Core, ma non incluse automaticamente nel metapacchetto dell'app .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-276">A common source of errors is missing references for APIs that are available for .NET Core but not automatically included in the .NET Core app metapackage.</span></span> <span data-ttu-id="b26a3-277">Per risolvere questo problema, è necessario fare `Microsoft.Windows.Compatibility` riferimento al pacchetto.</span><span class="sxs-lookup"><span data-stu-id="b26a3-277">To address this, you should reference the `Microsoft.Windows.Compatibility` package.</span></span> <span data-ttu-id="b26a3-278">Il pacchetto di compatibilità include un ampio set di API comuni nelle applicazioni desktop di Windows, ad esempio client WCF, servizi directory, registro di sistema, configurazione, API ACL e altro ancora.</span><span class="sxs-lookup"><span data-stu-id="b26a3-278">The compatibility package includes a broad set of APIs that are common in Windows desktop apps, such as WCF client, directory services, registry, configuration, ACLs APIs, and more.</span></span>

<span data-ttu-id="b26a3-279">Con l'esempio Bean trader, la maggior parte degli errori di compilazione sono dovuti <xref:System.ServiceModel> a tipi mancanti.</span><span class="sxs-lookup"><span data-stu-id="b26a3-279">With the Bean Trader sample, the majority of the build errors are due to missing <xref:System.ServiceModel> types.</span></span> <span data-ttu-id="b26a3-280">Per risolvere il problema, fare riferimento ai pacchetti NuGet WCF necessari.</span><span class="sxs-lookup"><span data-stu-id="b26a3-280">These could be addressed by referencing the necessary WCF NuGet packages.</span></span> <span data-ttu-id="b26a3-281">Tuttavia, le API client WCF sono tra quelle `Microsoft.Windows.Compatibility` presenti nel pacchetto, quindi fare riferimento al pacchetto di compatibilità è una soluzione ancora migliore (poiché risolve anche eventuali problemi correlati alle API, nonché soluzioni ai problemi WCF resi disponibili dal pacchetto di compatibilità).</span><span class="sxs-lookup"><span data-stu-id="b26a3-281">WCF client APIs are among those present in the `Microsoft.Windows.Compatibility` package, though, so referencing the compatibility package is an even better solution (since it also addresses any issues related to APIs as well as solutions to the WCF issues that the compatibility package makes available).</span></span> <span data-ttu-id="b26a3-282">Il `Microsoft.Windows.Compatibility` pacchetto è utile nella maggior parte degli scenari di porting WPF e WinForms di .net core 3,0.</span><span class="sxs-lookup"><span data-stu-id="b26a3-282">The `Microsoft.Windows.Compatibility` package helps in most .NET Core 3.0 WPF and WinForms porting scenarios.</span></span> <span data-ttu-id="b26a3-283">Dopo l'aggiunta del riferimento NuGet `Microsoft.Windows.Compatibility`a, rimane un solo errore di compilazione.</span><span class="sxs-lookup"><span data-stu-id="b26a3-283">After adding the NuGet reference to `Microsoft.Windows.Compatibility`, only one build error remains!</span></span>

### <a name="cleaning-up-unused-files"></a><span data-ttu-id="b26a3-284">Pulizia dei file non utilizzati</span><span class="sxs-lookup"><span data-stu-id="b26a3-284">Cleaning up unused files</span></span>

<span data-ttu-id="b26a3-285">Un tipo di problema di migrazione spesso si riferisce a file C# e XAML che in precedenza non erano inclusi nella compilazione prelevati dai nuovi progetti in stile SDK che includono *tutte le* origini automaticamente.</span><span class="sxs-lookup"><span data-stu-id="b26a3-285">One type of migration issue that comes up often relates to C# and XAML files that weren't previously included in the build getting picked up by the new SDK-style projects that include *all* source automatically.</span></span>

<span data-ttu-id="b26a3-286">Il successivo errore di compilazione visualizzato nell'esempio Bean trader si riferisce a un'implementazione di interfaccia errata in *OldUnusedViewModel.cs*.</span><span class="sxs-lookup"><span data-stu-id="b26a3-286">The next build error you see in the Bean Trader sample refers to a bad interface implementation in *OldUnusedViewModel.cs*.</span></span> <span data-ttu-id="b26a3-287">Il nome del file è un suggerimento, ma durante l'ispezione si noterà che il file di origine non è corretto.</span><span class="sxs-lookup"><span data-stu-id="b26a3-287">The file name is a hint, but on inspection, you'll find that this source file is incorrect.</span></span> <span data-ttu-id="b26a3-288">Non ha causato problemi in precedenza perché non era incluso nel progetto .NET Framework originale.</span><span class="sxs-lookup"><span data-stu-id="b26a3-288">It didn't cause issues previously because it wasn't included in the original .NET Framework project.</span></span> <span data-ttu-id="b26a3-289">I file di origine presenti sul disco ma non inclusi nel vecchio *csproj* sono ora inclusi automaticamente.</span><span class="sxs-lookup"><span data-stu-id="b26a3-289">Source files that were present on disk but not included in the old *csproj* are included automatically now.</span></span>

<span data-ttu-id="b26a3-290">Per problemi di questo tipo, è facile confrontarsi con l' *csproj* precedente per verificare che il file non sia necessario e quindi `<Compile Remove="" />` , se il file di origine non è più necessario, eliminarlo.</span><span class="sxs-lookup"><span data-stu-id="b26a3-290">For one-off issues like this, it's easy to compare to the previous *csproj* to confirm that the file isn't needed, and then either `<Compile Remove="" />` it or, if the source file isn't needed anywhere anymore, delete it.</span></span> <span data-ttu-id="b26a3-291">In questo caso, è possibile eliminare solo *OldUnusedViewModel.cs*.</span><span class="sxs-lookup"><span data-stu-id="b26a3-291">In this case, it's safe to just delete *OldUnusedViewModel.cs*.</span></span>

<span data-ttu-id="b26a3-292">Se si dispone di molti file di origine che devono essere esclusi in questo modo, è possibile disabilitare l'inclusione automatica dei file C# `<EnableDefaultCompileItems>` impostando la proprietà su false nel file di progetto.</span><span class="sxs-lookup"><span data-stu-id="b26a3-292">If you have many source files that would need to be excluded this way, you can disable auto-inclusion of C# files by setting the `<EnableDefaultCompileItems>` property to false in the project file.</span></span> <span data-ttu-id="b26a3-293">Quindi, è possibile copiare `<Compile Include>` gli elementi dal file di progetto precedente a quello nuovo in modo da creare solo le origini che si intende includere.</span><span class="sxs-lookup"><span data-stu-id="b26a3-293">Then, you can copy `<Compile Include>` items from the old project file to the new one in order to only build sources you intended to include.</span></span> <span data-ttu-id="b26a3-294">Analogamente `<EnableDefaultPageItems>` , può essere usato per disattivare l'inclusione automatica di pagine XAML `<EnableDefaultItems>` e può controllare entrambe con una singola proprietà.</span><span class="sxs-lookup"><span data-stu-id="b26a3-294">Similarly, `<EnableDefaultPageItems>` can be used to turn off auto-inclusion of XAML pages and `<EnableDefaultItems>` can control both with a single property.</span></span>

### <a name="a-brief-aside-on-multi-pass-compilers"></a><span data-ttu-id="b26a3-295">Una breve panoramica sui compilatori a più passaggi</span><span class="sxs-lookup"><span data-stu-id="b26a3-295">A brief aside on multi-pass compilers</span></span>

<span data-ttu-id="b26a3-296">Dopo aver rimosso il file danneggiato dall'esempio Bean trader, è possibile ricompilare e ricevere quattro errori.</span><span class="sxs-lookup"><span data-stu-id="b26a3-296">After removing the offending file from the Bean Trader sample, you can re-build and will get four errors.</span></span> <span data-ttu-id="b26a3-297">Non ne hai ancora uno?</span><span class="sxs-lookup"><span data-stu-id="b26a3-297">Didn't you have one before?</span></span> <span data-ttu-id="b26a3-298">Perché è stato impostato il numero di errori?</span><span class="sxs-lookup"><span data-stu-id="b26a3-298">Why did the number of errors go up?</span></span> <span data-ttu-id="b26a3-299">Il compilatore C# è un [compilatore](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes)a più passaggi.</span><span class="sxs-lookup"><span data-stu-id="b26a3-299">The C# compiler is a [multi-pass compiler](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span></span> <span data-ttu-id="b26a3-300">Ciò significa che viene eseguito due volte ogni file di origine.</span><span class="sxs-lookup"><span data-stu-id="b26a3-300">This means that it goes through each source file twice.</span></span> <span data-ttu-id="b26a3-301">In primo luogo, il compilatore esamina solo i metadati e le dichiarazioni in ogni file di origine e identifica eventuali problemi a livello di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="b26a3-301">First, the compiler just looks at metadata and declarations in each source file and identifies any declaration-level problems.</span></span> <span data-ttu-id="b26a3-302">Si tratta degli errori corretti.</span><span class="sxs-lookup"><span data-stu-id="b26a3-302">Those are the errors you've fixed.</span></span> <span data-ttu-id="b26a3-303">Quindi esegue nuovamente il codice per compilare l'origine C# in IL. si tratta del secondo set di errori che si sta osservando.</span><span class="sxs-lookup"><span data-stu-id="b26a3-303">Then it goes through the code again to build the C# source into IL; those are the second set of errors that you're seeing now.</span></span>

> [!NOTE]
> <span data-ttu-id="b26a3-304">Il compilatore C# esegue [più di due passaggi](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), ma il risultato finale è che gli errori del compilatore per modifiche di codice di grandi dimensioni, ad esempio, tendono a essere disponibili in due onde.</span><span class="sxs-lookup"><span data-stu-id="b26a3-304">The C# compiler does [more than just two passes](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), but the end result is that compiler errors for large code changes like this tend to come in two waves.</span></span>

### <a name="third-party-dependency-fixes-castlewindsor"></a><span data-ttu-id="b26a3-305">Correzioni di dipendenze di terze parti (Castle. Windsor)</span><span class="sxs-lookup"><span data-stu-id="b26a3-305">Third-party dependency fixes (Castle.Windsor)</span></span>

<span data-ttu-id="b26a3-306">Un'altra classe di problemi che si verificano in alcuni scenari di migrazione è rappresentata dalle differenze di API tra .NET Framework e le versioni .NET Core delle dipendenze.</span><span class="sxs-lookup"><span data-stu-id="b26a3-306">Another class of issue that comes up in some migration scenarios is API differences between .NET Framework and .NET Core versions of dependencies.</span></span> <span data-ttu-id="b26a3-307">Anche se un pacchetto NuGet è destinato sia a .NET Framework sia a .NET Standard o .NET Core, è possibile che siano presenti librerie diverse da usare con destinazioni .NET diverse.</span><span class="sxs-lookup"><span data-stu-id="b26a3-307">Even if a NuGet package targets both .NET Framework and .NET Standard or .NET Core, there may be different libraries for use with different .NET targets.</span></span> <span data-ttu-id="b26a3-308">Questo consente ai pacchetti di supportare diverse piattaforme .NET, che possono richiedere implementazioni diverse.</span><span class="sxs-lookup"><span data-stu-id="b26a3-308">This allows the packages to support many different .NET platforms, which may require different implementations.</span></span> <span data-ttu-id="b26a3-309">Significa anche che è possibile che nelle librerie siano presenti piccole differenze nell'API quando la destinazione è costituita da diverse piattaforme .NET.</span><span class="sxs-lookup"><span data-stu-id="b26a3-309">It also means that there may be small API differences in the libraries when targeting different .NET platforms.</span></span>

<span data-ttu-id="b26a3-310">Il set di errori successivo visualizzato nell'esempio Bean trader è correlato alle `Castle.Windsor` API.</span><span class="sxs-lookup"><span data-stu-id="b26a3-310">The next set of errors you'll see in the Bean Trader sample are related to `Castle.Windsor` APIs.</span></span> <span data-ttu-id="b26a3-311">Il progetto .NET Core Bean trader usa la stessa versione di `Castle.Windsor` del progetto di destinazione .NET Framework (4.1.1), ma le implementazioni per queste due piattaforme sono leggermente diverse.</span><span class="sxs-lookup"><span data-stu-id="b26a3-311">The .NET Core Bean Trader project uses the same version of `Castle.Windsor` as the .NET Framework-targeted project (4.1.1), but the implementations for those two platforms are slightly different.</span></span>

<span data-ttu-id="b26a3-312">In questo caso, vengono visualizzati i seguenti problemi che devono essere corretti:</span><span class="sxs-lookup"><span data-stu-id="b26a3-312">In this case, you see the following issues that need to be fixed:</span></span>

1. <span data-ttu-id="b26a3-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly`non è disponibile in .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` isn't available on .NET Core.</span></span> <span data-ttu-id="b26a3-314">Tuttavia `Classes.FromAssemblyContaining` , l'API simile è disponibile, pertanto è possibile sostituire entrambi gli utilizzi di `Classes.FromThisAssembly()` con chiamate a, `Classes.FromAssemblyContaining(t)`dove `t` è il tipo che effettua la chiamata.</span><span class="sxs-lookup"><span data-stu-id="b26a3-314">There is, however, the similar API `Classes.FromAssemblyContaining` available, so we can replace both uses of `Classes.FromThisAssembly()` with calls to `Classes.FromAssemblyContaining(t)`, where `t` is the type making the call.</span></span>
1. <span data-ttu-id="b26a3-315">Analogamente, *Bootstrapper.cs*in Bootstrapper.cs `Castle.Windsor.Installer.FromAssembly`,. Questa operazione non è disponibile in .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-315">Similarly, in *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`.This is unavailable on .NET Core.</span></span> <span data-ttu-id="b26a3-316">Al contrario, la chiamata può essere sostituita con `FromAssembly.Containing(typeof(Bootstrapper))`.</span><span class="sxs-lookup"><span data-stu-id="b26a3-316">Instead, that call can be replaced with `FromAssembly.Containing(typeof(Bootstrapper))`.</span></span>

### <a name="updating-wcf-client-usage"></a><span data-ttu-id="b26a3-317">Aggiornamento dell'utilizzo del client WCF</span><span class="sxs-lookup"><span data-stu-id="b26a3-317">Updating WCF client usage</span></span>

<span data-ttu-id="b26a3-318">Con la correzione `Castle.Windsor` delle differenze, l'ultimo errore di compilazione nel progetto .NET Core Bean trader è che `BeanTraderServiceClient` , che deriva da `DuplexClientBase`, non ha un `Open` metodo.</span><span class="sxs-lookup"><span data-stu-id="b26a3-318">Having fixed the `Castle.Windsor` differences, the last remaining build error in the .NET Core Bean Trader project is that `BeanTraderServiceClient` (which derives from `DuplexClientBase`) doesn't have an `Open` method.</span></span> <span data-ttu-id="b26a3-319">Questa operazione non è sorprendente perché si tratta di un'API che è stata evidenziata da .NET Portability Analyzer all'inizio di questo processo di migrazione.</span><span class="sxs-lookup"><span data-stu-id="b26a3-319">This isn't surprising since this is an API that was highlighted by the .NET Portability Analyzer at the beginning of this migration process.</span></span> <span data-ttu-id="b26a3-320">Tuttavia, `BeanTraderServiceClient` la ricerca di richiama l'attenzione su un problema più grande.</span><span class="sxs-lookup"><span data-stu-id="b26a3-320">Looking at `BeanTraderServiceClient` draws our attention to a larger issue, though.</span></span> <span data-ttu-id="b26a3-321">Questo client WCF è stato generato automaticamente dallo strumento [Svcutil. exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) .</span><span class="sxs-lookup"><span data-stu-id="b26a3-321">This WCF client was autogenerated by the [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) tool.</span></span>

<span data-ttu-id="b26a3-322">**I client WCF generati da Svcutil sono destinati all'uso in .NET Framework.**</span><span class="sxs-lookup"><span data-stu-id="b26a3-322">**WCF clients generated by Svcutil are meant for use on .NET Framework.**</span></span>

<span data-ttu-id="b26a3-323">Per le soluzioni che usano client WCF generati da Svcutil è necessario rigenerare client compatibili con .NET Standard per l'uso con .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-323">Solutions that use svcutil-generated WCF clients will need to regenerate .NET Standard-compatible clients for use with .NET Core.</span></span> <span data-ttu-id="b26a3-324">Uno dei motivi principali per cui i client precedenti non funziona è che dipendono dalla configurazione dell'app per la definizione di associazioni e endpoint WCF.</span><span class="sxs-lookup"><span data-stu-id="b26a3-324">One of the main reasons the old clients won't work is that they depend on app configuration for defining WCF bindings and endpoints.</span></span> <span data-ttu-id="b26a3-325">Poiché .NET Standard le API WCF possono funzionare su più piattaforme (in cui non sono disponibili API System. Configuration), i client WCF per gli scenari .NET Core e .NET Standard devono definire associazioni ed endpoint a livello di codice anziché nella configurazione.</span><span class="sxs-lookup"><span data-stu-id="b26a3-325">Because .NET Standard WCF APIs can work cross-platform (where System.Configuration APIs aren't available), WCF clients for .NET Core and .NET Standard scenarios must define bindings and endpoints programmatically instead of in configuration.</span></span>

<span data-ttu-id="b26a3-326">Di fatto, è necessario modificare qualsiasi utilizzo del `<system.serviceModel>` client WCF che dipende dalla sezione app. config (creata con Svcutil o manualmente) per funzionare in .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-326">In fact, any WCF client usage that depends on the `<system.serviceModel>` app.config section (whether created with Svcutil or manually) will need to be changed to work on .NET Core.</span></span>

<span data-ttu-id="b26a3-327">Esistono due modi per generare automaticamente client WCF compatibili con .NET Standard:</span><span class="sxs-lookup"><span data-stu-id="b26a3-327">There are two ways to automatically generate .NET Standard-compatible WCF clients:</span></span>

- <span data-ttu-id="b26a3-328">Lo `dotnet-svcutil` strumento è uno strumento .NET che genera client WCF in modo analogo al modo in cui Svcutil funzionava in precedenza.</span><span class="sxs-lookup"><span data-stu-id="b26a3-328">The `dotnet-svcutil` tool is a .NET tool that generates WCF clients in a way that is similar to how Svcutil worked previously.</span></span>
- <span data-ttu-id="b26a3-329">Visual Studio è in grado di generare client WCF utilizzando l'opzione di [riferimento al servizio Web WCF](../../core/additional-tools/wcf-web-service-reference-guide.md) della funzionalità Servizi connessi.</span><span class="sxs-lookup"><span data-stu-id="b26a3-329">Visual Studio can generate WCF clients using the [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) option of its Connected Services feature.</span></span>

<span data-ttu-id="b26a3-330">Entrambi gli approcci funzionano correttamente.</span><span class="sxs-lookup"><span data-stu-id="b26a3-330">Either approach works well.</span></span> <span data-ttu-id="b26a3-331">In alternativa, ovviamente, è possibile scrivere il codice client WCF manualmente.</span><span class="sxs-lookup"><span data-stu-id="b26a3-331">Alternatively, of course, you could write the WCF client code yourself.</span></span> <span data-ttu-id="b26a3-332">Per questo esempio si è scelto di usare la funzionalità servizio connesso di Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="b26a3-332">For this sample, I chose to use the Visual Studio Connected Service feature.</span></span> <span data-ttu-id="b26a3-333">A tale scopo, fare clic con il pulsante destro del mouse sul progetto *BeanTraderClient. Core* in Esplora soluzioni di Visual Studio e scegliere **Aggiungi** > **servizio connesso**.</span><span class="sxs-lookup"><span data-stu-id="b26a3-333">To do that, right-click on the *BeanTraderClient.Core* project in Visual Studio's solution explorer and select **Add** > **Connected Service**.</span></span> <span data-ttu-id="b26a3-334">Scegliere quindi il provider di riferimento al servizio Web WCF.</span><span class="sxs-lookup"><span data-stu-id="b26a3-334">Next, choose the WCF Web Service Reference Provider.</span></span> <span data-ttu-id="b26a3-335">Verrà visualizzata una finestra di dialogo in cui è possibile specificare l'indirizzo del servizio Web back-end trader`localhost:8080` (se si esegue il server in locale) e lo spazio dei nomi che i tipi generati devono usare (ad esempio,**BeanTrader. Service**).</span><span class="sxs-lookup"><span data-stu-id="b26a3-335">This will bring up a dialog where you can specify the address of the backend Bean Trader web service (`localhost:8080` if you are running the server locally) and the namespace that generated types should use (**BeanTrader.Service**, for example).</span></span>

![Finestra di dialogo del servizio connesso di riferimento al servizio Web WCF](./media/convert-project-from-net-framework/connected-service-dialog.png)

<span data-ttu-id="b26a3-337">Dopo aver selezionato il pulsante **fine** , viene aggiunto un nuovo nodo servizi connessi al progetto e viene aggiunto un file Reference.cs in quel nodo che contiene il nuovo client .NET standard WCF per accedere al servizio Bean trader.</span><span class="sxs-lookup"><span data-stu-id="b26a3-337">After you select the **Finish** button, a new Connected Services node is added to the project and a Reference.cs file is added under that node containing the new .NET Standard WCF client for accessing the Bean Trader service.</span></span> <span data-ttu-id="b26a3-338">Se si osservano i `GetEndpointAddress` metodi `GetBindingForEndpoint` o in quel file, si noterà che le associazioni e gli endpoint vengono ora generati a livello di codice, anziché tramite la configurazione dell'app.</span><span class="sxs-lookup"><span data-stu-id="b26a3-338">If you look at the `GetEndpointAddress` or `GetBindingForEndpoint` methods in that file, you'll see that bindings and endpoints are now generated programmatically (instead of via app config).</span></span> <span data-ttu-id="b26a3-339">La funzionalità' Aggiungi Servizi connessi ' può anche aggiungere riferimenti ad alcuni pacchetti System. ServiceModel nel file di progetto, che non sono necessari perché tutti i pacchetti WCF necessari sono inclusi tramite Microsoft. Windows. Compatibility.</span><span class="sxs-lookup"><span data-stu-id="b26a3-339">The 'Add Connected Services' feature may also add references to some System.ServiceModel packages in the project file, which aren't needed since all necessary WCF packages are included via Microsoft.Windows.Compatibility.</span></span> <span data-ttu-id="b26a3-340">Controllare csproj per verificare se sono stati aggiunti elementi System. `<PackageReference>` ServiceModel aggiuntivi e, in caso affermativo, rimuoverli.</span><span class="sxs-lookup"><span data-stu-id="b26a3-340">Check the csproj to see if any extra System.ServiceModel `<PackageReference>` items have been added, and if so, remove them.</span></span>

<span data-ttu-id="b26a3-341">Il progetto include nuove classi client WCF ora (in *Reference.cs*), ma ha ancora le versioni precedenti (in BeanTrader.cs).</span><span class="sxs-lookup"><span data-stu-id="b26a3-341">Our project has new WCF client classes now (in *Reference.cs*), but it also still has the old ones (in BeanTrader.cs).</span></span> <span data-ttu-id="b26a3-342">A questo punto sono disponibili due opzioni:</span><span class="sxs-lookup"><span data-stu-id="b26a3-342">There are two options at this point:</span></span>

- <span data-ttu-id="b26a3-343">Se si vuole essere in grado di compilare il progetto di .NET Framework originale (insieme alla nuova versione di destinazione di .NET Core), è possibile `<Compile Remove="BeanTrader.cs" />` usare un elemento nel file csproj del progetto .NET Core in modo che le versioni di .NET Framework e .NET Core usino client WCF diversi.</span><span class="sxs-lookup"><span data-stu-id="b26a3-343">If you want to be able to build the original .NET Framework project (alongside the new .NET Core-targeted one), you can use a `<Compile Remove="BeanTrader.cs" />` item in the .NET Core project's csproj file so that the .NET Framework and .NET Core versions of the app use different WCF clients.</span></span> <span data-ttu-id="b26a3-344">Questo ha il vantaggio di lasciare invariato il progetto di .NET Framework esistente, tuttavia, presenta lo svantaggio che il codice che usa i client WCF generati potrebbe dover essere leggermente diverso nel caso di .NET Core rispetto al progetto .NET Framework, quindi è probabile che si debbano usare `#if` le direttive per compilare in modo condizionale l'utilizzo del client WCF (creando client, ad esempio) per funzionare in modo singolo quando viene compilato per la .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b26a3-344">This has the advantage of leaving the existing .NET Framework project unchanged, but has the disadvantage that code using the generated WCF clients may need to be slightly different in the .NET Core case than it was in the .NET Framework project, so you'll likely need to use `#if` directives to conditionally compile some WCF client usage (creating clients, for example) to work one way when built for .NET Core and another way when built for .NET Framework.</span></span>

- <span data-ttu-id="b26a3-345">Se, invece, la varianza del codice nel progetto .NET Framework esistente è accettabile, è possibile rimuovere *BeanTrader.cs* tutti insieme.</span><span class="sxs-lookup"><span data-stu-id="b26a3-345">If, on the other hand, some code churn in the existing .NET Framework project is acceptable, you can remove *BeanTrader.cs* all together.</span></span> <span data-ttu-id="b26a3-346">Poiché il nuovo client WCF viene compilato per .NET Standard, funzionerà in scenari .NET Core e .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b26a3-346">Because the new WCF client is built for .NET Standard, it will work in both .NET Core and .NET Framework scenarios.</span></span> <span data-ttu-id="b26a3-347">Se si sta compilando per .NET Framework oltre a .NET Core (mediante la funzionalità multitargeting o con due file csproj), è possibile usare questo nuovo file *Reference.cs* per entrambe le destinazioni.</span><span class="sxs-lookup"><span data-stu-id="b26a3-347">If you are building for .NET Framework in addition to .NET Core (either by multi-targeting or by having two csproj files), you can use this new *Reference.cs* file for both targets.</span></span> <span data-ttu-id="b26a3-348">Questo approccio offre il vantaggio che il codice non deve biforcate per supportare due diversi client WCF; lo stesso codice verrà usato ovunque.</span><span class="sxs-lookup"><span data-stu-id="b26a3-348">This approach has the advantage that the code won't need to bifurcate to support two different WCF clients; the same code will be used everywhere.</span></span> <span data-ttu-id="b26a3-349">Lo svantaggio è che comporta la modifica del progetto (presumibilmente stabile) .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b26a3-349">The drawback is that it involves changing the (presumably stable) .NET Framework project.</span></span>

<span data-ttu-id="b26a3-350">Nel caso dell'esempio Bean trader, è possibile apportare piccole modifiche al progetto originale se semplifica la migrazione, quindi attenersi alla procedura seguente per riconciliare l'utilizzo dei client WCF:</span><span class="sxs-lookup"><span data-stu-id="b26a3-350">In the case of the Bean Trader sample, you can make small changes to the original project if it makes migration easier, so follow these steps to reconcile WCF client usage:</span></span>

01. <span data-ttu-id="b26a3-351">Aggiungere il nuovo file Reference.cs al progetto .NET Framework *BeanTraderClient. csproj* usando il menu di scelta rapida "Aggiungi elemento esistente" da Esplora soluzioni.</span><span class="sxs-lookup"><span data-stu-id="b26a3-351">Add the new Reference.cs file to the .NET Framework *BeanTraderClient.csproj* project using the 'Add existing item' context menu from the solution explorer.</span></span> <span data-ttu-id="b26a3-352">Assicurarsi di aggiungere "As link" in modo che lo stesso file venga usato da entrambi i progetti, anziché copiare il file C#.</span><span class="sxs-lookup"><span data-stu-id="b26a3-352">Be sure to add 'as link' so that the same file is used by both projects (as opposed to copying the C# file).</span></span> <span data-ttu-id="b26a3-353">Questo passaggio non è necessario se si compila sia per .NET Core che per .NET Framework con un solo csproj (usando la funzionalità multitargeting).</span><span class="sxs-lookup"><span data-stu-id="b26a3-353">If you are building for both .NET Core and .NET Framework with a single csproj (using multi-targeting) then this step isn't necessary.</span></span>

01. <span data-ttu-id="b26a3-354">Elimina *BeanTrader.cs*.</span><span class="sxs-lookup"><span data-stu-id="b26a3-354">Delete *BeanTrader.cs*.</span></span>

01. <span data-ttu-id="b26a3-355">Il nuovo client WCF è simile a quello precedente, ma un numero di spazi dei nomi nel codice generato è diverso.</span><span class="sxs-lookup"><span data-stu-id="b26a3-355">The new WCF client is similar to the old one, but a number of namespaces in the generated code are different.</span></span> <span data-ttu-id="b26a3-356">Per questo motivo, è necessario aggiornare il progetto in modo che i tipi di client WCF vengano utilizzati da BeanTrader. Service (o qualsiasi altro nome di spazio dei nomi scelto) anziché BeanTrader. Model o senza uno spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="b26a3-356">Because of this, it is necessary to update the project so that WCF client types are used from BeanTrader.Service (or whatever namespace name you chose) instead of BeanTrader.Model or without a namespace.</span></span> <span data-ttu-id="b26a3-357">La compilazione di *BeanTraderClient. Core. csproj* consente di identificare la posizione in cui devono essere apportate le modifiche.</span><span class="sxs-lookup"><span data-stu-id="b26a3-357">Building *BeanTraderClient.Core.csproj* will help to identify where these changes need to be made.</span></span> <span data-ttu-id="b26a3-358">Le correzioni saranno necessarie sia in C# che nei file di origine XAML.</span><span class="sxs-lookup"><span data-stu-id="b26a3-358">Fixes will be needed both in C# and in XAML source files.</span></span>

01. <span data-ttu-id="b26a3-359">Infine, si noterà che si verifica un errore in *BeanTraderServiceClientFactory.cs* perché i costruttori disponibili per il `BeanTraderServiceClient` tipo sono stati modificati.</span><span class="sxs-lookup"><span data-stu-id="b26a3-359">Finally, you'll discover that there is an error in *BeanTraderServiceClientFactory.cs* because the available constructors for the `BeanTraderServiceClient` type have changed.</span></span> <span data-ttu-id="b26a3-360">È stato usato per fornire un `InstanceContext` argomento, che è stato creato usando un `CallbackHandler` del contenitore `Castle.Windsor` IOC.</span><span class="sxs-lookup"><span data-stu-id="b26a3-360">It used to be possible to supply an `InstanceContext` argument (which was created using a `CallbackHandler` from the `Castle.Windsor` IoC container).</span></span> <span data-ttu-id="b26a3-361">I nuovi costruttori creano nuovi `CallbackHandler`oggetti.</span><span class="sxs-lookup"><span data-stu-id="b26a3-361">The new constructors create new `CallbackHandler`s.</span></span> <span data-ttu-id="b26a3-362">Esistono, tuttavia, i costruttori nel tipo `BeanTraderServiceClient`di base corrispondente a quello desiderato.</span><span class="sxs-lookup"><span data-stu-id="b26a3-362">There are, however, constructors in `BeanTraderServiceClient`'s base type that match what you want.</span></span> <span data-ttu-id="b26a3-363">Poiché il codice client WCF generato automaticamente esiste in classi parziali, è possibile estenderlo facilmente.</span><span class="sxs-lookup"><span data-stu-id="b26a3-363">Since the autogenerated WCF client code all exists in partial classes, you can easily extend it.</span></span> <span data-ttu-id="b26a3-364">A tale scopo, creare un nuovo file denominato *BeanTraderServiceClient.cs* e quindi creare una classe parziale con lo stesso nome (usando lo spazio dei nomi BeanTrader. Service).</span><span class="sxs-lookup"><span data-stu-id="b26a3-364">To do this, create a new file called *BeanTraderServiceClient.cs* and then create a partial class with that same name (using the BeanTrader.Service namespace).</span></span> <span data-ttu-id="b26a3-365">Aggiungere quindi un costruttore al tipo parziale, come illustrato di seguito.</span><span class="sxs-lookup"><span data-stu-id="b26a3-365">Then, add one constructor to the partial type as shown here.</span></span>

    ```csharp
    public BeanTraderServiceClient(System.ServiceModel.InstanceContext callbackInstance) :
        base(callbackInstance, EndpointConfiguration.NetTcpBinding_BeanTraderService)
            { }
    ```

<span data-ttu-id="b26a3-366">Con le modifiche apportate, l'esempio Bean trader utilizzerà ora un nuovo client WCF compatibile con .NET Standard ed è possibile apportare la correzione finale per modificare `Open` la chiamata in *TradingService.cs* in `await OpenAsync` modo da usare invece.</span><span class="sxs-lookup"><span data-stu-id="b26a3-366">With those changes made, the Bean Trader sample will now be using a new .NET Standard-compatible WCF client and you can make the final fix of changing the `Open` call in *TradingService.cs* to use `await OpenAsync` instead.</span></span>

<span data-ttu-id="b26a3-367">Con i problemi di WCF risolti, la versione .NET Core dell'esempio Bean trader viene ora compilata in modo corretto.</span><span class="sxs-lookup"><span data-stu-id="b26a3-367">With the WCF issues addressed, the .NET Core version of the Bean Trader sample now builds cleanly!</span></span>

## <a name="runtime-testing"></a><span data-ttu-id="b26a3-368">Test di runtime</span><span class="sxs-lookup"><span data-stu-id="b26a3-368">Runtime testing</span></span>

<span data-ttu-id="b26a3-369">È facile dimenticare che il lavoro di migrazione non viene eseguito non appena il progetto viene compilato correttamente con .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-369">It's easy to forget that migration work isn't done as soon as the project builds cleanly against .NET Core.</span></span> <span data-ttu-id="b26a3-370">È importante non perdere tempo per il test dell'app portata.</span><span class="sxs-lookup"><span data-stu-id="b26a3-370">It's important to leave time for testing the ported app, too.</span></span> <span data-ttu-id="b26a3-371">Una volta completata la compilazione, assicurarsi che l'app venga eseguita e funzioni come previsto, soprattutto se si usano pacchetti destinati a .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b26a3-371">Once things build successfully, make sure the app runs and works as expected, especially if you are using any packages targeting .NET Framework.</span></span>

<span data-ttu-id="b26a3-372">Si proverà ad avviare l'app del trader Bean trasferita per vedere cosa accade.</span><span class="sxs-lookup"><span data-stu-id="b26a3-372">Let's try launching the ported Bean Trader app and see what happens.</span></span> <span data-ttu-id="b26a3-373">L'app non si trova molto prima di avere esito negativo con l'eccezione seguente.</span><span class="sxs-lookup"><span data-stu-id="b26a3-373">The app doesn't get far before failing with the following exception.</span></span>

```output
System.Configuration.ConfigurationErrorsException: 'Configuration system failed to initialize'

Inner Exception
ConfigurationErrorsException: Unrecognized configuration section system.serviceModel.
```

<span data-ttu-id="b26a3-374">Questa operazione ha senso, ovviamente.</span><span class="sxs-lookup"><span data-stu-id="b26a3-374">This makes sense, of course.</span></span> <span data-ttu-id="b26a3-375">Tenere presente che WCF non usa più la configurazione dell'app, quindi è necessario rimuovere la precedente sezione System. serviceModel del file app. config.</span><span class="sxs-lookup"><span data-stu-id="b26a3-375">Remember that WCF no longer uses app configuration, so the old system.serviceModel section of the app.config file needs to be removed.</span></span> <span data-ttu-id="b26a3-376">Il client WCF aggiornato include tutte le stesse informazioni nel codice, quindi la sezione config non è più necessaria.</span><span class="sxs-lookup"><span data-stu-id="b26a3-376">The updated WCF client includes all of the same information in its code, so the config section isn't needed anymore.</span></span> <span data-ttu-id="b26a3-377">Se si desidera che l'endpoint WCF possa essere configurato in app. config, è possibile aggiungerlo come impostazione dell'app e aggiornare il codice client WCF per recuperare l'endpoint del servizio WCF dalla configurazione.</span><span class="sxs-lookup"><span data-stu-id="b26a3-377">If you wanted the WCF endpoint to be configurable in app.config, you could add it as an app setting and update the WCF client code to retrieve the WCF service endpoint from configuration.</span></span>

<span data-ttu-id="b26a3-378">Dopo la rimozione della sezione System. serviceModel di *app. config*, l'app viene avviata ma non riesce con un'altra eccezione quando un utente esegue l'accesso.</span><span class="sxs-lookup"><span data-stu-id="b26a3-378">After removing the system.serviceModel section of *app.config*, the app launches but fails with another exception when a user signs in.</span></span>

```output
System.PlatformNotSupportedException: 'Operation is not supported on this platform.'
```

<span data-ttu-id="b26a3-379">L'API non supportata è `Func<T>.BeginInvoke`.</span><span class="sxs-lookup"><span data-stu-id="b26a3-379">The unsupported API is `Func<T>.BeginInvoke`.</span></span> <span data-ttu-id="b26a3-380">Come spiegato in [DotNet/CoreFx # 5940](https://github.com/dotnet/corefx/issues/5940), .NET Core non supporta i `BeginInvoke` metodi `EndInvoke` e sui tipi delegati a causa di dipendenze di comunicazione remota sottostanti.</span><span class="sxs-lookup"><span data-stu-id="b26a3-380">As explained in [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET Core doesn't support the `BeginInvoke` and `EndInvoke` methods on delegate types due to underlying remoting dependencies.</span></span> <span data-ttu-id="b26a3-381">Questo problema e la relativa correzione sono illustrati in modo più dettagliato nel post di Blog relativo alla [migrazione di delegati. BeginInvoke calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) , ma la sostanza è che `BeginInvoke` le chiamate e `EndInvoke` devono essere sostituite con `Task.Run` (o alternative asincrone, se possibile).</span><span class="sxs-lookup"><span data-stu-id="b26a3-381">This issue and its fix are explained in more detail in the [Migrating Delegate.BeginInvoke Calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blog post, but the gist is that `BeginInvoke` and `EndInvoke` calls should be replaced with `Task.Run` (or async alternatives, if possible).</span></span> <span data-ttu-id="b26a3-382">Applicando la soluzione generale, la `BeginInvoke` chiamata può essere sostituita con `Invoke` una chiamata avviata da `Task.Run`.</span><span class="sxs-lookup"><span data-stu-id="b26a3-382">Applying the general solution here, the `BeginInvoke` call can be replaced with an `Invoke` call launched by `Task.Run`.</span></span>

```csharp
Task.Run(() =>
{
    return userInfoRetriever.Invoke();
}).ContinueWith(result =>
{
    // BeginInvoke's callback is replaced with ContinueWith
    var task = result.ConfigureAwait(false);
    CurrentTrader = task.GetAwaiter().GetResult();
}, TaskScheduler.Default);
```

<span data-ttu-id="b26a3-383">Dopo la rimozione `BeginInvoke` dell'utilizzo, l'app Bean trader viene eseguita correttamente in .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b26a3-383">After removing the `BeginInvoke` usage, the Bean Trader app runs successfully on .NET Core!</span></span>

![Trader Bean in esecuzione su .NET Core](./media/convert-project-from-net-framework/running-on-core.png)

<span data-ttu-id="b26a3-385">Tutte le app sono diverse, quindi i passaggi specifici necessari per eseguire la migrazione delle proprie app a .NET Core possono variare.</span><span class="sxs-lookup"><span data-stu-id="b26a3-385">All apps are different, so the specific steps needed to migrate your own apps to .NET Core will vary.</span></span> <span data-ttu-id="b26a3-386">Tuttavia, l'esempio Bean trader illustra il flusso di lavoro generale e i tipi di problemi che è possibile prevedere.</span><span class="sxs-lookup"><span data-stu-id="b26a3-386">But hopefully the Bean Trader sample demonstrates the general workflow and the types of issues that can be expected.</span></span> <span data-ttu-id="b26a3-387">Nonostante la lunghezza di questo articolo, le modifiche effettive necessarie nell'esempio Bean trader per farlo funzionare in .NET Core erano piuttosto limitate.</span><span class="sxs-lookup"><span data-stu-id="b26a3-387">And, despite this article's length, the actual changes needed in the Bean Trader sample to make it work on .NET Core were fairly limited.</span></span> <span data-ttu-id="b26a3-388">Molte app vengono migrate a .NET Core nello stesso modo; con limitazioni o persino senza modifiche al codice necessarie.</span><span class="sxs-lookup"><span data-stu-id="b26a3-388">Many apps migrate to .NET Core in this same way; with limited or even no code changes needed.</span></span>
