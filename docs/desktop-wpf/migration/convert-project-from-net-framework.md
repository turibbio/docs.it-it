---
title: Migrazione di app WPF a .NET Core 3.0Migrating WPF Apps to .NET Core 3.0
description: Informazioni su come eseguire la migrazione di un'app Windows Presentation Foundation (WPF) a .NET Core 3.0.
author: mjrousos
ms.date: 09/12/2019
ms.author: mikerou
ms.openlocfilehash: f52005e7c8a6312b8c4e09a950f1f635af1894e4
ms.sourcegitcommit: cdf5084648bf5e77970cbfeaa23f1cab3e6e234e
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 02/01/2020
ms.locfileid: "82071311"
---
# <a name="migrating-wpf-apps-to-net-core"></a><span data-ttu-id="b41f3-103">Migrazione di app WPF a .NET CoreMigrating WPF apps to .NET Core</span><span class="sxs-lookup"><span data-stu-id="b41f3-103">Migrating WPF apps to .NET Core</span></span>

<span data-ttu-id="b41f3-104">Questo articolo illustra i passaggi necessari per eseguire la migrazione di un'app Windows Presentation Foundation (WPF) da .NET Framework a .NET Core 3.0.</span><span class="sxs-lookup"><span data-stu-id="b41f3-104">This article covers the steps necessary to migrate a Windows Presentation Foundation (WPF) app from .NET Framework to .NET Core 3.0.</span></span> <span data-ttu-id="b41f3-105">Se non si dispone di un'app WPF a portata di mano per la porta, ma si desidera provare il processo, è possibile usare l'app di esempio **Bean Trader** disponibile su [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span><span class="sxs-lookup"><span data-stu-id="b41f3-105">If you don't have a WPF app on hand to port, but would like to try out the process, you can use the **Bean Trader** sample app available on [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span></span> <span data-ttu-id="b41f3-106">L'app originale (destinata a .NET Framework 4.7.2) è disponibile nella cartella NetFx-BeanTraderClient.</span><span class="sxs-lookup"><span data-stu-id="b41f3-106">The original app (targeting .NET Framework 4.7.2) is available in the NetFx\BeanTraderClient folder.</span></span> <span data-ttu-id="b41f3-107">In primo luogo spiegheremo i passaggi necessari per le applicazioni di porta in generale, e poi vedremo attraverso le modifiche specifiche che si applicano al **commerciante Bean** esempio.</span><span class="sxs-lookup"><span data-stu-id="b41f3-107">First we'll explain the steps necessary to port apps in general, and then we'll walk through the specific changes that apply to the **Bean Trader** sample.</span></span>

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

<span data-ttu-id="b41f3-108">Per eseguire la migrazione a .NET Core, è innanzitutto necessario:To migrate to .NET Core, you must first:</span><span class="sxs-lookup"><span data-stu-id="b41f3-108">To migrate to .NET Core, you must first:</span></span>

01. <span data-ttu-id="b41f3-109">Comprendere e aggiornare le dipendenze NuGet:Understand and update NuGet dependencies:</span><span class="sxs-lookup"><span data-stu-id="b41f3-109">Understand and update NuGet dependencies:</span></span>

    01. <span data-ttu-id="b41f3-110">Aggiornare le dipendenze `<PackageReference>` NuGet per utilizzare il formato.</span><span class="sxs-lookup"><span data-stu-id="b41f3-110">Upgrade NuGet dependencies to use the `<PackageReference>` format.</span></span>
    01. <span data-ttu-id="b41f3-111">Esaminare le dipendenze NuGet di primo livello per la compatibilità .NET Core o .NET Standard.Review top-level NuGet dependencies for .NET Core or .NET Standard compatibility.</span><span class="sxs-lookup"><span data-stu-id="b41f3-111">Review top-level NuGet dependencies for .NET Core or .NET Standard compatibility.</span></span>
    01. <span data-ttu-id="b41f3-112">Aggiornare i pacchetti NuGet alle versioni più recenti.</span><span class="sxs-lookup"><span data-stu-id="b41f3-112">Upgrade NuGet packages to newer versions.</span></span>
    01. <span data-ttu-id="b41f3-113">Utilizzare [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) per comprendere le dipendenze di .NET.</span><span class="sxs-lookup"><span data-stu-id="b41f3-113">Use the [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) to understand .NET dependencies.</span></span>

01. <span data-ttu-id="b41f3-114">Eseguire la migrazione del file di progetto nel nuovo formato in stile SDK:Migrate the project file to the new SDK-style format:</span><span class="sxs-lookup"><span data-stu-id="b41f3-114">Migrate the project file to the new SDK-style format:</span></span>

    01. <span data-ttu-id="b41f3-115">Scegliere se scegliere se scegliere come destinazione sia .NET Core che .NET Framework o solo .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b41f3-115">Choose whether to target both .NET Core and .NET Framework, or only .NET Core.</span></span>
    01. <span data-ttu-id="b41f3-116">Copiare le proprietà e gli elementi del file di progetto rilevanti nel nuovo file di progetto.</span><span class="sxs-lookup"><span data-stu-id="b41f3-116">Copy relevant project file properties and items to the new project file.</span></span>

01. <span data-ttu-id="b41f3-117">Risolvere i problemi di compilazione:Fix build issues:</span><span class="sxs-lookup"><span data-stu-id="b41f3-117">Fix build issues:</span></span>

    01. <span data-ttu-id="b41f3-118">Aggiungere un riferimento al pacchetto [Microsoft.Windows.Compatibility.Add](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) a reference to the Microsoft.Windows.Compatibility package.</span><span class="sxs-lookup"><span data-stu-id="b41f3-118">Add a reference to the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) package.</span></span>
    01. <span data-ttu-id="b41f3-119">Trovare e correggere le differenze a livello di API.</span><span class="sxs-lookup"><span data-stu-id="b41f3-119">Find and fix API-level differences.</span></span>
    01. <span data-ttu-id="b41f3-120">Rimuovere le sezioni *app.config* diverse da `appSettings` o `connectionStrings`.</span><span class="sxs-lookup"><span data-stu-id="b41f3-120">Remove *app.config* sections other than `appSettings` or `connectionStrings`.</span></span>
    01. <span data-ttu-id="b41f3-121">Rigenerare il codice generato, se necessario.</span><span class="sxs-lookup"><span data-stu-id="b41f3-121">Regenerate generated code, if necessary.</span></span>

01. <span data-ttu-id="b41f3-122">Test di runtime:</span><span class="sxs-lookup"><span data-stu-id="b41f3-122">Runtime testing:</span></span>

    01. <span data-ttu-id="b41f3-123">Verificare che l'app con conversione funzioni come previsto.</span><span class="sxs-lookup"><span data-stu-id="b41f3-123">Confirm the ported app works as expected.</span></span>
    01. <span data-ttu-id="b41f3-124">Attenzione alle <xref:System.NotSupportedException> eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b41f3-124">Beware of <xref:System.NotSupportedException> exceptions.</span></span>

## <a name="about-the-sample"></a><span data-ttu-id="b41f3-125">Informazioni sull'esempio</span><span class="sxs-lookup"><span data-stu-id="b41f3-125">About the sample</span></span>

<span data-ttu-id="b41f3-126">Questo articolo fa riferimento [all'app di esempio Bean Trader](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) perché usa una varietà di dipendenze simili a quelle che le app WPF del mondo reale potrebbero avere.</span><span class="sxs-lookup"><span data-stu-id="b41f3-126">This article references the [Bean Trader sample app](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) because it uses a variety of dependencies similar to those that real-world WPF apps might have.</span></span> <span data-ttu-id="b41f3-127">L'app non è grande, ma è pensata per essere un passo avanti rispetto a 'Hello World' in termini di complessità.</span><span class="sxs-lookup"><span data-stu-id="b41f3-127">The app isn't large, but is meant to be a step up from 'Hello World' in terms of complexity.</span></span> <span data-ttu-id="b41f3-128">L'app dimostra alcuni problemi che gli utenti possono riscontrare durante il porting di app reali.</span><span class="sxs-lookup"><span data-stu-id="b41f3-128">The app demonstrates some issues users may encounter while porting real apps.</span></span> <span data-ttu-id="b41f3-129">L'app comunica con un servizio WCF, pertanto per la corretta esecuzione, è inoltre necessario eseguire il progetto BeanTraderServer (disponibile nello stesso repository GitHub) e assicurarsi che la configurazione BeanTraderClient punti di configurazione all'endpoint corretto.</span><span class="sxs-lookup"><span data-stu-id="b41f3-129">The app communicates with a WCF service, so for it to run properly, you'll also need to run the BeanTraderServer project (available in the same GitHub repository) and make sure the BeanTraderClient configuration points to the correct endpoint.</span></span> <span data-ttu-id="b41f3-130">Per impostazione predefinita, nell'esempio si presuppone che *http://localhost:8090*il server sia in esecuzione sullo stesso computer in , che sarà vero se si avvia BeanTraderServer localmente.)</span><span class="sxs-lookup"><span data-stu-id="b41f3-130">(By default, the sample assumes the server is running on the same machine at *http://localhost:8090*, which will be true if you launch BeanTraderServer locally.)</span></span>

<span data-ttu-id="b41f3-131">Tieni presente che questa app di esempio ha lo scopo di illustrare le sfide e le soluzioni di porting di .NET Core.Keep in mind that this sample app is meant to demonstrate .NET Core porting challenges and solutions.</span><span class="sxs-lookup"><span data-stu-id="b41f3-131">Keep in mind that this sample app is meant to demonstrate .NET Core porting challenges and solutions.</span></span> <span data-ttu-id="b41f3-132">Non è destinato a dimostrare le procedure consigliate WPFWPF.</span><span class="sxs-lookup"><span data-stu-id="b41f3-132">It's not meant to demonstrate WPF best practices.</span></span> <span data-ttu-id="b41f3-133">Infatti, include deliberatamente alcuni anti-modelli per assicurarsi di incontrare almeno un paio di sfide interessanti durante il porting.</span><span class="sxs-lookup"><span data-stu-id="b41f3-133">In fact, it deliberately includes some anti-patterns to make sure you come across at least a couple of interesting challenges while porting.</span></span>

## <a name="getting-ready"></a><span data-ttu-id="b41f3-134">Preparazione</span><span class="sxs-lookup"><span data-stu-id="b41f3-134">Getting ready</span></span>

<span data-ttu-id="b41f3-135">La sfida principale della migrazione di un'app .NET Framework a .NET Core è che le relative dipendenze potrebbero funzionare in modo diverso o non funzionare affatto.</span><span class="sxs-lookup"><span data-stu-id="b41f3-135">The primary challenge of migrating a .NET Framework app to .NET Core is that its dependencies may work differently or not at all.</span></span> <span data-ttu-id="b41f3-136">La migrazione è molto più facile di prima; molti pacchetti NuGet ora sono destinati a .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="b41f3-136">Migration is much easier than it used to be; many NuGet packages now target .NET Standard.</span></span> <span data-ttu-id="b41f3-137">A partire da .NET Core 2.0, le aree di superficie di .NET Framework e .NET Core sono diventate simili.</span><span class="sxs-lookup"><span data-stu-id="b41f3-137">Starting with .NET Core 2.0, the .NET Framework and .NET Core surface areas have become similar.</span></span> <span data-ttu-id="b41f3-138">Anche così, rimangono alcune differenze (sia nel supporto dei pacchetti NuGet che nelle API .NET disponibili).</span><span class="sxs-lookup"><span data-stu-id="b41f3-138">Even so, some differences (both in support from NuGet packages and in available .NET APIs) remain.</span></span> <span data-ttu-id="b41f3-139">The first step in migrating is to review the app's dependencies and make sure references are in a format that's easily migrated to .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b41f3-139">The first step in migrating is to review the app's dependencies and make sure references are in a format that's easily migrated to .NET Core.</span></span>

### <a name="upgrade-to-packagereference-nuget-references"></a><span data-ttu-id="b41f3-140">Eseguire `<PackageReference>` l'aggiornamento ai riferimenti NuGetUpgrade to NuGet references</span><span class="sxs-lookup"><span data-stu-id="b41f3-140">Upgrade to `<PackageReference>` NuGet references</span></span>

<span data-ttu-id="b41f3-141">I progetti .NET Framework meno recenti in genere elencano le dipendenze NuGet in un file *packages.config.*</span><span class="sxs-lookup"><span data-stu-id="b41f3-141">Older .NET Framework projects typically list their NuGet dependencies in a *packages.config* file.</span></span> <span data-ttu-id="b41f3-142">Il nuovo formato di file di progetto [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) in stile SDK fa riferimento ai pacchetti NuGet come elementi nel file csproj stesso anziché in un file di configurazione separato.</span><span class="sxs-lookup"><span data-stu-id="b41f3-142">The new SDK-style project file format references NuGet packages as [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) elements in the csproj file itself rather than in a separate config file.</span></span>

<span data-ttu-id="b41f3-143">Durante la migrazione, l'utilizzo dei riferimenti di stile presenta due vantaggi:When migrating, there are two advantages to using `<PackageReference>`-style references:</span><span class="sxs-lookup"><span data-stu-id="b41f3-143">When migrating, there are two advantages to using `<PackageReference>`-style references:</span></span>

- <span data-ttu-id="b41f3-144">Questo è lo stile di riferimento NuGet necessario per il nuovo file di progetto .NET Core.This is the style of NuGet reference that is required for the new .NET Core project file.</span><span class="sxs-lookup"><span data-stu-id="b41f3-144">This is the style of NuGet reference that is required for the new .NET Core project file.</span></span> <span data-ttu-id="b41f3-145">Se si sta `<PackageReference>`già utilizzando , tali elementi del file di progetto possono essere copiati e incollati direttamente nel nuovo progetto.</span><span class="sxs-lookup"><span data-stu-id="b41f3-145">If you're already using `<PackageReference>`, those project file elements can be copied and pasted directly into the new project.</span></span>
- <span data-ttu-id="b41f3-146">A differenza di un `<PackageReference>` file packages.config, gli elementi fanno riferimento solo alle dipendenze di primo livello da cui dipende direttamente il progetto.</span><span class="sxs-lookup"><span data-stu-id="b41f3-146">Unlike a packages.config file, `<PackageReference>` elements only refer to the top-level dependencies that your project depends on directly.</span></span> <span data-ttu-id="b41f3-147">Tutti gli altri pacchetti NuGet transitivi verranno determinati in fase di ripristino e registrati nel file obj-project.assets.json generato automaticamente.</span><span class="sxs-lookup"><span data-stu-id="b41f3-147">All other transitive NuGet packages will be determined at restore time and recorded in the autogenerated obj\project.assets.json file.</span></span> <span data-ttu-id="b41f3-148">In questo modo è molto più semplice determinare le dipendenze del progetto, che è utile per determinare se le dipendenze necessarie funzioneranno su .NET Core o meno.</span><span class="sxs-lookup"><span data-stu-id="b41f3-148">This makes it much easier to determine what dependencies your project has, which is useful when determining whether the necessary dependencies will work on .NET Core or not.</span></span>

<span data-ttu-id="b41f3-149">Il primo passaggio per la migrazione di un'app .NET Framework a .NET Core consiste nell'aggiornarla per usare `<PackageReference>` i riferimenti NuGet.</span><span class="sxs-lookup"><span data-stu-id="b41f3-149">The first step to migrating a .NET Framework app to .NET Core is to update it to use `<PackageReference>` NuGet references.</span></span> <span data-ttu-id="b41f3-150">Visual Studio semplifica questa operazione.</span><span class="sxs-lookup"><span data-stu-id="b41f3-150">Visual Studio makes this simple.</span></span> <span data-ttu-id="b41f3-151">È sufficiente fare clic con il pulsante destro del mouse sul file *packages.config* del progetto in **Esplora soluzioni**di Visual Studio , quindi **scegliere Migrate packages.config to PackageReference**.</span><span class="sxs-lookup"><span data-stu-id="b41f3-151">Just right-click the project's *packages.config* file in Visual Studio's **Solution Explorer**, and then select **Migrate packages.config to PackageReference**.</span></span>

![Aggiornamento a PackageReferenceUpgrading to PackageReference](./media/convert-project-from-net-framework/package-reference-migration.png)

<span data-ttu-id="b41f3-153">Viene visualizzata una finestra di dialogo che mostra le dipendenze NuGet di primo livello calcolate e chiede quali altri pacchetti NuGet devono essere promossi a livello superiore.</span><span class="sxs-lookup"><span data-stu-id="b41f3-153">A dialog appears showing calculated top-level NuGet dependencies and asking which other NuGet packages should be promoted to top-level.</span></span> <span data-ttu-id="b41f3-154">Nessuno di questi altri pacchetti deve essere di primo livello per l'esempio Bean Trader, in modo da poter deselezionare tutte queste caselle.</span><span class="sxs-lookup"><span data-stu-id="b41f3-154">None of these other packages need to be top-level for the Bean Trader sample, so you can uncheck all of those boxes.</span></span> <span data-ttu-id="b41f3-155">Quindi, fare clic su **OK** e `<PackageReference>` il file *packages.config* viene rimosso e gli elementi vengono aggiunti al file di progetto.</span><span class="sxs-lookup"><span data-stu-id="b41f3-155">Then, click **Ok** and the *packages.config* file is removed and `<PackageReference>` elements are added to the project file.</span></span>

<span data-ttu-id="b41f3-156">`<PackageReference>`I riferimenti -style non archiviano i pacchetti NuGet localmente in una cartella di pacchetti.</span><span class="sxs-lookup"><span data-stu-id="b41f3-156">`<PackageReference>`-style references don't store NuGet packages locally in a packages folder.</span></span> <span data-ttu-id="b41f3-157">Al contrario, vengono archiviati a livello globale come ottimizzazione.</span><span class="sxs-lookup"><span data-stu-id="b41f3-157">Instead, they're stored globally as an optimization.</span></span> <span data-ttu-id="b41f3-158">Al termine della migrazione, modificare il file `<Analyzer>` csproj e rimuovere tutti gli elementi che fanno riferimento agli analizzatori che in precedenza provenivano da *.. directory packages.*</span><span class="sxs-lookup"><span data-stu-id="b41f3-158">After the migration completes, edit the csproj file and remove any `<Analyzer>` elements referring to the analyzers that previously came from the *..\packages* directory.</span></span> <span data-ttu-id="b41f3-159">Non ti preoccupare; poiché si dispone ancora dei riferimenti al pacchetto NuGet, gli analizzatori verranno inclusi nel progetto.</span><span class="sxs-lookup"><span data-stu-id="b41f3-159">Don't worry; since you still have the NuGet package references, the analyzers will be included in the project.</span></span> <span data-ttu-id="b41f3-160">Hai solo bisogno di pulire i vecchi `<Analyzer>` elementi packages.config-style.</span><span class="sxs-lookup"><span data-stu-id="b41f3-160">You just need to clean up the old packages.config-style `<Analyzer>` elements.</span></span>

### <a name="review-nuget-packages"></a><span data-ttu-id="b41f3-161">Esaminare i pacchetti NuGetReview NuGet packages</span><span class="sxs-lookup"><span data-stu-id="b41f3-161">Review NuGet packages</span></span>

<span data-ttu-id="b41f3-162">Ora che è possibile visualizzare i pacchetti NuGet di primo livello da cui dipende il progetto, è possibile verificare se tali pacchetti sono disponibili in .NET Core.Now that you can see the top-level NuGet packages that the project depends on, you can review whether those packages are available on .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b41f3-162">Now that you can see the top-level NuGet packages that the project depends on, you can review whether those packages are available on .NET Core.</span></span> <span data-ttu-id="b41f3-163">È possibile determinare se un pacchetto supporta .NET Core esaminando le relative dipendenze da [nuget.org](https://www.nuget.org/). Il sito [fuget.org](https://www.fuget.org/) creato dalla comunità mostra queste informazioni in primo piano nella parte superiore della pagina delle informazioni del pacchetto.</span><span class="sxs-lookup"><span data-stu-id="b41f3-163">You can determine whether a package supports .NET Core by looking at its dependencies on [nuget.org](https://www.nuget.org/). The community-created [fuget.org](https://www.fuget.org/) site shows this information prominently at the top of the package information page.</span></span>

<span data-ttu-id="b41f3-164">Quando la destinazione è .NET Core 3.0, tutti i pacchetti destinati a .NET Core o .NET Standard dovrebbero funzionare (poiché .NET Core implementa l'area di superficie standard .NET).</span><span class="sxs-lookup"><span data-stu-id="b41f3-164">When targeting .NET Core 3.0, any packages targeting .NET Core or .NET Standard should work (since .NET Core implements the .NET Standard surface area).</span></span> <span data-ttu-id="b41f3-165">In alcuni casi, la versione specifica di un pacchetto utilizzato non è destinata a .NET Core o .NET Standard, ma le versioni più recenti.</span><span class="sxs-lookup"><span data-stu-id="b41f3-165">In some cases, the specific version of a package that's used won't target .NET Core or .NET Standard, but newer versions will.</span></span> <span data-ttu-id="b41f3-166">In questo caso, è consigliabile eseguire l'aggiornamento alla versione più recente del pacchetto.</span><span class="sxs-lookup"><span data-stu-id="b41f3-166">In this case, you should consider upgrading to the latest version of the package.</span></span>

<span data-ttu-id="b41f3-167">È possibile usare anche i pacchetti destinati a .NET Framework, ma ciò introduce alcuni rischi.</span><span class="sxs-lookup"><span data-stu-id="b41f3-167">You can use packages targeting .NET Framework, as well, but that introduces some risk.</span></span> <span data-ttu-id="b41f3-168">Le dipendenze da .NET Core a .NET Framework sono consentite perché le aree di superficie di .NET Core e .NET Framework sono abbastanza simili che tali dipendenze *spesso* funzionano.</span><span class="sxs-lookup"><span data-stu-id="b41f3-168">.NET Core to .NET Framework dependencies are allowed because .NET Core and .NET Framework surface areas are similar enough that such dependencies *often* work.</span></span> <span data-ttu-id="b41f3-169">Tuttavia, se il pacchetto tenta di utilizzare un'API .NET che non è presente in .NET Core, si verificherà un'eccezione di runtime.</span><span class="sxs-lookup"><span data-stu-id="b41f3-169">However, if the package tries to use a .NET API that isn't present in .NET Core, you'll encounter a runtime exception.</span></span> <span data-ttu-id="b41f3-170">Per questo scopo, è necessario fare riferimento ai pacchetti .NET Framework solo quando non sono disponibili altre opzioni e comprendere che questa operazione impone un onere per i test.</span><span class="sxs-lookup"><span data-stu-id="b41f3-170">Because of that, you should only reference .NET Framework packages when no other options are available and understand that doing so imposes a test burden.</span></span>

<span data-ttu-id="b41f3-171">Se ci sono pacchetti a cui viene fatto riferimento che non sono destinati a .NET Core o .NET Standard, dovrete pensare ad altre alternative:</span><span class="sxs-lookup"><span data-stu-id="b41f3-171">If there are packages referenced that don't target .NET Core or .NET Standard, you'll have to think about other alternatives:</span></span>

- <span data-ttu-id="b41f3-172">Ci sono altri pacchetti simili che possono essere utilizzati invece?</span><span class="sxs-lookup"><span data-stu-id="b41f3-172">Are there other similar packages that can be used instead?</span></span> <span data-ttu-id="b41f3-173">A volte gli autori NuGet pubblicano 'separati'. Versioni di base delle librerie destinate in modo specifico a .NET Core.Core' versions of their libraries specifically ing .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b41f3-173">Sometimes NuGet authors publish separate '.Core' versions of their libraries specifically targeting .NET Core.</span></span> <span data-ttu-id="b41f3-174">I pacchetti Enterprise Library sono un esempio della pubblicazione della community ". NetCore" alternative.</span><span class="sxs-lookup"><span data-stu-id="b41f3-174">Enterprise Library packages are an example of the community publishing ".NetCore" alternatives.</span></span> <span data-ttu-id="b41f3-175">In other cases, newer SDKs for a particular service (sometimes with different package names) are available for .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="b41f3-175">In other cases, newer SDKs for a particular service (sometimes with different package names) are available for .NET Standard.</span></span> <span data-ttu-id="b41f3-176">Se non sono disponibili alternative, è possibile procedere utilizzando i pacchetti di .NET Framework mirati, tenendo presente che è necessario testarli accuratamente una volta eseguito su .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b41f3-176">If no alternatives are available, you can proceed using the .NET Framework-targeted packages, bearing in mind that you'll need to test them thoroughly once running on .NET Core.</span></span>

<span data-ttu-id="b41f3-177">L'esempio Bean Trader ha le seguenti dipendenze NuGet di primo livello:</span><span class="sxs-lookup"><span data-stu-id="b41f3-177">The Bean Trader sample has the following top-level NuGet dependencies:</span></span>

- [<span data-ttu-id="b41f3-178">**Castle.Windsor, versione 4.1.1**</span><span class="sxs-lookup"><span data-stu-id="b41f3-178">**Castle.Windsor, version 4.1.1**</span></span>](https://www.castleproject.org/projects/windsor/)  

  <span data-ttu-id="b41f3-179">Questo pacchetto è destinato a .NET Standard 1.6, quindi funziona in .NET Core.This package targets .NET Standard 1.6, so it works on .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b41f3-179">This package targets .NET Standard 1.6, so it works on .NET Core.</span></span>

- [<span data-ttu-id="b41f3-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, versione 2.6.3**</span><span class="sxs-lookup"><span data-stu-id="b41f3-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, version 2.6.3**</span></span>](https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/2.6.3)  
  <span data-ttu-id="b41f3-181">Questo è un meta-pacchetto, quindi non è immediatamente ovvio quali piattaforme supporta, ma la [documentazione](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indica che la sua versione più recente (2.9.2) funzionerà sia per .NET Framework che per .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b41f3-181">This is a meta-package, so it's not immediately obvious which platforms it supports, but [documentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indicates that its newest version (2.9.2) will work for both .NET Framework and .NET Core.</span></span>

- [<span data-ttu-id="b41f3-182">**Nito.AsyncEx, versione 4.0.1**</span><span class="sxs-lookup"><span data-stu-id="b41f3-182">**Nito.AsyncEx, version 4.0.1**</span></span>](https://www.nuget.org/packages/Nito.AsyncEx/4.0.1)  

  <span data-ttu-id="b41f3-183">Questo pacchetto non è destinato a .NET Core, ma la versione 5.0 più recente.</span><span class="sxs-lookup"><span data-stu-id="b41f3-183">This package doesn't target .NET Core, but the newer 5.0 version does.</span></span> <span data-ttu-id="b41f3-184">Ciò è comune durante la migrazione perché molti pacchetti NuGet hanno aggiunto di recente il supporto .NET Standard, ma le versioni di progetto precedenti saranno destinate solo a .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b41f3-184">This is common when migrating because many NuGet packages have added .NET Standard support recently, but older project versions will only target .NET Framework.</span></span> <span data-ttu-id="b41f3-185">Se la differenza di versione è solo una differenza di versione minore, è spesso facile eseguire l'aggiornamento alla versione più recente.</span><span class="sxs-lookup"><span data-stu-id="b41f3-185">If the version difference is only a minor version difference, it's often easy to upgrade to the newer version.</span></span> <span data-ttu-id="b41f3-186">Poiché si tratta di una modifica di versione principale, è necessario prestare attenzione all'aggiornamento poiché potrebbero essere presenti modifiche di rilievo nel pacchetto.</span><span class="sxs-lookup"><span data-stu-id="b41f3-186">Because this is a major version change, you need to be cautious upgrading since there could be breaking changes in the package.</span></span> <span data-ttu-id="b41f3-187">C'è una strada da percorrere, però, che è buona.</span><span class="sxs-lookup"><span data-stu-id="b41f3-187">There is a path forward, though, which is good.</span></span>

- [<span data-ttu-id="b41f3-188">**MahApps.Metro, versione 1.6.5**</span><span class="sxs-lookup"><span data-stu-id="b41f3-188">**MahApps.Metro, version 1.6.5**</span></span>](https://www.nuget.org/packages/MahApps.Metro/1.6.5)  

  <span data-ttu-id="b41f3-189">Questo pacchetto non è destinato a .NET Core, ma ha una versione non definitiva più recente (2.0-alfa) che ha.</span><span class="sxs-lookup"><span data-stu-id="b41f3-189">This package also doesn't target .NET Core, but has a newer pre-release (2.0-alpha) that does.</span></span> <span data-ttu-id="b41f3-190">Ancora una volta, si deve guardare fuori per i cambiamenti di rottura, ma il pacchetto più recente è incoraggiante.</span><span class="sxs-lookup"><span data-stu-id="b41f3-190">Again, you have to look out for breaking changes, but the newer package is encouraging.</span></span>

<span data-ttu-id="b41f3-191">Dipendenze NuGet dell'esempio Bean Trader sono tutte destinate a .NET Standard/.NET Core o con versioni più recenti che lo fanno, pertanto è improbabile che vi siano problemi di blocco qui.</span><span class="sxs-lookup"><span data-stu-id="b41f3-191">The Bean Trader sample's NuGet dependencies all either target .NET Standard/.NET Core or have newer versions that do, so there are unlikely to be any blocking issues here.</span></span>

### <a name="upgrade-nuget-packages"></a><span data-ttu-id="b41f3-192">Aggiornare i pacchetti NuGetUpgrade NuGet packages</span><span class="sxs-lookup"><span data-stu-id="b41f3-192">Upgrade NuGet packages</span></span>

<span data-ttu-id="b41f3-193">Se possibile, sarebbe bene aggiornare le versioni di tutti i pacchetti destinati solo a .NET Core o .NET Standard con versioni più recenti a questo punto (con il progetto ancora destinato a .NET Framework) per individuare e risolvere in anticipo eventuali modifiche di rilievo.</span><span class="sxs-lookup"><span data-stu-id="b41f3-193">If possible, it would be good to upgrade the versions of any packages that only target .NET Core or .NET Standard with more recent versions at this point (with the project still targeting .NET Framework) to discover and address any breaking changes early.</span></span>

<span data-ttu-id="b41f3-194">Se si preferisce non apportare modifiche rilevanti alla versione .NET Framework esistente dell'app, questa operazione può attendere fino a quando non si dispone di un nuovo file di progetto destinato a .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b41f3-194">If you would rather not make any material changes to the existing .NET Framework version of the app, this can wait until you have a new project file targeting .NET Core.</span></span> <span data-ttu-id="b41f3-195">Tuttavia, l'aggiornamento dei pacchetti NuGet alle versioni compatibili con .NET Core in anticipo rende il processo di migrazione ancora più semplice dopo aver creato il nuovo file di progetto e riduce il numero di differenze tra le versioni di .NET Framework e .NET Core dell'app.</span><span class="sxs-lookup"><span data-stu-id="b41f3-195">However, upgrading the NuGet packages to .NET Core-compatible versions ahead of time makes the migration process even easier once you create the new project file and reduces the number of differences between the .NET Framework and .NET Core versions of the app.</span></span>

<span data-ttu-id="b41f3-196">Con l'esempio Bean Trader, tutti gli aggiornamenti necessari possono essere effettuati facilmente (utilizzando il gestore di pacchetti NuGet di Visual Studio) con un'eccezione: l'aggiornamento da **MahApps.Metro 1.6.5** a **2.0** rivela le modifiche di rilievo relative alle API di gestione del tema e dell'accento.</span><span class="sxs-lookup"><span data-stu-id="b41f3-196">With the Bean Trader sample, all of the necessary upgrades can be made easily (using Visual Studio's NuGet package manager) with one exception: upgrading from **MahApps.Metro 1.6.5** to **2.0** reveals breaking changes related to theme and accent management APIs.</span></span>

<span data-ttu-id="b41f3-197">Idealmente, l'app verrebbe aggiornata per usare la versione più recente del pacchetto (poiché è più probabile che funzioni su .NET Core).</span><span class="sxs-lookup"><span data-stu-id="b41f3-197">Ideally, the app would be updated to use the newer version of the package (since that is more likely to work on .NET Core).</span></span> <span data-ttu-id="b41f3-198">In alcuni casi, tuttavia, ciò potrebbe non essere fattibile.</span><span class="sxs-lookup"><span data-stu-id="b41f3-198">In some cases, however, that may not be feasible.</span></span> <span data-ttu-id="b41f3-199">In questi casi, non aggiornare **MahApps.Metro** perché le modifiche necessarie non sono banali e questa esercitazione si concentra sulla migrazione a .NET Core 3, non a **MahApps.Metro 2.**</span><span class="sxs-lookup"><span data-stu-id="b41f3-199">In these cases, don't upgrade **MahApps.Metro** because the necessary changes are non-trivial and this tutorial focuses on migrating to .NET Core 3, not to **MahApps.Metro 2.**</span></span> <span data-ttu-id="b41f3-200">Inoltre, si tratta di una dipendenza .NET Framework a basso rischio perché l'app Bean Trader esercita solo una piccola parte di **MahApps.Metro**.</span><span class="sxs-lookup"><span data-stu-id="b41f3-200">Also, this is a low-risk .NET Framework dependency because the Bean Trader app only exercises a small part of **MahApps.Metro**.</span></span> <span data-ttu-id="b41f3-201">Naturalmente, richiederà test per assicurarsi che tutto funzioni una volta completata la migrazione.</span><span class="sxs-lookup"><span data-stu-id="b41f3-201">It will, of course, require testing to make sure everything's working once the migration is complete.</span></span> <span data-ttu-id="b41f3-202">Se questo fosse uno scenario reale, sarebbe bene presentare un problema per tenere traccia del lavoro per passare a **MahApps.Metro** versione 2.0 poiché non facendo la migrazione ora lascia dietro di sé un certo debito tecnico.</span><span class="sxs-lookup"><span data-stu-id="b41f3-202">If this were a real-world scenario, it would be good to file an issue to track the work to move to **MahApps.Metro** version 2.0 since not doing the migration now leaves behind some technical debt.</span></span>

<span data-ttu-id="b41f3-203">Una volta che i pacchetti NuGet `<PackageReference>` vengono aggiornati alle versioni recenti, il gruppo di elementi nel file di progetto dell'esempio Bean Trader dovrebbe essere simile al seguente.</span><span class="sxs-lookup"><span data-stu-id="b41f3-203">Once the NuGet packages are updated to recent versions, the `<PackageReference>` item group in the Bean Trader sample's project file should look like this.</span></span>

```xml
<ItemGroup>
  <PackageReference Include="Castle.Windsor">
    <Version>4.1.1</Version>
  </PackageReference>
  <PackageReference Include="MahApps.Metro">
    <Version>1.6.5</Version>
  </PackageReference>
  <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers">
    <Version>2.9.2</Version>
  </PackageReference>
  <PackageReference Include="Nito.AsyncEx">
    <Version>5.0.0</Version>
  </PackageReference>
</ItemGroup>
```

### <a name="net-framework-portability-analysis"></a><span data-ttu-id="b41f3-204">Analisi della portabilità di .NET Framework</span><span class="sxs-lookup"><span data-stu-id="b41f3-204">.NET Framework portability analysis</span></span>

<span data-ttu-id="b41f3-205">Una volta compreso lo stato delle dipendenze NuGet del progetto, l'elemento successivo da considerare è le dipendenze dell'API di .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b41f3-205">Once you understand the state of your project's NuGet dependencies, the next thing to consider is .NET Framework API dependencies.</span></span> <span data-ttu-id="b41f3-206">Lo strumento [analizzatore di portabilità .NET](../../standard/analyzers/portability-analyzer.md) è utile per comprendere quali API .NET utilizzate dal progetto sono disponibili in altre piattaforme .NET.</span><span class="sxs-lookup"><span data-stu-id="b41f3-206">The [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) tool is useful for understanding which of the .NET APIs your project uses are available on other .NET platforms.</span></span>

<span data-ttu-id="b41f3-207">Lo strumento viene fornito come un [plug-in](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer)di Visual Studio , uno strumento da riga di [comando](https://github.com/Microsoft/dotnet-apiport/releases)o avvolto in una [semplice GUI](https://github.com/Microsoft/dotnet-apiport-ui), che semplifica le opzioni.</span><span class="sxs-lookup"><span data-stu-id="b41f3-207">The tool comes as a [Visual Studio plugin](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), a [command-line tool](https://github.com/Microsoft/dotnet-apiport/releases), or wrapped in a [simple GUI](https://github.com/Microsoft/dotnet-apiport-ui), which simplifies its options.</span></span> <span data-ttu-id="b41f3-208">Per altre informazioni sull'uso di .NET Portability Analyzer (porta API) usando la GUI nel post di blog [Porting desktop apps to .NET Core.](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/)</span><span class="sxs-lookup"><span data-stu-id="b41f3-208">You can read more about using the .NET Portability Analyzer (API Port) using the GUI in the [Porting desktop apps to .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog post.</span></span> <span data-ttu-id="b41f3-209">Se si preferisce utilizzare la riga di comando, i passaggi necessari sono:</span><span class="sxs-lookup"><span data-stu-id="b41f3-209">If you prefer to use the command line, the necessary steps are:</span></span>

1. <span data-ttu-id="b41f3-210">Scaricare [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) se non è già presente.</span><span class="sxs-lookup"><span data-stu-id="b41f3-210">Download the [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) if you don't already have it.</span></span>
1. <span data-ttu-id="b41f3-211">Assicurarsi che l'app .NET Framework da convertire compilazioni correttamente (questa è una buona idea prima della migrazione indipendentemente).</span><span class="sxs-lookup"><span data-stu-id="b41f3-211">Make sure the .NET Framework app to be ported builds successfully (this is a good idea prior to migration regardless).</span></span>
1. <span data-ttu-id="b41f3-212">Eseguire Porta API con una riga di comando come questa.</span><span class="sxs-lookup"><span data-stu-id="b41f3-212">Run API Port with a command line like this.</span></span>

    ```console
    ApiPort.exe analyze -f <PathToBeanTraderBinaries> -r html -r excel -t ".NET Core"
    ```

    <span data-ttu-id="b41f3-213">L'argomento `-f` specifica il percorso contenente i file binari da analizzare.</span><span class="sxs-lookup"><span data-stu-id="b41f3-213">The `-f` argument specifies the path containing the binaries to analyze.</span></span> <span data-ttu-id="b41f3-214">L'argomento `-r` consente di specificare il formato di file di output desiderato.</span><span class="sxs-lookup"><span data-stu-id="b41f3-214">The `-r` argument specifies which output file format you want.</span></span> <span data-ttu-id="b41f3-215">L'argomento `-t` specifica la piattaforma .NET con cui analizzare l'utilizzo delle API.</span><span class="sxs-lookup"><span data-stu-id="b41f3-215">The `-t` argument specifies which .NET platform to analyze API usage against.</span></span> <span data-ttu-id="b41f3-216">In this case, you want .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b41f3-216">In this case, you want .NET Core.</span></span>

<span data-ttu-id="b41f3-217">Quando si apre il report HTML, la prima sezione elencherà tutti i file binari analizzati e la percentuale delle API .NET utilizzate sono disponibili nella piattaforma di destinazione.</span><span class="sxs-lookup"><span data-stu-id="b41f3-217">When you open the HTML report, the first section will list all of the analyzed binaries and what percentage of the .NET APIs they use are available on the targeted platform.</span></span> <span data-ttu-id="b41f3-218">La percentuale non è significativa da sola.</span><span class="sxs-lookup"><span data-stu-id="b41f3-218">The percentage is not meaningful by itself.</span></span> <span data-ttu-id="b41f3-219">La cosa più utile è vedere le API specifiche che mancano.</span><span class="sxs-lookup"><span data-stu-id="b41f3-219">What's more useful is to see the specific APIs that are missing.</span></span> <span data-ttu-id="b41f3-220">A tale scopo, selezionare il nome di un assembly o scorrere verso il basso fino ai report per i singoli assembly.</span><span class="sxs-lookup"><span data-stu-id="b41f3-220">To do that, either select an assembly name or scroll down to the reports for individual assemblies.</span></span>

<span data-ttu-id="b41f3-221">Concentrarsi sugli assembly di cui si è proprietari del codice sorgente.</span><span class="sxs-lookup"><span data-stu-id="b41f3-221">Focus on the assemblies that you own the source code for.</span></span> <span data-ttu-id="b41f3-222">Nel report Bean Trader ApiPort, ad esempio, sono elencati molti file binari, ma la maggior parte di essi appartiene ai pacchetti NuGet.</span><span class="sxs-lookup"><span data-stu-id="b41f3-222">In the Bean Trader ApiPort report, for example, there are many binaries listed, but most of them belong to NuGet packages.</span></span> <span data-ttu-id="b41f3-223">`Castle.Windsor`dimostra che dipende da alcune API System.Web mancanti in .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b41f3-223">`Castle.Windsor` shows that it depends on some System.Web APIs that are missing in .NET Core.</span></span> <span data-ttu-id="b41f3-224">Questo non è un problema perché `Castle.Windsor` in precedenza verificato che supporta .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b41f3-224">This isn't a concern because you previously verified that `Castle.Windsor` supports .NET Core.</span></span> <span data-ttu-id="b41f3-225">È comune che i pacchetti NuGet dispongano di file binari diversi per l'utilizzo `Castle.Windsor` con piattaforme .NET diverse, pertanto se la versione di .NET Framework degli utilizzi o meno delle API System.Web è irrilevante, purché il pacchetto sia destinato anche a .NET Standard o .NET Core (operazione che viene).</span><span class="sxs-lookup"><span data-stu-id="b41f3-225">It is common for NuGet packages to have different binaries for use with different .NET platforms, so whether the .NET Framework version of `Castle.Windsor` uses System.Web APIs or not is irrelevant as long as the package also targets .NET Standard or .NET Core (which it does).</span></span>

<span data-ttu-id="b41f3-226">Con l'esempio Bean Trader, l'unico binario che è necessario considerare è **BeanTraderClient** e `System.ServiceModel.ClientBase<T>.Close` `System.ServiceModel.ClientBase<T>.Open`il report mostra che mancano solo due API .NET: e .</span><span class="sxs-lookup"><span data-stu-id="b41f3-226">With the Bean Trader sample, the only binary that you need to consider is **BeanTraderClient** and the report shows that only two .NET APIs are missing: `System.ServiceModel.ClientBase<T>.Close` and `System.ServiceModel.ClientBase<T>.Open`.</span></span>

![Report di portabilità BeanTraderClient](./media/convert-project-from-net-framework/portability-report.png)

<span data-ttu-id="b41f3-228">È improbabile che si tratti di problemi di blocco perché le API client WCF sono (per lo più) supportate in .NET Core, pertanto devono essere disponibili alternative per queste API centrali.</span><span class="sxs-lookup"><span data-stu-id="b41f3-228">These are unlikely to be blocking issues because WCF Client APIs are (mostly) supported on .NET Core, so there must be alternatives available for these central APIs.</span></span> <span data-ttu-id="b41f3-229">Infatti, esaminando `System.ServiceModel`l'area di superficie <https://apisof.net>di .NET Core (utilizzando ), si nota che esistono alternative asincrone in .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b41f3-229">In fact, looking at `System.ServiceModel`'s .NET Core surface area (using <https://apisof.net>), you see that there are async alternatives in .NET Core instead.</span></span>

<span data-ttu-id="b41f3-230">Sulla base di questo report e l'analisi delle dipendenze NuGet precedente, sembra che non dovrebbero esserci problemi importanti la migrazione dell'esempio Bean Trader a .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b41f3-230">Based on this report and the previous NuGet dependency analysis, it looks like there should be no major issues migrating the Bean Trader sample to .NET Core.</span></span> <span data-ttu-id="b41f3-231">Si è pronti per il passaggio successivo in cui si avvierà effettivamente la migrazione.</span><span class="sxs-lookup"><span data-stu-id="b41f3-231">You're ready for the next step in which you'll actually start the migration.</span></span>

## <a name="migrating-the-project-file"></a><span data-ttu-id="b41f3-232">Migrazione del file di progetto</span><span class="sxs-lookup"><span data-stu-id="b41f3-232">Migrating the project file</span></span>

<span data-ttu-id="b41f3-233">Se l'app non usa il nuovo formato di file di [progetto in stile SDK,](../../core/tools/csproj.md)è necessario un nuovo file di progetto per impostare come destinazione .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b41f3-233">If your app isn't using the new [SDK-style project file format](../../core/tools/csproj.md), you'll need a new project file to target .NET Core.</span></span> <span data-ttu-id="b41f3-234">È possibile sostituire il file csproj esistente o, se si preferisce mantenere il progetto esistente invariato nello stato corrente, è possibile aggiungere un nuovo file csproj destinato a .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b41f3-234">You can replace the existing csproj file or, if you prefer to keep the existing project untouched in its current state, you can add a new csproj file targeting .NET Core.</span></span> <span data-ttu-id="b41f3-235">Puoi compilare versioni dell'app per .NET Framework e .NET Core con un singolo file `<TargetFrameworks>` di progetto in stile SDK con [multitargeting](../../standard/library-guidance/cross-platform-targeting.md) (specificando più destinazioni).</span><span class="sxs-lookup"><span data-stu-id="b41f3-235">You can build versions of the app for .NET Framework and .NET Core with a single SDK-style project file with [multi-targeting](../../standard/library-guidance/cross-platform-targeting.md) (specifying multiple `<TargetFrameworks>` targets).</span></span>

<span data-ttu-id="b41f3-236">Per creare il nuovo file di progetto, è possibile creare `dotnet new wpf` un nuovo progetto WPF in Visual Studio o usare il comando in una directory temporanea per generare il file di progetto e quindi copiarlo/rinominarlo nel percorso corretto.</span><span class="sxs-lookup"><span data-stu-id="b41f3-236">To create the new project file, you can create a new WPF project in Visual Studio or use the `dotnet new wpf` command in a temporary directory to generate the project file and then copy/rename it to the correct location.</span></span> <span data-ttu-id="b41f3-237">C'è anche uno strumento creato dalla comunità, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), che può automatizzare parte della migrazione dei file di progetto.</span><span class="sxs-lookup"><span data-stu-id="b41f3-237">There is also a community-created tool, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), that can automate some of the project file migration.</span></span> <span data-ttu-id="b41f3-238">Lo strumento è utile, ma ha ancora bisogno di un essere umano per esaminare i risultati per assicurarsi che tutti i dettagli della migrazione siano corretti.</span><span class="sxs-lookup"><span data-stu-id="b41f3-238">The tool is helpful but still needs a human to review the results to make sure all the details of the migration are correct.</span></span> <span data-ttu-id="b41f3-239">Un'area particolare che lo strumento non gestisce in modo ottimale è la migrazione dei pacchetti NuGet dai file *packages.config.*</span><span class="sxs-lookup"><span data-stu-id="b41f3-239">One particular area that the tool doesn't handle optimally is migrating NuGet packages from *packages.config* files.</span></span> <span data-ttu-id="b41f3-240">Se lo strumento viene eseguito in un file di progetto che usa ancora un file *packages.config* per fare riferimento ai pacchetti NuGet, verrà eseguita automaticamente la migrazione agli `<PackageReference>` elementi, ma aggiungerà `<PackageReference>` elementi per tutti *i* pacchetti anziché solo quelli di primo livello.</span><span class="sxs-lookup"><span data-stu-id="b41f3-240">If the tool runs on a project file that still uses a *packages.config* file to reference NuGet packages, it will migrate to `<PackageReference>` elements automatically, but will add `<PackageReference>` elements for *all* of the packages instead of just top-level ones.</span></span> <span data-ttu-id="b41f3-241">Se è già stata`<PackageReference>` eseguita la migrazione agli elementi con Visual Studio (come è stato fatto in questo esempio), lo strumento può aiutare con il resto della conversione.</span><span class="sxs-lookup"><span data-stu-id="b41f3-241">If you have already migrated to`<PackageReference>` elements with Visual Studio (as you've done in this sample), then the tool can help with the rest of the conversion.</span></span> <span data-ttu-id="b41f3-242">Come Scott Hanselman raccomanda nel [suo post sul blog sulla migrazione di file csproj](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), porting a mano è educativo e darà risultati migliori se si dispone solo di pochi progetti da portare.</span><span class="sxs-lookup"><span data-stu-id="b41f3-242">Like Scott Hanselman recommends in [his blog post on migrating csproj files](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), porting by hand is educational and will give better results if you only have a few projects to port.</span></span> <span data-ttu-id="b41f3-243">Ma se si esegue il porting di decine o centinaia di file di progetto, uno strumento come [CsprojToVs2017] può essere d'aiuto.</span><span class="sxs-lookup"><span data-stu-id="b41f3-243">But if you are porting dozens or hundreds of project files, then a tool like [CsprojToVs2017] can be a help.</span></span>

<span data-ttu-id="b41f3-244">Per creare un nuovo file di progetto `dotnet new wpf` per l'esempio Bean Trader, eseguire in una directory temporanea e spostare il file *con estensione csproj* generato nella cartella *BeanTraderClient* e rinominarlo **BeanTraderClient.Core.csproj**.</span><span class="sxs-lookup"><span data-stu-id="b41f3-244">To create a new project file for the Bean Trader sample, run `dotnet new wpf` in a temporary directory and move the generated *.csproj* file into the *BeanTraderClient* folder and rename it **BeanTraderClient.Core.csproj**.</span></span>

<span data-ttu-id="b41f3-245">Poiché il nuovo formato di file di progetto include automaticamente i file di C, i file *resx* e i file XAML trovati nella directory o nella directory, il file di progetto è già quasi completo.</span><span class="sxs-lookup"><span data-stu-id="b41f3-245">Because the new project file format automatically includes C# files, *resx* files, and XAML files that it finds in or under its directory, the project file is already almost complete!</span></span> <span data-ttu-id="b41f3-246">Per completare la migrazione, aprire i file di progetto vecchi e nuovi side-by-side e guardare attraverso quello precedente per vedere se tutte le informazioni che contiene deve essere migrato.</span><span class="sxs-lookup"><span data-stu-id="b41f3-246">To finish the migration, open the old and new project files side-by-side and look through the old one to see if any information it contains needs to be migrated.</span></span> <span data-ttu-id="b41f3-247">Nel caso di esempio Bean Trader, i seguenti elementi devono essere copiati nel nuovo progetto:</span><span class="sxs-lookup"><span data-stu-id="b41f3-247">In the Bean Trader sample case, the following items should be copied to the new project:</span></span>

- <span data-ttu-id="b41f3-248">Le `<RootNamespace>` `<AssemblyName>`proprietà `<ApplicationIcon>` , e devono essere tutte copiate.</span><span class="sxs-lookup"><span data-stu-id="b41f3-248">The `<RootNamespace>`, `<AssemblyName>`, and `<ApplicationIcon>` properties should all be copied.</span></span>

- <span data-ttu-id="b41f3-249">È inoltre necessario `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` aggiungere una proprietà al nuovo file di progetto poiché `[AssemblyTitle]`l'esempio Bean Trader include attributi a livello di assembly (ad esempio ) in un file di AssemblyInfo.cs.</span><span class="sxs-lookup"><span data-stu-id="b41f3-249">You also need to add a `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` property to the new project file since the Bean Trader sample includes assembly-level attributes (like `[AssemblyTitle]`) in an AssemblyInfo.cs file.</span></span> <span data-ttu-id="b41f3-250">Per impostazione predefinita, i nuovi progetti in stile SDK genereranno automaticamente questi attributi in base alle proprietà nel file csproj.</span><span class="sxs-lookup"><span data-stu-id="b41f3-250">By default, new SDK-style projects will autogenerate these attributes based on properties in the csproj file.</span></span> <span data-ttu-id="b41f3-251">Poiché non si desidera che ciò accada in questo caso (gli attributi generati automaticamente `<GenerateAssemblyInfo>`sarebbero in conflitto con quelli di AssemblyInfo.cs), si disattivano gli attributi generati automaticamente con .</span><span class="sxs-lookup"><span data-stu-id="b41f3-251">Because you don't want that to happen in this case (the autogenerated attributes would conflict with those from AssemblyInfo.cs), you disable the autogenerated attributes with `<GenerateAssemblyInfo>`.</span></span>

- <span data-ttu-id="b41f3-252">Anche se i file *resx* vengono `<Resource>` inclusi automaticamente come risorse incorporate, altri elementi come le immagini non lo sono.</span><span class="sxs-lookup"><span data-stu-id="b41f3-252">Although *resx* files are automatically included as embedded resources, other `<Resource>` items like images are not.</span></span> <span data-ttu-id="b41f3-253">Quindi, copiare gli `<Resource>` elementi per incorporare i file di immagine e icona.</span><span class="sxs-lookup"><span data-stu-id="b41f3-253">So, copy the `<Resource>` elements for embedding image and icon files.</span></span> <span data-ttu-id="b41f3-254">È possibile semplificare i riferimenti png a una singola riga utilizzando il supporto `<Resource Include="**\*.png" />`del nuovo formato di file di progetto per i modelli di globbing: .</span><span class="sxs-lookup"><span data-stu-id="b41f3-254">You can simplify the png references to a single line by using the new project file format's support for globbing patterns: `<Resource Include="**\*.png" />`.</span></span>

- <span data-ttu-id="b41f3-255">Analogamente, `<None>` gli elementi vengono inclusi automaticamente, ma non vengono copiati nella directory di output, per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="b41f3-255">Similarly, `<None>` items are included automatically, but they aren't copied to the output directory, by default.</span></span> <span data-ttu-id="b41f3-256">Poiché `<None>` il progetto Bean Trader include un elemento che *viene* copiato nella directory di output (utilizzando `PreserveNewest` i comportamenti), è necessario aggiornare l'elemento popolato `<None>` automaticamente per tale file, in questo modo.</span><span class="sxs-lookup"><span data-stu-id="b41f3-256">Because the Bean Trader project includes a `<None>` item that *is* copied to the output directory (using `PreserveNewest` behaviors), you need to update the automatically populated `<None>` item for that file, like this.</span></span>

  ```xml
  <None Update="BeanTrader.pfx">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
  ```

- <span data-ttu-id="b41f3-257">L'esempio Bean Trader include un file XAML `Content` (Default.Accent.xaml) come (anziché come un `Page`) perché i temi e gli accenti definiti in questo file vengono caricati dal codice XAML del file in fase di esecuzione, anziché essere incorporati nell'app stessa.</span><span class="sxs-lookup"><span data-stu-id="b41f3-257">The Bean Trader sample includes a XAML file (Default.Accent.xaml) as `Content` (rather than as a `Page`) because themes and accents defined in this file are loaded from the file's XAML at runtime, rather than being embedded in the app itself.</span></span> <span data-ttu-id="b41f3-258">Il nuovo sistema del progetto `<Page>`include automaticamente questo file come , tuttavia, poiché si tratta di un file XAML.</span><span class="sxs-lookup"><span data-stu-id="b41f3-258">The new project system automatically includes this file as a `<Page>`, however, since it's a XAML file.</span></span> <span data-ttu-id="b41f3-259">Pertanto, è necessario rimuovere il file`<Page Remove="**\Default.Accent.xaml" />`XAML come pagina ( ) e aggiungerlo come contenuto.</span><span class="sxs-lookup"><span data-stu-id="b41f3-259">So, you need to both remove the XAML file as a page (`<Page Remove="**\Default.Accent.xaml" />`) and add it as content.</span></span>

  ```xml
  <Content Include="Resources\Themes\Default.Accent.xaml">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </Content>
  ```

- <span data-ttu-id="b41f3-260">Infine, aggiungere riferimenti NuGet `<ItemGroup>` copiando `<PackageReference>` l'oggetto con tutti gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b41f3-260">Finally, add NuGet references by copying the `<ItemGroup>` with all the `<PackageReference>` elements.</span></span> <span data-ttu-id="b41f3-261">Se in precedenza non è stato aggiornato i pacchetti NuGet alle versioni compatibili con .NET Core, è possibile farlo ora che i riferimenti al pacchetto sono in un progetto specifico di .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b41f3-261">If you hadn't previously upgraded the NuGet packages to .NET Core-compatible versions, you could do that now that the package references are in a .NET Core-specific project.</span></span>

<span data-ttu-id="b41f3-262">A questo punto, dovrebbe essere possibile aggiungere il nuovo progetto alla soluzione BeanTrader e aprirlo in Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="b41f3-262">At this point, it should be possible to add the new project to the BeanTrader solution and open it in Visual Studio.</span></span> <span data-ttu-id="b41f3-263">Il progetto deve essere corretto `dotnet restore BeanTraderClient.Core.csproj` in **Esplora soluzioni**e deve ripristinare correttamente i pacchetti (con due avvisi previsti relativi alla versione di MahApps.Metro in uso con .NET Framework di destinazione).</span><span class="sxs-lookup"><span data-stu-id="b41f3-263">The project should look correct in **Solution Explorer**, and `dotnet restore BeanTraderClient.Core.csproj` should successfully restore packages (with two expected warnings related to the MahApps.Metro version you're using targeting .NET Framework).</span></span>

<span data-ttu-id="b41f3-264">Anche se è possibile mantenere entrambi i file di progetto side-by-side (e può anche essere auspicabile se si desidera continuare a compilare il vecchio progetto esattamente come era), complica il processo di migrazione (i due progetti tenteranno di utilizzare le stesse cartelle bin e obj) e di solito non è necessario.</span><span class="sxs-lookup"><span data-stu-id="b41f3-264">Although it's possible to keep both project files side-by-side (and may even be desirable if you want to keep building the old project exactly as it was), it complicates the migration process (the two projects will try to use the same bin and obj folders) and usually isn't necessary.</span></span> <span data-ttu-id="b41f3-265">Se si desidera compilare sia per destinazioni .NET Core `<TargetFramework>netcoreapp3.0</TargetFramework>` che .NET Framework, è possibile sostituire la proprietà nel nuovo file di progetto con `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` invece.</span><span class="sxs-lookup"><span data-stu-id="b41f3-265">If you want to build for both .NET Core and .NET Framework targets, you can replace the `<TargetFramework>netcoreapp3.0</TargetFramework>` property in the new project file with `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` instead.</span></span> <span data-ttu-id="b41f3-266">Per l'esempio Bean Trader, eliminare il file di progetto precedente (BeanTraderClient.csproj) poiché non è più necessario.</span><span class="sxs-lookup"><span data-stu-id="b41f3-266">For the Bean Trader sample, delete the old project file (BeanTraderClient.csproj) since it's no longer needed.</span></span> <span data-ttu-id="b41f3-267">Se si preferisce mantenere entrambi i file di progetto, assicurarsi di compilarli in percorsi di output e intermedi diversi.</span><span class="sxs-lookup"><span data-stu-id="b41f3-267">If you prefer to keep both project files, be sure to have them build to different output and intermediate output paths.</span></span>

## <a name="fix-build-issues"></a><span data-ttu-id="b41f3-268">Risolvere i problemi di compilazione</span><span class="sxs-lookup"><span data-stu-id="b41f3-268">Fix build issues</span></span>

<span data-ttu-id="b41f3-269">Il terzo passaggio del processo di porting consiste nell'ottenere la compilazione del progetto.</span><span class="sxs-lookup"><span data-stu-id="b41f3-269">The third step of the porting process is getting the project to build.</span></span> <span data-ttu-id="b41f3-270">Alcune app verranno già compilate correttamente dopo la conversione del file di progetto in un progetto di tipo SDK.</span><span class="sxs-lookup"><span data-stu-id="b41f3-270">Some apps will already build successfully once the project file is converted to an SDK-style project.</span></span> <span data-ttu-id="b41f3-271">Se questo è il caso per la tua app, congratulazioni!</span><span class="sxs-lookup"><span data-stu-id="b41f3-271">If that's the case for your app, congratulations!</span></span> <span data-ttu-id="b41f3-272">Si può andare al passo 4.</span><span class="sxs-lookup"><span data-stu-id="b41f3-272">You can go on to Step 4.</span></span> <span data-ttu-id="b41f3-273">Altre app avranno bisogno di alcuni aggiornamenti per farli costruire per .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b41f3-273">Other apps will need some updates to get them building for .NET Core.</span></span> <span data-ttu-id="b41f3-274">Se si tenta `dotnet build` di eseguire sul progetto di esempio Bean Trader ora, ad esempio, (o compilarlo in Visual Studio), ci saranno molti errori, ma si otterrà risolverli rapidamente.</span><span class="sxs-lookup"><span data-stu-id="b41f3-274">If you try to run `dotnet build` on the Bean Trader sample project now, for example, (or build it in Visual Studio), there will be many errors, but you'll get them fixed quickly.</span></span>

### <a name="systemservicemodel-references-and-microsoftwindowscompatibility"></a><span data-ttu-id="b41f3-275">Riferimenti a System.ServiceModel e Microsoft.Windows.Compatibility</span><span class="sxs-lookup"><span data-stu-id="b41f3-275">System.ServiceModel references and Microsoft.Windows.Compatibility</span></span>

<span data-ttu-id="b41f3-276">Un'origine comune di errori mancano riferimenti per le API disponibili per .NET Core ma non inclusi automaticamente nel metapacchetto dell'app .NET Core.A common source of errors is missing references for APIs that are available for .NET Core but not automatically included in the .NET Core app metapackage.</span><span class="sxs-lookup"><span data-stu-id="b41f3-276">A common source of errors is missing references for APIs that are available for .NET Core but not automatically included in the .NET Core app metapackage.</span></span> <span data-ttu-id="b41f3-277">Per risolvere questo problema, `Microsoft.Windows.Compatibility` è necessario fare riferimento al pacchetto.</span><span class="sxs-lookup"><span data-stu-id="b41f3-277">To address this, you should reference the `Microsoft.Windows.Compatibility` package.</span></span> <span data-ttu-id="b41f3-278">Il pacchetto di compatibilità include un'ampia gamma di API comuni nelle app desktop di Windows, ad esempio il client WCF, i servizi directory, il Registro di sistema, la configurazione, le API ACLs e altro ancora.</span><span class="sxs-lookup"><span data-stu-id="b41f3-278">The compatibility package includes a broad set of APIs that are common in Windows desktop apps, such as WCF client, directory services, registry, configuration, ACLs APIs, and more.</span></span>

<span data-ttu-id="b41f3-279">Con l'esempio Bean Trader, la maggior parte <xref:System.ServiceModel> degli errori di compilazione sono dovuti a tipi mancanti.</span><span class="sxs-lookup"><span data-stu-id="b41f3-279">With the Bean Trader sample, the majority of the build errors are due to missing <xref:System.ServiceModel> types.</span></span> <span data-ttu-id="b41f3-280">Questi potrebbero essere risolti facendo riferimento ai pacchetti WCF NuGet necessari.</span><span class="sxs-lookup"><span data-stu-id="b41f3-280">These could be addressed by referencing the necessary WCF NuGet packages.</span></span> <span data-ttu-id="b41f3-281">Le API client WCF sono tra `Microsoft.Windows.Compatibility` quelle presenti nel pacchetto, tuttavia, pertanto il riferimento al pacchetto di compatibilità è una soluzione ancora migliore (poiché risolve anche eventuali problemi relativi alle API, nonché soluzioni ai problemi WCF resi disponibili dal pacchetto di compatibilità).</span><span class="sxs-lookup"><span data-stu-id="b41f3-281">WCF client APIs are among those present in the `Microsoft.Windows.Compatibility` package, though, so referencing the compatibility package is an even better solution (since it also addresses any issues related to APIs as well as solutions to the WCF issues that the compatibility package makes available).</span></span> <span data-ttu-id="b41f3-282">Il `Microsoft.Windows.Compatibility` pacchetto è utile nella maggior parte degli scenari di conversione di .NET Core 3.0 WPF e WinForms.The package helps in most .NET Core 3.0 WPF and WinForms porting scenarios.</span><span class="sxs-lookup"><span data-stu-id="b41f3-282">The `Microsoft.Windows.Compatibility` package helps in most .NET Core 3.0 WPF and WinForms porting scenarios.</span></span> <span data-ttu-id="b41f3-283">Dopo aver aggiunto il `Microsoft.Windows.Compatibility`riferimento NuGet a , rimane un solo errore di compilazione.</span><span class="sxs-lookup"><span data-stu-id="b41f3-283">After adding the NuGet reference to `Microsoft.Windows.Compatibility`, only one build error remains!</span></span>

### <a name="cleaning-up-unused-files"></a><span data-ttu-id="b41f3-284">Pulizia dei file inutilizzati</span><span class="sxs-lookup"><span data-stu-id="b41f3-284">Cleaning up unused files</span></span>

<span data-ttu-id="b41f3-285">Un tipo di problema di migrazione che si presenta spesso si riferisce ai file c'è e XAML che non sono stati precedentemente inclusi nella compilazione vengono prelevati dai nuovi progetti in stile SDK che includono automaticamente *tutte le* origini.</span><span class="sxs-lookup"><span data-stu-id="b41f3-285">One type of migration issue that comes up often relates to C# and XAML files that weren't previously included in the build getting picked up by the new SDK-style projects that include *all* source automatically.</span></span>

<span data-ttu-id="b41f3-286">Il prossimo errore di compilazione visualizzato nell'esempio Bean Trader si riferisce a un'implementazione dell'interfaccia non valida in *OldUnusedViewModel.cs*.</span><span class="sxs-lookup"><span data-stu-id="b41f3-286">The next build error you see in the Bean Trader sample refers to a bad interface implementation in *OldUnusedViewModel.cs*.</span></span> <span data-ttu-id="b41f3-287">Il nome del file è un suggerimento, ma durante l'ispezione, si scoprirà che questo file di origine non è corretto.</span><span class="sxs-lookup"><span data-stu-id="b41f3-287">The file name is a hint, but on inspection, you'll find that this source file is incorrect.</span></span> <span data-ttu-id="b41f3-288">Non causava problemi in precedenza perché non era incluso nel progetto .NET Framework originale.</span><span class="sxs-lookup"><span data-stu-id="b41f3-288">It didn't cause issues previously because it wasn't included in the original .NET Framework project.</span></span> <span data-ttu-id="b41f3-289">I file di origine presenti sul disco ma non inclusi nel *vecchio csproj* vengono ora inclusi automaticamente.</span><span class="sxs-lookup"><span data-stu-id="b41f3-289">Source files that were present on disk but not included in the old *csproj* are included automatically now.</span></span>

<span data-ttu-id="b41f3-290">Per problemi una tantum come questo, è facile confrontare con il *csproj* precedente per `<Compile Remove="" />` confermare che il file non è necessario e quindi o, se il file di origine non è più necessario da nessuna parte, eliminarlo.</span><span class="sxs-lookup"><span data-stu-id="b41f3-290">For one-off issues like this, it's easy to compare to the previous *csproj* to confirm that the file isn't needed, and then either `<Compile Remove="" />` it or, if the source file isn't needed anywhere anymore, delete it.</span></span> <span data-ttu-id="b41f3-291">In questo caso, è sicuro eliminare solo *OldUnusedViewModel.cs*.</span><span class="sxs-lookup"><span data-stu-id="b41f3-291">In this case, it's safe to just delete *OldUnusedViewModel.cs*.</span></span>

<span data-ttu-id="b41f3-292">Se si dispone di molti file di origine che devono essere esclusi in questo `<EnableDefaultCompileItems>` modo, è possibile disabilitare l'inclusione automatica dei file di C , impostando la proprietà su false nel file di progetto.</span><span class="sxs-lookup"><span data-stu-id="b41f3-292">If you have many source files that would need to be excluded this way, you can disable auto-inclusion of C# files by setting the `<EnableDefaultCompileItems>` property to false in the project file.</span></span> <span data-ttu-id="b41f3-293">Quindi, è `<Compile Include>` possibile copiare gli elementi dal file di progetto precedente a quello nuovo per compilare solo le origini che si intende includere.</span><span class="sxs-lookup"><span data-stu-id="b41f3-293">Then, you can copy `<Compile Include>` items from the old project file to the new one in order to only build sources you intended to include.</span></span> <span data-ttu-id="b41f3-294">Analogamente, `<EnableDefaultPageItems>` può essere usato per disattivare `<EnableDefaultItems>` l'inclusione automatica delle pagine XAML e può controllare entrambi con una singola proprietà.</span><span class="sxs-lookup"><span data-stu-id="b41f3-294">Similarly, `<EnableDefaultPageItems>` can be used to turn off auto-inclusion of XAML pages and `<EnableDefaultItems>` can control both with a single property.</span></span>

### <a name="a-brief-aside-on-multi-pass-compilers"></a><span data-ttu-id="b41f3-295">Una breve parte sui compilatori multi-pass</span><span class="sxs-lookup"><span data-stu-id="b41f3-295">A brief aside on multi-pass compilers</span></span>

<span data-ttu-id="b41f3-296">Dopo aver rimosso il file incriminato dall'esempio Bean Trader, è possibile ricompilare e otterrà quattro errori.</span><span class="sxs-lookup"><span data-stu-id="b41f3-296">After removing the offending file from the Bean Trader sample, you can re-build and will get four errors.</span></span> <span data-ttu-id="b41f3-297">Non ne avevi uno prima?</span><span class="sxs-lookup"><span data-stu-id="b41f3-297">Didn't you have one before?</span></span> <span data-ttu-id="b41f3-298">Perché il numero di errori è aumentato?</span><span class="sxs-lookup"><span data-stu-id="b41f3-298">Why did the number of errors go up?</span></span> <span data-ttu-id="b41f3-299">Il compilatore di Cè è un [compilatore a più passaggi.](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes)</span><span class="sxs-lookup"><span data-stu-id="b41f3-299">The C# compiler is a [multi-pass compiler](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span></span> <span data-ttu-id="b41f3-300">Ciò significa che passa attraverso ogni file di origine due volte.</span><span class="sxs-lookup"><span data-stu-id="b41f3-300">This means that it goes through each source file twice.</span></span> <span data-ttu-id="b41f3-301">In primo luogo, il compilatore esamina solo i metadati e le dichiarazioni in ogni file di origine e identifica eventuali problemi a livello di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="b41f3-301">First, the compiler just looks at metadata and declarations in each source file and identifies any declaration-level problems.</span></span> <span data-ttu-id="b41f3-302">Questi sono gli errori che hai risolto.</span><span class="sxs-lookup"><span data-stu-id="b41f3-302">Those are the errors you've fixed.</span></span> <span data-ttu-id="b41f3-303">Quindi passa attraverso il codice di nuovo per compilare l'origine C , in IL; questi sono il secondo set di errori che si sta vedendo ora.</span><span class="sxs-lookup"><span data-stu-id="b41f3-303">Then it goes through the code again to build the C# source into IL; those are the second set of errors that you're seeing now.</span></span>

> [!NOTE]
> <span data-ttu-id="b41f3-304">Il compilatore di C, non solo [due passaggi](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), ma il risultato finale è che gli errori del compilatore per le modifiche di codice di grandi dimensioni come questo tendono a venire in due onde.</span><span class="sxs-lookup"><span data-stu-id="b41f3-304">The C# compiler does [more than just two passes](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), but the end result is that compiler errors for large code changes like this tend to come in two waves.</span></span>

### <a name="third-party-dependency-fixes-castlewindsor"></a><span data-ttu-id="b41f3-305">Correzioni di dipendenza di terze parti (Castle.Windsor)</span><span class="sxs-lookup"><span data-stu-id="b41f3-305">Third-party dependency fixes (Castle.Windsor)</span></span>

<span data-ttu-id="b41f3-306">Un'altra classe di problemi che si presenta in alcuni scenari di migrazione è differenze DI API tra .NET Framework e .NET Core versioni delle dipendenze.</span><span class="sxs-lookup"><span data-stu-id="b41f3-306">Another class of issue that comes up in some migration scenarios is API differences between .NET Framework and .NET Core versions of dependencies.</span></span> <span data-ttu-id="b41f3-307">Anche se un pacchetto NuGet è destinato sia a .NET Framework che a .NET Standard o a .NET Core, potrebbero essere presenti librerie diverse da utilizzare con destinazioni .NET diverse.</span><span class="sxs-lookup"><span data-stu-id="b41f3-307">Even if a NuGet package targets both .NET Framework and .NET Standard or .NET Core, there may be different libraries for use with different .NET targets.</span></span> <span data-ttu-id="b41f3-308">Ciò consente ai pacchetti di supportare molte piattaforme .NET diverse, che possono richiedere implementazioni diverse.</span><span class="sxs-lookup"><span data-stu-id="b41f3-308">This allows the packages to support many different .NET platforms, which may require different implementations.</span></span> <span data-ttu-id="b41f3-309">Significa anche che potrebbero esserci piccole differenze API nelle librerie quando si prendono di mira diverse piattaforme .NET.</span><span class="sxs-lookup"><span data-stu-id="b41f3-309">It also means that there may be small API differences in the libraries when targeting different .NET platforms.</span></span>

<span data-ttu-id="b41f3-310">Il successivo set di errori che vedrai nell'esempio `Castle.Windsor` Bean Trader è correlato alle API.</span><span class="sxs-lookup"><span data-stu-id="b41f3-310">The next set of errors you'll see in the Bean Trader sample are related to `Castle.Windsor` APIs.</span></span> <span data-ttu-id="b41f3-311">Il progetto .NET Core Bean Trader `Castle.Windsor` utilizza la stessa versione del progetto di destinazione di .NET Framework (4.1.1), ma le implementazioni per queste due piattaforme sono leggermente diverse.</span><span class="sxs-lookup"><span data-stu-id="b41f3-311">The .NET Core Bean Trader project uses the same version of `Castle.Windsor` as the .NET Framework-targeted project (4.1.1), but the implementations for those two platforms are slightly different.</span></span>

<span data-ttu-id="b41f3-312">In questo caso, vengono visualizzati i seguenti problemi che devono essere risolti:</span><span class="sxs-lookup"><span data-stu-id="b41f3-312">In this case, you see the following issues that need to be fixed:</span></span>

1. <span data-ttu-id="b41f3-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly`non è disponibile in .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b41f3-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` isn't available on .NET Core.</span></span> <span data-ttu-id="b41f3-314">Esiste, `Classes.FromAssemblyContaining` tuttavia, l'API simile disponibile, pertanto è possibile sostituire entrambi gli utilizzi di `Classes.FromThisAssembly()` con le chiamate a `Classes.FromAssemblyContaining(t)`, dove `t` è il tipo che effettua la chiamata.</span><span class="sxs-lookup"><span data-stu-id="b41f3-314">There is, however, the similar API `Classes.FromAssemblyContaining` available, so we can replace both uses of `Classes.FromThisAssembly()` with calls to `Classes.FromAssemblyContaining(t)`, where `t` is the type making the call.</span></span>
1. <span data-ttu-id="b41f3-315">Analogamente, *Bootstrapper.cs*in `Castle.Windsor.Installer.FromAssembly`Bootstrapper.cs , . Questa opzione non è disponibile in .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b41f3-315">Similarly, in *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`.This is unavailable on .NET Core.</span></span> <span data-ttu-id="b41f3-316">Al contrario, tale `FromAssembly.Containing(typeof(Bootstrapper))`chiamata può essere sostituita con .</span><span class="sxs-lookup"><span data-stu-id="b41f3-316">Instead, that call can be replaced with `FromAssembly.Containing(typeof(Bootstrapper))`.</span></span>

### <a name="updating-wcf-client-usage"></a><span data-ttu-id="b41f3-317">Aggiornamento dell'utilizzo del client WCFUpdating WCF client usage</span><span class="sxs-lookup"><span data-stu-id="b41f3-317">Updating WCF client usage</span></span>

<span data-ttu-id="b41f3-318">Dopo aver `Castle.Windsor` corretto le differenze, l'ultimo errore di compilazione rimanente nel progetto .NET Core Bean Trader è che `BeanTraderServiceClient` (che deriva da `DuplexClientBase`) non dispone di un `Open` metodo.</span><span class="sxs-lookup"><span data-stu-id="b41f3-318">Having fixed the `Castle.Windsor` differences, the last remaining build error in the .NET Core Bean Trader project is that `BeanTraderServiceClient` (which derives from `DuplexClientBase`) doesn't have an `Open` method.</span></span> <span data-ttu-id="b41f3-319">Questo non è sorprendente poiché si tratta di un'API che è stata evidenziata da .NET Portability Analyzer all'inizio di questo processo di migrazione.</span><span class="sxs-lookup"><span data-stu-id="b41f3-319">This isn't surprising since this is an API that was highlighted by the .NET Portability Analyzer at the beginning of this migration process.</span></span> <span data-ttu-id="b41f3-320">Guardando `BeanTraderServiceClient` attira la nostra attenzione su una questione più grande, però.</span><span class="sxs-lookup"><span data-stu-id="b41f3-320">Looking at `BeanTraderServiceClient` draws our attention to a larger issue, though.</span></span> <span data-ttu-id="b41f3-321">Questo client WCF è stato generato automaticamente dallo strumento [Svcutil.exe.](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)</span><span class="sxs-lookup"><span data-stu-id="b41f3-321">This WCF client was autogenerated by the [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) tool.</span></span>

<span data-ttu-id="b41f3-322">**WCF clients generated by Svcutil are meant for use on .NET Framework.**</span><span class="sxs-lookup"><span data-stu-id="b41f3-322">**WCF clients generated by Svcutil are meant for use on .NET Framework.**</span></span>

<span data-ttu-id="b41f3-323">Le soluzioni che utilizzano client WCF generati da svcutil dovranno rigenerare i client compatibili con .NET Standard per l'utilizzo con .NET Core.Solutions that use svcutil-generated WCF clients will need to regenerate .NET Standard-compatible clients for use with .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b41f3-323">Solutions that use svcutil-generated WCF clients will need to regenerate .NET Standard-compatible clients for use with .NET Core.</span></span> <span data-ttu-id="b41f3-324">Uno dei motivi principali per cui i client precedenti non funzioneranno è che dipendono dalla configurazione dell'app per la definizione di associazioni ed endpoint WCF.</span><span class="sxs-lookup"><span data-stu-id="b41f3-324">One of the main reasons the old clients won't work is that they depend on app configuration for defining WCF bindings and endpoints.</span></span> <span data-ttu-id="b41f3-325">Poiché le API WCF di .NET Standard possono funzionare multipiattaforma (dove le API System.Configuration non sono disponibili), i client WCF per gli scenari .NET Core e .NET Standard devono definire associazioni ed endpoint a livello di codice anziché nella configurazione.</span><span class="sxs-lookup"><span data-stu-id="b41f3-325">Because .NET Standard WCF APIs can work cross-platform (where System.Configuration APIs aren't available), WCF clients for .NET Core and .NET Standard scenarios must define bindings and endpoints programmatically instead of in configuration.</span></span>

<span data-ttu-id="b41f3-326">In effetti, qualsiasi utilizzo del `<system.serviceModel>` client WCF che dipende dalla sezione app.config (se creato con Svcutil o manualmente) dovrà essere modificato per funzionare in .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b41f3-326">In fact, any WCF client usage that depends on the `<system.serviceModel>` app.config section (whether created with Svcutil or manually) will need to be changed to work on .NET Core.</span></span>

<span data-ttu-id="b41f3-327">Esistono due modi per generare automaticamente client WCF compatibili con .NET Standard:There are two ways to automatically generate .NET Standard-compatible clients:</span><span class="sxs-lookup"><span data-stu-id="b41f3-327">There are two ways to automatically generate .NET Standard-compatible WCF clients:</span></span>

- <span data-ttu-id="b41f3-328">Lo `dotnet-svcutil` strumento è uno strumento .NET che genera client WCF in un modo simile a come Svcutil funzionava in precedenza.</span><span class="sxs-lookup"><span data-stu-id="b41f3-328">The `dotnet-svcutil` tool is a .NET tool that generates WCF clients in a way that is similar to how Svcutil worked previously.</span></span>
- <span data-ttu-id="b41f3-329">Visual Studio può generare client WCF utilizzando l'opzione [Riferimento al servizio Web WCF](../../core/additional-tools/wcf-web-service-reference-guide.md) della relativa funzionalità di servizi connessi.</span><span class="sxs-lookup"><span data-stu-id="b41f3-329">Visual Studio can generate WCF clients using the [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) option of its Connected Services feature.</span></span>

<span data-ttu-id="b41f3-330">Entrambi gli approcci funzionano bene.</span><span class="sxs-lookup"><span data-stu-id="b41f3-330">Either approach works well.</span></span> <span data-ttu-id="b41f3-331">In alternativa, è possibile scrivere manualmente il codice client WCF.</span><span class="sxs-lookup"><span data-stu-id="b41f3-331">Alternatively, of course, you could write the WCF client code yourself.</span></span> <span data-ttu-id="b41f3-332">Per questo esempio, ho scelto di usare la funzionalità servizio connesso di Visual Studio.For this sample, I chose to use the Visual Studio Connected Service feature.</span><span class="sxs-lookup"><span data-stu-id="b41f3-332">For this sample, I chose to use the Visual Studio Connected Service feature.</span></span> <span data-ttu-id="b41f3-333">A tale scopo, fare clic con il pulsante destro del mouse sul progetto *BeanTraderClient.Core* in Esplora soluzioni di Visual Studio e scegliere **Aggiungi** > **servizio connesso**.</span><span class="sxs-lookup"><span data-stu-id="b41f3-333">To do that, right-click on the *BeanTraderClient.Core* project in Visual Studio's solution explorer and select **Add** > **Connected Service**.</span></span> <span data-ttu-id="b41f3-334">Successivamente, scegliere il provider di riferimento del servizio Web WCF.</span><span class="sxs-lookup"><span data-stu-id="b41f3-334">Next, choose the WCF Web Service Reference Provider.</span></span> <span data-ttu-id="b41f3-335">Verrà visualizzata una finestra di dialogo in cui è possibile`localhost:8080` specificare l'indirizzo del servizio Web Bean Trader back-end (se si esegue il server in locale) e lo spazio dei nomi che i tipi generati devono utilizzare (**BeanTrader.Service**, ad esempio).</span><span class="sxs-lookup"><span data-stu-id="b41f3-335">This will bring up a dialog where you can specify the address of the backend Bean Trader web service (`localhost:8080` if you are running the server locally) and the namespace that generated types should use (**BeanTrader.Service**, for example).</span></span>

![Finestra di dialogo Servizio connesso a riferimento al servizio Web WCFWCF Web Service Reference Connected Service Dialog](./media/convert-project-from-net-framework/connected-service-dialog.png)

<span data-ttu-id="b41f3-337">Dopo aver selezionato **il** fine pulsante, un nuovo nodo servizi connessi viene aggiunto al progetto e un file di Reference.cs viene aggiunto in tale nodo contenente il nuovo client WCF .NET Standard per l'accesso al servizio Bean Trader.</span><span class="sxs-lookup"><span data-stu-id="b41f3-337">After you select the **Finish** button, a new Connected Services node is added to the project and a Reference.cs file is added under that node containing the new .NET Standard WCF client for accessing the Bean Trader service.</span></span> <span data-ttu-id="b41f3-338">Se si esaminano i `GetEndpointAddress` metodi o `GetBindingForEndpoint` in tale file, si noterà che le associazioni e gli endpoint vengono ora generati a livello di codice (anziché tramite la configurazione dell'app).</span><span class="sxs-lookup"><span data-stu-id="b41f3-338">If you look at the `GetEndpointAddress` or `GetBindingForEndpoint` methods in that file, you'll see that bindings and endpoints are now generated programmatically (instead of via app config).</span></span> <span data-ttu-id="b41f3-339">The 'Add Connected Services' feature may also add references to some System.ServiceModel packages in the project file, which aren't needed since all necessary WCF packages are included via Microsoft.Windows.Compatibility.</span><span class="sxs-lookup"><span data-stu-id="b41f3-339">The 'Add Connected Services' feature may also add references to some System.ServiceModel packages in the project file, which aren't needed since all necessary WCF packages are included via Microsoft.Windows.Compatibility.</span></span> <span data-ttu-id="b41f3-340">Controllare il csproj per verificare se `<PackageReference>` sono stati aggiunti ulteriori elementi System.ServiceModel e, in caso affermativo, rimuoverli.</span><span class="sxs-lookup"><span data-stu-id="b41f3-340">Check the csproj to see if any extra System.ServiceModel `<PackageReference>` items have been added, and if so, remove them.</span></span>

<span data-ttu-id="b41f3-341">Il progetto ha nuove classi client WCF ora (in *Reference.cs*), ma ha anche quelle precedenti (in BeanTrader.cs).</span><span class="sxs-lookup"><span data-stu-id="b41f3-341">Our project has new WCF client classes now (in *Reference.cs*), but it also still has the old ones (in BeanTrader.cs).</span></span> <span data-ttu-id="b41f3-342">Ci sono due opzioni a questo punto:</span><span class="sxs-lookup"><span data-stu-id="b41f3-342">There are two options at this point:</span></span>

- <span data-ttu-id="b41f3-343">Se si desidera essere in grado di compilare il progetto .NET Framework originale (insieme al nuovo .NET Core di destinazione), è possibile utilizzare un `<Compile Remove="BeanTrader.cs" />` elemento nel file csproj del progetto .NET Core in modo che le versioni di .NET Framework e .NET Core dell'app utilizzano client WCF diversi.</span><span class="sxs-lookup"><span data-stu-id="b41f3-343">If you want to be able to build the original .NET Framework project (alongside the new .NET Core-targeted one), you can use a `<Compile Remove="BeanTrader.cs" />` item in the .NET Core project's csproj file so that the .NET Framework and .NET Core versions of the app use different WCF clients.</span></span> <span data-ttu-id="b41f3-344">Questo ha il vantaggio di lasciare invariato il progetto .NET Framework esistente, ma presenta lo svantaggio che il codice che utilizza i client WCF generati potrebbe `#if` essere necessario essere leggermente diverso nel caso .NET Core rispetto a .NET Framework, pertanto è probabile che sia necessario utilizzare le direttive per compilare in modo condizionale alcuni utilizzi client WCF (creazione di client, ad esempio) per funzionare in un modo quando compilato per .NET Core e un altro modo quando viene compilato per .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b41f3-344">This has the advantage of leaving the existing .NET Framework project unchanged, but has the disadvantage that code using the generated WCF clients may need to be slightly different in the .NET Core case than it was in the .NET Framework project, so you'll likely need to use `#if` directives to conditionally compile some WCF client usage (creating clients, for example) to work one way when built for .NET Core and another way when built for .NET Framework.</span></span>

- <span data-ttu-id="b41f3-345">Se, d'altra parte, parte della varianza del codice nel progetto .NET Framework esistente è accettabile, è possibile rimuovere *BeanTrader.cs* tutti insieme.</span><span class="sxs-lookup"><span data-stu-id="b41f3-345">If, on the other hand, some code churn in the existing .NET Framework project is acceptable, you can remove *BeanTrader.cs* all together.</span></span> <span data-ttu-id="b41f3-346">Poiché il nuovo client WCF è compilato per .NET Standard, funzionerà sia in scenari .NET Core che .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b41f3-346">Because the new WCF client is built for .NET Standard, it will work in both .NET Core and .NET Framework scenarios.</span></span> <span data-ttu-id="b41f3-347">Se si compila per .NET Framework in aggiunta a .NET Core (tramite multitargeting o con due file csproj), è possibile utilizzare questo nuovo *file di Reference.cs* per entrambe le destinazioni.</span><span class="sxs-lookup"><span data-stu-id="b41f3-347">If you are building for .NET Framework in addition to .NET Core (either by multi-targeting or by having two csproj files), you can use this new *Reference.cs* file for both targets.</span></span> <span data-ttu-id="b41f3-348">Questo approccio ha il vantaggio che il codice non sarà necessario biforcare per supportare due client WCF diversi; lo stesso codice verrà utilizzato ovunque.</span><span class="sxs-lookup"><span data-stu-id="b41f3-348">This approach has the advantage that the code won't need to bifurcate to support two different WCF clients; the same code will be used everywhere.</span></span> <span data-ttu-id="b41f3-349">Lo svantaggio è che si tratta di modificare il progetto .NET Framework (presumibilmente stabile).</span><span class="sxs-lookup"><span data-stu-id="b41f3-349">The drawback is that it involves changing the (presumably stable) .NET Framework project.</span></span>

<span data-ttu-id="b41f3-350">Nel caso dell'esempio Bean Trader, è possibile apportare piccole modifiche al progetto originale se semplifica la migrazione, pertanto attenersi alla seguente procedura per riconciliare l'utilizzo del client WCF:In the case of the Bean Trader sample, you can make small changes to the original project if it makes migration easier, so follow these steps to reconcile WCF client usage:</span><span class="sxs-lookup"><span data-stu-id="b41f3-350">In the case of the Bean Trader sample, you can make small changes to the original project if it makes migration easier, so follow these steps to reconcile WCF client usage:</span></span>

01. <span data-ttu-id="b41f3-351">Aggiungere il nuovo file di Reference.cs al progetto *BeanTraderClient.csproj* di .NET Framework utilizzando il menu di scelta rapida 'Aggiungi elemento esistente' da Esplora soluzioni.</span><span class="sxs-lookup"><span data-stu-id="b41f3-351">Add the new Reference.cs file to the .NET Framework *BeanTraderClient.csproj* project using the 'Add existing item' context menu from the solution explorer.</span></span> <span data-ttu-id="b41f3-352">Assicurarsi di aggiungere 'come collegamento' in modo che lo stesso file viene utilizzato da entrambi i progetti (anziché copiare il file di C .</span><span class="sxs-lookup"><span data-stu-id="b41f3-352">Be sure to add 'as link' so that the same file is used by both projects (as opposed to copying the C# file).</span></span> <span data-ttu-id="b41f3-353">Se si compila sia per .NET Core che per .NET Framework con un singolo csproj (utilizzando il multitargeting), questo passaggio non è necessario.</span><span class="sxs-lookup"><span data-stu-id="b41f3-353">If you are building for both .NET Core and .NET Framework with a single csproj (using multi-targeting) then this step isn't necessary.</span></span>

01. <span data-ttu-id="b41f3-354">Eliminare *BeanTrader.cs*.</span><span class="sxs-lookup"><span data-stu-id="b41f3-354">Delete *BeanTrader.cs*.</span></span>

01. <span data-ttu-id="b41f3-355">Il nuovo client WCF è simile a quello precedente, ma un numero di spazi dei nomi nel codice generato sono diversi.</span><span class="sxs-lookup"><span data-stu-id="b41f3-355">The new WCF client is similar to the old one, but a number of namespaces in the generated code are different.</span></span> <span data-ttu-id="b41f3-356">Per questo motivo, è necessario aggiornare il progetto in modo che i tipi di client WCF vengono utilizzati da BeanTrader.Service (o qualsiasi nome dello spazio dei nomi scelto) anziché BeanTrader.Model o senza uno spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="b41f3-356">Because of this, it is necessary to update the project so that WCF client types are used from BeanTrader.Service (or whatever namespace name you chose) instead of BeanTrader.Model or without a namespace.</span></span> <span data-ttu-id="b41f3-357">La compilazione di *BeanTraderClient.Core.csproj* consentirà di identificare dove devono essere apportate queste modifiche.</span><span class="sxs-lookup"><span data-stu-id="b41f3-357">Building *BeanTraderClient.Core.csproj* will help to identify where these changes need to be made.</span></span> <span data-ttu-id="b41f3-358">Le correzioni saranno necessarie sia nei file di origine in C, sia nei file di origine XAML.</span><span class="sxs-lookup"><span data-stu-id="b41f3-358">Fixes will be needed both in C# and in XAML source files.</span></span>

01. <span data-ttu-id="b41f3-359">Infine, si scoprirà che si *BeanTraderServiceClientFactory.cs* è verificato un errore `BeanTraderServiceClient` nel BeanTraderServiceClientFactory.cs perché i costruttori disponibili per il tipo sono stati modificati.</span><span class="sxs-lookup"><span data-stu-id="b41f3-359">Finally, you'll discover that there is an error in *BeanTraderServiceClientFactory.cs* because the available constructors for the `BeanTraderServiceClient` type have changed.</span></span> <span data-ttu-id="b41f3-360">Consente di fornire un `InstanceContext` argomento (creato utilizzando `CallbackHandler` un `Castle.Windsor` dal contenitore IoC).</span><span class="sxs-lookup"><span data-stu-id="b41f3-360">It used to be possible to supply an `InstanceContext` argument (which was created using a `CallbackHandler` from the `Castle.Windsor` IoC container).</span></span> <span data-ttu-id="b41f3-361">I nuovi costruttori `CallbackHandler`creano nuovi s.</span><span class="sxs-lookup"><span data-stu-id="b41f3-361">The new constructors create new `CallbackHandler`s.</span></span> <span data-ttu-id="b41f3-362">Esistono, tuttavia, costruttori nel `BeanTraderServiceClient`tipo di base 's che corrispondono a quello che si desidera.</span><span class="sxs-lookup"><span data-stu-id="b41f3-362">There are, however, constructors in `BeanTraderServiceClient`'s base type that match what you want.</span></span> <span data-ttu-id="b41f3-363">Poiché il codice client WCF generato automaticamente esiste tutto in classi parziali, è possibile estenderlo facilmente.</span><span class="sxs-lookup"><span data-stu-id="b41f3-363">Since the autogenerated WCF client code all exists in partial classes, you can easily extend it.</span></span> <span data-ttu-id="b41f3-364">A tale scopo, creare un nuovo file denominato *BeanTraderServiceClient.cs* e quindi creare una classe parziale con lo stesso nome (utilizzando lo spazio dei nomi BeanTrader.Service).</span><span class="sxs-lookup"><span data-stu-id="b41f3-364">To do this, create a new file called *BeanTraderServiceClient.cs* and then create a partial class with that same name (using the BeanTrader.Service namespace).</span></span> <span data-ttu-id="b41f3-365">Quindi, aggiungere un costruttore al tipo parziale, come illustrato di seguito.</span><span class="sxs-lookup"><span data-stu-id="b41f3-365">Then, add one constructor to the partial type as shown here.</span></span>

    ```csharp
    public BeanTraderServiceClient(System.ServiceModel.InstanceContext callbackInstance) :
        base(callbackInstance, EndpointConfiguration.NetTcpBinding_BeanTraderService)
            { }
    ```

<span data-ttu-id="b41f3-366">Con le modifiche apportate, l'esempio Bean Trader utilizzerà ora un nuovo client WCF compatibile `Open` con .NET `await OpenAsync` Standard ed è possibile effettuare la correzione finale della modifica della chiamata in *TradingService.cs* da utilizzare.</span><span class="sxs-lookup"><span data-stu-id="b41f3-366">With those changes made, the Bean Trader sample will now be using a new .NET Standard-compatible WCF client and you can make the final fix of changing the `Open` call in *TradingService.cs* to use `await OpenAsync` instead.</span></span>

<span data-ttu-id="b41f3-367">Con i problemi WCF risolti, la versione .NET Core dell'esempio Bean Trader ora si compila in modo pulito!</span><span class="sxs-lookup"><span data-stu-id="b41f3-367">With the WCF issues addressed, the .NET Core version of the Bean Trader sample now builds cleanly!</span></span>

## <a name="runtime-testing"></a><span data-ttu-id="b41f3-368">Test di runtime</span><span class="sxs-lookup"><span data-stu-id="b41f3-368">Runtime testing</span></span>

<span data-ttu-id="b41f3-369">È facile dimenticare che il lavoro di migrazione non viene eseguito non appena il progetto viene compilato in modo pulito rispetto a .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b41f3-369">It's easy to forget that migration work isn't done as soon as the project builds cleanly against .NET Core.</span></span> <span data-ttu-id="b41f3-370">È importante lasciare il tempo per testare anche l'app con porting.</span><span class="sxs-lookup"><span data-stu-id="b41f3-370">It's important to leave time for testing the ported app, too.</span></span> <span data-ttu-id="b41f3-371">Una volta che le cose vengono compilate correttamente, assicurati che l'app venga eseguita e funzioni come previsto, soprattutto se usi pacchetti destinati a .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b41f3-371">Once things build successfully, make sure the app runs and works as expected, especially if you are using any packages targeting .NET Framework.</span></span>

<span data-ttu-id="b41f3-372">Proviamo a lanciare l'app Bean Trader portata e vediamo cosa succede.</span><span class="sxs-lookup"><span data-stu-id="b41f3-372">Let's try launching the ported Bean Trader app and see what happens.</span></span> <span data-ttu-id="b41f3-373">L'app non arriva lontano prima di non riuscire con l'eccezione seguente.</span><span class="sxs-lookup"><span data-stu-id="b41f3-373">The app doesn't get far before failing with the following exception.</span></span>

```output
System.Configuration.ConfigurationErrorsException: 'Configuration system failed to initialize'

Inner Exception
ConfigurationErrorsException: Unrecognized configuration section system.serviceModel.
```

<span data-ttu-id="b41f3-374">Questo ha un senso, naturalmente.</span><span class="sxs-lookup"><span data-stu-id="b41f3-374">This makes sense, of course.</span></span> <span data-ttu-id="b41f3-375">Tenere presente che WCF non usa più la configurazione dell'app, pertanto la sezione system.serviceModel precedente del file app.config deve essere rimossa.</span><span class="sxs-lookup"><span data-stu-id="b41f3-375">Remember that WCF no longer uses app configuration, so the old system.serviceModel section of the app.config file needs to be removed.</span></span> <span data-ttu-id="b41f3-376">Il client WCF aggiornato include tutte le stesse informazioni nel codice, pertanto la sezione di configurazione non è più necessaria.</span><span class="sxs-lookup"><span data-stu-id="b41f3-376">The updated WCF client includes all of the same information in its code, so the config section isn't needed anymore.</span></span> <span data-ttu-id="b41f3-377">Se si desidera che l'endpoint WCF sia configurabile in app.config, è possibile aggiungerlo come impostazione dell'app e aggiornare il codice client WCF per recuperare l'endpoint del servizio WCF dalla configurazione.</span><span class="sxs-lookup"><span data-stu-id="b41f3-377">If you wanted the WCF endpoint to be configurable in app.config, you could add it as an app setting and update the WCF client code to retrieve the WCF service endpoint from configuration.</span></span>

<span data-ttu-id="b41f3-378">Dopo aver rimosso la sezione system.serviceModel di *app.config*, l'app viene avviata ma non riesce con un'altra eccezione quando un utente accede.</span><span class="sxs-lookup"><span data-stu-id="b41f3-378">After removing the system.serviceModel section of *app.config*, the app launches but fails with another exception when a user signs in.</span></span>

```output
System.PlatformNotSupportedException: 'Operation is not supported on this platform.'
```

<span data-ttu-id="b41f3-379">L'API non `Func<T>.BeginInvoke`supportata è .</span><span class="sxs-lookup"><span data-stu-id="b41f3-379">The unsupported API is `Func<T>.BeginInvoke`.</span></span> <span data-ttu-id="b41f3-380">Come illustrato in [dotnet/corefx-5940](https://github.com/dotnet/corefx/issues/5940), .NET `BeginInvoke` Core `EndInvoke` non supporta i metodi e sui tipi delegati a causa delle dipendenze remote sottostanti.</span><span class="sxs-lookup"><span data-stu-id="b41f3-380">As explained in [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET Core doesn't support the `BeginInvoke` and `EndInvoke` methods on delegate types due to underlying remoting dependencies.</span></span> <span data-ttu-id="b41f3-381">Questo problema e la relativa correzione sono spiegati in modo più dettagliato nel post di `BeginInvoke` blog `EndInvoke` [Delega.BeginInvoke migrazione per .NET Core,](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) ma il succo è che e le chiamate devono essere sostituiti con `Task.Run` (o alternative asincrone, se possibile).</span><span class="sxs-lookup"><span data-stu-id="b41f3-381">This issue and its fix are explained in more detail in the [Migrating Delegate.BeginInvoke Calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blog post, but the gist is that `BeginInvoke` and `EndInvoke` calls should be replaced with `Task.Run` (or async alternatives, if possible).</span></span> <span data-ttu-id="b41f3-382">Applicando la soluzione generale `BeginInvoke` qui, la chiamata `Invoke` può `Task.Run`essere sostituita con una chiamata avviata da .</span><span class="sxs-lookup"><span data-stu-id="b41f3-382">Applying the general solution here, the `BeginInvoke` call can be replaced with an `Invoke` call launched by `Task.Run`.</span></span>

```csharp
Task.Run(() =>
{
    return userInfoRetriever.Invoke();
}).ContinueWith(result =>
{
    // BeginInvoke's callback is replaced with ContinueWith
    var task = result.ConfigureAwait(false);
    CurrentTrader = task.GetAwaiter().GetResult();
}, TaskScheduler.Default);
```

<span data-ttu-id="b41f3-383">Dopo aver `BeginInvoke` rimosso l'utilizzo, l'app Bean Trader viene eseguita correttamente in .NET Core!</span><span class="sxs-lookup"><span data-stu-id="b41f3-383">After removing the `BeginInvoke` usage, the Bean Trader app runs successfully on .NET Core!</span></span>

![Bean Trader in esecuzione su .NET Core](./media/convert-project-from-net-framework/running-on-core.png)

<span data-ttu-id="b41f3-385">Tutte le app sono diverse, pertanto i passaggi specifici necessari per eseguire la migrazione delle proprie app a .NET Core variano.</span><span class="sxs-lookup"><span data-stu-id="b41f3-385">All apps are different, so the specific steps needed to migrate your own apps to .NET Core will vary.</span></span> <span data-ttu-id="b41f3-386">Ma si spera che l'esempio Bean Trader dimostra il flusso di lavoro generale e i tipi di problemi che ci si può aspettare.</span><span class="sxs-lookup"><span data-stu-id="b41f3-386">But hopefully the Bean Trader sample demonstrates the general workflow and the types of issues that can be expected.</span></span> <span data-ttu-id="b41f3-387">E, nonostante la lunghezza di questo articolo, le modifiche effettive necessarie nell'esempio Bean Trader per farlo funzionare su .NET Core erano piuttosto limitate.</span><span class="sxs-lookup"><span data-stu-id="b41f3-387">And, despite this article's length, the actual changes needed in the Bean Trader sample to make it work on .NET Core were fairly limited.</span></span> <span data-ttu-id="b41f3-388">Molte app migrano a .NET Core nello stesso modo; con modifiche al codice limitate o addirittura senza necessità.</span><span class="sxs-lookup"><span data-stu-id="b41f3-388">Many apps migrate to .NET Core in this same way; with limited or even no code changes needed.</span></span>
