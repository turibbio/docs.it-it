---
title: Definizione di tipi personalizzati da usare con i servizi XAML .NET
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: ff7e4229450e801a6d618c5141efde8cdcbef03d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/12/2020
ms.locfileid: "82071857"
---
# <a name="define-custom-types-for-use-with-net-xaml-services"></a><span data-ttu-id="e3954-102">Definire tipi personalizzati da usare con i servizi XAML di .NETDefine custom types for use with .NET XAML Services</span><span class="sxs-lookup"><span data-stu-id="e3954-102">Define custom types for use with .NET XAML Services</span></span>

<span data-ttu-id="e3954-103">Quando si definiscono tipi personalizzati che sono oggetti business o che non hanno una dipendenza da framework specifici, è possibile seguire alcune procedure consigliate per XAML.</span><span class="sxs-lookup"><span data-stu-id="e3954-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="e3954-104">Se segui queste procedure, i servizi XAML .NET e i relativi reader XAML e writer XAML possono individuare le caratteristiche XAML del tipo e fornirgli una rappresentazione appropriata in un flusso del nodo XAML usando il sistema di tipi XAML.</span><span class="sxs-lookup"><span data-stu-id="e3954-104">If you follow these practices, .NET XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="e3954-105">In questo argomento vengono descritte le procedure consigliate per le definizioni dei tipi, le definizioni dei membri e l'attribuzione CLR di tipi o membri.</span><span class="sxs-lookup"><span data-stu-id="e3954-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>

## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="e3954-106">Modelli di costruttore e definizioni dei tipi per XAMLConstructor Patterns and Type Definitions for XAML</span><span class="sxs-lookup"><span data-stu-id="e3954-106">Constructor Patterns and Type Definitions for XAML</span></span>

<span data-ttu-id="e3954-107">Per creare un'istanza come elemento oggetto in XAML, una classe personalizzata deve soddisfare i requisiti seguenti:To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span><span class="sxs-lookup"><span data-stu-id="e3954-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>

- <span data-ttu-id="e3954-108">La classe personalizzata deve essere pubblica e deve esporre un costruttore pubblico senza parametri.</span><span class="sxs-lookup"><span data-stu-id="e3954-108">The custom class must be public and must expose a parameterless public constructor.</span></span> <span data-ttu-id="e3954-109">Per alcune note riguardanti le strutture, vedere la sezione seguente.</span><span class="sxs-lookup"><span data-stu-id="e3954-109">(See following section for notes regarding structures.)</span></span>

- <span data-ttu-id="e3954-110">La classe personalizzata non deve essere una classe annidata.</span><span class="sxs-lookup"><span data-stu-id="e3954-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="e3954-111">Il "punto" aggiuntivo nel percorso del nome completo rende ambigua la divisione dello spazio dei nomi della classe e interferisce con altre funzionalità XAML, ad esempio le proprietà associate.</span><span class="sxs-lookup"><span data-stu-id="e3954-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>
<span data-ttu-id="e3954-112">Se è possibile creare un'istanza di un oggetto come elemento oggetto, l'oggetto creato può riempire la forma dell'elemento proprietà di tutte le proprietà che accettano l'oggetto come tipo sottostante.</span><span class="sxs-lookup"><span data-stu-id="e3954-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>

<span data-ttu-id="e3954-113">È comunque possibile fornire valori di oggetto per i tipi che non soddisfano questi criteri, se si abilita un convertitore di valori.</span><span class="sxs-lookup"><span data-stu-id="e3954-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="e3954-114">Per altre informazioni, vedere Convertitori di tipi ed Estensioni di [markup per XAML.](type-converters-and-markup-extensions.md)</span><span class="sxs-lookup"><span data-stu-id="e3954-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

### <a name="structures"></a><span data-ttu-id="e3954-115">Strutture</span><span class="sxs-lookup"><span data-stu-id="e3954-115">Structures</span></span>

<span data-ttu-id="e3954-116">Le strutture possono sempre essere costruite in XAML, in base alla definizione CLR.</span><span class="sxs-lookup"><span data-stu-id="e3954-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="e3954-117">Ciò è dovuto al fatto che un compilatore CLR crea in modo implicito un costruttore senza parametri per una struttura.</span><span class="sxs-lookup"><span data-stu-id="e3954-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="e3954-118">Questo costruttore inizializza tutti i valori di proprietà sui valori predefiniti.</span><span class="sxs-lookup"><span data-stu-id="e3954-118">This constructor initializes all property values to their defaults.</span></span>

<span data-ttu-id="e3954-119">In alcuni casi, il comportamento di costruzione predefinito per una struttura non è auspicabile.</span><span class="sxs-lookup"><span data-stu-id="e3954-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="e3954-120">Ciò potrebbe essere dovuto al fatto che la struttura è destinata a riempire i valori e funzionare concettualmente come un'unione.</span><span class="sxs-lookup"><span data-stu-id="e3954-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="e3954-121">Come unione, i valori contenuti potrebbero avere interpretazioni che si escludono a vicenda e pertanto nessuna delle relative proprietà è impostabile.</span><span class="sxs-lookup"><span data-stu-id="e3954-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="e3954-122">Un esempio di tale struttura nel <xref:System.Windows.GridLength>vocabolario WPFWPF è .</span><span class="sxs-lookup"><span data-stu-id="e3954-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="e3954-123">Tali strutture devono implementare un convertitore di tipi in modo che i valori possano essere espressi in forma di attributo, utilizzando convenzioni di stringa che creano le diverse interpretazioni o modalità dei valori della struttura.</span><span class="sxs-lookup"><span data-stu-id="e3954-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="e3954-124">La struttura deve inoltre esporre un comportamento simile per la costruzione del codice tramite un costruttore senza parametri.</span><span class="sxs-lookup"><span data-stu-id="e3954-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>

### <a name="interfaces"></a><span data-ttu-id="e3954-125">Interfacce</span><span class="sxs-lookup"><span data-stu-id="e3954-125">Interfaces</span></span>

<span data-ttu-id="e3954-126">Le interfacce possono essere utilizzate come tipi sottostanti di membri.</span><span class="sxs-lookup"><span data-stu-id="e3954-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="e3954-127">Il sistema di tipi XAML controlla l'elenco assegnabile e prevede che l'oggetto fornito come valore possa essere assegnato all'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="e3954-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="e3954-128">Non esiste alcun concetto di come l'interfaccia deve essere presentata come un tipo XAML, purché un tipo assegnabile pertinente supporti i requisiti di costruzione XAML.</span><span class="sxs-lookup"><span data-stu-id="e3954-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>

### <a name="factory-methods"></a><span data-ttu-id="e3954-129">Metodi Factory</span><span class="sxs-lookup"><span data-stu-id="e3954-129">Factory Methods</span></span>

<span data-ttu-id="e3954-130">I metodi factory sono una funzionalità xaml 2009.</span><span class="sxs-lookup"><span data-stu-id="e3954-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="e3954-131">Modificano il principio XAML secondo cui gli oggetti devono avere costruttori senza parametri.</span><span class="sxs-lookup"><span data-stu-id="e3954-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="e3954-132">I metodi factory non sono documentati in questo articolo.</span><span class="sxs-lookup"><span data-stu-id="e3954-132">Factory methods are not documented in this article.</span></span> <span data-ttu-id="e3954-133">Vedere [direttiva x:FactoryMethod](xfactorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="e3954-133">See [x:FactoryMethod Directive](xfactorymethod-directive.md).</span></span>

## <a name="enumerations"></a><span data-ttu-id="e3954-134">Enumerazioni</span><span class="sxs-lookup"><span data-stu-id="e3954-134">Enumerations</span></span>

<span data-ttu-id="e3954-135">Le enumerazioni hanno il comportamento di conversione dei tipi nativi XAML.</span><span class="sxs-lookup"><span data-stu-id="e3954-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="e3954-136">I nomi delle costanti di enumerazione specificati in XAML vengono risolti in base al tipo di enumerazione sottostante e restituiscono il valore di enumerazione a un writer di oggetti XAML.</span><span class="sxs-lookup"><span data-stu-id="e3954-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>

<span data-ttu-id="e3954-137">XAML supporta un utilizzo di stile <xref:System.FlagsAttribute> flag per le enumerazioni con applicato.</span><span class="sxs-lookup"><span data-stu-id="e3954-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="e3954-138">Per ulteriori informazioni, vedere [Sintassi XAML in dettaglio](../../framework/wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="e3954-138">For more information, see [XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="e3954-139">[(Sintassi XAML in dettaglio](../../framework/wpf/advanced/xaml-syntax-in-detail.md) è scritto per il pubblico WPFWPF, ma la maggior parte delle informazioni in tale argomento è rilevante per XAML che non è specifico di un particolare framework di implementazione.)</span><span class="sxs-lookup"><span data-stu-id="e3954-139">([XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>

## <a name="member-definitions"></a><span data-ttu-id="e3954-140">Definizioni dei membri</span><span class="sxs-lookup"><span data-stu-id="e3954-140">Member Definitions</span></span>

<span data-ttu-id="e3954-141">I tipi possono definire membri per l'utilizzo di XAML.</span><span class="sxs-lookup"><span data-stu-id="e3954-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="e3954-142">È possibile che i tipi definiscano membri che sono utilizzabili in XAML anche se quel tipo specifico non è utilizzabile con XAML.</span><span class="sxs-lookup"><span data-stu-id="e3954-142">It's possible for types to define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="e3954-143">Ciò è possibile a causa dell'ereditarietà CLR.</span><span class="sxs-lookup"><span data-stu-id="e3954-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="e3954-144">Finché un tipo che eredita il membro supporta l'utilizzo di XAML come tipo e il membro supporta l'utilizzo di XAML per il tipo sottostante o ha una sintassi XAML nativa disponibile, tale membro è utilizzabile in XAML.</span><span class="sxs-lookup"><span data-stu-id="e3954-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>

### <a name="properties"></a><span data-ttu-id="e3954-145">Proprietà</span><span class="sxs-lookup"><span data-stu-id="e3954-145">Properties</span></span>

<span data-ttu-id="e3954-146">Se si definiscono le proprietà come `get` proprietà `set` CLR pubblica utilizzando i modelli CLR tipici e i modelli di funzione <xref:System.Xaml.XamlMember> di accesso <xref:System.Xaml.XamlMember.IsReadPublic%2A> e <xref:System.Xaml.XamlMember.IsWritePublic%2A>le parole chiave appropriate per il linguaggio, il sistema di tipi XAML può segnalare la proprietà come membro con le informazioni appropriate fornite per le proprietà, ad esempio e .</span><span class="sxs-lookup"><span data-stu-id="e3954-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>

<span data-ttu-id="e3954-147">Proprietà specifiche possono abilitare una <xref:System.ComponentModel.TypeConverterAttribute>sintassi di testo applicando .</span><span class="sxs-lookup"><span data-stu-id="e3954-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="e3954-148">Per altre informazioni, vedere Convertitori di tipi ed Estensioni di [markup per XAML.](type-converters-and-markup-extensions.md)</span><span class="sxs-lookup"><span data-stu-id="e3954-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="e3954-149">In assenza di una sintassi di testo o di una conversione XAML nativa e in<xref:System.Xaml.XamlMember.TargetType%2A> assenza di ulteriori direzioni indiretti, ad esempio l'utilizzo di un'estensione di markup, il tipo di una proprietà (nel sistema di tipi XAML) deve essere in grado di restituire un'istanza a un writer di oggetti XAML trattando il tipo di destinazione come un tipo CLR.</span><span class="sxs-lookup"><span data-stu-id="e3954-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>

<span data-ttu-id="e3954-150">Se si usa XAML 2009, [x:Reference Markup Extension](xreference-markup-extension.md) può essere usato per fornire valori se le considerazioni precedenti non vengono soddisfatte; Tuttavia, si tratta di un problema di utilizzo maggiore rispetto a un problema di definizione del tipo.</span><span class="sxs-lookup"><span data-stu-id="e3954-150">If using XAML 2009, [x:Reference Markup Extension](xreference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>

### <a name="events"></a><span data-ttu-id="e3954-151">Events</span><span class="sxs-lookup"><span data-stu-id="e3954-151">Events</span></span>

<span data-ttu-id="e3954-152">Se si definiscono eventi come evento CLR pubblico, il sistema <xref:System.Xaml.XamlMember.IsEvent%2A> di `true`tipi XAML può segnalare l'evento come membro con as .</span><span class="sxs-lookup"><span data-stu-id="e3954-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="e3954-153">Il cablaggio dei gestori eventi non rientra nell'ambito delle funzionalità dei servizi XAML di .NET. cablaggio è lasciato a quadri e implementazioni specifici.</span><span class="sxs-lookup"><span data-stu-id="e3954-153">Wiring the event handlers is not within the scope of .NET XAML Services capabilities; wiring is left to specific frameworks and implementations.</span></span>

### <a name="methods"></a><span data-ttu-id="e3954-154">Metodi</span><span class="sxs-lookup"><span data-stu-id="e3954-154">Methods</span></span>

<span data-ttu-id="e3954-155">Il codice inline per i metodi non è una funzionalità XAML predefinita.</span><span class="sxs-lookup"><span data-stu-id="e3954-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="e3954-156">Nella maggior parte dei casi, non fai riferimento direttamente ai membri del metodo da XAML e il ruolo dei metodi in XAML è solo quello di fornire il supporto per modelli XAML specifici.</span><span class="sxs-lookup"><span data-stu-id="e3954-156">In most cases, you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="e3954-157">[La direttiva x:FactoryMethod](xfactorymethod-directive.md) è un'eccezione.X:FactoryMethod Directive is an exception.</span><span class="sxs-lookup"><span data-stu-id="e3954-157">[x:FactoryMethod Directive](xfactorymethod-directive.md) is an exception.</span></span>

### <a name="fields"></a><span data-ttu-id="e3954-158">Campi</span><span class="sxs-lookup"><span data-stu-id="e3954-158">Fields</span></span>

<span data-ttu-id="e3954-159">Le linee guida di progettazione CLR scoraggiano i campi non statici.</span><span class="sxs-lookup"><span data-stu-id="e3954-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="e3954-160">Per i campi statici, è possibile accedere ai valori dei campi statici solo tramite [x:Static Markup Extension](xstatic-markup-extension.md); in questo caso non si esegue alcuna operazione speciale nella definizione CLR per esporre un campo per gli utilizzi [x:Static.](xstatic-markup-extension.md)</span><span class="sxs-lookup"><span data-stu-id="e3954-160">For static fields, you can access static field values only through [x:Static Markup Extension](xstatic-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](xstatic-markup-extension.md) usages.</span></span>

## <a name="attachable-members"></a><span data-ttu-id="e3954-161">Membri associabili</span><span class="sxs-lookup"><span data-stu-id="e3954-161">Attachable Members</span></span>

<span data-ttu-id="e3954-162">I membri associabili vengono esposti a XAML tramite un modello di metodo della funzione di accesso in un tipo di definizione.</span><span class="sxs-lookup"><span data-stu-id="e3954-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="e3954-163">Non è necessario che il tipo di definizione stesso sia utilizzabile in XAML come oggetto.</span><span class="sxs-lookup"><span data-stu-id="e3954-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="e3954-164">Infatti, un modello comune consiste nel dichiarare una classe di servizio il cui ruolo è quello di possedere il membro associabile e implementare i comportamenti correlati, ma non servono altre funzioni, ad esempio una rappresentazione dell'interfaccia utente.</span><span class="sxs-lookup"><span data-stu-id="e3954-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="e3954-165">Per le sezioni seguenti, il segnaposto *PropertyName* rappresenta il nome del membro associabile.</span><span class="sxs-lookup"><span data-stu-id="e3954-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="e3954-166">Tale nome deve essere valido nella grammatica [XamlName](xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="e3954-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>

<span data-ttu-id="e3954-167">Prestare attenzione alle collisioni di nomi tra questi modelli e altri metodi di un tipo.</span><span class="sxs-lookup"><span data-stu-id="e3954-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="e3954-168">Se esiste un membro che corrisponde a uno dei modelli, può essere interpretato come un percorso di utilizzo del membro associabile da un processore XAML anche se questo non era l'intenzione.</span><span class="sxs-lookup"><span data-stu-id="e3954-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>

#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="e3954-169">La funzione di accesso GetPropertyNameThe GetPropertyName Accessor</span><span class="sxs-lookup"><span data-stu-id="e3954-169">The GetPropertyName Accessor</span></span>

<span data-ttu-id="e3954-170">La firma `GetPropertyName` per la funzione di accesso deve essere:</span><span class="sxs-lookup"><span data-stu-id="e3954-170">The signature for the `GetPropertyName` accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="e3954-171">L'oggetto `target` può essere specificato come tipo più specifico nell'implementazione.</span><span class="sxs-lookup"><span data-stu-id="e3954-171">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="e3954-172">È possibile utilizzare questo per definire l'ambito dell'utilizzo del membro associabile; Gli utilizzi al di fuori dell'ambito previsto genereranno eccezioni di cast non valide che vengono quindi rilevate da un errore di analisi XAML.</span><span class="sxs-lookup"><span data-stu-id="e3954-172">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="e3954-173">Il nome `target` del parametro non `target` è un requisito, ma è denominato per convenzione nella maggior parte delle implementazioni.</span><span class="sxs-lookup"><span data-stu-id="e3954-173">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>

- <span data-ttu-id="e3954-174">Il valore restituito può essere specificato come tipo più specifico nell'implementazione.</span><span class="sxs-lookup"><span data-stu-id="e3954-174">The return value can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="e3954-175">Per supportare una <xref:System.ComponentModel.TypeConverter> sintassi di testo abilitata <xref:System.ComponentModel.TypeConverterAttribute> per `GetPropertyName` l'utilizzo degli attributi del membro associabile, applicare alla funzione di accesso.</span><span class="sxs-lookup"><span data-stu-id="e3954-175">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `GetPropertyName` accessor.</span></span> <span data-ttu-id="e3954-176">Applicare al `get` posto di `set` può sembrare non intuitivo; Tuttavia, questa convenzione può supportare il concetto di membri associabili di sola lettura che sono serializzabili, che è utile negli scenari di progettazione.</span><span class="sxs-lookup"><span data-stu-id="e3954-176">Applying to the `get` instead of the `set` may seem non-intuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>

#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="e3954-177">La funzione di accesso SetPropertyNameThe SetPropertyName Accessor</span><span class="sxs-lookup"><span data-stu-id="e3954-177">The SetPropertyName Accessor</span></span>

<span data-ttu-id="e3954-178">La firma `SetPropertyName` per la funzione di accesso deve essere:</span><span class="sxs-lookup"><span data-stu-id="e3954-178">The signature for the `SetPropertyName` accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="e3954-179">L'oggetto `target` può essere specificato come un tipo più specifico nell'implementazione, con la stessa logica e le stesse conseguenze descritte nella sezione precedente.</span><span class="sxs-lookup"><span data-stu-id="e3954-179">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>

- <span data-ttu-id="e3954-180">L'oggetto `value` può essere specificato come tipo più specifico nell'implementazione.</span><span class="sxs-lookup"><span data-stu-id="e3954-180">The `value` object can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="e3954-181">Tenere presente che il valore di questo metodo è l'input proveniente dall'utilizzo di XAML, in genere in forma di attributo.</span><span class="sxs-lookup"><span data-stu-id="e3954-181">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="e3954-182">Dal modulo di attributo deve essere il supporto del `GetPropertyName`convertitore di valori per una sintassi di testo e l'attributo nella funzione di accesso s.</span><span class="sxs-lookup"><span data-stu-id="e3954-182">From attribute form there must be value converter support for a text syntax, and you attribute on the `GetPropertyName`s accessor.</span></span>

### <a name="attachable-member-stores"></a><span data-ttu-id="e3954-183">Archivi membri associabili</span><span class="sxs-lookup"><span data-stu-id="e3954-183">Attachable Member Stores</span></span>

<span data-ttu-id="e3954-184">I metodi della funzione di accesso non sono in genere sufficienti per fornire un mezzo per inserire i valori dei membri associabili in un oggetto grafico o per recuperare i valori dall'oggetto grafico e serializzarli correttamente.</span><span class="sxs-lookup"><span data-stu-id="e3954-184">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="e3954-185">Per fornire questa `target` funzionalità, gli oggetti nelle firme delle accessire precedenti devono essere in grado di archiviare valori.</span><span class="sxs-lookup"><span data-stu-id="e3954-185">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="e3954-186">Il meccanismo di archiviazione deve essere coerente con il principio del membro associabile che il membro è associabile alle destinazioni in cui il membro associabile non è presente nell'elenco dei membri.</span><span class="sxs-lookup"><span data-stu-id="e3954-186">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="e3954-187">Servizi XAML .NET fornisce una tecnica di implementazione <xref:System.Xaml.IAttachedPropertyStore> per <xref:System.Xaml.AttachablePropertyServices>gli archivi membri collegabili tramite le API e .</span><span class="sxs-lookup"><span data-stu-id="e3954-187">.NET XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="e3954-188"><xref:System.Xaml.IAttachedPropertyStore>viene utilizzato dai writer XAML per individuare l'implementazione dell'archivio e deve essere implementato nel tipo che è il `target` delle funzioni di accesso.</span><span class="sxs-lookup"><span data-stu-id="e3954-188"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="e3954-189">Le <xref:System.Xaml.AttachablePropertyServices> API statiche vengono utilizzate all'interno del corpo delle funzioni di <xref:System.Xaml.AttachableMemberIdentifier>accesso e fanno riferimento al membro associabile tramite il relativo oggetto .</span><span class="sxs-lookup"><span data-stu-id="e3954-189">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>

## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="e3954-190">Attributi CLR correlati a XAMLXAML-Related CLR Attributes</span><span class="sxs-lookup"><span data-stu-id="e3954-190">XAML-Related CLR Attributes</span></span>

<span data-ttu-id="e3954-191">Attribuire correttamente i tipi, i membri e gli assembly è importante per segnalare le informazioni sul sistema di tipi XAML ai servizi XAML .NET.</span><span class="sxs-lookup"><span data-stu-id="e3954-191">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET XAML Services.</span></span> <span data-ttu-id="e3954-192">La segnalazione delle informazioni sul sistema di tipi XAML è rilevante se si verifica una delle situazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="e3954-192">Reporting XAML type system information is relevant if either of the following situations apply:</span></span>

- <span data-ttu-id="e3954-193">Si intende utilizzare i tipi con sistemi XAML basati direttamente su reader XAML dei servizi XAML .NET e writer XAML.</span><span class="sxs-lookup"><span data-stu-id="e3954-193">You intend your types for use with XAML systems that are directly based on .NET XAML Services XAML readers and XAML writers.</span></span>
- <span data-ttu-id="e3954-194">È possibile definire o utilizzare un framework che utilizza XAML basato su tali reader XAML e writer XAML.</span><span class="sxs-lookup"><span data-stu-id="e3954-194">You define or use a XAML-utilizing framework that's based on those XAML readers and XAML writers.</span></span>

<span data-ttu-id="e3954-195">Per un elenco di ogni attributo correlato a XAML rilevante per il supporto XAML dei tipi personalizzati, vedere [Attributi CLR correlati a XAML per tipi e librerie personalizzati.](clr-attributes-with-custom-types-and-libraries.md)</span><span class="sxs-lookup"><span data-stu-id="e3954-195">For a listing of each XAML-related attribute that's relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](clr-attributes-with-custom-types-and-libraries.md).</span></span>

## <a name="usage"></a><span data-ttu-id="e3954-196">Uso</span><span class="sxs-lookup"><span data-stu-id="e3954-196">Usage</span></span>

<span data-ttu-id="e3954-197">L'utilizzo di tipi personalizzati richiede che l'autore del markup debba eseguire il mapping di un prefisso per l'assembly e lo spazio dei nomi CLR che contengono il tipo personalizzato.</span><span class="sxs-lookup"><span data-stu-id="e3954-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="e3954-198">Questa procedura non è documentata in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="e3954-198">This procedure is not documented in this topic.</span></span>

## <a name="access-level"></a><span data-ttu-id="e3954-199">Livello di accesso</span><span class="sxs-lookup"><span data-stu-id="e3954-199">Access Level</span></span>

<span data-ttu-id="e3954-200">XAML fornisce un mezzo per caricare `internal` e creare istanze di tipi che dispongono di un livello di accesso.</span><span class="sxs-lookup"><span data-stu-id="e3954-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="e3954-201">Questa funzionalità viene fornita in modo che il codice utente possa definire i propri tipi e quindi creare un'istanza di tali classi dal markup che fa anche parte dello stesso ambito del codice utente.</span><span class="sxs-lookup"><span data-stu-id="e3954-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>

<span data-ttu-id="e3954-202">Un esempio da WPFWPF è <xref:System.Windows.Controls.UserControl> ogni volta che il codice utente definisce un che è inteso come un modo per effettuare `public` il refactoring di un comportamento dell'interfaccia utente, ma non come parte di qualsiasi possibile meccanismo di estensione che potrebbe essere implicito dichiarando la classe di supporto con il livello di accesso.</span><span class="sxs-lookup"><span data-stu-id="e3954-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="e3954-203">Tale <xref:System.Windows.Controls.UserControl> oggetto può `internal` essere dichiarato con accesso se il codice di supporto viene compilato nello stesso assembly da cui viene fatto riferimento come tipo XAML.</span><span class="sxs-lookup"><span data-stu-id="e3954-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>

<span data-ttu-id="e3954-204">Per un'applicazione che carica XAML <xref:System.Xaml.XamlObjectWriter>con attendibilità totale e usa , il caricamento di classi con `internal` livello di accesso è sempre abilitato.</span><span class="sxs-lookup"><span data-stu-id="e3954-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>

<span data-ttu-id="e3954-205">Per un'applicazione che carica XAML in attendibilità parziale, <xref:System.Xaml.Permissions.XamlAccessLevel> è possibile controllare le caratteristiche del livello di accesso usando l'API.</span><span class="sxs-lookup"><span data-stu-id="e3954-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="e3954-206">Inoltre, i meccanismi di differimento (ad esempio il sistema di modelli WPFWPF) devono essere in grado di propagare le autorizzazioni del livello di accesso e conservarle per le valutazioni in fase di esecuzione finali; questo viene gestito internamente <xref:System.Xaml.Permissions.XamlAccessLevel> passando le informazioni.</span><span class="sxs-lookup"><span data-stu-id="e3954-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>

### <a name="wpf-implementation"></a><span data-ttu-id="e3954-207">Implementazione WPFWPF Implementation</span><span class="sxs-lookup"><span data-stu-id="e3954-207">WPF Implementation</span></span>

<span data-ttu-id="e3954-208">XAML WPFWPF XAML usa un modello di accesso parzialmente attendibile <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> in cui se BAML viene caricato in attendibilità parziale, l'accesso è limitato all'assembly che è l'origine BAML.</span><span class="sxs-lookup"><span data-stu-id="e3954-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="e3954-209">Per il rinvio, <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> WPFWPF usa come meccanismo per il passaggio delle informazioni sul livello di accesso.</span><span class="sxs-lookup"><span data-stu-id="e3954-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>

<span data-ttu-id="e3954-210">Nella terminologia XAML WPF, un *tipo interno* è un tipo definito dallo stesso assembly che include anche il codice XAML di riferimento.</span><span class="sxs-lookup"><span data-stu-id="e3954-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="e3954-211">È possibile eseguire il mapping di un tipo di questo tipo tramite uno spazio `xmlns:local="clr-namespace:WPFApplication1"`dei nomi XAML che omette deliberatamente la parte assembly di un mapping, ad esempio .</span><span class="sxs-lookup"><span data-stu-id="e3954-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span> <span data-ttu-id="e3954-212">Se BAML fa riferimento a `internal` un tipo interno `GeneratedInternalTypeHelper` e tale tipo ha un livello di accesso, viene generata una classe per l'assembly.</span><span class="sxs-lookup"><span data-stu-id="e3954-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="e3954-213">Se si desidera `GeneratedInternalTypeHelper`evitare , `public` è necessario utilizzare il livello di accesso oppure fare trafattore la classe pertinente in un assembly separato e rendere tale assembly dipendente.</span><span class="sxs-lookup"><span data-stu-id="e3954-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>

## <a name="see-also"></a><span data-ttu-id="e3954-214">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="e3954-214">See also</span></span>

- [<span data-ttu-id="e3954-215">Attributi CLR correlati a XAML per tipi e librerie personalizzati</span><span class="sxs-lookup"><span data-stu-id="e3954-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](clr-attributes-with-custom-types-and-libraries.md)
- [<span data-ttu-id="e3954-216">Servizi XAML</span><span class="sxs-lookup"><span data-stu-id="e3954-216">XAML Services</span></span>](../../../api/index.md)
