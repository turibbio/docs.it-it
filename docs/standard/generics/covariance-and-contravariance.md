---
title: Covarianza e controvarianza nei generics
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- generics, covariance and contravariance
- generics, variance
- covariance and contravariance in generics
- generic type parameters
ms.assetid: 2678dc63-c7f9-4590-9ddc-0a4df684d42e
ms.openlocfilehash: b11b5fc93d9b7289e62d6abc9d3ca19027a107c5
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/02/2020
ms.locfileid: "84287558"
---
# <a name="covariance-and-contravariance-in-generics"></a><span data-ttu-id="b1162-102">Covarianza e controvarianza nei generics</span><span class="sxs-lookup"><span data-stu-id="b1162-102">Covariance and Contravariance in Generics</span></span>
<span data-ttu-id="b1162-103"> La covarianza e la controvarianza sono termini che fanno riferimento alla possibilità di usare un tipo più derivato (più specifico) o un tipo meno derivato (meno specifico) di quanto specificato in origine.</span><span class="sxs-lookup"><span data-stu-id="b1162-103">Covariance and contravariance are terms that refer to the ability to use a more derived type (more specific) or a less derived type (less specific) than originally specified.</span></span> <span data-ttu-id="b1162-104">I parametri di tipo generico supportano la covarianza e la controvarianza per offrire la massima flessibilità nell'assegnazione e nell'utilizzo dei tipi generici.</span><span class="sxs-lookup"><span data-stu-id="b1162-104">Generic type parameters support covariance and contravariance to provide greater flexibility in assigning and using generic types.</span></span> <span data-ttu-id="b1162-105">Quando si fa riferimento a un sistema di tipi, la covarianza, la controvarianza e l'invarianza hanno le seguenti definizioni.</span><span class="sxs-lookup"><span data-stu-id="b1162-105">When you are referring to a type system, covariance, contravariance, and invariance have the following definitions.</span></span> <span data-ttu-id="b1162-106">Negli esempi si presuppone una classe di base denominata `Base` e una classe derivata denominata `Derived`.</span><span class="sxs-lookup"><span data-stu-id="b1162-106">The examples assume a base class named `Base` and a derived class named `Derived`.</span></span>  
  
- `Covariance`  
  
     <span data-ttu-id="b1162-107">Permette di usare un tipo più derivato di quello originariamente specificato.</span><span class="sxs-lookup"><span data-stu-id="b1162-107">Enables you to use a more derived type than originally specified.</span></span>  
  
     <span data-ttu-id="b1162-108">È possibile assegnare un'istanza di `IEnumerable<Derived>` (`IEnumerable(Of Derived)` in Visual Basic) a una variabile di tipo `IEnumerable<Base>`.</span><span class="sxs-lookup"><span data-stu-id="b1162-108">You can assign an instance of `IEnumerable<Derived>` (`IEnumerable(Of Derived)` in Visual Basic) to a variable of type `IEnumerable<Base>`.</span></span>  
  
- `Contravariance`  
  
     <span data-ttu-id="b1162-109">Consente di utilizzare un tipo più generico (meno derivato) di quello originariamente specificato.</span><span class="sxs-lookup"><span data-stu-id="b1162-109">Enables you to use a more generic (less derived) type than originally specified.</span></span>  
  
     <span data-ttu-id="b1162-110">È possibile assegnare un'istanza di `Action<Base>` (`Action(Of Base)` in Visual Basic) a una variabile di tipo `Action<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="b1162-110">You can assign an instance of `Action<Base>` (`Action(Of Base)` in Visual Basic) to a variable of type `Action<Derived>`.</span></span>  
  
- `Invariance`  
  
     <span data-ttu-id="b1162-111">Significa che è possibile usare solo il tipo specificato originariamente; pertanto un parametro di tipo generico invariante non è covariante o controvariante.</span><span class="sxs-lookup"><span data-stu-id="b1162-111">Means that you can use only the type originally specified; so an invariant generic type parameter is neither covariant nor contravariant.</span></span>  
  
     <span data-ttu-id="b1162-112">Non è possibile assegnare un'istanza di `List<Base>` (`List(Of Base)` in Visual Basic) a una variabile di tipo `List<Derived>` o viceversa.</span><span class="sxs-lookup"><span data-stu-id="b1162-112">You cannot assign an instance of `List<Base>` (`List(Of Base)` in Visual Basic) to a variable of type `List<Derived>` or vice versa.</span></span>  
  
 <span data-ttu-id="b1162-113">I parametri di tipo covariante consentono di effettuare assegnazioni simili al [polimorfismo](../../csharp/programming-guide/classes-and-structs/polymorphism.md) ordinario., come illustrato nel codice seguente.</span><span class="sxs-lookup"><span data-stu-id="b1162-113">Covariant type parameters enable you to make assignments that look much like ordinary [Polymorphism](../../csharp/programming-guide/classes-and-structs/polymorphism.md), as shown in the following code.</span></span>  
  
 [!code-csharp[CoContraSimpleIEnum#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleienum/cs/example.cs#1)]
 [!code-vb[CoContraSimpleIEnum#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleienum/vb/example.vb#1)]  
  
 <span data-ttu-id="b1162-114">La classe <xref:System.Collections.Generic.List%601> implementa l'interfaccia <xref:System.Collections.Generic.IEnumerable%601> , pertanto `List<Derived>` (`List(Of Derived)` in Visual Basic) implementa `IEnumerable<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="b1162-114">The <xref:System.Collections.Generic.List%601> class implements the <xref:System.Collections.Generic.IEnumerable%601> interface, so `List<Derived>` (`List(Of Derived)` in Visual Basic) implements `IEnumerable<Derived>`.</span></span> <span data-ttu-id="b1162-115">Il parametro di tipo covariante completa l'operazione.</span><span class="sxs-lookup"><span data-stu-id="b1162-115">The covariant type parameter does the rest.</span></span>  
  
 <span data-ttu-id="b1162-116">Viceversa, la controvarianza è poco intuitiva.</span><span class="sxs-lookup"><span data-stu-id="b1162-116">Contravariance, on the other hand, seems counterintuitive.</span></span> <span data-ttu-id="b1162-117">Nell'esempio seguente viene creato un delegato di tipo `Action<Base>` (`Action(Of Base)` in Visual Basic), che viene quindi assegnato a una variabile di tipo `Action<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="b1162-117">The following example creates a delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic), and then assigns that delegate to a variable of type `Action<Derived>`.</span></span>  
  
 [!code-csharp[CoContraSimpleAction#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleaction/cs/example.cs#1)]
 [!code-vb[CoContraSimpleAction#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleaction/vb/example.vb#1)]  
  
 <span data-ttu-id="b1162-118">Può sembrare un passo indietro, ma si tratta di codice indipendente dai tipi che viene compilato ed eseguito.</span><span class="sxs-lookup"><span data-stu-id="b1162-118">This seems backward, but it is type-safe code that compiles and runs.</span></span> <span data-ttu-id="b1162-119">L'espressione lambda corrisponde al delegato a cui è assegnato, pertanto definisce un metodo che accetta un parametro di tipo `Base` senza valore restituito.</span><span class="sxs-lookup"><span data-stu-id="b1162-119">The lambda expression matches the delegate it is assigned to, so it defines a method that takes one parameter of type `Base` and that has no return value.</span></span> <span data-ttu-id="b1162-120">Il delegato risultante può essere assegnato a una variabile di tipo `Action<Derived>` poiché il parametro di tipo `T` del delegato <xref:System.Action%601> è controvariante.</span><span class="sxs-lookup"><span data-stu-id="b1162-120">The resulting delegate can be assigned to a variable of type `Action<Derived>` because the type parameter `T` of the <xref:System.Action%601> delegate is contravariant.</span></span> <span data-ttu-id="b1162-121">Il codice è indipendente dai tipi perché `T` specifica un tipo di parametro.</span><span class="sxs-lookup"><span data-stu-id="b1162-121">The code is type-safe because `T` specifies a parameter type.</span></span> <span data-ttu-id="b1162-122">Quando il delegato di tipo `Action<Base>` viene richiamato come se fosse un delegato di tipo `Action<Derived>`, il relativo argomento deve essere di tipo `Derived`.</span><span class="sxs-lookup"><span data-stu-id="b1162-122">When the delegate of type `Action<Base>` is invoked as if it were a delegate of type `Action<Derived>`, its argument must be of type `Derived`.</span></span> <span data-ttu-id="b1162-123">Questo argomento può sempre essere passato in modo sicuro al metodo sottostante, perché il parametro del metodo è di tipo `Base`.</span><span class="sxs-lookup"><span data-stu-id="b1162-123">This argument can always be passed safely to the underlying method, because the method's parameter is of type `Base`.</span></span>  
  
 <span data-ttu-id="b1162-124">In genere, un parametro di tipo covariante può essere utilizzato come tipo restituito di un delegato e i parametri di tipo controvariante possono essere utilizzati come tipi di parametri.</span><span class="sxs-lookup"><span data-stu-id="b1162-124">In general, a covariant type parameter can be used as the return type of a delegate, and contravariant type parameters can be used as parameter types.</span></span> <span data-ttu-id="b1162-125">Per un'interfaccia, i parametri di tipo covariante possono essere utilizzati come tipi restituiti dei metodi dell'interfaccia e i parametri di tipo controvariante possono essere utilizzati come tipi di parametri dei metodi dell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="b1162-125">For an interface, covariant type parameters can be used as the return types of the interface's methods, and contravariant type parameters can be used as the parameter types of the interface's methods.</span></span>  
  
 <span data-ttu-id="b1162-126">La covarianza e la controvarianza sono definite collettivamente *varianza*.</span><span class="sxs-lookup"><span data-stu-id="b1162-126">Covariance and contravariance are collectively referred to as *variance*.</span></span> <span data-ttu-id="b1162-127">Un parametro di tipo generico non contrassegnato come covariante o controvariante viene definito *invariante*.</span><span class="sxs-lookup"><span data-stu-id="b1162-127">A generic type parameter that is not marked covariant or contravariant is referred to as *invariant*.</span></span> <span data-ttu-id="b1162-128">Di seguito vengono riepilogati i concetti relativi alla varianza in Common Language Runtime:</span><span class="sxs-lookup"><span data-stu-id="b1162-128">A brief summary of facts about variance in the common language runtime:</span></span>  
  
- <span data-ttu-id="b1162-129">In .NET Framework 4, i parametri di tipo variante sono limitati ai tipi di interfaccia generica e delegato generico.</span><span class="sxs-lookup"><span data-stu-id="b1162-129">In the .NET Framework 4, variant type parameters are restricted to generic interface and generic delegate types.</span></span>  
  
- <span data-ttu-id="b1162-130">Un tipo di interfaccia generica o delegato generico può presentare parametri di tipo sia covariante sia controvariante.</span><span class="sxs-lookup"><span data-stu-id="b1162-130">A generic interface or generic delegate type can have both covariant and contravariant type parameters.</span></span>  
  
- <span data-ttu-id="b1162-131">La varianza si applica solo ai tipi di riferimento. Se si specifica un tipo di valore per un parametro di tipo variante, tale parametro di tipo è invariante per il tipo costruito risultante.</span><span class="sxs-lookup"><span data-stu-id="b1162-131">Variance applies only to reference types; if you specify a value type for a variant type parameter, that type parameter is invariant for the resulting constructed type.</span></span>  
  
- <span data-ttu-id="b1162-132">La varianza non si applica alla combinazione di delegati.</span><span class="sxs-lookup"><span data-stu-id="b1162-132">Variance does not apply to delegate combination.</span></span> <span data-ttu-id="b1162-133">Ciò significa che nel caso di due delegati di tipo `Action<Derived>` e `Action<Base>` (`Action(Of Derived)` e `Action(Of Base)` in Visual Basic), non è possibile combinare il secondo delegato con il primo anche se il risultato sarebbe indipendente dai tipi.</span><span class="sxs-lookup"><span data-stu-id="b1162-133">That is, given two delegates of types `Action<Derived>` and `Action<Base>` (`Action(Of Derived)` and `Action(Of Base)` in Visual Basic), you cannot combine the second delegate with the first although the result would be type safe.</span></span> <span data-ttu-id="b1162-134">La varianza consente l'assegnazione del secondo delegato a una variabile di tipo `Action<Derived>`, ma i delegati possono essere combinati solo se il loro tipo corrisponde esattamente.</span><span class="sxs-lookup"><span data-stu-id="b1162-134">Variance allows the second delegate to be assigned to a variable of type `Action<Derived>`, but delegates can combine only if their types match exactly.</span></span>

<a name="InterfaceCovariantTypeParameters"></a>
## <a name="generic-interfaces-with-covariant-type-parameters"></a><span data-ttu-id="b1162-135">Interfacce generiche con parametri di tipo covariante</span><span class="sxs-lookup"><span data-stu-id="b1162-135">Generic Interfaces with Covariant Type Parameters</span></span>  
 <span data-ttu-id="b1162-136">A partire da .NET Framework 4, diverse interfacce generiche presentano parametri di tipo covariante, ad esempio <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601> e <xref:System.Linq.IGrouping%602>.</span><span class="sxs-lookup"><span data-stu-id="b1162-136">Starting with the .NET Framework 4, several generic interfaces have covariant type parameters; for example: <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601>, and <xref:System.Linq.IGrouping%602>.</span></span> <span data-ttu-id="b1162-137">Tutti i parametri del tipo di queste interfacce sono covarianti, pertanto i parametri del tipo vengono utilizzati solo per i tipi restituiti dei membri.</span><span class="sxs-lookup"><span data-stu-id="b1162-137">All the type parameters of these interfaces are covariant, so the type parameters are used only for the return types of the members.</span></span>  
  
 <span data-ttu-id="b1162-138">Nell'esempio seguente vengono illustrati parametri di tipo covariante.</span><span class="sxs-lookup"><span data-stu-id="b1162-138">The following example illustrates covariant type parameters.</span></span> <span data-ttu-id="b1162-139">Nell'esempio vengono definiti due tipi: `Base` presenta un metodo statico denominato `PrintBases` che accetta `IEnumerable<Base>` (`IEnumerable(Of Base)` in Visual Basic) e stampa gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b1162-139">The example defines two types: `Base` has a static method named `PrintBases` that takes an `IEnumerable<Base>` (`IEnumerable(Of Base)` in Visual Basic) and prints the elements.</span></span> <span data-ttu-id="b1162-140">`Derived` eredita da `Base`.</span><span class="sxs-lookup"><span data-stu-id="b1162-140">`Derived` inherits from `Base`.</span></span> <span data-ttu-id="b1162-141">Nell'esempio viene creato un tipo `List<Derived>` (`List(Of Derived)` in Visual Basic) vuoto e viene illustrato che è possibile passare tale tipo a `PrintBases` e assegnarlo a una variabile di tipo `IEnumerable<Base>` senza eseguire il cast.</span><span class="sxs-lookup"><span data-stu-id="b1162-141">The example creates an empty `List<Derived>` (`List(Of Derived)` in Visual Basic) and demonstrates that this type can be passed to `PrintBases` and assigned to a variable of type `IEnumerable<Base>` without casting.</span></span> <span data-ttu-id="b1162-142"><xref:System.Collections.Generic.List%601> implementa <xref:System.Collections.Generic.IEnumerable%601>, che dispone di un solo parametro di tipo covariante.</span><span class="sxs-lookup"><span data-stu-id="b1162-142"><xref:System.Collections.Generic.List%601> implements <xref:System.Collections.Generic.IEnumerable%601>, which has a single covariant type parameter.</span></span> <span data-ttu-id="b1162-143">Il parametro di tipo covariante è il motivo per cui è possibile usare un'istanza di `IEnumerable<Derived>` anziché di `IEnumerable<Base>`.</span><span class="sxs-lookup"><span data-stu-id="b1162-143">The covariant type parameter is the reason why an instance of `IEnumerable<Derived>` can be used instead of `IEnumerable<Base>`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici/vb/example.vb#1)]  
  
## <a name="generic-interfaces-with-contravariant-generic-type-parameters"></a><span data-ttu-id="b1162-144">Interfacce generiche con parametri di tipo generico controvariante</span><span class="sxs-lookup"><span data-stu-id="b1162-144">Generic Interfaces with Contravariant Generic Type Parameters</span></span>  
 <span data-ttu-id="b1162-145">A partire da .NET Framework 4, diverse interfacce generiche presentano parametri di tipo contravariante, ad esempio <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601> e <xref:System.Collections.Generic.IEqualityComparer%601>.</span><span class="sxs-lookup"><span data-stu-id="b1162-145">Starting with the .NET Framework 4, several generic interfaces have contravariant type parameters; for example: <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601>, and <xref:System.Collections.Generic.IEqualityComparer%601>.</span></span> <span data-ttu-id="b1162-146">Queste interfacce dispongono solo di parametri di tipo controvariante, pertanto i parametri di tipo vengono utilizzati solo come tipi di parametri nei membri delle interfacce.</span><span class="sxs-lookup"><span data-stu-id="b1162-146">These interfaces have only contravariant type parameters, so the type parameters are used only as parameter types in the members of the interfaces.</span></span>  
  
 <span data-ttu-id="b1162-147">Nell'esempio seguente vengono illustrati parametri di tipo controvariante.</span><span class="sxs-lookup"><span data-stu-id="b1162-147">The following example illustrates contravariant type parameters.</span></span> <span data-ttu-id="b1162-148">Nell'esempio viene definita una classe`MustInherit` astratta ( `Shape` in Visual Basic) con una proprietà `Area` .</span><span class="sxs-lookup"><span data-stu-id="b1162-148">The example defines an abstract (`MustInherit` in Visual Basic) `Shape` class with an `Area` property.</span></span> <span data-ttu-id="b1162-149">Nell'esempio viene definita anche una classe `ShapeAreaComparer` che implementa `IComparer<Shape>` (`IComparer(Of Shape)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b1162-149">The example also defines a `ShapeAreaComparer` class that implements `IComparer<Shape>` (`IComparer(Of Shape)` in Visual Basic).</span></span> <span data-ttu-id="b1162-150">L'implementazione del metodo <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> è basata sul valore della proprietà `Area` , pertanto `ShapeAreaComparer` può essere utilizzato per ordinare gli oggetti `Shape` in base all'area.</span><span class="sxs-lookup"><span data-stu-id="b1162-150">The implementation of the <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> method is based on the value of the `Area` property, so `ShapeAreaComparer` can be used to sort `Shape` objects by area.</span></span>  
  
 <span data-ttu-id="b1162-151">La classe `Circle` eredita dalla classe `Shape` ed esegue l'override di `Area`.</span><span class="sxs-lookup"><span data-stu-id="b1162-151">The `Circle` class inherits `Shape` and overrides `Area`.</span></span> <span data-ttu-id="b1162-152">Nell'esempio viene creato un oggetto <xref:System.Collections.Generic.SortedSet%601> di oggetti `Circle` , usando un costruttore che accetta un oggetto `IComparer<Circle>` (`IComparer(Of Circle)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b1162-152">The example creates a <xref:System.Collections.Generic.SortedSet%601> of `Circle` objects, using a constructor that takes an `IComparer<Circle>` (`IComparer(Of Circle)` in Visual Basic).</span></span> <span data-ttu-id="b1162-153">Tuttavia, anziché passare un oggetto `IComparer<Circle>`, nell'esempio viene passato un oggetto `ShapeAreaComparer` che implementa `IComparer<Shape>`.</span><span class="sxs-lookup"><span data-stu-id="b1162-153">However, instead of passing an `IComparer<Circle>`, the example passes a `ShapeAreaComparer` object, which implements `IComparer<Shape>`.</span></span> <span data-ttu-id="b1162-154">È possibile passare un operatore di confronto di un tipo meno derivato (`Shape`) quando il codice chiama un operatore di confronto di un tipo più derivato (`Circle`), poiché il parametro di tipo dell'interfaccia generica <xref:System.Collections.Generic.IComparer%601> è controvariante.</span><span class="sxs-lookup"><span data-stu-id="b1162-154">The example can pass a comparer of a less derived type (`Shape`) when the code calls for a comparer of a more derived type (`Circle`), because the type parameter of the <xref:System.Collections.Generic.IComparer%601> generic interface is contravariant.</span></span>  
  
 <span data-ttu-id="b1162-155">Quando un nuovo oggetto `Circle` viene aggiunto all'oggetto `SortedSet<Circle>`, il metodo `IComparer<Shape>.Compare` (metodo`IComparer(Of Shape).Compare` in Visual Basic) dell'oggetto `ShapeAreaComparer` viene chiamato ogni volta che il nuovo elemento viene confrontato con un elemento esistente.</span><span class="sxs-lookup"><span data-stu-id="b1162-155">When a new `Circle` object is added to the `SortedSet<Circle>`, the `IComparer<Shape>.Compare` method (`IComparer(Of Shape).Compare` method in Visual Basic) of the `ShapeAreaComparer` object is called each time the new element is compared to an existing element.</span></span> <span data-ttu-id="b1162-156">Il tipo di parametro del metodo (`Shape`) è meno derivato rispetto al tipo passato (`Circle`), pertanto la chiamata è indipendente dai tipi.</span><span class="sxs-lookup"><span data-stu-id="b1162-156">The parameter type of the method (`Shape`) is less derived than the type that is being passed (`Circle`), so the call is type safe.</span></span> <span data-ttu-id="b1162-157">La controvarianza consente a `ShapeAreaComparer` di ordinare una raccolta di qualsiasi singolo tipo nonché una raccolta mista di tipi che derivano da `Shape`.</span><span class="sxs-lookup"><span data-stu-id="b1162-157">Contravariance enables `ShapeAreaComparer` to sort a collection of any single type, as well as a mixed collection of types, that derive from `Shape`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI2#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici2/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI2#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici2/vb/example.vb#1)]  

## <a name="generic-delegates-with-variant-type-parameters"></a><span data-ttu-id="b1162-158">Delegati generici con parametri di tipo variante</span><span class="sxs-lookup"><span data-stu-id="b1162-158">Generic Delegates with Variant Type Parameters</span></span>  
 <span data-ttu-id="b1162-159">In .NET Framework 4 i delegati generici `Func`, ad esempio <xref:System.Func%602>, presentano tipi restituiti covarianti e tipi di parametro controvarianti.</span><span class="sxs-lookup"><span data-stu-id="b1162-159">In the .NET Framework 4, the `Func` generic delegates, such as <xref:System.Func%602>, have covariant return types and contravariant parameter types.</span></span> <span data-ttu-id="b1162-160">I delegati generici `Action` , ad esempio <xref:System.Action%602>, presentano tipi di parametro controvarianti.</span><span class="sxs-lookup"><span data-stu-id="b1162-160">The `Action` generic delegates, such as <xref:System.Action%602>, have contravariant parameter types.</span></span> <span data-ttu-id="b1162-161">Ciò significa che i delegati possono essere assegnati a variabili che presentano tipi di parametro più derivati e (nel caso dei delegati generici `Func` ) tipi restituiti meno derivati.</span><span class="sxs-lookup"><span data-stu-id="b1162-161">This means that the delegates can be assigned to variables that have more derived parameter types and (in the case of the `Func` generic delegates) less derived return types.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b1162-162">L'ultimo parametro di tipo generico dei delegati generici `Func` specifica il tipo del valore restituito nella firma del delegato.</span><span class="sxs-lookup"><span data-stu-id="b1162-162">The last generic type parameter of the `Func` generic delegates specifies the type of the return value in the delegate signature.</span></span> <span data-ttu-id="b1162-163">È covariante (parola chiave`out` ), mentre gli altri parametri di tipo generico sono controvarianti (parola chiave`in` ).</span><span class="sxs-lookup"><span data-stu-id="b1162-163">It is covariant (`out` keyword), whereas the other generic type parameters are contravariant (`in` keyword).</span></span>  
  
 <span data-ttu-id="b1162-164">Questa condizione è illustrata nel codice che segue.</span><span class="sxs-lookup"><span data-stu-id="b1162-164">The following code illustrates this.</span></span> <span data-ttu-id="b1162-165">Nella prima parte di codice vengono definite una classe denominata `Base`, una classe denominata `Derived` che eredita da `Base`e un'altra classe con un metodo `static` (`Shared` in Visual Basic) denominata `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="b1162-165">The first piece of code defines a class named `Base`, a class named `Derived` that inherits `Base`, and another class with a `static` method (`Shared` in Visual Basic) named `MyMethod`.</span></span> <span data-ttu-id="b1162-166">Il metodo accetta un'istanza di `Base` e restituisce un'istanza di `Derived`.</span><span class="sxs-lookup"><span data-stu-id="b1162-166">The method takes an instance of `Base` and returns an instance of `Derived`.</span></span> <span data-ttu-id="b1162-167">Se l'argomento è un'istanza di `Derived` , lo `MyMethod` restituisce. se l'argomento è un'istanza di `Base` , `MyMethod` restituisce una nuova istanza di `Derived` . In `Main()` l'esempio crea un'istanza di `Func<Base, Derived>` ( `Func(Of Base, Derived)` in Visual Basic) che rappresenta `MyMethod` e la archivia nella variabile `f1` .</span><span class="sxs-lookup"><span data-stu-id="b1162-167">(If the argument is an instance of `Derived`, `MyMethod` returns it; if the argument is an instance of `Base`, `MyMethod` returns a new instance of `Derived`.) In `Main()`, the example creates an instance of `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic) that represents `MyMethod`, and stores it in the variable `f1`.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#2](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#2)]
 [!code-vb[CoContravarianceDelegates#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#2)]  
  
 <span data-ttu-id="b1162-168">Nella seconda parte di codice viene illustrato che è possibile assegnare il delegato a una variabile di tipo `Func<Base, Base>` (`Func(Of Base, Base)` in Visual Basic), poiché il tipo restituito è covariante.</span><span class="sxs-lookup"><span data-stu-id="b1162-168">The second piece of code shows that the delegate can be assigned to a variable of type `Func<Base, Base>` (`Func(Of Base, Base)` in Visual Basic), because the return type is covariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#3](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#3)]
 [!code-vb[CoContravarianceDelegates#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#3)]  
  
 <span data-ttu-id="b1162-169">Nella terza parte di codice viene illustrato che è possibile assegnare il delegato a una variabile di tipo `Func<Derived, Derived>` (`Func(Of Derived, Derived)` in Visual Basic), poiché il tipo di parametro è controvariante.</span><span class="sxs-lookup"><span data-stu-id="b1162-169">The third piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Derived>` (`Func(Of Derived, Derived)` in Visual Basic), because the parameter type is contravariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#4](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#4)]
 [!code-vb[CoContravarianceDelegates#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#4)]  
  
 <span data-ttu-id="b1162-170">Nella parte finale di codice viene illustrato che è possibile assegnare il delegato a una variabile di tipo `Func<Derived, Base>` (`Func(Of Derived, Base)` in Visual Basic), combinando gli effetti del tipo di parametro controvariante e del tipo restituito covariante.</span><span class="sxs-lookup"><span data-stu-id="b1162-170">The final piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Base>` (`Func(Of Derived, Base)` in Visual Basic), combining the effects of the contravariant parameter type and the covariant return type.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#5](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#5)]
 [!code-vb[CoContravarianceDelegates#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#5)]  
  
### <a name="variance-in-generic-and-non-generic-delegates"></a><span data-ttu-id="b1162-171">Varianza nei delegati generici e non generici</span><span class="sxs-lookup"><span data-stu-id="b1162-171">Variance in Generic and Non-Generic Delegates</span></span>  
 <span data-ttu-id="b1162-172">Nel codice precedente la firma di `MyMethod` corrisponde esattamente alla firma del delegato generico costruito: `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b1162-172">In the preceding code, the signature of `MyMethod` exactly matches the signature of the constructed generic delegate: `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic).</span></span> <span data-ttu-id="b1162-173">Nell'esempio viene illustrato che è possibile archiviare questo delegato generico in variabili o parametri del metodo che presentano tipi di parametro più derivati e tipi restituiti meno derivati, purché tutti i tipi delegati vengano costruiti a partire dal tipo delegato generico <xref:System.Func%602>.</span><span class="sxs-lookup"><span data-stu-id="b1162-173">The example shows that this generic delegate can be stored in variables or method parameters that have more derived parameter types and less derived return types, as long as all the delegate types are constructed from the generic delegate type <xref:System.Func%602>.</span></span>  
  
 <span data-ttu-id="b1162-174">Questo è un punto importante.</span><span class="sxs-lookup"><span data-stu-id="b1162-174">This is an important point.</span></span> <span data-ttu-id="b1162-175">Gli effetti della covarianza e della controvarianza nei parametri di tipo dei delegati generici sono simili agli effetti della covarianza e della controvarianza nel normale binding di delegati. Vedere [Varianza nei delegati (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) e [Varianza nei delegati (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md).</span><span class="sxs-lookup"><span data-stu-id="b1162-175">The effects of covariance and contravariance in the type parameters of generic delegates are similar to the effects of covariance and contravariance in ordinary delegate binding (see [Variance in Delegates (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) and [Variance in Delegates (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)).</span></span> <span data-ttu-id="b1162-176">Tuttavia, la varianza nell'associazione di delegati funziona con tutti i tipi delegati, non solo con quelli generici aventi parametri di tipo variante.</span><span class="sxs-lookup"><span data-stu-id="b1162-176">However, variance in delegate binding works with all delegate types, not just with generic delegate types that have variant type parameters.</span></span> <span data-ttu-id="b1162-177">Inoltre, la varianza nell'associazione di delegati consente l'associazione di un metodo a qualsiasi delegato con tipi di parametro più restrittivi e un tipo restituito meno restrittivo, mentre l'assegnazione di delegati generici funziona solo se entrambi i tipi di delegati sono costruiti a partire dalla stessa definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="b1162-177">Furthermore, variance in delegate binding enables a method to be bound to any delegate that has more restrictive parameter types and a less restrictive return type, whereas the assignment of generic delegates works only if both delegate types are constructed from the same generic type definition.</span></span>  
  
 <span data-ttu-id="b1162-178">Nell'esempio seguente sono mostrati gli effetti combinati della varianza nell'associazione di delegati e della varianza nei parametri di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="b1162-178">The following example shows the combined effects of variance in delegate binding and variance in generic type parameters.</span></span> <span data-ttu-id="b1162-179">Nell'esempio viene definita una gerarchia di tre tipi, da quello meno derivato (`Type1`) a quello più derivato (`Type3`).</span><span class="sxs-lookup"><span data-stu-id="b1162-179">The example defines a type hierarchy that includes three types, from least derived (`Type1`) to most derived (`Type3`).</span></span> <span data-ttu-id="b1162-180">La varianza nella normale associazione di delegati viene utilizzata per associare un metodo con un tipo di parametro `Type1` e un tipo restituito `Type3` a un delegato generico con un tipo di parametro `Type2` e un tipo restituito `Type2`.</span><span class="sxs-lookup"><span data-stu-id="b1162-180">Variance in ordinary delegate binding is used to bind a method with a parameter type of `Type1` and a return type of `Type3` to a generic delegate with a parameter type of `Type2` and a return type of `Type2`.</span></span> <span data-ttu-id="b1162-181">Il delegato generico risultante viene quindi assegnato a un'altra variabile il cui tipo delegato generico presenta un parametro di tipo `Type3` e un tipo restituito `Type1`, utilizzando la covarianza e la controvarianza di parametri di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="b1162-181">The resulting generic delegate is then assigned to another variable whose generic delegate type has a parameter of type `Type3` and a return type of `Type1`, using the covariance and contravariance of generic type parameters.</span></span> <span data-ttu-id="b1162-182">Per la seconda assegnazione è necessario che sia il tipo della variabile sia quello del delegato vengano costruiti a partire dalla stessa definizione di tipo generico, in questo caso <xref:System.Func%602>.</span><span class="sxs-lookup"><span data-stu-id="b1162-182">The second assignment requires both the variable type and the delegate type to be constructed from the same generic type definition, in this case, <xref:System.Func%602>.</span></span>  
  
 [!code-csharp[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/cs/example.cs#1)]
 [!code-vb[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/vb/example.vb#1)]  

## <a name="defining-variant-generic-interfaces-and-delegates"></a><span data-ttu-id="b1162-183">Definizione di interfacce e delegati generici varianti</span><span class="sxs-lookup"><span data-stu-id="b1162-183">Defining Variant Generic Interfaces and Delegates</span></span>
 <span data-ttu-id="b1162-184">A partire da .NET Framework 4, Visual Basic e C# presentano parole chiave che consentono di contrassegnare i parametri di tipo generico di interfacce e delegati come covarianti o controvarianti.</span><span class="sxs-lookup"><span data-stu-id="b1162-184">Starting with the .NET Framework 4, Visual Basic and C# have keywords that enable you to mark the generic type parameters of interfaces and delegates as covariant or contravariant.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b1162-185">A partire dalla versione 2.0 di .NET Framework, Common Language Runtime supporta le annotazioni di variante nei parametri di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="b1162-185">Starting with the .NET Framework version 2.0, the common language runtime supports variance annotations on generic type parameters.</span></span> <span data-ttu-id="b1162-186">Nelle versioni precedenti a .NET Framework 4, l'unico modo per definire una classe generica con queste annotazioni consiste nell'usare Microsoft Intermediate Language (MSIL), compilando la classe con [Ilasm.exe (IL Assembler)](../../framework/tools/ilasm-exe-il-assembler.md) oppure creandola in un assembly dinamico.</span><span class="sxs-lookup"><span data-stu-id="b1162-186">Prior to the .NET Framework 4, the only way to define a generic class that has these annotations is to use Microsoft intermediate language (MSIL), either by compiling the class with [Ilasm.exe (IL Assembler)](../../framework/tools/ilasm-exe-il-assembler.md) or by emitting it in a dynamic assembly.</span></span>  
  
 <span data-ttu-id="b1162-187">Un parametro di tipo covariante è contrassegnato con la parola chiave `out` (parola chiave`Out` in Visual Basic, `+` per l' [assembler MSIL](../../framework/tools/ilasm-exe-il-assembler.md)).</span><span class="sxs-lookup"><span data-stu-id="b1162-187">A covariant type parameter is marked with the `out` keyword (`Out` keyword in Visual Basic, `+` for the [MSIL Assembler](../../framework/tools/ilasm-exe-il-assembler.md)).</span></span> <span data-ttu-id="b1162-188">È possibile usare un parametro di tipo covariante come valore restituito di un metodo che appartiene a un'interfaccia o come tipo restituito di un delegato.</span><span class="sxs-lookup"><span data-stu-id="b1162-188">You can use a covariant type parameter as the return value of a method that belongs to an interface, or as the return type of a delegate.</span></span> <span data-ttu-id="b1162-189">Non è possibile usare un parametro di tipo covariante come vincolo di tipo generico per i metodi di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="b1162-189">You cannot use a covariant type parameter as a generic type constraint for interface methods.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b1162-190">Se un metodo di un'interfaccia presenta un parametro che è un tipo delegato generico, per specificare un parametro di tipo controvariante del tipo delegato è possibile usare un parametro di tipo covariante del tipo di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="b1162-190">If a method of an interface has a parameter that is a generic delegate type, a covariant type parameter of the interface type can be used to specify a contravariant type parameter of the delegate type.</span></span>  
  
 <span data-ttu-id="b1162-191">Un parametro di tipo controvariante è contrassegnato con la parola chiave `in` (parola chiave`In` in Visual Basic, `-` per l' [assembler MSIL](../../framework/tools/ilasm-exe-il-assembler.md)).</span><span class="sxs-lookup"><span data-stu-id="b1162-191">A contravariant type parameter is marked with the `in` keyword (`In` keyword in Visual Basic, `-` for the [MSIL Assembler](../../framework/tools/ilasm-exe-il-assembler.md)).</span></span> <span data-ttu-id="b1162-192">È possibile usare un parametro di tipo controvariante come tipo di un parametro di un metodo che appartiene a un'interfaccia o come tipo di un parametro di un delegato.</span><span class="sxs-lookup"><span data-stu-id="b1162-192">You can use a contravariant type parameter as the type of a parameter of a method that belongs to an interface, or as the type of a parameter of a delegate.</span></span> <span data-ttu-id="b1162-193">È possibile usare un parametro di tipo controvariante come vincolo di tipo generico per un metodo di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="b1162-193">You can use a contravariant type parameter as a generic type constraint for an interface method.</span></span>  
  
 <span data-ttu-id="b1162-194">Solo i tipi di interfaccia e i tipi delegati possono presentare parametri di tipo variante.</span><span class="sxs-lookup"><span data-stu-id="b1162-194">Only interface types and delegate types can have variant type parameters.</span></span> <span data-ttu-id="b1162-195">Un tipo di interfaccia o delegato può presentare parametri di tipo sia covariante sia controvariante.</span><span class="sxs-lookup"><span data-stu-id="b1162-195">An interface or delegate type can have both covariant and contravariant type parameters.</span></span>  
  
 <span data-ttu-id="b1162-196">Visual Basic e C# non consentono di violare le regole per l'utilizzo di parametri di tipo covariante e controvariante o aggiungere annotazioni di covarianza e controvarianza ai parametri relativi a tipi diversi da interfacce e delegati.</span><span class="sxs-lookup"><span data-stu-id="b1162-196">Visual Basic and C# do not allow you to violate the rules for using covariant and contravariant type parameters, or to add covariance and contravariance annotations to the type parameters of types other than interfaces and delegates.</span></span> <span data-ttu-id="b1162-197">L' [assembler MSIL](../../framework/tools/ilasm-exe-il-assembler.md) non esegue tali controlli. Tuttavia, se si tenta di caricare un tipo che viola le regole, viene generato un oggetto <xref:System.TypeLoadException> .</span><span class="sxs-lookup"><span data-stu-id="b1162-197">The [MSIL Assembler](../../framework/tools/ilasm-exe-il-assembler.md) does not perform such checks, but a <xref:System.TypeLoadException> is thrown if you try to load a type that violates the rules.</span></span>  
  
 <span data-ttu-id="b1162-198">Per informazioni e codice di esempio, vedere [Varianza nelle interfacce generiche (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md) e [Varianza nelle interfacce generiche (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).</span><span class="sxs-lookup"><span data-stu-id="b1162-198">For information and example code, see [Variance in Generic Interfaces (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md) and [Variance in Generic Interfaces (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).</span></span>  

## <a name="list-of-variant-generic-interface-and-delegate-types"></a><span data-ttu-id="b1162-199">Elenco di tipi di interfacce e delegati generici varianti</span><span class="sxs-lookup"><span data-stu-id="b1162-199">List of Variant Generic Interface and Delegate Types</span></span>
 <span data-ttu-id="b1162-200">In .NET Framework 4 il tipo di interfaccia e il tipo delegato seguenti presentano parametri di tipo covariante e/o controvariante.</span><span class="sxs-lookup"><span data-stu-id="b1162-200">In the .NET Framework 4, the following interface and delegate types have covariant and/or contravariant type parameters.</span></span>  
  
|<span data-ttu-id="b1162-201">Type</span><span class="sxs-lookup"><span data-stu-id="b1162-201">Type</span></span>|<span data-ttu-id="b1162-202">Parametri di tipo covariante</span><span class="sxs-lookup"><span data-stu-id="b1162-202">Covariant type parameters</span></span>|<span data-ttu-id="b1162-203">Parametri di tipo controvariante</span><span class="sxs-lookup"><span data-stu-id="b1162-203">Contravariant type parameters</span></span>|  
|----------|-------------------------------|-----------------------------------|  
|<span data-ttu-id="b1162-204">Da <xref:System.Action%601> a <xref:System.Action%6016></span><span class="sxs-lookup"><span data-stu-id="b1162-204"><xref:System.Action%601> to <xref:System.Action%6016></span></span>||<span data-ttu-id="b1162-205">Sì</span><span class="sxs-lookup"><span data-stu-id="b1162-205">Yes</span></span>|  
|<xref:System.Comparison%601>||<span data-ttu-id="b1162-206">Sì</span><span class="sxs-lookup"><span data-stu-id="b1162-206">Yes</span></span>|  
|<xref:System.Converter%602>|<span data-ttu-id="b1162-207">Sì</span><span class="sxs-lookup"><span data-stu-id="b1162-207">Yes</span></span>|<span data-ttu-id="b1162-208">Sì</span><span class="sxs-lookup"><span data-stu-id="b1162-208">Yes</span></span>|  
|<xref:System.Func%601>|<span data-ttu-id="b1162-209">Sì</span><span class="sxs-lookup"><span data-stu-id="b1162-209">Yes</span></span>||  
|<span data-ttu-id="b1162-210">Da <xref:System.Func%602> a <xref:System.Func%6017></span><span class="sxs-lookup"><span data-stu-id="b1162-210"><xref:System.Func%602> to <xref:System.Func%6017></span></span>|<span data-ttu-id="b1162-211">Sì</span><span class="sxs-lookup"><span data-stu-id="b1162-211">Yes</span></span>|<span data-ttu-id="b1162-212">Sì</span><span class="sxs-lookup"><span data-stu-id="b1162-212">Yes</span></span>|  
|<xref:System.IComparable%601>||<span data-ttu-id="b1162-213">Sì</span><span class="sxs-lookup"><span data-stu-id="b1162-213">Yes</span></span>|  
|<xref:System.Predicate%601>||<span data-ttu-id="b1162-214">Sì</span><span class="sxs-lookup"><span data-stu-id="b1162-214">Yes</span></span>|  
|<xref:System.Collections.Generic.IComparer%601>||<span data-ttu-id="b1162-215">Sì</span><span class="sxs-lookup"><span data-stu-id="b1162-215">Yes</span></span>|  
|<xref:System.Collections.Generic.IEnumerable%601>|<span data-ttu-id="b1162-216">Sì</span><span class="sxs-lookup"><span data-stu-id="b1162-216">Yes</span></span>||  
|<xref:System.Collections.Generic.IEnumerator%601>|<span data-ttu-id="b1162-217">Sì</span><span class="sxs-lookup"><span data-stu-id="b1162-217">Yes</span></span>||  
|<xref:System.Collections.Generic.IEqualityComparer%601>||<span data-ttu-id="b1162-218">Sì</span><span class="sxs-lookup"><span data-stu-id="b1162-218">Yes</span></span>|  
|<xref:System.Linq.IGrouping%602>|<span data-ttu-id="b1162-219">Sì</span><span class="sxs-lookup"><span data-stu-id="b1162-219">Yes</span></span>||  
|<xref:System.Linq.IOrderedEnumerable%601>|<span data-ttu-id="b1162-220">Sì</span><span class="sxs-lookup"><span data-stu-id="b1162-220">Yes</span></span>||  
|<xref:System.Linq.IOrderedQueryable%601>|<span data-ttu-id="b1162-221">Sì</span><span class="sxs-lookup"><span data-stu-id="b1162-221">Yes</span></span>||  
|<xref:System.Linq.IQueryable%601>|<span data-ttu-id="b1162-222">Sì</span><span class="sxs-lookup"><span data-stu-id="b1162-222">Yes</span></span>||  
  
## <a name="see-also"></a><span data-ttu-id="b1162-223">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="b1162-223">See also</span></span>

- [<span data-ttu-id="b1162-224">Covarianza e controvarianza (C#)</span><span class="sxs-lookup"><span data-stu-id="b1162-224">Covariance and Contravariance (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="b1162-225">Covarianza e controvarianza (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="b1162-225">Covariance and Contravariance (Visual Basic)</span></span>](../../visual-basic/programming-guide/concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="b1162-226">Varianza nei delegati (C#)</span><span class="sxs-lookup"><span data-stu-id="b1162-226">Variance in Delegates (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)
- [<span data-ttu-id="b1162-227">Varianza nei delegati (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="b1162-227">Variance in Delegates (Visual Basic)</span></span>](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)
