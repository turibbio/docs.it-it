---
title: Quando utilizzare una raccolta thread-safe
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, when to upgrade
ms.assetid: a9babe97-e457-4ff3-b528-a1bc940d5320
ms.openlocfilehash: e2c5d612abb824c93c611514a836c811e6e65efe
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/02/2020
ms.locfileid: "84288875"
---
# <a name="when-to-use-a-thread-safe-collection"></a><span data-ttu-id="e4eb8-102">Quando utilizzare una raccolta thread-safe</span><span class="sxs-lookup"><span data-stu-id="e4eb8-102">When to Use a Thread-Safe Collection</span></span>
<span data-ttu-id="e4eb8-103">.NET Framework 4 introduce cinque nuovi tipi di raccolta creati specificamente per il supporto di operazioni di aggiunta e rimozione multithread.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-103">The .NET Framework 4 introduces five new collection types that are specially designed to support multi-threaded add and remove operations.</span></span> <span data-ttu-id="e4eb8-104">Per ottenere la thread safety, questi nuovi tipi usano vari nuovi meccanismi di sincronizzazione, sia di blocco che senza blocco.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-104">To achieve thread-safety, these new types use various kinds of efficient locking and lock-free synchronization mechanisms.</span></span> <span data-ttu-id="e4eb8-105">La sincronizzazione aggiunge sovraccarico a un'operazione.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-105">Synchronization adds overhead to an operation.</span></span> <span data-ttu-id="e4eb8-106">La quantità di sovraccarico dipende dal tipo di sincronizzazione usato, dal tipo di operazioni eseguite e da altri fattori, quali il numero di thread che provano ad accedere contemporaneamente alla raccolta.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-106">The amount of overhead depends on the kind of synchronization that is used, the kind of operations that are performed, and other factors such as the number of threads that are trying to concurrently access the collection.</span></span>  
  
 <span data-ttu-id="e4eb8-107">In determinati scenari il sovraccarico della sincronizzazione è trascurabile e consente al tipo con multithread un'elaborazione molto più rapida e una miglior scalabilità rispetto al tipo equivalente non thread-safe se protetto da un blocco esterno.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-107">In some scenarios, synchronization overhead is negligible and enables the multi-threaded type to perform significantly faster and scale far better than its non-thread-safe equivalent when protected by an external lock.</span></span> <span data-ttu-id="e4eb8-108">In altri scenari il sovraccarico può far sì che la scalabilità e le prestazioni del tipo thread-safe risultino uguali o più lente rispetto alla versione del tipo non thread-safe con blocco esterno.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-108">In other scenarios, the overhead can cause the thread-safe type to perform and scale about the same or even more slowly than the externally-locked, non-thread-safe version of the type.</span></span>  
  
 <span data-ttu-id="e4eb8-109">Le sezioni seguenti offrono indicazioni generali su quando usare una raccolta thread-safe o una raccolta non thread-safe equivalente e provvista di un blocco specificato dall'utente per le operazioni di lettura e scrittura.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-109">The following sections provide general guidance about when to use a thread-safe collection versus its non-thread-safe equivalent that has a user-provided lock around its read and write operations.</span></span> <span data-ttu-id="e4eb8-110">Dato che le prestazioni possono variare in base a molti fattori, le indicazioni non sono specifiche e non sono necessariamente valide in qualsiasi circostanza.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-110">Because performance may vary depending on many factors, the guidance is not specific and is not necessarily valid in all circumstances.</span></span> <span data-ttu-id="e4eb8-111">Se le prestazioni sono molto importanti, il modo migliore per determinare il tipo di raccolta da usare è la misurazione delle prestazioni in base alle configurazioni e ai carichi di lavoro di computer campione.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-111">If performance is very important, then the best way to determine which collection type to use is to measure performance based on representative computer configurations and loads.</span></span> <span data-ttu-id="e4eb8-112">In questo documento vengono usati i seguenti termini:</span><span class="sxs-lookup"><span data-stu-id="e4eb8-112">This document uses the following terms:</span></span>  
  
 <span data-ttu-id="e4eb8-113">*Scenario producer-consumer puro*</span><span class="sxs-lookup"><span data-stu-id="e4eb8-113">*Pure producer-consumer scenario*</span></span>  
 <span data-ttu-id="e4eb8-114">Un qualsiasi thread esegue l'aggiunta o la rimozione di elementi, ma non entrambe le operazioni.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-114">Any given thread is either adding or removing elements, but not both.</span></span>  
  
 <span data-ttu-id="e4eb8-115">*Scenario producer-consumer misto*</span><span class="sxs-lookup"><span data-stu-id="e4eb8-115">*Mixed producer-consumer scenario*</span></span>  
 <span data-ttu-id="e4eb8-116">Un qualsiasi thread esegue sia l'aggiunta che la rimozione di elementi.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-116">Any given thread is both adding and removing elements.</span></span>  
  
 <span data-ttu-id="e4eb8-117">*Aumento della velocità*</span><span class="sxs-lookup"><span data-stu-id="e4eb8-117">*Speedup*</span></span>  
 <span data-ttu-id="e4eb8-118">Prestazioni algoritmiche più veloci rispetto a un altro tipo nello stesso scenario.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-118">Faster algorithmic performance relative to another type in the same scenario.</span></span>  
  
 <span data-ttu-id="e4eb8-119">*Scalabilità*</span><span class="sxs-lookup"><span data-stu-id="e4eb8-119">*Scalability*</span></span>  
 <span data-ttu-id="e4eb8-120">Miglioramento delle prestazioni proporzionale al numero di core nel computer.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-120">The increase in performance that is proportional to the number of cores on the computer.</span></span> <span data-ttu-id="e4eb8-121">Un algoritmo con scalabilità viene eseguito più velocemente su otto core che su due core.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-121">An algorithm that scales performs faster on eight cores than it does on two cores.</span></span>  
  
## <a name="concurrentqueuet-vs-queuet"></a><span data-ttu-id="e4eb8-122">Confronta tra ConcurrentQueue(T) e Queue(T)</span><span class="sxs-lookup"><span data-stu-id="e4eb8-122">ConcurrentQueue(T) vs. Queue(T)</span></span>  
 <span data-ttu-id="e4eb8-123">Negli scenari producer-consumer puri, in cui il tempo di elaborazione per ogni elemento è molto ridotto (poche istruzioni), <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> offre vantaggi di prestazioni modesti rispetto a <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> con blocco esterno.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-123">In pure producer-consumer scenarios, where the processing time for each element is very small (a few instructions), then <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> can offer modest performance benefits over a <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> that has an external lock.</span></span> <span data-ttu-id="e4eb8-124">In questo scenario, <xref:System.Collections.Concurrent.ConcurrentQueue%601> offre le prestazioni migliori quando un thread dedicato aggiunge elementi alla coda e un altro thread dedicato rimuove elementi dalla coda.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-124">In this scenario, <xref:System.Collections.Concurrent.ConcurrentQueue%601> performs best when one dedicated thread is queuing and one dedicated thread is de-queuing.</span></span> <span data-ttu-id="e4eb8-125">Se non si applica questa regola, le prestazioni di <xref:System.Collections.Generic.Queue%601> potrebbe persino risultare leggermente più veloci di quelle di <xref:System.Collections.Concurrent.ConcurrentQueue%601> nei computer che dispongono di più core.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-125">If you do not enforce this rule, then <xref:System.Collections.Generic.Queue%601> might even perform slightly faster than <xref:System.Collections.Concurrent.ConcurrentQueue%601> on computers that have multiple cores.</span></span>  
  
 <span data-ttu-id="e4eb8-126">Quando il tempo di elaborazione è pari o superiore a circa 500 FLOPS (floating point operations, operazioni a virgola mobile), la regola dei due thread non è più valida per <xref:System.Collections.Concurrent.ConcurrentQueue%601>, che in questo caso registra una scalabilità ottimale.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-126">When processing time is around 500 FLOPS (floating point operations) or more, then the two-thread rule does not apply to <xref:System.Collections.Concurrent.ConcurrentQueue%601>, which then has very good scalability.</span></span> <span data-ttu-id="e4eb8-127"><xref:System.Collections.Generic.Queue%601> non presenta una scalabilità ottimale in questo scenario.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-127"><xref:System.Collections.Generic.Queue%601> does not scale well in this scenario.</span></span>  
  
 <span data-ttu-id="e4eb8-128">Negli scenari producer-consumer misti, quando il tempo di elaborazione è molto breve, un <xref:System.Collections.Generic.Queue%601> provvisto di blocco esterno offre una scalabilità migliore rispetto a <xref:System.Collections.Concurrent.ConcurrentQueue%601>.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-128">In mixed producer-consumer scenarios, when the processing time is very small, a <xref:System.Collections.Generic.Queue%601> that has an external lock scales better than <xref:System.Collections.Concurrent.ConcurrentQueue%601> does.</span></span> <span data-ttu-id="e4eb8-129">Tuttavia, quando il tempo di elaborazione è pari o superiore a 500 FLOPS, <xref:System.Collections.Concurrent.ConcurrentQueue%601> offre una scalabilità migliore.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-129">However, when processing time is around 500 FLOPS or more, then the <xref:System.Collections.Concurrent.ConcurrentQueue%601> scales better.</span></span>  
  
## <a name="concurrentstack-vs-stack"></a><span data-ttu-id="e4eb8-130">Confronto tra ConcurrentStack e Stack</span><span class="sxs-lookup"><span data-stu-id="e4eb8-130">ConcurrentStack vs. Stack</span></span>  
 <span data-ttu-id="e4eb8-131">Negli scenari producer-consumer puri, quando il tempo di elaborazione è molto ridotto, è probabile che <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> e <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> con un blocco esterno abbiano prestazioni simili con un thread push dedicato e un thread pop dedicato.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-131">In pure producer-consumer scenarios, when processing time is very small, then <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> and <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> that has an external lock will probably perform about the same with one dedicated pushing thread and one dedicated popping thread.</span></span> <span data-ttu-id="e4eb8-132">Se tuttavia il numero di thread aumenta, le prestazioni di entrambi i tipi rallentano per l'incremento dei conflitti e <xref:System.Collections.Generic.Stack%601> potrebbe registrare prestazioni migliori di <xref:System.Collections.Concurrent.ConcurrentStack%601>.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-132">However, as the number of threads increases, both types slow down because of increased contention, and <xref:System.Collections.Generic.Stack%601> might perform better than <xref:System.Collections.Concurrent.ConcurrentStack%601>.</span></span> <span data-ttu-id="e4eb8-133">Quando il tempo di elaborazione è pari o superiore a 500 FLOPS, la velocità di scalabilità dei due tipi è circa la stessa.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-133">When processing time is around 500 FLOPS or more, then both types scale at about the same rate.</span></span>  
  
 <span data-ttu-id="e4eb8-134">Negli scenari producer-consumer misti <xref:System.Collections.Concurrent.ConcurrentStack%601> è più veloce per i carichi di lavoro sia piccoli che grandi.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-134">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentStack%601> is faster for both small and large workloads.</span></span>  
  
 <span data-ttu-id="e4eb8-135">L'uso di <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> e <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> può accelerare notevolmente i tempi di accesso.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-135">The use of the <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> and <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> may greatly speed up access times.</span></span>  
  
## <a name="concurrentdictionary-vs-dictionary"></a><span data-ttu-id="e4eb8-136">Confronto tra ConcurrentDictionary e Dictionary</span><span class="sxs-lookup"><span data-stu-id="e4eb8-136">ConcurrentDictionary vs. Dictionary</span></span>  
 <span data-ttu-id="e4eb8-137">In generale, è consigliabile usare <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> negli scenari in cui si aggiungono e aggiornano chiavi o valori da più thread simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-137">In general, use a <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> in any scenario where you are adding and updating keys or values concurrently from multiple threads.</span></span> <span data-ttu-id="e4eb8-138">Negli scenari che presentano aggiornamenti frequenti e letture poco frequenti, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> offre in genere moderati vantaggi.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-138">In scenarios that involve frequent updates and relatively few reads, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally offers modest benefits.</span></span> <span data-ttu-id="e4eb8-139">Negli scenari che presentano molte letture e molti aggiornamenti, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> è in genere molto più rapida su computer con un numero qualsiasi di core.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-139">In scenarios that involve many reads and many updates, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally is significantly faster on computers that have any number of cores.</span></span>  
  
 <span data-ttu-id="e4eb8-140">Negli scenari con aggiornamenti frequenti è possibile aumentare il livello di concorrenza di <xref:System.Collections.Concurrent.ConcurrentDictionary%602> e quindi effettuare una misurazione per quantificare eventuali incrementi delle prestazioni nei computer con più core.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-140">In scenarios that involve frequent updates, you can increase the degree of concurrency in the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> and then measure to see whether performance increases on computers that have more cores.</span></span> <span data-ttu-id="e4eb8-141">Se si modifica il livello di concorrenza, evitare per quanto possibile le operazioni globali.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-141">If you change the concurrency level, avoid global operations as much as possible.</span></span>  
  
 <span data-ttu-id="e4eb8-142">Se si esegue solo la lettura di chiavi o valori, <xref:System.Collections.Generic.Dictionary%602> è più veloce, perché non è richiesta alcuna sincronizzazione se il dizionario non viene modificato da nessun thread.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-142">If you are only reading key or values, the <xref:System.Collections.Generic.Dictionary%602> is faster because no synchronization is required if the dictionary is not being modified by any threads.</span></span>  
  
## <a name="concurrentbag"></a><span data-ttu-id="e4eb8-143">ConcurrentBag</span><span class="sxs-lookup"><span data-stu-id="e4eb8-143">ConcurrentBag</span></span>  
 <span data-ttu-id="e4eb8-144">Negli scenari producer-consumer puri, è probabile che l'esecuzione di <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> risulti più lenta di quella di altri tipi di raccolta simultanea.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-144">In pure producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> will probably perform more slowly than the other concurrent collection types.</span></span>  
  
 <span data-ttu-id="e4eb8-145">Negli scenari producer-consumer misti, <xref:System.Collections.Concurrent.ConcurrentBag%601> è in genere molto più veloce e più scalabile di qualsiasi altro tipo di raccolta simultanea per carichi di lavoro sia piccoli che grandi.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-145">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601> is generally much faster and more scalable than any other concurrent collection type for both large and small workloads.</span></span>  
  
## <a name="blockingcollection"></a><span data-ttu-id="e4eb8-146">BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="e4eb8-146">BlockingCollection</span></span>  
 <span data-ttu-id="e4eb8-147">Quando è necessaria la semantica di delimitazione e blocco, è probabile che l'esecuzione di <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> risulti più rapida di quella di qualsiasi implementazione personalizzata.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-147">When bounding and blocking semantics are required, <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> will probably perform faster than any custom implementation.</span></span> <span data-ttu-id="e4eb8-148">Supporta anche funzionalità complete di annullamento, enumerazione e gestione eccezioni.</span><span class="sxs-lookup"><span data-stu-id="e4eb8-148">It also supports rich cancellation, enumeration, and exception handling.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e4eb8-149">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="e4eb8-149">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="e4eb8-150">Raccolte thread-safe</span><span class="sxs-lookup"><span data-stu-id="e4eb8-150">Thread-Safe Collections</span></span>](index.md)
- [<span data-ttu-id="e4eb8-151">Programmazione parallela</span><span class="sxs-lookup"><span data-stu-id="e4eb8-151">Parallel Programming</span></span>](../../parallel-programming/index.md)
