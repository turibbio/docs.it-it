---
title: Raccolte thread-safe
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, overview
ms.assetid: 2e7ca21f-786c-4367-96be-0cf3f3dcc6bd
ms.openlocfilehash: 7af59cf0fdbe8d5c7d7d586b4b86992ae1dc7601
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/02/2020
ms.locfileid: "84290370"
---
# <a name="thread-safe-collections"></a><span data-ttu-id="ac209-102">Raccolte thread-safe</span><span class="sxs-lookup"><span data-stu-id="ac209-102">Thread-Safe Collections</span></span>
<span data-ttu-id="ac209-103">.NET Framework 4 introduce lo spazio dei nomi <xref:System.Collections.Concurrent?displayProperty=nameWithType> che include diverse classi di raccolta thread-safe e scalabili.</span><span class="sxs-lookup"><span data-stu-id="ac209-103">The .NET Framework 4 introduces the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, which includes several collection classes that are both thread-safe and scalable.</span></span> <span data-ttu-id="ac209-104">Più thread possono aggiungere o rimuovere elementi da queste raccolte in modo sicuro ed efficiente, senza richiedere una sincronizzazione aggiuntiva nel codice utente.</span><span class="sxs-lookup"><span data-stu-id="ac209-104">Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.</span></span> <span data-ttu-id="ac209-105">Quando si scrive nuovo codice, usare le classi di raccolta simultanee ogni volta che più thread scriveranno nella raccolta contemporaneamente.</span><span class="sxs-lookup"><span data-stu-id="ac209-105">When you write new code, use the concurrent collection classes whenever multiple threads will write to the collection concurrently.</span></span> <span data-ttu-id="ac209-106">Se si prevede di leggere solo da una raccolta condivisa, è possibile usare le classi dello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ac209-106">If you are only reading from a shared collection, then you can use the classes in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="ac209-107">È consigliabile evitare di usare le classi di raccolta 1.0 a meno che non sia necessario definire come destinazione il runtime di .NET Framework versione 1.1 o precedente.</span><span class="sxs-lookup"><span data-stu-id="ac209-107">We recommend that you do not use 1.0 collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.</span></span>  
  
## <a name="thread-synchronization-in-the-net-framework-10-and-20-collections"></a><span data-ttu-id="ac209-108">Sincronizzazione dei thread nelle raccolte di .NET Framework 1.0 e 2.0</span><span class="sxs-lookup"><span data-stu-id="ac209-108">Thread Synchronization in the .NET Framework 1.0 and 2.0 Collections</span></span>  
 <span data-ttu-id="ac209-109">Le raccolte introdotte in .NET Framework 1.0 sono reperibili nello spazio dei nomi <xref:System.Collections?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ac209-109">The collections introduced in the .NET Framework 1.0 are found in the <xref:System.Collections?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="ac209-110">Queste raccolte, incluse le raccolte <xref:System.Collections.ArrayList> e <xref:System.Collections.Hashtable> usate normalmente, supportano la thread safety con la proprietà `Synchronized`, che restituisce un wrapper thread-safe per la raccolta.</span><span class="sxs-lookup"><span data-stu-id="ac209-110">These collections, which include the commonly used <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>, provide some thread-safety through the `Synchronized` property, which returns a thread-safe wrapper around the collection.</span></span> <span data-ttu-id="ac209-111">Il wrapper funziona bloccando l'intera raccolta in ogni operazione di aggiunta o rimozione.</span><span class="sxs-lookup"><span data-stu-id="ac209-111">The wrapper works by locking the entire collection on every add or remove operation.</span></span> <span data-ttu-id="ac209-112">Pertanto, ogni thread che tenta di accedere alla raccolta deve attendere il proprio turno per acquisire l'unico blocco.</span><span class="sxs-lookup"><span data-stu-id="ac209-112">Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock.</span></span> <span data-ttu-id="ac209-113">Questa caratteristica non è scalabile e può causare un peggioramento delle prestazioni per le raccolte di grandi dimensioni.</span><span class="sxs-lookup"><span data-stu-id="ac209-113">This is not scalable and can cause significant performance degradation for large collections.</span></span> <span data-ttu-id="ac209-114">Inoltre, la progettazione non è completamente protetta da race condition.</span><span class="sxs-lookup"><span data-stu-id="ac209-114">Also, the design is not completely protected from race conditions.</span></span> <span data-ttu-id="ac209-115">Per altre informazioni, vedere la pagina relativa alla [sincronizzazione nelle raccolte generiche](https://docs.microsoft.com/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer).</span><span class="sxs-lookup"><span data-stu-id="ac209-115">For more information, see [Synchronization in Generic Collections](https://docs.microsoft.com/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer).</span></span>  
  
 <span data-ttu-id="ac209-116">Le classi di raccolta introdotte in .NET Framework 2.0 sono reperibili nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ac209-116">The collection classes introduced in the .NET Framework 2.0 are found in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="ac209-117">Sono incluse <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602> e così via.</span><span class="sxs-lookup"><span data-stu-id="ac209-117">These include <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602>, and so on.</span></span> <span data-ttu-id="ac209-118">che forniscono maggiore indipendenza dai tipi e migliori prestazioni rispetto alle classi di .NET Framework 1.0.</span><span class="sxs-lookup"><span data-stu-id="ac209-118">These classes provide improved type safety and performance compared to the .NET Framework 1.0 classes.</span></span> <span data-ttu-id="ac209-119">Tuttavia, le classi di raccolta di .NET Framework 2.0 non forniscono la sincronizzazione dei thread. Quando gli elementi vengono aggiunti o rimossi contemporaneamente su più thread, la sincronizzazione deve essere gestita dal codice utente.</span><span class="sxs-lookup"><span data-stu-id="ac209-119">However, the .NET Framework 2.0 collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.</span></span>  
  
 <span data-ttu-id="ac209-120">È quindi consigliabile usare le classi di raccolta simultanea disponibili in .NET Framework 4 perché offrono non solo l'indipendenza dai tipi delle classi di raccolta .NET Framework 2.0, ma anche una thread safety più efficiente e completa rispetto alle raccolte di .NET Framework 1.0.</span><span class="sxs-lookup"><span data-stu-id="ac209-120">We recommend the concurrent collections classes in the .NET Framework 4 because they provide not only the type safety of the .NET Framework 2.0 collection classes, but also more efficient and more complete thread safety than the .NET Framework 1.0 collections provide.</span></span>  
  
## <a name="fine-grained-locking-and-lock-free-mechanisms"></a><span data-ttu-id="ac209-121">Blocco con granularità fine e meccanismi senza blocco</span><span class="sxs-lookup"><span data-stu-id="ac209-121">Fine-Grained Locking and Lock-Free Mechanisms</span></span>  
 <span data-ttu-id="ac209-122">Alcuni tipi di raccolta simultanea usano meccanismi di sincronizzazione leggeri, ad esempio <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim> e <xref:System.Threading.CountdownEvent>, che sono una novità di .NET Framework 4.</span><span class="sxs-lookup"><span data-stu-id="ac209-122">Some of the concurrent collection types use lightweight synchronization mechanisms such as <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim>, and <xref:System.Threading.CountdownEvent>, which are new in the .NET Framework 4.</span></span> <span data-ttu-id="ac209-123">Questi tipi di sincronizzazione usano in genere la rotazione con *stato occupato* per breve periodi di tempo prima di impostare il thread in uno stato di attesa effettivo.</span><span class="sxs-lookup"><span data-stu-id="ac209-123">These synchronization types typically use *busy spinning* for brief periods before they put the thread into a true Wait state.</span></span> <span data-ttu-id="ac209-124">Quando si prevedono tempi di attesa molto brevi, la rotazione è molto meno dispendiosa a livello di elaborazione rispetto all'attesa, che implica una transizione del kernel complessa.</span><span class="sxs-lookup"><span data-stu-id="ac209-124">When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.</span></span> <span data-ttu-id="ac209-125">Per le classi di raccolta che usano la rotazione, questo livello di efficienza significa che più thread possono aggiungere e rimuovere elementi con una frequenza molto elevata.</span><span class="sxs-lookup"><span data-stu-id="ac209-125">For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.</span></span> <span data-ttu-id="ac209-126">Per altre informazioni sul confronto tra spin e blocco, vedere [SpinLock](../../threading/spinlock.md) e [SpinWait](../../threading/spinwait.md).</span><span class="sxs-lookup"><span data-stu-id="ac209-126">For more information about spinning vs. blocking, see [SpinLock](../../threading/spinlock.md) and [SpinWait](../../threading/spinwait.md).</span></span>  
  
 <span data-ttu-id="ac209-127">Le classi <xref:System.Collections.Concurrent.ConcurrentQueue%601> e <xref:System.Collections.Concurrent.ConcurrentStack%601> non usano alcun blocco.</span><span class="sxs-lookup"><span data-stu-id="ac209-127">The <xref:System.Collections.Concurrent.ConcurrentQueue%601> and <xref:System.Collections.Concurrent.ConcurrentStack%601> classes do not use locks at all.</span></span> <span data-ttu-id="ac209-128">Al contrario, si basano sulle operazioni <xref:System.Threading.Interlocked> per ottenere la thread safety.</span><span class="sxs-lookup"><span data-stu-id="ac209-128">Instead, they rely on <xref:System.Threading.Interlocked> operations to achieve thread-safety.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ac209-129">Poiché supportano <xref:System.Collections.ICollection>, le classi di raccolta simultanee offrono implementazioni per le proprietà <xref:System.Collections.ICollection.IsSynchronized%2A> e <xref:System.Collections.ICollection.SyncRoot%2A>, anche se queste sono irrilevanti.</span><span class="sxs-lookup"><span data-stu-id="ac209-129">Because the concurrent collections classes support <xref:System.Collections.ICollection>, they provide implementations for the <xref:System.Collections.ICollection.IsSynchronized%2A> and <xref:System.Collections.ICollection.SyncRoot%2A> properties, even though these properties are irrelevant.</span></span> <span data-ttu-id="ac209-130">`IsSynchronized` restituisce sempre `false` e `SyncRoot` è sempre `null` (`Nothing` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="ac209-130">`IsSynchronized` always returns `false` and `SyncRoot` is always `null` (`Nothing` in Visual Basic).</span></span>  
  
 <span data-ttu-id="ac209-131">Nella tabella seguente sono elencati i tipi di raccolta dello spazio dei nomi <xref:System.Collections.Concurrent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ac209-131">The following table lists the collection types in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace.</span></span>  
  
|<span data-ttu-id="ac209-132">Type</span><span class="sxs-lookup"><span data-stu-id="ac209-132">Type</span></span>|<span data-ttu-id="ac209-133">Description</span><span class="sxs-lookup"><span data-stu-id="ac209-133">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601>|<span data-ttu-id="ac209-134">Offre la funzionalità di delimitazione e blocco per qualsiasi tipo che implementa <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="ac209-134">Provides bounding and blocking functionality for any type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span></span> <span data-ttu-id="ac209-135">Per altre informazioni, vedere [Panoramica di BlockingCollection](blockingcollection-overview.md).</span><span class="sxs-lookup"><span data-stu-id="ac209-135">For more information, see [BlockingCollection Overview](blockingcollection-overview.md).</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602>|<span data-ttu-id="ac209-136">Implementazione thread-safe di un dizionario di coppie chiave-valore.</span><span class="sxs-lookup"><span data-stu-id="ac209-136">Thread-safe implementation of a dictionary of key-value pairs.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601>|<span data-ttu-id="ac209-137">Implementazione thread-safe di una coda FIFO (First-In, First-Out).</span><span class="sxs-lookup"><span data-stu-id="ac209-137">Thread-safe implementation of a FIFO (first-in, first-out) queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601>|<span data-ttu-id="ac209-138">Implementazione thread-safe di una coda LIFO (Last-In, First-Out).</span><span class="sxs-lookup"><span data-stu-id="ac209-138">Thread-safe implementation of a LIFO (last-in, first-out) stack.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601>|<span data-ttu-id="ac209-139">Implementazione thread-safe di una raccolta non ordinata di elementi.</span><span class="sxs-lookup"><span data-stu-id="ac209-139">Thread-safe implementation of an unordered collection of elements.</span></span>|  
|<xref:System.Collections.Concurrent.IProducerConsumerCollection%601>|<span data-ttu-id="ac209-140">Interfaccia che un tipo deve implementare per essere usato in un oggetto `BlockingCollection`.</span><span class="sxs-lookup"><span data-stu-id="ac209-140">The interface that a type must implement to be used in a `BlockingCollection`.</span></span>|  
  
## <a name="related-topics"></a><span data-ttu-id="ac209-141">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="ac209-141">Related Topics</span></span>  
  
|<span data-ttu-id="ac209-142">Titolo</span><span class="sxs-lookup"><span data-stu-id="ac209-142">Title</span></span>|<span data-ttu-id="ac209-143">Descrizione</span><span class="sxs-lookup"><span data-stu-id="ac209-143">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="ac209-144">Panoramica di BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="ac209-144">BlockingCollection Overview</span></span>](blockingcollection-overview.md)|<span data-ttu-id="ac209-145">Descrive la funzionalità fornita dal tipo <xref:System.Collections.Concurrent.BlockingCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="ac209-145">Describes the functionality provided by the <xref:System.Collections.Concurrent.BlockingCollection%601> type.</span></span>|  
|[<span data-ttu-id="ac209-146">Procedura: aggiungere e rimuovere elementi da un oggetto ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="ac209-146">How to: Add and Remove Items from a ConcurrentDictionary</span></span>](how-to-add-and-remove-items.md)|<span data-ttu-id="ac209-147">Descrive come aggiungere e rimuovere elementi da un oggetto <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span><span class="sxs-lookup"><span data-stu-id="ac209-147">Describes how to add and remove elements from a <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span></span>|  
|[<span data-ttu-id="ac209-148">Procedura: Aggiungere e rimuovere singoli elementi di un oggetto BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="ac209-148">How to: Add and Take Items Individually from a BlockingCollection</span></span>](how-to-add-and-take-items.md)|<span data-ttu-id="ac209-149">Descrive come aggiungere e recuperare elementi da una raccolta di blocco senza usare l'enumeratore di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="ac209-149">Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.</span></span>|  
|[<span data-ttu-id="ac209-150">Procedura: Aggiungere funzionalità di delimitazione e blocco a una raccolta</span><span class="sxs-lookup"><span data-stu-id="ac209-150">How to: Add Bounding and Blocking Functionality to a Collection</span></span>](how-to-add-bounding-and-blocking.md)|<span data-ttu-id="ac209-151">Descrive come usare una classe di raccolta come meccanismo di archiviazione sottostante per una raccolta <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="ac209-151">Describes how to use any collection class as the underlying storage mechanism for an <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> collection.</span></span>|  
|[<span data-ttu-id="ac209-152">Procedura: utilizzare ForEach per rimuovere elementi in un oggetto BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="ac209-152">How to: Use ForEach to Remove Items in a BlockingCollection</span></span>](how-to-use-foreach-to-remove.md)|<span data-ttu-id="ac209-153">Descrive come usare `foreach` (`For Each` in Visual Basic) per rimuovere tutti gli elementi in una raccolta di blocco.</span><span class="sxs-lookup"><span data-stu-id="ac209-153">Describes how to use `foreach`, (`For Each` in Visual Basic) to remove all items in a blocking collection.</span></span>|  
|[<span data-ttu-id="ac209-154">Procedura: utilizzare matrici di raccolte di blocco in una pipeline</span><span class="sxs-lookup"><span data-stu-id="ac209-154">How to: Use Arrays of Blocking Collections in a Pipeline</span></span>](how-to-use-arrays-of-blockingcollections.md)|<span data-ttu-id="ac209-155">Descrive come usare più raccolte di blocco contemporaneamente per implementare una pipeline.</span><span class="sxs-lookup"><span data-stu-id="ac209-155">Describes how to use multiple blocking collections at the same time to implement a pipeline.</span></span>|  
|[<span data-ttu-id="ac209-156">Procedura: Creare un pool di oggetti con un oggetto ConcurrentBag</span><span class="sxs-lookup"><span data-stu-id="ac209-156">How to: Create an Object Pool by Using a ConcurrentBag</span></span>](how-to-create-an-object-pool.md)|<span data-ttu-id="ac209-157">Illustra come usare un contenitore simultaneo per migliorare le prestazioni negli scenari in cui è possibile riutilizzare gli oggetti anziché crearne continuamente di nuovi.</span><span class="sxs-lookup"><span data-stu-id="ac209-157">Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="ac209-158">Informazioni di riferimento</span><span class="sxs-lookup"><span data-stu-id="ac209-158">Reference</span></span>  
 <xref:System.Collections.Concurrent?displayProperty=nameWithType>
