---
title: Implementare un metodo Dispose
ms.date: 05/13/2020
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Dispose method
- garbage collection, Dispose method
ms.assetid: eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9
ms.openlocfilehash: a002e0d27dfe28795b28e6813c4f5d5b3e13cdaf
ms.sourcegitcommit: 046a9c22487551360e20ec39fc21eef99820a254
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 05/14/2020
ms.locfileid: "83396911"
---
# <a name="implement-a-dispose-method"></a><span data-ttu-id="2e7cd-102">Implementare un metodo Dispose</span><span class="sxs-lookup"><span data-stu-id="2e7cd-102">Implement a Dispose method</span></span>

<span data-ttu-id="2e7cd-103">L'implementazione del <xref:System.IDisposable.Dispose%2A> metodo è principalmente per rilasciare le risorse non gestite usate dal codice.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-103">Implementing the <xref:System.IDisposable.Dispose%2A> method is primarily for releasing unmanaged resources used by your code.</span></span> <span data-ttu-id="2e7cd-104">Quando si lavora con membri di istanza che sono <xref:System.IDisposable> implementazioni, le chiamate a cascata sono comuni <xref:System.IDisposable.Dispose%2A> .</span><span class="sxs-lookup"><span data-stu-id="2e7cd-104">When working with instance members that are <xref:System.IDisposable> implementations, it's common to cascade <xref:System.IDisposable.Dispose%2A> calls.</span></span> <span data-ttu-id="2e7cd-105">Esistono altri motivi per l'implementazione di <xref:System.IDisposable.Dispose%2A> , ad esempio l'annullamento di un'operazione eseguita in precedenza.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-105">There are additional reasons for implementing <xref:System.IDisposable.Dispose%2A>, such as undoing something that was previously done.</span></span> <span data-ttu-id="2e7cd-106">Ad esempio, liberando la memoria allocata, rimuovendo un elemento da una raccolta che è stata aggiunta, segnalando il rilascio di un blocco acquisito e così via.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-106">For example, freeing memory that was allocated, removing an item from a collection that was added, signaling the release of a lock that was acquired, and so on.</span></span>

<span data-ttu-id="2e7cd-107">Il [Garbage Collector .NET](index.md) non alloca o rilascia la memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-107">The [.NET garbage collector](index.md) does not allocate or release unmanaged memory.</span></span> <span data-ttu-id="2e7cd-108">Il modello per l'eliminazione di un oggetto, definito come modello Dispose, impone un ordine per la durata di un oggetto.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-108">The pattern for disposing an object, referred to as the dispose pattern, imposes order on the lifetime of an object.</span></span> <span data-ttu-id="2e7cd-109">Il modello Dispose viene usato per gli oggetti che implementano l' <xref:System.IDisposable> interfaccia ed è comune quando si interagisce con handle di file e pipe, handle del registro di sistema, handle di attesa o puntatori a blocchi di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-109">The dispose pattern is used for objects that implement the <xref:System.IDisposable> interface, and is common when interacting with file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory.</span></span> <span data-ttu-id="2e7cd-110">Questo perché il Garbage Collector non è in grado di recuperare gli oggetti non gestiti.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-110">This is because the garbage collector is unable to reclaim unmanaged objects.</span></span>

<span data-ttu-id="2e7cd-111">Per garantire che le risorse vengano sempre pulite correttamente, un <xref:System.IDisposable.Dispose%2A> metodo deve essere idempotente, in modo che sia possibile chiamarlo più volte senza generare un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-111">To help ensure that resources are always cleaned up appropriately, a <xref:System.IDisposable.Dispose%2A> method should be idempotent, such that it is callable multiple times without throwing an exception.</span></span> <span data-ttu-id="2e7cd-112">Inoltre, le chiamate successive di <xref:System.IDisposable.Dispose%2A> non devono eseguire alcuna operazione.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-112">Furthermore, subsequent invocations of <xref:System.IDisposable.Dispose%2A> should do nothing.</span></span>

<span data-ttu-id="2e7cd-113">Nell'esempio di codice fornito per il <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> metodo viene illustrato come Garbage Collection possibile causare l'esecuzione di un finalizzatore, mentre un riferimento non gestito all'oggetto o ai relativi membri è ancora in uso.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-113">The code example provided for the <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> method shows how garbage collection can cause a finalizer to run, while an unmanaged reference to the object or its members is still in use.</span></span> <span data-ttu-id="2e7cd-114">Potrebbe essere utile usare <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> per rendere l'oggetto non idoneo per Garbage Collection dall'inizio della routine corrente fino al punto in cui viene chiamato il metodo.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-114">It may make sense to utilize <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> to make the object ineligible for garbage collection from the start of the current routine to the point where this method is called.</span></span>

## <a name="safe-handles"></a><span data-ttu-id="2e7cd-115">Handle sicuri</span><span class="sxs-lookup"><span data-stu-id="2e7cd-115">Safe handles</span></span>

<span data-ttu-id="2e7cd-116">La scrittura di codice per il finalizzatore di un oggetto è un'attività complessa che può causare problemi se non eseguita correttamente.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-116">Writing code for an object's finalizer is a complex task that can cause problems if not done correctly.</span></span> <span data-ttu-id="2e7cd-117">È pertanto consigliabile costruire oggetti <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> anziché implementare un finalizzatore.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-117">Therefore, we recommend that you construct <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> objects instead of implementing a finalizer.</span></span>

<span data-ttu-id="2e7cd-118">Un <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> è un tipo gestito astratto che esegue il wrapping di un oggetto <xref:System.IntPtr?displayProperty=nameWithType> che identifica una risorsa non gestita.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-118">A <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract managed type that wraps an <xref:System.IntPtr?displayProperty=nameWithType> that identifies an unmanaged resource.</span></span> <span data-ttu-id="2e7cd-119">In Windows è possibile che identifichi un handle in UNIX, un descrittore di file.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-119">On Windows it might identify a handle while on Unix, a file descriptor.</span></span> <span data-ttu-id="2e7cd-120">Fornisce tutta la logica necessaria per garantire che questa risorsa venga rilasciata una sola volta, quando l'oggetto `SafeHandle` viene eliminato o quando tutti i riferimenti all'oggetto `SafeHandle` sono stati eliminati e l' `SafeHandle` istanza viene finalizzata.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-120">It provides all of the logic necessary to ensure that this resource is released once and only once, when the `SafeHandle` is disposed of or when all references to the `SafeHandle` have been dropped and the `SafeHandle` instance is finalized.</span></span>

<span data-ttu-id="2e7cd-121"><xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>È una classe di base astratta.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-121">The <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract base class.</span></span> <span data-ttu-id="2e7cd-122">Le classi derivate forniscono istanze specifiche per diversi tipi di handle.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-122">Derived classes provide specific instances for different kinds of handle.</span></span> <span data-ttu-id="2e7cd-123">Queste classi derivate convalidano quali valori per <xref:System.IntPtr?displayProperty=nameWithType> sono considerati non validi e come effettivamente liberare l'handle.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-123">These derived classes validate what values for the <xref:System.IntPtr?displayProperty=nameWithType> are considered invalid and how to actually free the handle.</span></span> <span data-ttu-id="2e7cd-124">Ad esempio, <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> deriva da `SafeHandle` a wrap `IntPtrs` che identificano gli handle di file aperti/descrittori ed esegue l'override <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> del relativo metodo per chiuderlo (tramite la `close` funzione su UNIX o `CloseHandle` Function in Windows).</span><span class="sxs-lookup"><span data-stu-id="2e7cd-124">For example, <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> derives from `SafeHandle` to wrap `IntPtrs` that identify open file handles/descriptors, and overrides its <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> method to close it (via the `close` function on Unix or `CloseHandle` function on Windows).</span></span> <span data-ttu-id="2e7cd-125">La maggior parte delle API nelle librerie .NET che creano una risorsa non gestita ne eseguirà il wrapping in un oggetto `SafeHandle` e lo restituirà in `SafeHandle` base alle esigenze, anziché tornare al puntatore non elaborato.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-125">Most APIs in .NET libraries that create an unmanaged resource will wrap it in a `SafeHandle` and return that `SafeHandle` to you as needed, rather than handing back the raw pointer.</span></span> <span data-ttu-id="2e7cd-126">Nelle situazioni in cui si interagisce con un componente non gestito e si ottiene un `IntPtr` per una risorsa non gestita, è possibile creare un `SafeHandle` tipo personalizzato per eseguire il wrapping.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-126">In situations where you interact with an unmanaged component and get an `IntPtr` for an unmanaged resource, you can create your own `SafeHandle` type to wrap it.</span></span> <span data-ttu-id="2e7cd-127">Di conseguenza, pochi `SafeHandle` tipi non devono implementare i finalizzatori. la maggior parte delle implementazioni di modelli Disposable finirà solo con il wrapping di altre risorse gestite, alcune delle quali possono essere `SafeHandle` .</span><span class="sxs-lookup"><span data-stu-id="2e7cd-127">As a result, few non-`SafeHandle` types need to implement finalizers; most disposable pattern implementations only end up wrapping other managed resources, some of which may be `SafeHandle`s.</span></span>

<span data-ttu-id="2e7cd-128">Le seguenti classi derivate nello spazio dei nomi <xref:Microsoft.Win32.SafeHandles> forniscono handle sicuri:</span><span class="sxs-lookup"><span data-stu-id="2e7cd-128">The following derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace provide safe handles:</span></span>

- <span data-ttu-id="2e7cd-129">Le classi <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> e <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> per file, file mappati alla memoria e pipe.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-129">The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>, and <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class, for files, memory mapped files, and pipes.</span></span>
- <span data-ttu-id="2e7cd-130">La classe <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> per visualizzazioni di memoria.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-130">The <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class, for memory views.</span></span>
- <span data-ttu-id="2e7cd-131">Le classi <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle> e <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> per i costrutti di crittografia.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-131">The <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes, for cryptography constructs.</span></span>
- <span data-ttu-id="2e7cd-132">La classe <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> per le chiavi del Registro di sistema.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-132">The <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class, for registry keys.</span></span>
- <span data-ttu-id="2e7cd-133">La classe <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> per gli handle di attesa.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-133">The <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class, for wait handles.</span></span>

## <a name="dispose-and-disposebool"></a><span data-ttu-id="2e7cd-134">Dispose () e Dispose (bool)</span><span class="sxs-lookup"><span data-stu-id="2e7cd-134">Dispose() and Dispose(bool)</span></span>

<span data-ttu-id="2e7cd-135">L'interfaccia <xref:System.IDisposable> richiede l'implementazione di un singolo metodo senza parametri, <xref:System.IDisposable.Dispose%2A>.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-135">The <xref:System.IDisposable> interface requires the implementation of a single parameterless method, <xref:System.IDisposable.Dispose%2A>.</span></span> <span data-ttu-id="2e7cd-136">Inoltre, qualsiasi classe non sealed deve avere un `Dispose(bool)` metodo di overload aggiuntivo da implementare:</span><span class="sxs-lookup"><span data-stu-id="2e7cd-136">Also, any non-sealed class should have an additional `Dispose(bool)` overload method to be implemented:</span></span>

- <span data-ttu-id="2e7cd-137">`public`Implementazione non virtuale ( `NonInheritable` in Visual Basic) priva di <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> parametri.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-137">A `public` non-virtual (`NonInheritable` in Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation that has no parameters.</span></span>

- <span data-ttu-id="2e7cd-138">`protected virtual`Metodo ( `Overridable` in Visual Basic) la `Dispose` cui firma è:</span><span class="sxs-lookup"><span data-stu-id="2e7cd-138">A `protected virtual` (`Overridable` in Visual Basic) `Dispose` method whose signature is:</span></span>

  [!code-csharp[Conceptual.Disposable#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)]
  [!code-vb[Conceptual.Disposable#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)]

  > [!IMPORTANT]
  > <span data-ttu-id="2e7cd-139">Il `disposing` parametro deve essere `false` chiamato da un finalizzatore e quando viene `true` chiamato dal <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-139">The `disposing` parameter should be `false` when called from a finalizer, and `true` when called from the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="2e7cd-140">In altre parole, è quando viene chiamato in modo `true` deterministico e quando viene chiamato in modo `false` non deterministico.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-140">In other words, it is `true` when deterministically called and `false` when non-deterministically called.</span></span>

### <a name="the-dispose-method"></a><span data-ttu-id="2e7cd-141">Metodo Dispose ()</span><span class="sxs-lookup"><span data-stu-id="2e7cd-141">The Dispose() method</span></span>

<span data-ttu-id="2e7cd-142">Poiché la proprietà `public` , non virtuale ( `NonInheritable` in Visual Basic), il metodo senza parametri `Dispose` viene chiamato da un consumer del tipo, il suo scopo è liberare le risorse non gestite, eseguire una pulizia generale e indicare che il finalizzatore, se presente, non è necessario eseguire.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-142">Because the `public`, non-virtual (`NonInheritable` in Visual Basic), parameterless `Dispose` method is called by a consumer of the type, its purpose is to free unmanaged resources, perform general cleanup, and to indicate that the finalizer, if one is present, doesn't have to run.</span></span> <span data-ttu-id="2e7cd-143">La liberazione della memoria effettiva associata a un oggetto gestito è sempre il dominio del [Garbage Collector](index.md).</span><span class="sxs-lookup"><span data-stu-id="2e7cd-143">Freeing the actual memory associated with a managed object is always the domain of the [garbage collector](index.md).</span></span> <span data-ttu-id="2e7cd-144">Per questo motivo il metodo ha un'implementazione standard:</span><span class="sxs-lookup"><span data-stu-id="2e7cd-144">Because of this, it has a standard implementation:</span></span>

[!code-csharp[Conceptual.Disposable#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#7)]
[!code-vb[Conceptual.Disposable#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#7)]

<span data-ttu-id="2e7cd-145">Il metodo `Dispose` esegue la pulizia di tutti gli oggetti, quindi il Garbage Collector non deve più chiamare l'override <xref:System.Object.Finalize%2A?displayProperty=nameWithType> degli oggetti.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-145">The `Dispose` method performs all object cleanup, so the garbage collector no longer needs to call the objects' <xref:System.Object.Finalize%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="2e7cd-146">Pertanto, la chiamata al metodo <xref:System.GC.SuppressFinalize%2A> impedisce al Garbage Collector di eseguire il finalizzatore.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-146">Therefore, the call to the <xref:System.GC.SuppressFinalize%2A> method prevents the garbage collector from running the finalizer.</span></span> <span data-ttu-id="2e7cd-147">Se il tipo non dispone di un finalizzatore, la chiamata a <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-147">If the type has no finalizer, the call to <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> has no effect.</span></span> <span data-ttu-id="2e7cd-148">Si noti che l'effettiva pulizia viene eseguita dall' `Dispose(bool)` Overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-148">Note that the actual cleanup is performed by the `Dispose(bool)` method overload.</span></span>

### <a name="the-disposebool-method-overload"></a><span data-ttu-id="2e7cd-149">Overload del metodo Dispose (bool)</span><span class="sxs-lookup"><span data-stu-id="2e7cd-149">The Dispose(bool) method overload</span></span>

<span data-ttu-id="2e7cd-150">Nell'overload, il `disposing` parametro è un oggetto <xref:System.Boolean> che indica se la chiamata al metodo deriva da un <xref:System.IDisposable.Dispose%2A> Metodo (il valore è `true` ) o da un finalizzatore (il valore è `false` ).</span><span class="sxs-lookup"><span data-stu-id="2e7cd-150">In the overload, the `disposing` parameter is a <xref:System.Boolean> that indicates whether the method call comes from a <xref:System.IDisposable.Dispose%2A> method (its value is `true`) or from a finalizer (its value is `false`).</span></span>

<span data-ttu-id="2e7cd-151">Il corpo del metodo è costituito da due blocchi di codice:</span><span class="sxs-lookup"><span data-stu-id="2e7cd-151">The body of the method consists of two blocks of code:</span></span>

- <span data-ttu-id="2e7cd-152">Un blocco che libera le risorse non gestite.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-152">A block that frees unmanaged resources.</span></span> <span data-ttu-id="2e7cd-153">Questo blocco viene eseguito indipendentemente dal valore del parametro `disposing`.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-153">This block executes regardless of the value of the `disposing` parameter.</span></span>
- <span data-ttu-id="2e7cd-154">Un blocco condizionale che libera le risorse gestite.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-154">A conditional block that frees managed resources.</span></span> <span data-ttu-id="2e7cd-155">Il blocco è eseguito se il valore di `disposing` è `true`.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-155">This block executes if the value of `disposing` is `true`.</span></span> <span data-ttu-id="2e7cd-156">Le risorse gestite liberate possono includere:</span><span class="sxs-lookup"><span data-stu-id="2e7cd-156">The managed resources that it frees can include:</span></span>

  - <span data-ttu-id="2e7cd-157">**Oggetti gestiti che implementano <xref:System.IDisposable>.**</span><span class="sxs-lookup"><span data-stu-id="2e7cd-157">**Managed objects that implement <xref:System.IDisposable>.**</span></span> <span data-ttu-id="2e7cd-158">Il blocco condizionale può essere usato per chiamare la relativa <xref:System.IDisposable.Dispose%2A> implementazione (Cascade Dispose).</span><span class="sxs-lookup"><span data-stu-id="2e7cd-158">The conditional block can be used to call their <xref:System.IDisposable.Dispose%2A> implementation (cascade dispose).</span></span> <span data-ttu-id="2e7cd-159">Se è stata usata una classe derivata di <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> per eseguire il wrapping della risorsa non gestita, è necessario chiamare l' <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> implementazione qui.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-159">If you have used a derived class of <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> to wrap your unmanaged resource, you should call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> implementation here.</span></span>

  - <span data-ttu-id="2e7cd-160">**Oggetti gestiti che usano grandi quantità di memoria o risorse insufficienti.**</span><span class="sxs-lookup"><span data-stu-id="2e7cd-160">**Managed objects that consume large amounts of memory or consume scarce resources.**</span></span> <span data-ttu-id="2e7cd-161">Assegnare riferimenti a oggetti gestiti di grandi dimensioni a `null` per renderli più probabilmente irraggiungibili.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-161">Assign large managed object references to `null` to make them more likely to be unreachable.</span></span> <span data-ttu-id="2e7cd-162">Questo li rilascia più velocemente rispetto a quelli che sono stati recuperati in modo non deterministico.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-162">This releases them faster than if they were reclaimed non-deterministically.</span></span>

<span data-ttu-id="2e7cd-163">Se la chiamata al metodo deriva da un finalizzatore, deve essere eseguito solo il codice che libera le risorse non gestite.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-163">If the method call comes from a finalizer, only the code that frees unmanaged resources should execute.</span></span> <span data-ttu-id="2e7cd-164">L'implementatore è responsabile di garantire che il percorso false non interagisca con gli oggetti gestiti che potrebbero essere stati recuperati.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-164">The implementer is responsible for ensuring the the false path doesn't interact with managed objects that may have been reclaimed.</span></span> <span data-ttu-id="2e7cd-165">Questo è importante perché l'ordine in cui il Garbage Collector elimina gli oggetti gestiti durante la finalizzazione non è deterministico.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-165">This is important because the order in which the garbage collector destroys managed objects during finalization is non-deterministic.</span></span>

## <a name="cascade-dispose-calls"></a><span data-ttu-id="2e7cd-166">Chiamate a Dispose a catena</span><span class="sxs-lookup"><span data-stu-id="2e7cd-166">Cascade dispose calls</span></span>

<span data-ttu-id="2e7cd-167">Se la classe è proprietaria di un campo o di una proprietà e il tipo implementa <xref:System.IDisposable> , anche la classe che lo contiene deve implementare <xref:System.IDisposable> .</span><span class="sxs-lookup"><span data-stu-id="2e7cd-167">If your class owns a field or property, and its type implements <xref:System.IDisposable>, the containing class itself should also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="2e7cd-168">Una classe che crea un'istanza di un' <xref:System.IDisposable> implementazione di e la archivia come membro di istanza è anche responsabile della pulizia.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-168">A class that instantiates an <xref:System.IDisposable> implementation and storing it as an instance member, is also responsible for its cleanup.</span></span> <span data-ttu-id="2e7cd-169">Ciò consente di garantire che ai tipi Disposable a cui viene fatto riferimento venga data la possibilità di eseguire la pulizia in modo deterministico tramite il <xref:System.IDisposable.Dispose%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-169">This is to help ensure that the referenced disposable types are given the opportunity to deterministically perform clean up through the <xref:System.IDisposable.Dispose%2A> method.</span></span> <span data-ttu-id="2e7cd-170">In questo esempio la classe è `sealed` (o `NotInheritable` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2e7cd-170">In this example, the class is `sealed` (or `NotInheritable` in Visual Basic).</span></span>

[!code-csharp[Conceptual.Disposable#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/disposable1.cs#1)]
[!code-vb[Conceptual.Disposable#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/disposable1.vb#1)]

## <a name="implement-the-dispose-pattern"></a><span data-ttu-id="2e7cd-171">Implementare il modello Dispose</span><span class="sxs-lookup"><span data-stu-id="2e7cd-171">Implement the dispose pattern</span></span>

<span data-ttu-id="2e7cd-172">Tutte le classi non sealed o (Visual Basic classi non modificate come `NotInheritable` ) devono essere considerate come una classe di base potenziale, perché potrebbero essere ereditate.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-172">All non-sealed classes or (Visual Basic classes not modified as `NotInheritable`) should be considered a potential base class, because they could be inherited.</span></span> <span data-ttu-id="2e7cd-173">Se si implementa il modello Dispose per qualsiasi classe di base potenziale, è necessario specificare quanto segue:</span><span class="sxs-lookup"><span data-stu-id="2e7cd-173">If you implement the dispose pattern for any potential base class, you must provide the following:</span></span>

- <span data-ttu-id="2e7cd-174">Un'implementazione <xref:System.IDisposable.Dispose%2A> che chiami il metodo `Dispose(bool)`.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-174">A <xref:System.IDisposable.Dispose%2A> implementation that calls the `Dispose(bool)` method.</span></span>
- <span data-ttu-id="2e7cd-175">`Dispose(bool)`Metodo che esegue la pulizia effettiva.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-175">A `Dispose(bool)` method that performs the actual cleanup.</span></span>
- <span data-ttu-id="2e7cd-176">Una classe derivata da <xref:System.Runtime.InteropServices.SafeHandle> che esegua il wrapping della risorsa non gestita (consigliato) o un override al metodo <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-176">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="2e7cd-177">La <xref:System.Runtime.InteropServices.SafeHandle> classe fornisce un finalizzatore, quindi non è necessario scriverne uno manualmente.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-177">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer, so you do not have to write one yourself.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="2e7cd-178">Una classe di base può fare riferimento solo a oggetti gestiti e implementare il modello Dispose.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-178">It is possible for a base class to only reference managed objects, and implement the dispose pattern.</span></span> <span data-ttu-id="2e7cd-179">In questi casi, un finalizzatore non è necessario.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-179">In these cases, a finalizer is unnecessary.</span></span> <span data-ttu-id="2e7cd-180">Un finalizzatore è necessario solo se si fa riferimento direttamente A risorse non gestite.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-180">A finalizer is only required if you directly reference unmanaged resources.</span></span>

<span data-ttu-id="2e7cd-181">Di seguito è illustrato il modello generale per implementare il modello Dispose per una classe di base che usa un handle sicuro.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-181">Here's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.</span></span>

[!code-csharp[System.IDisposable#3](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
[!code-vb[System.IDisposable#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]

> [!NOTE]
> <span data-ttu-id="2e7cd-182">L'esempio precedente usa un oggetto <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> per illustrato il criterio; sarebbe possibile usare invece qualsiasi oggetto derivato da <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-182">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="2e7cd-183">Si noti che l'esempio non crea correttamente un'istanza del relativo oggetto <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-183">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="2e7cd-184">Di seguito è illustrato il modello generale per implementare il modello Dispose per una classe di base che esegue l'override di <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-184">Here's the general pattern for implementing the dispose pattern for a base class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span>

[!code-csharp[System.IDisposable#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
[!code-vb[System.IDisposable#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]

> [!TIP]
> <span data-ttu-id="2e7cd-185">In C# si crea un [finalizzatore](../../csharp/programming-guide/classes-and-structs/destructors.md) eseguendo l'override di <xref:System.Object.Finalize%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="2e7cd-185">In C#, you create a [finalizer](../../csharp/programming-guide/classes-and-structs/destructors.md) by overriding <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2e7cd-186">In Visual Basic, questa operazione viene eseguita con `Protected Overrides Sub Finalize()` .</span><span class="sxs-lookup"><span data-stu-id="2e7cd-186">In Visual Basic, this is done with `Protected Overrides Sub Finalize()`.</span></span>

## <a name="implement-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="2e7cd-187">Implementare il modello Dispose per una classe derivata</span><span class="sxs-lookup"><span data-stu-id="2e7cd-187">Implement the dispose pattern for a derived class</span></span>

<span data-ttu-id="2e7cd-188">Una classe derivata da una classe che implementa l'interfaccia <xref:System.IDisposable> non deve implementare <xref:System.IDisposable>, poiché l'implementazione della classe di base di <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> viene ereditata dalle classi derivate.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-188">A class derived from a class that implements the <xref:System.IDisposable> interface shouldn't implement <xref:System.IDisposable>, because the base class implementation of <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> is inherited by its derived classes.</span></span> <span data-ttu-id="2e7cd-189">Al contrario, per pulire una classe derivata, è necessario specificare quanto segue:</span><span class="sxs-lookup"><span data-stu-id="2e7cd-189">Instead, to cleanup a derived class, you provide the following:</span></span>

- <span data-ttu-id="2e7cd-190">`protected override void Dispose(bool)`Metodo che esegue l'override del metodo della classe di base ed esegue l'effettiva pulizia della classe derivata.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-190">A `protected override void Dispose(bool)` method that overrides the base class method and performs the actual cleanup of the derived class.</span></span> <span data-ttu-id="2e7cd-191">Questo metodo deve anche chiamare il `base.Dispose(bool)` `MyBase.Dispose(bool)` Metodo (in Visual Basic) della classe di base e passare il relativo stato di eliminazione per l'argomento.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-191">This method must also call the `base.Dispose(bool)` (`MyBase.Dispose(bool)` in Visual Basic) method of the base class and pass its disposing status for the argument.</span></span>
- <span data-ttu-id="2e7cd-192">Una classe derivata da <xref:System.Runtime.InteropServices.SafeHandle> che esegua il wrapping della risorsa non gestita (consigliato) o un override al metodo <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-192">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="2e7cd-193">La classe <xref:System.Runtime.InteropServices.SafeHandle> fornisce un finalizzatore, evitando la necessità di codificarne uno.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-193">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span> <span data-ttu-id="2e7cd-194">Se si fornisce un finalizzatore, questo deve chiamare l' `Dispose(bool)` Overload di con un `disposing` argomento di `false` .</span><span class="sxs-lookup"><span data-stu-id="2e7cd-194">If you do provide a finalizer, it must call the `Dispose(bool)` overload with a `disposing` argument of `false`.</span></span>

<span data-ttu-id="2e7cd-195">Di seguito è illustrato il modello generale per implementare il modello Dispose per una classe derivata che usa un handle sicuro:</span><span class="sxs-lookup"><span data-stu-id="2e7cd-195">Here's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:</span></span>

[!code-csharp[System.IDisposable#4](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
[!code-vb[System.IDisposable#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]

> [!NOTE]
> <span data-ttu-id="2e7cd-196">L'esempio precedente usa un oggetto <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> per illustrato il criterio; sarebbe possibile usare invece qualsiasi oggetto derivato da <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-196">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="2e7cd-197">Si noti che l'esempio non crea correttamente un'istanza del relativo oggetto <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-197">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="2e7cd-198">Di seguito è illustrato il modello generale per implementare il modello Dispose per una classe derivata che esegue l'override di <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="2e7cd-198">Here's the general pattern for implementing the dispose pattern for a derived class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span></span>

[!code-csharp[System.IDisposable#6](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived2.cs#6)]
[!code-vb[System.IDisposable#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived2.vb#6)]

## <a name="implement-the-dispose-pattern-with-safe-handles"></a><span data-ttu-id="2e7cd-199">Implementare il modello Dispose con handle sicuri</span><span class="sxs-lookup"><span data-stu-id="2e7cd-199">Implement the dispose pattern with safe handles</span></span>

<span data-ttu-id="2e7cd-200">L'esempio seguente illustra il modello Dispose per una classe di base, `DisposableStreamResource`, che usa handle sicuri per incapsulare le risorse non gestite.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-200">The following example illustrates the dispose pattern for a base class, `DisposableStreamResource`, that uses a safe handle to encapsulate unmanaged resources.</span></span> <span data-ttu-id="2e7cd-201">Viene definita una classe `DisposableStreamResource` che usa <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> per eseguire il wrapping di un oggetto <xref:System.IO.Stream> che rappresenta un file aperto.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-201">It defines a `DisposableStreamResource` class that uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> to wrap a <xref:System.IO.Stream> object that represents an open file.</span></span> <span data-ttu-id="2e7cd-202">La classe include anche una singola proprietà, `Size` , che restituisce il numero totale di byte nel flusso di file.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-202">The class also includes a single property, `Size`, that returns the total number of bytes in the file stream.</span></span>

[!code-csharp[Conceptual.Disposable#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/base1.cs#9)]
[!code-vb[Conceptual.Disposable#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/base1.vb#9)]

## <a name="implement-the-dispose-pattern-for-a-derived-class-with-safe-handles"></a><span data-ttu-id="2e7cd-203">Implementare il modello Dispose per una classe derivata con handle sicuri</span><span class="sxs-lookup"><span data-stu-id="2e7cd-203">Implement the dispose pattern for a derived class with safe handles</span></span>

<span data-ttu-id="2e7cd-204">Nell'esempio seguente viene illustrato il modello Dispose per una classe derivata, `DisposableStreamResource2`, che eredita dalla classe `DisposableStreamResource` presentata nell'esempio precedente.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-204">The following example illustrates the dispose pattern for a derived class, `DisposableStreamResource2`, that inherits from the `DisposableStreamResource` class presented in the previous example.</span></span> <span data-ttu-id="2e7cd-205">La classe aggiunge un metodo aggiuntivo, `WriteFileInfo`, e usa un oggetto <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> per il wrapping dell'handle del file modificabile.</span><span class="sxs-lookup"><span data-stu-id="2e7cd-205">The class adds an additional method, `WriteFileInfo`, and uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to wrap the handle of the writable file.</span></span>

[!code-csharp[Conceptual.Disposable#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/derived1.cs#10)]
[!code-vb[Conceptual.Disposable#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/derived1.vb#10)]

## <a name="see-also"></a><span data-ttu-id="2e7cd-206">Vedi anche</span><span class="sxs-lookup"><span data-stu-id="2e7cd-206">See also</span></span>

- <xref:System.GC.SuppressFinalize%2A>
- <xref:System.IDisposable>
- <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>
- <xref:Microsoft.Win32.SafeHandles>
- <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>
- <xref:System.Object.Finalize%2A?displayProperty=nameWithType>
- [<span data-ttu-id="2e7cd-207">Procedura: Definire e usare classi e struct (C++/CLI)</span><span class="sxs-lookup"><span data-stu-id="2e7cd-207">How to: Define and Consume Classes and Structs (C++/CLI)</span></span>](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli)
- [<span data-ttu-id="2e7cd-208">Modello Dispose</span><span class="sxs-lookup"><span data-stu-id="2e7cd-208">Dispose Pattern</span></span>](implementing-dispose.md)
