---
title: Principi fondamentali di Garbage Collection
description: Informazioni su come funziona il Garbage Collector e su come può essere configurato per ottenere prestazioni ottimali.
ms.date: 11/15/2019
ms.technology: dotnet-standard
helpviewer_keywords:
- garbage collection, generations
- garbage collection, background
- garbage collection, concurrent
- garbage collection, server
- garbage collection, workstation
- garbage collection, managed heap
ms.assetid: 67c5a20d-1be1-4ea7-8a9a-92b0b08658d2
ms.openlocfilehash: d59f368f21964c07d371df604f0728fa6ca8ac00
ms.sourcegitcommit: 5280b2aef60a1ed99002dba44e4b9e7f6c830604
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/03/2020
ms.locfileid: "84307033"
---
# <a name="fundamentals-of-garbage-collection"></a><span data-ttu-id="02aee-103">Principi fondamentali di Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="02aee-103">Fundamentals of garbage collection</span></span>

<span data-ttu-id="02aee-104">Nel Common Language Runtime (CLR), il Garbage Collector (GC) funge da gestore di memoria automatico.</span><span class="sxs-lookup"><span data-stu-id="02aee-104">In the common language runtime (CLR), the garbage collector (GC) serves as an automatic memory manager.</span></span> <span data-ttu-id="02aee-105">Il Garbage Collector gestisce l'allocazione e il rilascio di memoria per un'applicazione.</span><span class="sxs-lookup"><span data-stu-id="02aee-105">The garbage collector manages the allocation and release of memory for an application.</span></span> <span data-ttu-id="02aee-106">Per gli sviluppatori che utilizzano codice gestito, questo significa che non è necessario scrivere codice per eseguire attività di gestione della memoria.</span><span class="sxs-lookup"><span data-stu-id="02aee-106">For developers working with managed code, this means that you don't have to write code to perform memory management tasks.</span></span> <span data-ttu-id="02aee-107">La gestione automatica della memoria può eliminare i problemi comuni, ad esempio dimenticando di liberare un oggetto e causando una perdita di memoria o provando ad accedere alla memoria per un oggetto già liberato.</span><span class="sxs-lookup"><span data-stu-id="02aee-107">Automatic memory management can eliminate common problems, such as forgetting to free an object and causing a memory leak or attempting to access memory for an object that's already been freed.</span></span>

<span data-ttu-id="02aee-108">Questo articolo descrive i concetti di base di Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="02aee-108">This article describes the core concepts of garbage collection.</span></span>

## <a name="benefits"></a><span data-ttu-id="02aee-109">Vantaggi</span><span class="sxs-lookup"><span data-stu-id="02aee-109">Benefits</span></span>

<span data-ttu-id="02aee-110">Il Garbage Collector offre i vantaggi seguenti:</span><span class="sxs-lookup"><span data-stu-id="02aee-110">The garbage collector provides the following benefits:</span></span>

- <span data-ttu-id="02aee-111">Consente agli sviluppatori di liberare manualmente la memoria.</span><span class="sxs-lookup"><span data-stu-id="02aee-111">Frees developers from having to manually release memory.</span></span>

- <span data-ttu-id="02aee-112">Alloca gli oggetti nell'heap gestito in maniera efficiente.</span><span class="sxs-lookup"><span data-stu-id="02aee-112">Allocates objects on the managed heap efficiently.</span></span>

- <span data-ttu-id="02aee-113">Recupera gli oggetti inutilizzati, ne cancella la memoria e tiene la memoria a disposizione per le future allocazioni.</span><span class="sxs-lookup"><span data-stu-id="02aee-113">Reclaims objects that are no longer being used, clears their memory, and keeps the memory available for future allocations.</span></span> <span data-ttu-id="02aee-114">Gli oggetti gestiti ottengono automaticamente contenuto pulito da cui iniziare, pertanto i costruttori non devono inizializzare ogni campo dati.</span><span class="sxs-lookup"><span data-stu-id="02aee-114">Managed objects automatically get clean content to start with, so their constructors don't have to initialize every data field.</span></span>

- <span data-ttu-id="02aee-115">Garantisce protezione per la memoria assicurando che un oggetto non possa usare il contenuto di un altro oggetto.</span><span class="sxs-lookup"><span data-stu-id="02aee-115">Provides memory safety by making sure that an object cannot use the content of another object.</span></span>

## <a name="fundamentals-of-memory"></a><span data-ttu-id="02aee-116">Nozioni fondamentali sulla memoria</span><span class="sxs-lookup"><span data-stu-id="02aee-116">Fundamentals of memory</span></span>

<span data-ttu-id="02aee-117">Nell'elenco seguente sono riepilogati concetti importanti relativi alla memoria CLR.</span><span class="sxs-lookup"><span data-stu-id="02aee-117">The following list summarizes important CLR memory concepts.</span></span>

- <span data-ttu-id="02aee-118">Ogni processo dispone di un proprio spazio degli indirizzi virtuali distinto.</span><span class="sxs-lookup"><span data-stu-id="02aee-118">Each process has its own, separate virtual address space.</span></span> <span data-ttu-id="02aee-119">Tutti i processi nello stesso computer condividono la stessa memoria fisica e il file di paging, se presente.</span><span class="sxs-lookup"><span data-stu-id="02aee-119">All processes on the same computer share the same physical memory and the page file, if there is one.</span></span>

- <span data-ttu-id="02aee-120">Per impostazione predefinita, nei computer a 32 bit ogni processo dispone di uno spazio degli indirizzi virtuali in modalità utente da 2 GB.</span><span class="sxs-lookup"><span data-stu-id="02aee-120">By default, on 32-bit computers, each process has a 2-GB user-mode virtual address space.</span></span>

- <span data-ttu-id="02aee-121">Uno sviluppatore di applicazioni usa solo lo spazio degli indirizzi virtuali e non modifica mai direttamente la memoria fisica.</span><span class="sxs-lookup"><span data-stu-id="02aee-121">As an application developer, you work only with virtual address space and never manipulate physical memory directly.</span></span> <span data-ttu-id="02aee-122">Il Garbage Collector alloca e libera automaticamente la memoria virtuale nell'heap gestito.</span><span class="sxs-lookup"><span data-stu-id="02aee-122">The garbage collector allocates and frees virtual memory for you on the managed heap.</span></span>

  <span data-ttu-id="02aee-123">Se si sta scrivendo codice nativo, si usano le funzioni di Windows per lavorare con lo spazio degli indirizzi virtuali.</span><span class="sxs-lookup"><span data-stu-id="02aee-123">If you're writing native code, you use Windows functions to work with the virtual address space.</span></span> <span data-ttu-id="02aee-124">Queste funzioni allocano e liberano automaticamente la memoria virtuale negli heap nativi.</span><span class="sxs-lookup"><span data-stu-id="02aee-124">These functions allocate and free virtual memory for you on native heaps.</span></span>

- <span data-ttu-id="02aee-125">La memoria virtuale può trovarsi in tre stati:</span><span class="sxs-lookup"><span data-stu-id="02aee-125">Virtual memory can be in three states:</span></span>

  | <span data-ttu-id="02aee-126">State</span><span class="sxs-lookup"><span data-stu-id="02aee-126">State</span></span> | <span data-ttu-id="02aee-127">Descrizione</span><span class="sxs-lookup"><span data-stu-id="02aee-127">Description</span></span> |
  |---------|---------|
  | <span data-ttu-id="02aee-128">Gratuito</span><span class="sxs-lookup"><span data-stu-id="02aee-128">Free</span></span> | <span data-ttu-id="02aee-129">Non vi sono riferimenti al blocco di memoria, che è disponibile per l'allocazione.</span><span class="sxs-lookup"><span data-stu-id="02aee-129">The block of memory has no references to it and is available for allocation.</span></span> |
  | <span data-ttu-id="02aee-130">Riservato</span><span class="sxs-lookup"><span data-stu-id="02aee-130">Reserved</span></span> | <span data-ttu-id="02aee-131">Il blocco di memoria è disponibile per l'utilizzo e non può essere usato da un'altra richiesta di allocazione.</span><span class="sxs-lookup"><span data-stu-id="02aee-131">The block of memory is available for your use and cannot be used for any other allocation request.</span></span> <span data-ttu-id="02aee-132">Non è tuttavia possibile archiviare i dati in questo blocco di memoria fino a quando non viene eseguito il commit.</span><span class="sxs-lookup"><span data-stu-id="02aee-132">However, you cannot store data to this memory block until it is committed.</span></span> |
  | <span data-ttu-id="02aee-133">Impegnato</span><span class="sxs-lookup"><span data-stu-id="02aee-133">Committed</span></span> | <span data-ttu-id="02aee-134">Il blocco di memoria è assegnato all'archiviazione fisica.</span><span class="sxs-lookup"><span data-stu-id="02aee-134">The block of memory is assigned to physical storage.</span></span> |

- <span data-ttu-id="02aee-135">Lo spazio degli indirizzi virtuali può diventare frammentato.</span><span class="sxs-lookup"><span data-stu-id="02aee-135">Virtual address space can get fragmented.</span></span> <span data-ttu-id="02aee-136">Ciò significa che sono presenti blocchi liberi, noti anche come buchi, nello spazio degli indirizzi.</span><span class="sxs-lookup"><span data-stu-id="02aee-136">This means that there are free blocks, also known as holes, in the address space.</span></span> <span data-ttu-id="02aee-137">Quando viene richiesta un'allocazione della memoria virtuale, il gestore di memoria virtuale deve trovare un singolo blocco libero con dimensioni sufficienti per soddisfare la richiesta di allocazione.</span><span class="sxs-lookup"><span data-stu-id="02aee-137">When a virtual memory allocation is requested, the virtual memory manager has to find a single free block that is large enough to satisfy that allocation request.</span></span> <span data-ttu-id="02aee-138">Anche se si dispone di 2 GB di spazio libero, un'allocazione che richiede 2 GB avrà esito negativo a meno che tutto lo spazio libero non si trovi in un unico blocco di indirizzi.</span><span class="sxs-lookup"><span data-stu-id="02aee-138">Even if you have 2 GB of free space, an allocation that requires 2 GB will be unsuccessful unless all of that free space is in a single address block.</span></span>

- <span data-ttu-id="02aee-139">Se lo spazio degli indirizzi virtuali da riservare o lo spazio fisico di cui eseguire il commit non è sufficiente, è possibile che si esaurisca la memoria.</span><span class="sxs-lookup"><span data-stu-id="02aee-139">You can run out of memory if there isn't enough virtual address space to reserve or physical space to commit.</span></span>

  <span data-ttu-id="02aee-140">Il file di paging viene utilizzato anche se la pressione della memoria fisica (ovvero la richiesta di memoria fisica) è bassa.</span><span class="sxs-lookup"><span data-stu-id="02aee-140">The page file is used even if physical memory pressure (that is, demand for physical memory) is low.</span></span> <span data-ttu-id="02aee-141">La prima volta che la quantità di memoria fisica è elevata, il sistema operativo deve fare spazio nella memoria fisica per archiviare i dati e quindi eseguire il backup di alcuni dei dati presenti nella memoria fisica nel file di paging.</span><span class="sxs-lookup"><span data-stu-id="02aee-141">The first time physical memory pressure is high, the operating system must make room in physical memory to store data, and it backs up some of the data that is in physical memory to the page file.</span></span> <span data-ttu-id="02aee-142">I dati non vengono sottoposto a paging fino a quando non sono necessari, quindi è possibile che si verifichi il paging in situazioni in cui la pressione della memoria fisica è insufficiente.</span><span class="sxs-lookup"><span data-stu-id="02aee-142">That data is not paged until it's needed, so it's possible to encounter paging in situations where the physical memory pressure is low.</span></span>
  
### <a name="memory-allocation"></a><span data-ttu-id="02aee-143">Allocazione di memoria</span><span class="sxs-lookup"><span data-stu-id="02aee-143">Memory allocation</span></span>

<span data-ttu-id="02aee-144">Quando si inizializza un nuovo processo, per tale processo viene riservata una regione contigua di spazio degli indirizzi.</span><span class="sxs-lookup"><span data-stu-id="02aee-144">When you initialize a new process, the runtime reserves a contiguous region of address space for the process.</span></span> <span data-ttu-id="02aee-145">Lo spazio degli indirizzi riservato viene definito heap gestito.</span><span class="sxs-lookup"><span data-stu-id="02aee-145">This reserved address space is called the managed heap.</span></span> <span data-ttu-id="02aee-146">Nell'heap gestito viene conservato un puntatore all'indirizzo in cui verrà allocato il successivo oggetto dell'heap.</span><span class="sxs-lookup"><span data-stu-id="02aee-146">The managed heap maintains a pointer to the address where the next object in the heap will be allocated.</span></span> <span data-ttu-id="02aee-147">Le impostazioni iniziali del puntatore corrispondono all'indirizzo di base dell'heap gestito.</span><span class="sxs-lookup"><span data-stu-id="02aee-147">Initially, this pointer is set to the managed heap's base address.</span></span> <span data-ttu-id="02aee-148">Tutti i tipi di riferimento vengono allocati nell'heap gestito.</span><span class="sxs-lookup"><span data-stu-id="02aee-148">All reference types are allocated on the managed heap.</span></span> <span data-ttu-id="02aee-149">Quando il primo tipo di riferimento viene creato da un'applicazione, per tale tipo viene allocata memoria nell'indirizzo di base dell'heap gestito.</span><span class="sxs-lookup"><span data-stu-id="02aee-149">When an application creates the first reference type, memory is allocated for the type at the base address of the managed heap.</span></span> <span data-ttu-id="02aee-150">Quando l'oggetto successivo viene creato dall'applicazione, la memoria destinata a tale oggetto viene allocata dal Garbage Collector nello spazio degli indirizzi immediatamente successivo al primo oggetto.</span><span class="sxs-lookup"><span data-stu-id="02aee-150">When the application creates the next object, the garbage collector allocates memory for it in the address space immediately following the first object.</span></span> <span data-ttu-id="02aee-151">Lo spazio per i nuovi oggetti verrà allocato in questo modo dal Garbage Collector fino all'esaurimento dello spazio degli indirizzi.</span><span class="sxs-lookup"><span data-stu-id="02aee-151">As long as address space is available, the garbage collector continues to allocate space for new objects in this manner.</span></span>

<span data-ttu-id="02aee-152">L'allocazione della memoria dall'heap gestito risulta più veloce dell'allocazione di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="02aee-152">Allocating memory from the managed heap is faster than unmanaged memory allocation.</span></span> <span data-ttu-id="02aee-153">Poiché il runtime alloca memoria per un oggetto aggiungendo un valore a un puntatore, è quasi altrettanto veloce dell'allocazione di memoria dallo stack.</span><span class="sxs-lookup"><span data-stu-id="02aee-153">Because the runtime allocates memory for an object by adding a value to a pointer, it's almost as fast as allocating memory from the stack.</span></span> <span data-ttu-id="02aee-154">Poiché inoltre i nuovi oggetti allocati consecutivamente vengono archiviati in modo contiguo nell'heap gestito, un'applicazione può accedere rapidamente agli oggetti.</span><span class="sxs-lookup"><span data-stu-id="02aee-154">In addition, because new objects that are allocated consecutively are stored contiguously in the managed heap, an application can access the objects quickly.</span></span>

### <a name="memory-release"></a><span data-ttu-id="02aee-155">Versione memoria</span><span class="sxs-lookup"><span data-stu-id="02aee-155">Memory release</span></span>

<span data-ttu-id="02aee-156">Il modulo di ottimizzazione del Garbage Collector consente di determinare il momento migliore per l'esecuzione di una raccolta sulla base delle allocazioni in corso.</span><span class="sxs-lookup"><span data-stu-id="02aee-156">The garbage collector's optimizing engine determines the best time to perform a collection based on the allocations being made.</span></span> <span data-ttu-id="02aee-157">Durante l'esecuzione di una raccolta, la memoria per gli oggetti non più utilizzati dall'applicazione viene rilasciata dal Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="02aee-157">When the garbage collector performs a collection, it releases the memory for objects that are no longer being used by the application.</span></span> <span data-ttu-id="02aee-158">Determina quali oggetti non vengono più utilizzati esaminando le *radici*dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="02aee-158">It determines which objects are no longer being used by examining the application's *roots*.</span></span> <span data-ttu-id="02aee-159">Le radici di un'applicazione includono campi statici, variabili e parametri locali su uno stack di thread e registri della CPU.</span><span class="sxs-lookup"><span data-stu-id="02aee-159">An application's roots include static fields, local variables and parameters on a thread's stack, and CPU registers.</span></span> <span data-ttu-id="02aee-160">Ogni radice fa riferimento a un oggetto dell'heap gestito o è impostata su null.</span><span class="sxs-lookup"><span data-stu-id="02aee-160">Each root either refers to an object on the managed heap or is set to null.</span></span> <span data-ttu-id="02aee-161">Garbage Collector ha accesso all'elenco delle radici attive mantenute dal compilatore JIT e dal runtime.</span><span class="sxs-lookup"><span data-stu-id="02aee-161">The garbage collector has access to the list of active roots that the just-in-time (JIT) compiler and the runtime maintain.</span></span> <span data-ttu-id="02aee-162">Utilizzando questo elenco, il Garbage Collector crea un grafico contenente tutti gli oggetti raggiungibili dalle radici.</span><span class="sxs-lookup"><span data-stu-id="02aee-162">Using this list, the garbage collector creates a graph that contains all the objects that are reachable from the roots.</span></span>

<span data-ttu-id="02aee-163">Gli oggetti non inclusi nel grafo non sono raggiungibili dalle radici dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="02aee-163">Objects that are not in the graph are unreachable from the application's roots.</span></span> <span data-ttu-id="02aee-164">Il Garbage Collector considera gli oggetti non raggiungibili Garbage Collection e rilascia la memoria allocata per tali oggetti.</span><span class="sxs-lookup"><span data-stu-id="02aee-164">The garbage collector considers unreachable objects garbage and releases the memory allocated for them.</span></span> <span data-ttu-id="02aee-165">Nel corso di una raccolta, l'heap gestito viene esaminato dal Garbage Collector, alla ricerca dei blocchi di spazi degli indirizzi occupati da oggetti non raggiungibili.</span><span class="sxs-lookup"><span data-stu-id="02aee-165">During a collection, the garbage collector examines the managed heap, looking for the blocks of address space occupied by unreachable objects.</span></span> <span data-ttu-id="02aee-166">Quando un oggetto non raggiungibile viene rilevato, viene utilizzata una funzione di copia della memoria che consente di ricompattare lo spazio allocato per gli oggetti ancora raggiungibili nella memoria, liberando i blocchi di spazi degli indirizzi allocati per oggetti non raggiungibili.</span><span class="sxs-lookup"><span data-stu-id="02aee-166">As it discovers each unreachable object, it uses a memory-copying function to compact the reachable objects in memory, freeing up the blocks of address spaces allocated to unreachable objects.</span></span> <span data-ttu-id="02aee-167">Una volta compattata la memoria per gli oggetti non raggiungibili, il Garbage Collector aggiorna i puntatori agli oggetti ai rispettivi nuovi indirizzi, in modo che le radici dell'applicazione puntino agli oggetti nelle rispettive nuove posizioni.</span><span class="sxs-lookup"><span data-stu-id="02aee-167">Once the memory for the reachable objects has been compacted, the garbage collector makes the necessary pointer corrections so that the application's roots point to the objects in their new locations.</span></span> <span data-ttu-id="02aee-168">Il puntatore relativo all'heap gestito viene inoltre posizionato dopo l'ultimo oggetto non raggiungibile.</span><span class="sxs-lookup"><span data-stu-id="02aee-168">It also positions the managed heap's pointer after the last reachable object.</span></span>

<span data-ttu-id="02aee-169">La memoria viene compattata solo se una raccolta rileva un numero significativo di oggetti non raggiungibili.</span><span class="sxs-lookup"><span data-stu-id="02aee-169">Memory is compacted only if a collection discovers a significant number of unreachable objects.</span></span> <span data-ttu-id="02aee-170">Se tutti gli oggetti dell'heap gestito superano la raccolta, non è necessaria alcuna compressione della memoria.</span><span class="sxs-lookup"><span data-stu-id="02aee-170">If all the objects in the managed heap survive a collection, then there is no need for memory compaction.</span></span>

<span data-ttu-id="02aee-171">Per migliorare le prestazioni, la memoria per oggetti di grandi dimensioni viene allocata da Common Language Runtime in un heap separato.</span><span class="sxs-lookup"><span data-stu-id="02aee-171">To improve performance, the runtime allocates memory for large objects in a separate heap.</span></span> <span data-ttu-id="02aee-172">La memoria per oggetti di grandi dimensioni viene rilasciata automaticamente dal Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="02aee-172">The garbage collector automatically releases the memory for large objects.</span></span> <span data-ttu-id="02aee-173">Tuttavia, per evitare lo trasferimento di oggetti di grandi dimensioni in memoria, questa memoria non viene in genere compattata.</span><span class="sxs-lookup"><span data-stu-id="02aee-173">However, to avoid moving large objects in memory, this memory is usually not compacted.</span></span>

## <a name="conditions-for-a-garbage-collection"></a><span data-ttu-id="02aee-174">Condizioni per un'operazione di Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="02aee-174">Conditions for a garbage collection</span></span>

<span data-ttu-id="02aee-175">Le operazioni di Garbage Collection vengono eseguite in presenza di una delle seguenti condizioni:</span><span class="sxs-lookup"><span data-stu-id="02aee-175">Garbage collection occurs when one of the following conditions is true:</span></span>

- <span data-ttu-id="02aee-176">La memoria fisica del sistema è insufficiente.</span><span class="sxs-lookup"><span data-stu-id="02aee-176">The system has low physical memory.</span></span> <span data-ttu-id="02aee-177">Questa condizione viene rilevata dalla notifica di memoria insufficiente dal sistema operativo o da una memoria insufficiente come indicato dall'host.</span><span class="sxs-lookup"><span data-stu-id="02aee-177">This is detected by either the low memory notification from the OS or low memory as indicated by the host.</span></span>

- <span data-ttu-id="02aee-178">La memoria usata dagli oggetti allocati nell'heap gestito supera una soglia accettabile.</span><span class="sxs-lookup"><span data-stu-id="02aee-178">The memory that's used by allocated objects on the managed heap surpasses an acceptable threshold.</span></span> <span data-ttu-id="02aee-179">Questa soglia viene continuamente modificata durante l'esecuzione del processo.</span><span class="sxs-lookup"><span data-stu-id="02aee-179">This threshold is continuously adjusted as the process runs.</span></span>

- <span data-ttu-id="02aee-180">Viene chiamato il metodo <xref:System.GC.Collect%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="02aee-180">The <xref:System.GC.Collect%2A?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="02aee-181">In quasi tutti i casi, non è necessario chiamare questo metodo, perché il Garbage Collector viene eseguito in modo continuo.</span><span class="sxs-lookup"><span data-stu-id="02aee-181">In almost all cases, you don't have to call this method, because the garbage collector runs continuously.</span></span> <span data-ttu-id="02aee-182">Il metodo viene usato principalmente in situazioni eccezionali e per scopi di test.</span><span class="sxs-lookup"><span data-stu-id="02aee-182">This method is primarily used for unique situations and testing.</span></span>

## <a name="the-managed-heap"></a><span data-ttu-id="02aee-183">Heap gestito</span><span class="sxs-lookup"><span data-stu-id="02aee-183">The managed heap</span></span>

<span data-ttu-id="02aee-184">Dopo essere stato inizializzato da CLR, il Garbage Collector alloca un segmento di memoria per archiviare e gestire oggetti.</span><span class="sxs-lookup"><span data-stu-id="02aee-184">After the garbage collector is initialized by the CLR, it allocates a segment of memory to store and manage objects.</span></span> <span data-ttu-id="02aee-185">Questa memoria è definita heap gestito, in contrapposizione a un heap nativo presente nel sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="02aee-185">This memory is called the managed heap, as opposed to a native heap in the operating system.</span></span>

<span data-ttu-id="02aee-186">Per ogni processo gestito esiste un heap gestito.</span><span class="sxs-lookup"><span data-stu-id="02aee-186">There is a managed heap for each managed process.</span></span> <span data-ttu-id="02aee-187">Tutti i thread nel processo allocano memoria per gli oggetti sullo stesso heap.</span><span class="sxs-lookup"><span data-stu-id="02aee-187">All threads in the process allocate memory for objects on the same heap.</span></span>

<span data-ttu-id="02aee-188">Per riservare memoria, il Garbage Collector chiama la funzione [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) di Windows e riserva un segmento di memoria alla volta per le applicazioni gestite.</span><span class="sxs-lookup"><span data-stu-id="02aee-188">To reserve memory, the garbage collector calls the Windows [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) function and reserves one segment of memory at a time for managed applications.</span></span> <span data-ttu-id="02aee-189">Il Garbage Collector riserva inoltre i segmenti, se necessario, e rilascia i segmenti al sistema operativo (dopo aver cancellato tutti gli oggetti) chiamando la funzione [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) di Windows.</span><span class="sxs-lookup"><span data-stu-id="02aee-189">The garbage collector also reserves segments, as needed, and releases segments back to the operating system (after clearing them of any objects) by calling the Windows [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) function.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="02aee-190">La dimensione dei segmenti allocati dal Garbage Collector è specifica dell'implementazione ed è soggetta a modifiche in qualsiasi momento, tra cui aggiornamenti periodici.</span><span class="sxs-lookup"><span data-stu-id="02aee-190">The size of segments allocated by the garbage collector is implementation-specific and is subject to change at any time, including in periodic updates.</span></span> <span data-ttu-id="02aee-191">L'applicazione non deve dare per scontata o dipendere da una particolare dimensione del segmento, né provare a configurare la quantità di memoria disponibile per le allocazioni di segmenti.</span><span class="sxs-lookup"><span data-stu-id="02aee-191">Your app should never make assumptions about or depend on a particular segment size, nor should it attempt to configure the amount of memory available for segment allocations.</span></span>

<span data-ttu-id="02aee-192">Minore è il numero di oggetti allocati nell'heap, minore sarà il lavoro del Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="02aee-192">The fewer objects allocated on the heap, the less work the garbage collector has to do.</span></span> <span data-ttu-id="02aee-193">Quando si allocano oggetti, non usare valori arrotondati per eccesso che superino le proprie esigenze, ad esempio l'allocazione di una matrice di 32 byte quando sono necessari solo 15 byte.</span><span class="sxs-lookup"><span data-stu-id="02aee-193">When you allocate objects, don't use rounded-up values that exceed your needs, such as allocating an array of 32 bytes when you need only 15 bytes.</span></span>

<span data-ttu-id="02aee-194">Quando viene attivata una Garbage Collection, il Garbage Collector recupera la memoria occupata dagli oggetti inattivi.</span><span class="sxs-lookup"><span data-stu-id="02aee-194">When a garbage collection is triggered, the garbage collector reclaims the memory that's occupied by dead objects.</span></span> <span data-ttu-id="02aee-195">Durante il processo di recupero, gli oggetti attivi vengono compattati in modo da poter essere spostati insieme e lo spazio inutilizzato viene rimosso, riducendo le dimensioni dell'heap.</span><span class="sxs-lookup"><span data-stu-id="02aee-195">The reclaiming process compacts live objects so that they are moved together, and the dead space is removed, thereby making the heap smaller.</span></span> <span data-ttu-id="02aee-196">In questo modo si garantisce che gli oggetti allocati insieme restino insieme nell'heap gestito per conservarne la località.</span><span class="sxs-lookup"><span data-stu-id="02aee-196">This ensures that objects that are allocated together stay together on the managed heap to preserve their locality.</span></span>

<span data-ttu-id="02aee-197">L'impatto (frequenza e durata) delle operazioni di Garbage Collection è il risultato del volume di allocazioni e della quantità di memoria esclusa nell'heap gestito.</span><span class="sxs-lookup"><span data-stu-id="02aee-197">The intrusiveness (frequency and duration) of garbage collections is the result of the volume of allocations and the amount of survived memory on the managed heap.</span></span>

<span data-ttu-id="02aee-198">L'heap può essere considerato l'insieme di due heap: l'[heap degli oggetti grandi](large-object-heap.md) e l'heap degli oggetti piccoli.</span><span class="sxs-lookup"><span data-stu-id="02aee-198">The heap can be considered as the accumulation of two heaps: the [large object heap](large-object-heap.md) and the small object heap.</span></span> <span data-ttu-id="02aee-199">L'heap degli oggetti grandi contiene oggetti di 85.000 byte e più grandi, che sono in genere matrici.</span><span class="sxs-lookup"><span data-stu-id="02aee-199">The large object heap contains objects that are 85,000 bytes and larger, which are usually arrays.</span></span> <span data-ttu-id="02aee-200">È raro che un oggetto istanza sia estremamente grande.</span><span class="sxs-lookup"><span data-stu-id="02aee-200">It's rare for an instance object to be extremely large.</span></span>

> [!TIP]
> <span data-ttu-id="02aee-201">È possibile [configurare le dimensioni della soglia](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold) per gli oggetti da usare nell'heap degli oggetti grandi.</span><span class="sxs-lookup"><span data-stu-id="02aee-201">You can [configure the threshold size](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold) for objects to go on the large object heap.</span></span>

## <a name="generations"></a><span data-ttu-id="02aee-202">Generazioni</span><span class="sxs-lookup"><span data-stu-id="02aee-202">Generations</span></span>

<span data-ttu-id="02aee-203">L'algoritmo GC si basa su diverse considerazioni:</span><span class="sxs-lookup"><span data-stu-id="02aee-203">The GC algorithm is based on several considerations:</span></span>

- <span data-ttu-id="02aee-204">È più veloce compattare la memoria per una parte dell'heap gestito rispetto all'intero heap gestito.</span><span class="sxs-lookup"><span data-stu-id="02aee-204">It's faster to compact the memory for a portion of the managed heap than for the entire managed heap.</span></span>
- <span data-ttu-id="02aee-205">Gli oggetti più recenti hanno una durata più breve e gli oggetti meno recenti hanno una durata maggiore.</span><span class="sxs-lookup"><span data-stu-id="02aee-205">Newer objects have shorter lifetimes and older objects have longer lifetimes.</span></span>
- <span data-ttu-id="02aee-206">Gli oggetti più recenti tendono a essere correlati gli uni agli altri e a cui l'applicazione accede più a lungo.</span><span class="sxs-lookup"><span data-stu-id="02aee-206">Newer objects tend to be related to each other and accessed by the application around the same time.</span></span>

<span data-ttu-id="02aee-207">Il processo di Garbage Collection si verifica principalmente con il recupero di oggetti di breve durata.</span><span class="sxs-lookup"><span data-stu-id="02aee-207">Garbage collection primarily occurs with the reclamation of short-lived objects.</span></span> <span data-ttu-id="02aee-208">Per ottimizzare le prestazioni dell'Garbage Collector, l'heap gestito è diviso in tre generazioni, 0, 1 e 2, in modo da poter gestire oggetti di lunga durata e di breve durata separatamente.</span><span class="sxs-lookup"><span data-stu-id="02aee-208">To optimize the performance of the garbage collector, the managed heap is divided into three generations, 0, 1, and 2, so it can handle long-lived and short-lived objects separately.</span></span> <span data-ttu-id="02aee-209">Il Garbage Collector archivia nuovi oggetti nella generazione 0.</span><span class="sxs-lookup"><span data-stu-id="02aee-209">The garbage collector stores new objects in generation 0.</span></span> <span data-ttu-id="02aee-210">Gli oggetti creati nelle prime fasi della durata dell'applicazione che non vengono raccolti vengono promossi e archiviati nelle generazioni 1 e 2.</span><span class="sxs-lookup"><span data-stu-id="02aee-210">Objects created early in the application's lifetime that survive collections are promoted and stored in generations 1 and 2.</span></span> <span data-ttu-id="02aee-211">Poiché è più veloce comprimere una parte dell'heap gestito rispetto all'intero heap, questo schema consente al Garbage Collector di rilasciare la memoria in una determinata generazione anziché rilasciare la memoria per l'intero heap gestito ogni volta che viene eseguita una raccolta.</span><span class="sxs-lookup"><span data-stu-id="02aee-211">Because it's faster to compact a portion of the managed heap than the entire heap, this scheme allows the garbage collector to release the memory in a specific generation rather than release the memory for the entire managed heap each time it performs a collection.</span></span>

- <span data-ttu-id="02aee-212">**Generazione 0**.</span><span class="sxs-lookup"><span data-stu-id="02aee-212">**Generation 0**.</span></span> <span data-ttu-id="02aee-213">È la generazione più recente e contiene oggetti di breve durata.</span><span class="sxs-lookup"><span data-stu-id="02aee-213">This is the youngest generation and contains short-lived objects.</span></span> <span data-ttu-id="02aee-214">Un esempio di oggetto di breve durata è una variabile temporanea.</span><span class="sxs-lookup"><span data-stu-id="02aee-214">An example of a short-lived object is a temporary variable.</span></span> <span data-ttu-id="02aee-215">Le operazioni di Garbage Collection vengono eseguite il più delle volte in questa generazione.</span><span class="sxs-lookup"><span data-stu-id="02aee-215">Garbage collection occurs most frequently in this generation.</span></span>

  <span data-ttu-id="02aee-216">Gli oggetti appena allocati formano una nuova generazione di oggetti e sono implicitamente raccolte di generazione 0.</span><span class="sxs-lookup"><span data-stu-id="02aee-216">Newly allocated objects form a new generation of objects and are implicitly generation 0 collections.</span></span> <span data-ttu-id="02aee-217">Tuttavia, se si tratta di oggetti di grandi dimensioni, vengono inseriti nell'heap degli oggetti grandi (LOH), a volte definito *generazione 3*.</span><span class="sxs-lookup"><span data-stu-id="02aee-217">However, if they are large objects, they go on the large object heap (LOH), which is sometimes referred to as *generation 3*.</span></span> <span data-ttu-id="02aee-218">Generazione 3 è una generazione fisica che viene raccolta logicamente come parte della generazione 2.</span><span class="sxs-lookup"><span data-stu-id="02aee-218">Generation 3 is a physical generation that's logically collected as part of generation 2.</span></span>

  <span data-ttu-id="02aee-219">La maggior parte degli oggetti vengono recuperati per Garbage Collection nella generazione 0 e non sopravvivono alla prossima generazione.</span><span class="sxs-lookup"><span data-stu-id="02aee-219">Most objects are reclaimed for garbage collection in generation 0 and don't survive to the next generation.</span></span>
  
  <span data-ttu-id="02aee-220">Se un'applicazione tenta di creare un nuovo oggetto quando la generazione 0 è piena, il Garbage Collector esegue una raccolta in un tentativo di liberare spazio degli indirizzi per l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="02aee-220">If an application attempts to create a new object when generation 0 is full, the garbage collector performs a collection in an attempt to free address space for the object.</span></span> <span data-ttu-id="02aee-221">Il Garbage Collector esamina prima di tutto gli oggetti presenti nella generazione 0, anziché tutti gli oggetti presenti nell'heap gestito.</span><span class="sxs-lookup"><span data-stu-id="02aee-221">The garbage collector starts by examining the objects in generation 0 rather than all objects in the managed heap.</span></span> <span data-ttu-id="02aee-222">Una raccolta di sola generazione 0 recupera spesso memoria sufficiente per consentire all'applicazione di continuare a creare nuovi oggetti.</span><span class="sxs-lookup"><span data-stu-id="02aee-222">A collection of generation 0 alone often reclaims enough memory to enable the application to continue creating new objects.</span></span>

- <span data-ttu-id="02aee-223">**Generazione 1**.</span><span class="sxs-lookup"><span data-stu-id="02aee-223">**Generation 1**.</span></span> <span data-ttu-id="02aee-224">Questa generazione contiene oggetti di breve durata e funge da buffer tra gli oggetti di breve durata e gli oggetti di lunga durata.</span><span class="sxs-lookup"><span data-stu-id="02aee-224">This generation contains short-lived objects and serves as a buffer between short-lived objects and long-lived objects.</span></span>

  <span data-ttu-id="02aee-225">Dopo che il Garbage Collector esegue una raccolta della generazione 0, comprime la memoria per gli oggetti raggiungibili e li promuove alla generazione 1.</span><span class="sxs-lookup"><span data-stu-id="02aee-225">After the garbage collector performs a collection of generation 0, it compacts the memory for the reachable objects and promotes them to generation 1.</span></span> <span data-ttu-id="02aee-226">Poiché la durata degli oggetti non raccolti è solitamente più lunga, la promozione a una generazione superiore risulta opportuna.</span><span class="sxs-lookup"><span data-stu-id="02aee-226">Because objects that survive collections tend to have longer lifetimes, it makes sense to promote them to a higher generation.</span></span> <span data-ttu-id="02aee-227">Il Garbage Collector non deve riesaminare gli oggetti nelle generazioni 1 e 2 ogni volta che viene eseguita una raccolta di generazione 0.</span><span class="sxs-lookup"><span data-stu-id="02aee-227">The garbage collector doesn't have to reexamine the objects in generations 1 and 2 each time it performs a collection of generation 0.</span></span>
  
  <span data-ttu-id="02aee-228">Se una raccolta di generazione 0 non recupera memoria sufficiente per l'applicazione per la creazione di un nuovo oggetto, il Garbage Collector può eseguire una raccolta di generazione 1, quindi generazione 2.</span><span class="sxs-lookup"><span data-stu-id="02aee-228">If a collection of generation 0 does not reclaim enough memory for the application to create a new object, the garbage collector can perform a collection of generation 1, then generation 2.</span></span> <span data-ttu-id="02aee-229">Gli oggetti presenti nella generazione 1 non raccolti vengono promossi alla generazione 2.</span><span class="sxs-lookup"><span data-stu-id="02aee-229">Objects in generation 1 that survive collections are promoted to generation 2.</span></span>

- <span data-ttu-id="02aee-230">**Generazione 2**.</span><span class="sxs-lookup"><span data-stu-id="02aee-230">**Generation 2**.</span></span> <span data-ttu-id="02aee-231">Questa generazione contiene oggetti di lunga durata.</span><span class="sxs-lookup"><span data-stu-id="02aee-231">This generation contains long-lived objects.</span></span> <span data-ttu-id="02aee-232">Un esempio di oggetto di lunga durata è un oggetto in un'applicazione server contenente dati statici attivi per tutta la durata del processo.</span><span class="sxs-lookup"><span data-stu-id="02aee-232">An example of a long-lived object is an object in a server application that contains static data that's live for the duration of the process.</span></span>

  <span data-ttu-id="02aee-233">Gli oggetti della generazione 2 che sopravvivono a una raccolta rimangono nella generazione 2 fino a quando non vengono determinati come irraggiungibili in una raccolta futura.</span><span class="sxs-lookup"><span data-stu-id="02aee-233">Objects in generation 2 that survive a collection remain in generation 2 until they are determined to be unreachable in a future collection.</span></span>
  
  <span data-ttu-id="02aee-234">Gli oggetti nell'heap degli oggetti grandi (a volte definito *generazione 3*) vengono raccolti anche nella generazione 2.</span><span class="sxs-lookup"><span data-stu-id="02aee-234">Objects on the large object heap (which is sometimes referred to as *generation 3*) are also collected in generation 2.</span></span>

<span data-ttu-id="02aee-235">Le operazioni di Garbage Collection vengono eseguite in generazioni specifiche a seconda delle condizioni.</span><span class="sxs-lookup"><span data-stu-id="02aee-235">Garbage collections occur on specific generations as conditions warrant.</span></span> <span data-ttu-id="02aee-236">Raccogliere una generazione significa raccogliere gli oggetti in quella generazione e in tutte le generazioni più recenti.</span><span class="sxs-lookup"><span data-stu-id="02aee-236">Collecting a generation means collecting objects in that generation and all its younger generations.</span></span> <span data-ttu-id="02aee-237">Una Garbage Collection di generazione 2 è nota anche come Garbage Collection completa, in quanto recupera gli oggetti in tutte le generazioni, ovvero tutti gli oggetti nell'heap gestito.</span><span class="sxs-lookup"><span data-stu-id="02aee-237">A generation 2 garbage collection is also known as a full garbage collection, because it reclaims objects in all generations (that is, all objects in the managed heap).</span></span>

### <a name="survival-and-promotions"></a><span data-ttu-id="02aee-238">Esclusione e promozioni</span><span class="sxs-lookup"><span data-stu-id="02aee-238">Survival and promotions</span></span>

<span data-ttu-id="02aee-239">Gli oggetti che non vengono recuperati in una Garbage Collection sono noti come superstiti e vengono promossi alla generazione successiva:</span><span class="sxs-lookup"><span data-stu-id="02aee-239">Objects that are not reclaimed in a garbage collection are known as survivors and are promoted to the next generation:</span></span>

- <span data-ttu-id="02aee-240">Gli oggetti che sopravvivono a un Garbage Collection di generazione 0 vengono promossi alla generazione 1.</span><span class="sxs-lookup"><span data-stu-id="02aee-240">Objects that survive a generation 0 garbage collection are promoted to generation 1.</span></span>
- <span data-ttu-id="02aee-241">Gli oggetti che sopravvivono a un Garbage Collection di generazione 1 vengono promossi alla generazione 2.</span><span class="sxs-lookup"><span data-stu-id="02aee-241">Objects that survive a generation 1 garbage collection are promoted to generation 2.</span></span>
- <span data-ttu-id="02aee-242">Gli oggetti che sopravvivono a una generazione 2 Garbage Collection rimangono nella generazione 2.</span><span class="sxs-lookup"><span data-stu-id="02aee-242">Objects that survive a generation 2 garbage collection remain in generation 2.</span></span>

<span data-ttu-id="02aee-243">Quando il Garbage Collector rileva che il tasso di sopravvivenza è elevato in una generazione, aumenta la soglia delle allocazioni per tale generazione.</span><span class="sxs-lookup"><span data-stu-id="02aee-243">When the garbage collector detects that the survival rate is high in a generation, it increases the threshold of allocations for that generation.</span></span> <span data-ttu-id="02aee-244">La raccolta successiva ottiene una dimensione sostanziale della memoria recuperata.</span><span class="sxs-lookup"><span data-stu-id="02aee-244">The next collection gets a substantial size of reclaimed memory.</span></span> <span data-ttu-id="02aee-245">CLR bilancia continuamente due priorità: non consentire a un working set di un'applicazione di essere troppo grande ritardando Garbage Collection e non consentendo l'esecuzione troppo frequente dei Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="02aee-245">The CLR continually balances two priorities: not letting an application's working set get too large by delaying garbage collection and not letting the garbage collection run too frequently.</span></span>

### <a name="ephemeral-generations-and-segments"></a><span data-ttu-id="02aee-246">Generazioni e segmenti temporanei</span><span class="sxs-lookup"><span data-stu-id="02aee-246">Ephemeral generations and segments</span></span>

<span data-ttu-id="02aee-247">Poiché gli oggetti nelle generazioni 0 e 1 sono di breve durata, queste generazioni sono note come *generazioni effimere*.</span><span class="sxs-lookup"><span data-stu-id="02aee-247">Because objects in generations 0 and 1 are short-lived, these generations are known as the *ephemeral generations*.</span></span>

<span data-ttu-id="02aee-248">Le generazioni effimere vengono allocate nel segmento di memoria noto come segmento temporaneo.</span><span class="sxs-lookup"><span data-stu-id="02aee-248">Ephemeral generations are allocated in the memory segment that's known as the ephemeral segment.</span></span> <span data-ttu-id="02aee-249">Ogni nuovo segmento acquisito dal Garbage Collector diventa il nuovo segmento temporaneo e contiene gli oggetti esclusi da un'operazione di Garbage Collection di generazione 0.</span><span class="sxs-lookup"><span data-stu-id="02aee-249">Each new segment acquired by the garbage collector becomes the new ephemeral segment and contains the objects that survived a generation 0 garbage collection.</span></span> <span data-ttu-id="02aee-250">Il segmento temporaneo precedente diventa il nuovo segmento di generazione 2.</span><span class="sxs-lookup"><span data-stu-id="02aee-250">The old ephemeral segment becomes the new generation 2 segment.</span></span>

<span data-ttu-id="02aee-251">La dimensione del segmento temporaneo varia a seconda che un sistema sia a 32 bit o a 64 bit e sul tipo di Garbage Collector in esecuzione ([GC workstation o server](workstation-server-gc.md)).</span><span class="sxs-lookup"><span data-stu-id="02aee-251">The size of the ephemeral segment varies depending on whether a system is 32-bit or 64-bit and on the type of garbage collector it is running ([workstation or server GC](workstation-server-gc.md)).</span></span> <span data-ttu-id="02aee-252">La tabella seguente mostra le dimensioni predefinite del segmento temporaneo.</span><span class="sxs-lookup"><span data-stu-id="02aee-252">The following table shows the default sizes of the ephemeral segment.</span></span>

|<span data-ttu-id="02aee-253">GC workstation/server</span><span class="sxs-lookup"><span data-stu-id="02aee-253">Workstation/server GC</span></span>|<span data-ttu-id="02aee-254">32 bit</span><span class="sxs-lookup"><span data-stu-id="02aee-254">32-bit</span></span>|<span data-ttu-id="02aee-255">64 bit</span><span class="sxs-lookup"><span data-stu-id="02aee-255">64-bit</span></span>|
|-|-------------|-------------|
|<span data-ttu-id="02aee-256">GC workstation</span><span class="sxs-lookup"><span data-stu-id="02aee-256">Workstation GC</span></span>|<span data-ttu-id="02aee-257">16 MB</span><span class="sxs-lookup"><span data-stu-id="02aee-257">16 MB</span></span>|<span data-ttu-id="02aee-258">256 MB</span><span class="sxs-lookup"><span data-stu-id="02aee-258">256 MB</span></span>|
|<span data-ttu-id="02aee-259">GC server</span><span class="sxs-lookup"><span data-stu-id="02aee-259">Server GC</span></span>|<span data-ttu-id="02aee-260">64 MB</span><span class="sxs-lookup"><span data-stu-id="02aee-260">64 MB</span></span>|<span data-ttu-id="02aee-261">4 GB</span><span class="sxs-lookup"><span data-stu-id="02aee-261">4 GB</span></span>|
|<span data-ttu-id="02aee-262">GC server con > 4 CPU logiche</span><span class="sxs-lookup"><span data-stu-id="02aee-262">Server GC with > 4 logical CPUs</span></span>|<span data-ttu-id="02aee-263">32 MB</span><span class="sxs-lookup"><span data-stu-id="02aee-263">32 MB</span></span>|<span data-ttu-id="02aee-264">2 GB</span><span class="sxs-lookup"><span data-stu-id="02aee-264">2 GB</span></span>|
|<span data-ttu-id="02aee-265">GC server con > 8 CPU logiche</span><span class="sxs-lookup"><span data-stu-id="02aee-265">Server GC with > 8 logical CPUs</span></span>|<span data-ttu-id="02aee-266">16 MB</span><span class="sxs-lookup"><span data-stu-id="02aee-266">16 MB</span></span>|<span data-ttu-id="02aee-267">1 GB</span><span class="sxs-lookup"><span data-stu-id="02aee-267">1 GB</span></span>|

<span data-ttu-id="02aee-268">Il segmento temporaneo può includere oggetti di generazione 2,</span><span class="sxs-lookup"><span data-stu-id="02aee-268">The ephemeral segment can include generation 2 objects.</span></span> <span data-ttu-id="02aee-269">i quali possono usare più segmenti (nella misura richiesta dal processo e consentita dalla memoria).</span><span class="sxs-lookup"><span data-stu-id="02aee-269">Generation 2 objects can use multiple segments (as many as your process requires and memory allows for).</span></span>

<span data-ttu-id="02aee-270">La quantità di memoria liberata da un'operazione di Garbage Collection temporanea è limitata alla dimensione del segmento temporaneo.</span><span class="sxs-lookup"><span data-stu-id="02aee-270">The amount of freed memory from an ephemeral garbage collection is limited to the size of the ephemeral segment.</span></span> <span data-ttu-id="02aee-271">Tale quantità di memoria è proporzionale allo spazio occupato dagli oggetti inutilizzati.</span><span class="sxs-lookup"><span data-stu-id="02aee-271">The amount of memory that is freed is proportional to the space that was occupied by the dead objects.</span></span>

## <a name="what-happens-during-a-garbage-collection"></a><span data-ttu-id="02aee-272">Fasi di un'operazione di Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="02aee-272">What happens during a garbage collection</span></span>

<span data-ttu-id="02aee-273">Un'operazione di Garbage Collection si compone delle seguenti fasi:</span><span class="sxs-lookup"><span data-stu-id="02aee-273">A garbage collection has the following phases:</span></span>

- <span data-ttu-id="02aee-274">Una fase di contrassegno in cui vengono individuati tutti gli oggetti attivi e ne viene creato un elenco.</span><span class="sxs-lookup"><span data-stu-id="02aee-274">A marking phase that finds and creates a list of all live objects.</span></span>

- <span data-ttu-id="02aee-275">Una fase di rilocazione in cui vengono aggiornati i riferimenti agli oggetti che saranno compattati.</span><span class="sxs-lookup"><span data-stu-id="02aee-275">A relocating phase that updates the references to the objects that will be compacted.</span></span>

- <span data-ttu-id="02aee-276">Una fase di compattazione in cui lo spazio occupato dagli oggetti inutilizzati viene recuperato e gli oggetti esclusi compattati.</span><span class="sxs-lookup"><span data-stu-id="02aee-276">A compacting phase that reclaims the space occupied by the dead objects and compacts the surviving objects.</span></span> <span data-ttu-id="02aee-277">Durante questa fase, gli oggetti rimasti dopo un'operazione di Garbage Collection vengono spostati verso l'estremità meno recente del segmento.</span><span class="sxs-lookup"><span data-stu-id="02aee-277">The compacting phase moves objects that have survived a garbage collection toward the older end of the segment.</span></span>

  <span data-ttu-id="02aee-278">Poiché le raccolte di generazione 2 possono occupare più segmenti, gli oggetti promossi alla generazione 2 possono essere spostati in un segmento meno recente.</span><span class="sxs-lookup"><span data-stu-id="02aee-278">Because generation 2 collections can occupy multiple segments, objects that are promoted into generation 2 can be moved into an older segment.</span></span> <span data-ttu-id="02aee-279">Gli oggetti esclusi di generazione 1 e 2 possono essere spostati in un segmento diverso, in quanto vengono promossi alla generazione 2.</span><span class="sxs-lookup"><span data-stu-id="02aee-279">Both generation 1 and generation 2 survivors can be moved to a different segment, because they are promoted to generation 2.</span></span>

  <span data-ttu-id="02aee-280">In genere, l'heap degli oggetti grandi (LOH) non viene compattato, perché la copia di oggetti di grandi dimensioni impone una riduzione delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="02aee-280">Ordinarily, the large object heap (LOH) is not compacted, because copying large objects imposes a performance penalty.</span></span> <span data-ttu-id="02aee-281">Tuttavia, in .NET Core e in .NET Framework 4.5.1 e versioni successive, è possibile usare la <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> proprietà per comprimere l'heap oggetti grandi su richiesta.</span><span class="sxs-lookup"><span data-stu-id="02aee-281">However, in .NET Core and in .NET Framework 4.5.1 and later, you can use the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to compact the large object heap on demand.</span></span> <span data-ttu-id="02aee-282">Inoltre, l'heap oggetti grandi viene compattato automaticamente quando si imposta un limite rigido specificando uno dei seguenti valori:</span><span class="sxs-lookup"><span data-stu-id="02aee-282">In addition, the LOH is automatically compacted when a hard limit is set by specifying either:</span></span>

  - <span data-ttu-id="02aee-283">Limite di memoria per un contenitore.</span><span class="sxs-lookup"><span data-stu-id="02aee-283">A memory limit on a container.</span></span>
  - <span data-ttu-id="02aee-284">Opzioni di configurazione della fase di esecuzione [GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitcomplus_gcheaphardlimit) o [GCHeapHardLimitPercent](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitpercentcomplus_gcheaphardlimitpercent) .</span><span class="sxs-lookup"><span data-stu-id="02aee-284">The [GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitcomplus_gcheaphardlimit) or [GCHeapHardLimitPercent](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitpercentcomplus_gcheaphardlimitpercent) run-time configuration options.</span></span>

<span data-ttu-id="02aee-285">Per stabilire se gli oggetti sono attivi, il Garbage Collector usa le seguenti informazioni:</span><span class="sxs-lookup"><span data-stu-id="02aee-285">The garbage collector uses the following information to determine whether objects are live:</span></span>

- <span data-ttu-id="02aee-286">**Radici dello stack**.</span><span class="sxs-lookup"><span data-stu-id="02aee-286">**Stack roots**.</span></span> <span data-ttu-id="02aee-287">Variabili dello stack fornite dal compilatore JIT e dal percorso di chiamate nello stack.</span><span class="sxs-lookup"><span data-stu-id="02aee-287">Stack variables provided by the just-in-time (JIT) compiler and stack walker.</span></span> <span data-ttu-id="02aee-288">Le ottimizzazioni JIT possono allungare o ridurre le aree di codice in cui vengono segnalate le variabili dello stack al Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="02aee-288">JIT optimizations can lengthen or shorten regions of code within which stack variables are reported to the garbage collector.</span></span>

- <span data-ttu-id="02aee-289">**Handle di Garbage Collection**.</span><span class="sxs-lookup"><span data-stu-id="02aee-289">**Garbage collection handles**.</span></span> <span data-ttu-id="02aee-290">Handle che puntano agli oggetti gestiti e che possono essere allocati mediante codice utente o Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="02aee-290">Handles that point to managed objects and that can be allocated by user code or by the common language runtime.</span></span>

- <span data-ttu-id="02aee-291">**Dati statici**.</span><span class="sxs-lookup"><span data-stu-id="02aee-291">**Static data**.</span></span> <span data-ttu-id="02aee-292">Oggetti statici nei domini applicazione che possono fare riferimento ad altri oggetti.</span><span class="sxs-lookup"><span data-stu-id="02aee-292">Static objects in application domains that could be referencing other objects.</span></span> <span data-ttu-id="02aee-293">Ogni dominio applicazione tiene traccia dei rispettivi oggetti statici.</span><span class="sxs-lookup"><span data-stu-id="02aee-293">Each application domain keeps track of its static objects.</span></span>

<span data-ttu-id="02aee-294">Prima di eseguire un'operazione di Garbage Collection, tutti i thread gestiti vengono sospesi, eccetto il thread che attiva l'operazione.</span><span class="sxs-lookup"><span data-stu-id="02aee-294">Before a garbage collection starts, all managed threads are suspended except for the thread that triggered the garbage collection.</span></span>

<span data-ttu-id="02aee-295">Nell'illustrazione seguente viene illustrato un thread che attiva un'operazione di Garbage Collection causando la sospensione degli altri thread.</span><span class="sxs-lookup"><span data-stu-id="02aee-295">The following illustration shows a thread that triggers a garbage collection and causes the other threads to be suspended.</span></span>

![Thread che attiva un'operazione di Garbage Collection](media/gc-triggered.png)

## <a name="unmanaged-resources"></a><span data-ttu-id="02aee-297">Risorse non gestite</span><span class="sxs-lookup"><span data-stu-id="02aee-297">Unmanaged resources</span></span>

<span data-ttu-id="02aee-298">Per la maggior parte degli oggetti creati dall'applicazione, è possibile fare affidamento su Garbage Collection per eseguire automaticamente le attività di gestione della memoria necessarie.</span><span class="sxs-lookup"><span data-stu-id="02aee-298">For most of the objects that your application creates, you can rely on garbage collection to automatically perform the necessary memory management tasks.</span></span> <span data-ttu-id="02aee-299">Per le risorse non gestite è tuttavia necessario il rilascio esplicito.</span><span class="sxs-lookup"><span data-stu-id="02aee-299">However, unmanaged resources require explicit cleanup.</span></span> <span data-ttu-id="02aee-300">Il tipo più comune di risorsa non gestita è rappresentato da un oggetto che esegue il wrapping di una risorsa del sistema operativo, quale un handle di file, un handle di finestra o una connessione di rete.</span><span class="sxs-lookup"><span data-stu-id="02aee-300">The most common type of unmanaged resource is an object that wraps an operating system resource, such as a file handle, window handle, or network connection.</span></span> <span data-ttu-id="02aee-301">Sebbene il Garbage Collector sia in grado di tenere traccia della durata di un oggetto gestito che incapsula una risorsa non gestita, non ha informazioni specifiche su come pulire la risorsa.</span><span class="sxs-lookup"><span data-stu-id="02aee-301">Although the garbage collector is able to track the lifetime of a managed object that encapsulates an unmanaged resource, it doesn't have specific knowledge about how to clean up the resource.</span></span>

<span data-ttu-id="02aee-302">Quando si crea un oggetto che incapsula una risorsa non gestita, è consigliabile specificare il codice necessario per pulire la risorsa non gestita in un `Dispose` Metodo pubblico.</span><span class="sxs-lookup"><span data-stu-id="02aee-302">When you create an object that encapsulates an unmanaged resource, it's recommended that you provide the necessary code to clean up the unmanaged resource in a public `Dispose` method.</span></span> <span data-ttu-id="02aee-303">Specificando un metodo `Dispose` si consente agli utenti dell'oggetto di liberarne esplicitamente la memoria dopo l'uso dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="02aee-303">By providing a `Dispose` method, you enable users of your object to explicitly free its memory when they are finished with the object.</span></span> <span data-ttu-id="02aee-304">Quando si usa un oggetto che incapsula una risorsa non gestita, assicurarsi di chiamare `Dispose` se necessario.</span><span class="sxs-lookup"><span data-stu-id="02aee-304">When you use an object that encapsulates an unmanaged resource, make sure to call `Dispose` as necessary.</span></span>

<span data-ttu-id="02aee-305">È inoltre necessario fornire un modo per rilasciare le risorse non gestite nel caso in cui un consumer del tipo dimentichi di chiamare `Dispose` .</span><span class="sxs-lookup"><span data-stu-id="02aee-305">You must also provide a way for your unmanaged resources to be released in case a consumer of your type forgets to call `Dispose`.</span></span> <span data-ttu-id="02aee-306">È possibile utilizzare un handle sicuro per eseguire il wrapping della risorsa non gestita oppure eseguire l'override del <xref:System.Object.Finalize?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="02aee-306">You can either use a safe handle to wrap the unmanaged resource, or override the <xref:System.Object.Finalize?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="02aee-307">Per altre informazioni sulla pulizia di risorse non gestite, vedere [pulire le risorse non gestite](unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="02aee-307">For more information about cleaning up unmanaged resources, see [Clean up unmanaged resources](unmanaged.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="02aee-308">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="02aee-308">See also</span></span>

- [<span data-ttu-id="02aee-309">Operazione di Garbage Collection per workstation e server</span><span class="sxs-lookup"><span data-stu-id="02aee-309">Workstation and server garbage collection</span></span>](workstation-server-gc.md)
- [<span data-ttu-id="02aee-310">Garbage Collection in background</span><span class="sxs-lookup"><span data-stu-id="02aee-310">Background garbage collection</span></span>](background-gc.md)
- [<span data-ttu-id="02aee-311">Opzioni di configurazione per GC</span><span class="sxs-lookup"><span data-stu-id="02aee-311">Configuration options for GC</span></span>](../../core/run-time-config/garbage-collector.md)
- [<span data-ttu-id="02aee-312">Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="02aee-312">Garbage collection</span></span>](index.md)
