---
title: Platform Invoke (P/Invoke)
description: Informazioni su come chiamare funzioni native tramite P/Invoke in .NET.
ms.date: 01/18/2019
ms.openlocfilehash: fa8b43edfba50fbc620f257c4e7caf1673f83235
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/07/2020
ms.locfileid: "75706305"
---
# <a name="platform-invoke-pinvoke"></a><span data-ttu-id="591b4-103">Platform Invoke (P/Invoke)</span><span class="sxs-lookup"><span data-stu-id="591b4-103">Platform Invoke (P/Invoke)</span></span>

<span data-ttu-id="591b4-104">P/Invoke è una tecnologia che consente di accedere dal codice gestito a struct, callback e funzioni presenti in librerie non gestite.</span><span class="sxs-lookup"><span data-stu-id="591b4-104">P/Invoke is a technology that allows you to access structs, callbacks, and functions in unmanaged libraries from your managed code.</span></span> <span data-ttu-id="591b4-105">La maggior parte delle API di P/Invoke è contenuta in due spazi dei nomi: `System` e `System.Runtime.InteropServices`.</span><span class="sxs-lookup"><span data-stu-id="591b4-105">Most of the P/Invoke API is contained in two namespaces: `System` and `System.Runtime.InteropServices`.</span></span> <span data-ttu-id="591b4-106">Usando questi due spazi dei nomi si ottengono gli strumenti per descrivere il modo in cui si vuole comunicare con il componente nativo.</span><span class="sxs-lookup"><span data-stu-id="591b4-106">Using these two namespaces give you the tools to describe how you want to communicate with the native component.</span></span>

<span data-ttu-id="591b4-107">Per iniziare viene mostrato l'esempio più comune, ovvero la chiamata di funzioni non gestite nel codice gestito.</span><span class="sxs-lookup"><span data-stu-id="591b4-107">Let’s start from the most common example, and that is calling unmanaged functions in your managed code.</span></span> <span data-ttu-id="591b4-108">Di seguito viene visualizzata una finestra di messaggio da un'applicazione della riga di comando:</span><span class="sxs-lookup"><span data-stu-id="591b4-108">Let’s show a message box from a command-line application:</span></span>

[!code-csharp[MessageBox](~/samples/snippets/standard/interop/pinvoke/messagebox.cs)]

<span data-ttu-id="591b4-109">L'esempio precedente è semplice, ma mostra chiaramente gli elementi necessari per richiamare funzioni non gestite da codice gestito.</span><span class="sxs-lookup"><span data-stu-id="591b4-109">The previous example is simple, but it does show off what's needed to invoke unmanaged functions from managed code.</span></span> <span data-ttu-id="591b4-110">Di seguito l'esempio viene descritto in modo dettagliato:</span><span class="sxs-lookup"><span data-stu-id="591b4-110">Let’s step through the example:</span></span>

- <span data-ttu-id="591b4-111">La riga 1 mostra l'istruzione using per lo spazio dei nomi `System.Runtime.InteropServices` contenente tutti gli elementi necessari.</span><span class="sxs-lookup"><span data-stu-id="591b4-111">Line #1 shows the using statement for the `System.Runtime.InteropServices` namespace that holds all the items needed.</span></span>
- <span data-ttu-id="591b4-112">La riga 7 introduce l'attributo `DllImport`.</span><span class="sxs-lookup"><span data-stu-id="591b4-112">Line #7 introduces the `DllImport` attribute.</span></span> <span data-ttu-id="591b4-113">Questo attributo è fondamentale, in quanto comunica al runtime che deve caricare la DLL non gestita.</span><span class="sxs-lookup"><span data-stu-id="591b4-113">This attribute is crucial, as it tells the runtime that it should load the unmanaged DLL.</span></span> <span data-ttu-id="591b4-114">La stringa passata è la DLL che contiene la funzione di destinazione.</span><span class="sxs-lookup"><span data-stu-id="591b4-114">The string passed in is the DLL our target function is in.</span></span> <span data-ttu-id="591b4-115">Specifica anche quale [set di caratteri](./charset.md) usare per il marshalling delle stringhe.</span><span class="sxs-lookup"><span data-stu-id="591b4-115">Additionally, it specifies which [character set](./charset.md) to use for marshalling the strings.</span></span> <span data-ttu-id="591b4-116">Indica infine che questa funzione chiama [SetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror) e che il runtime deve acquisire il codice di errore in modo che l'utente possa recuperarlo tramite <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="591b4-116">Finally, it specifies that this function calls [SetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror) and that the runtime should capture that error code so the user can retrieve it via <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="591b4-117">La riga 8 è il punto cruciale dell'attività di P/Invoke.</span><span class="sxs-lookup"><span data-stu-id="591b4-117">Line #8 is the crux of the P/Invoke work.</span></span> <span data-ttu-id="591b4-118">Definisce un metodo gestito che ha **esattamente la stessa firma** del metodo non gestito.</span><span class="sxs-lookup"><span data-stu-id="591b4-118">It defines a managed method that has the **exact same signature** as the unmanaged one.</span></span> <span data-ttu-id="591b4-119">Come è possibile notare, la dichiarazione dispone di una nuova parola chiave, `extern`, che indica al runtime che si tratta di un metodo esterno. Quando si richiama tale metodo, il runtime dovrebbe individuarlo nella DLL specificata nell'attributo `DllImport`.</span><span class="sxs-lookup"><span data-stu-id="591b4-119">The declaration has a new keyword that you can notice, `extern`, which tells the runtime this is an external method, and that when you invoke it, the runtime should find it in the DLL specified in `DllImport` attribute.</span></span>

<span data-ttu-id="591b4-120">La restante parte dell'esempio è semplicemente la chiamata del metodo, analoga alla chiamata di qualsiasi altro metodo gestito.</span><span class="sxs-lookup"><span data-stu-id="591b4-120">The rest of the example is just invoking the method as you would any other managed method.</span></span>

<span data-ttu-id="591b4-121">L'esempio è simile per macOS.</span><span class="sxs-lookup"><span data-stu-id="591b4-121">The sample is similar for macOS.</span></span> <span data-ttu-id="591b4-122">Il nome della libreria nell'attributo `DllImport` deve essere modificato perché macOS usa uno schema diverso di denominazione delle librerie dinamiche.</span><span class="sxs-lookup"><span data-stu-id="591b4-122">The name of the library in the `DllImport` attribute needs to change since macOS has a different scheme of naming dynamic libraries.</span></span> <span data-ttu-id="591b4-123">L'esempio seguente usa la funzione `getpid(2)` per ottenere l'ID processo dell'applicazione e stamparlo nella console:</span><span class="sxs-lookup"><span data-stu-id="591b4-123">The following sample uses the `getpid(2)` function to get the process ID of the application and print it out to the console:</span></span>

[!code-csharp[getpid macOS](~/samples/snippets/standard/interop/pinvoke/getpid-macos.cs)]

<span data-ttu-id="591b4-124">È simile anche in Linux.</span><span class="sxs-lookup"><span data-stu-id="591b4-124">It is also similar on Linux.</span></span> <span data-ttu-id="591b4-125">Il nome della funzione è lo stesso, dal momento che `getpid(2)` è una chiamata di sistema [POSIX](https://en.wikipedia.org/wiki/POSIX) standard.</span><span class="sxs-lookup"><span data-stu-id="591b4-125">The function name is the same, since `getpid(2)` is a standard [POSIX](https://en.wikipedia.org/wiki/POSIX) system call.</span></span>

[!code-csharp[getpid Linux](~/samples/snippets/standard/interop/pinvoke/getpid-linux.cs)]

## <a name="invoking-managed-code-from-unmanaged-code"></a><span data-ttu-id="591b4-126">Richiamare codice gestito da codice non gestito</span><span class="sxs-lookup"><span data-stu-id="591b4-126">Invoking managed code from unmanaged code</span></span>

<span data-ttu-id="591b4-127">Il runtime consente la comunicazione in entrambe le direzioni, permettendo il callback in codice gestito da funzioni native usando puntatori alle funzioni.</span><span class="sxs-lookup"><span data-stu-id="591b4-127">The runtime allows communication to flow in both directions, enabling you to call back into managed code from native functions by using function pointers.</span></span> <span data-ttu-id="591b4-128">In un codice gestito l'elemento più simile a un puntatore a funzione è un **delegato**. Viene quindi usato un delegato per consentire i callback dal codice nativo al codice gestito.</span><span class="sxs-lookup"><span data-stu-id="591b4-128">The closest thing to a function pointer in managed code is a **delegate**, so this is what is used to allow callbacks from native code into managed code.</span></span>

<span data-ttu-id="591b4-129">La modalità di uso di questa funzionalità è simile al processo di passaggio dal codice gestito a quello nativo descritto in precedenza.</span><span class="sxs-lookup"><span data-stu-id="591b4-129">The way to use this feature is similar to the managed to native process previously described.</span></span> <span data-ttu-id="591b4-130">Per un determinato callback, viene definito un delegato corrispondente alla firma e tale delegato viene quindi passato al metodo esterno.</span><span class="sxs-lookup"><span data-stu-id="591b4-130">For a given callback, you define a delegate that matches the signature and pass that into the external method.</span></span> <span data-ttu-id="591b4-131">Il runtime eseguirà tutte le altre operazioni.</span><span class="sxs-lookup"><span data-stu-id="591b4-131">The runtime will take care of everything else.</span></span>

[!code-csharp[EnumWindows](~/samples/snippets/standard/interop/pinvoke/enumwindows.cs)]

<span data-ttu-id="591b4-132">Prima di analizzare l'esempio, è opportuno esaminare le firme delle funzioni non gestite che è necessario utilizzare.</span><span class="sxs-lookup"><span data-stu-id="591b4-132">Before walking through the example, it's good to review the signatures of the unmanaged functions you need to work with.</span></span> <span data-ttu-id="591b4-133">La firma della funzione da chiamare per enumerare tutte le finestre è la seguente: `BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</span><span class="sxs-lookup"><span data-stu-id="591b4-133">The function to be called to enumerate all of the windows has the following signature: `BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</span></span>

<span data-ttu-id="591b4-134">Il primo parametro è un callback.</span><span class="sxs-lookup"><span data-stu-id="591b4-134">The first parameter is a callback.</span></span> <span data-ttu-id="591b4-135">La firma di tale callback è la seguente: `BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</span><span class="sxs-lookup"><span data-stu-id="591b4-135">The said callback has the following signature: `BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</span></span>

<span data-ttu-id="591b4-136">A questo punto, è possibile esaminare l'esempio:</span><span class="sxs-lookup"><span data-stu-id="591b4-136">Now, let’s walk through the example:</span></span>

- <span data-ttu-id="591b4-137">La riga 9 nell'esempio definisce un delegato che corrisponde alla firma del callback da codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="591b4-137">Line #9 in the example defines a delegate that matches the signature of the callback from unmanaged code.</span></span> <span data-ttu-id="591b4-138">Si noti che i tipi LPARAM e HWND vengono rappresentati usando `IntPtr` nel codice gestito.</span><span class="sxs-lookup"><span data-stu-id="591b4-138">Notice how the LPARAM and HWND types are represented using `IntPtr` in the managed code.</span></span>
- <span data-ttu-id="591b4-139">Le righe 13 e 14 introducono la funzione `EnumWindows` dalla libreria user32.dll.</span><span class="sxs-lookup"><span data-stu-id="591b4-139">Lines #13 and #14 introduce the `EnumWindows` function from the user32.dll library.</span></span>
- <span data-ttu-id="591b4-140">Le righe da 17 a 20 implementano il delegato.</span><span class="sxs-lookup"><span data-stu-id="591b4-140">Lines #17 - 20 implement the delegate.</span></span> <span data-ttu-id="591b4-141">Per questo semplice esempio si vuole eseguire l'output dell'handle alla console.</span><span class="sxs-lookup"><span data-stu-id="591b4-141">For this simple example, we just want to output the handle to the console.</span></span>
- <span data-ttu-id="591b4-142">Nella riga 24, infine, il metodo esterno viene chiamato e passato al delegato.</span><span class="sxs-lookup"><span data-stu-id="591b4-142">Finally, in line #24, the external method is called and passed in the delegate.</span></span>

<span data-ttu-id="591b4-143">Gli esempi Linux e macOS sono riportati di seguito.</span><span class="sxs-lookup"><span data-stu-id="591b4-143">The Linux and macOS examples are shown below.</span></span> <span data-ttu-id="591b4-144">Per questi esempi viene usata la funzione `ftw` disponibile in `libc`, la libreria C.</span><span class="sxs-lookup"><span data-stu-id="591b4-144">For them, we use the `ftw` function that can be found in `libc`, the C library.</span></span> <span data-ttu-id="591b4-145">Questa funzione viene usata per scorrere le gerarchie di directory e accetta un puntatore a una funzione come uno dei propri parametri.</span><span class="sxs-lookup"><span data-stu-id="591b4-145">This function is used to traverse directory hierarchies and it takes a pointer to a function as one of its parameters.</span></span> <span data-ttu-id="591b4-146">Tale funzione ha la firma seguente: `int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`.</span><span class="sxs-lookup"><span data-stu-id="591b4-146">The said function has the following signature: `int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`.</span></span>

[!code-csharp[ftw Linux](~/samples/snippets/standard/interop/pinvoke/ftw-linux.cs)]

<span data-ttu-id="591b4-147">Nell'esempio macOS viene usata la stessa funzione. L'unica differenza è l'argomento dell'attributo `DllImport`, dal momento che macOS mantiene `libc` in una posizione differente.</span><span class="sxs-lookup"><span data-stu-id="591b4-147">macOS example uses the same function, and the only difference is the argument to the `DllImport` attribute, as macOS keeps `libc` in a different place.</span></span>

[!code-csharp[ftw macOS](~/samples/snippets/standard/interop/pinvoke/ftw-macos.cs)]

<span data-ttu-id="591b4-148">Entrambi gli esempi precedenti dipendono da parametri e in entrambi i casi i parametri vengono forniti come tipi gestiti.</span><span class="sxs-lookup"><span data-stu-id="591b4-148">Both of the previous examples depend on parameters, and in both cases, the parameters are given as managed types.</span></span> <span data-ttu-id="591b4-149">Il runtime esegue le operazioni necessarie ed elabora i parametri ottenendo i relativi equivalenti sull'altro lato.</span><span class="sxs-lookup"><span data-stu-id="591b4-149">Runtime does the "right thing" and processes these into its equivalents on the other side.</span></span> <span data-ttu-id="591b4-150">Sono disponibili informazioni su come i tipi sono sottoposti a marshalling in codice nativo nella pagina [Type marshaling](type-marshaling.md) (Marshalling dei tipi).</span><span class="sxs-lookup"><span data-stu-id="591b4-150">Learn about how types are marshaled to native code in our page on [Type marshaling](type-marshaling.md).</span></span>

## <a name="more-resources"></a><span data-ttu-id="591b4-151">Altre risorse</span><span class="sxs-lookup"><span data-stu-id="591b4-151">More resources</span></span>

- <span data-ttu-id="591b4-152">[PInvoke.net wiki](https://www.pinvoke.net/): accurata pagina wiki con informazioni sulle API Windows comuni e sul modo di richiamarle.</span><span class="sxs-lookup"><span data-stu-id="591b4-152">[PInvoke.net wiki](https://www.pinvoke.net/) an excellent Wiki with information on common Windows APIs and how to call them.</span></span>
- [<span data-ttu-id="591b4-153">P/Invoke in C++/CLI</span><span class="sxs-lookup"><span data-stu-id="591b4-153">P/Invoke in C++/CLI</span></span>](/cpp/dotnet/native-and-dotnet-interoperability)
- [<span data-ttu-id="591b4-154">Documentazione su Mono in P/Invoke</span><span class="sxs-lookup"><span data-stu-id="591b4-154">Mono documentation on P/Invoke</span></span>](https://www.mono-project.com/docs/advanced/pinvoke/)
