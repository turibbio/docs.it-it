---
title: Panoramica delle primitive di sincronizzazione
description: Informazioni sulle primitive di sincronizzazione di thread .NET usate per sincronizzare l'accesso a una risorsa condivisa o controllare l'interazione tra thread
ms.date: 10/01/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- synchronization, threads
- threading [.NET],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
ms.openlocfilehash: 7347c9b40f150febc6a163ae3aa3267123ea0e9d
ms.sourcegitcommit: 465547886a1224a5435c3ac349c805e39ce77706
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/21/2020
ms.locfileid: "81739368"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="ec22a-103">Panoramica delle primitive di sincronizzazione</span><span class="sxs-lookup"><span data-stu-id="ec22a-103">Overview of synchronization primitives</span></span>

<span data-ttu-id="ec22a-104">.NET offre una gamma di tipi che è possibile usare per sincronizzare l'accesso a una risorsa condivisa o coordinare l'interazione tra thread.</span><span class="sxs-lookup"><span data-stu-id="ec22a-104">.NET provides a range of types that you can use to synchronize access to a shared resource or coordinate thread interaction.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="ec22a-105">Usare la stessa istanza di primitiva di sincronizzazione per proteggere l'accesso a una risorsa condivisa.</span><span class="sxs-lookup"><span data-stu-id="ec22a-105">Use the same synchronization primitive instance to protect access of a shared resource.</span></span> <span data-ttu-id="ec22a-106">Se si usano istanze di primitive di sincronizzazione diverse per proteggere la stessa risorsa, sarà possibile aggirare la protezione fornita da una primitiva di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="ec22a-106">If you use different synchronization primitive instances to protect the same resource, you'll circumvent the protection provided by a synchronization primitive.</span></span>

## <a name="waithandle-class-and-lightweight-synchronization-types"></a><span data-ttu-id="ec22a-107">Classe WaitHandle e tipi di sincronizzazione leggeri</span><span class="sxs-lookup"><span data-stu-id="ec22a-107">WaitHandle class and lightweight synchronization types</span></span>

<span data-ttu-id="ec22a-108">Più primitive di sincronizzazione .NET derivano dalla classe <xref:System.Threading.WaitHandle?displayProperty=nameWithType>, che incapsula un handle di sincronizzazione del sistema operativo nativo e usa un meccanismo di segnalazione per l'interazione tra thread.</span><span class="sxs-lookup"><span data-stu-id="ec22a-108">Multiple .NET synchronization primitives derive from the <xref:System.Threading.WaitHandle?displayProperty=nameWithType> class, which encapsulates a native operating system synchronization handle and uses a signaling mechanism for thread interaction.</span></span> <span data-ttu-id="ec22a-109">Tali classi includono:</span><span class="sxs-lookup"><span data-stu-id="ec22a-109">Those classes include:</span></span>

- <span data-ttu-id="ec22a-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, che concede l'accesso esclusivo a una risorsa condivisa.</span><span class="sxs-lookup"><span data-stu-id="ec22a-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, which grants exclusive access to a shared resource.</span></span> <span data-ttu-id="ec22a-111">Lo stato di un mutex viene segnalato se nessun thread lo possiede.</span><span class="sxs-lookup"><span data-stu-id="ec22a-111">The state of a mutex is signaled if no thread owns it.</span></span>
- <span data-ttu-id="ec22a-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, che limita il numero di thread che possono accedere simultaneamente a una risorsa condivisa o a un pool di risorse.</span><span class="sxs-lookup"><span data-stu-id="ec22a-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, which limits the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="ec22a-113">Lo stato di un semaforo denominato è impostato come segnalato quando il relativo conteggio è maggiore di zero e come non segnalato quando il relativo conteggio è zero.</span><span class="sxs-lookup"><span data-stu-id="ec22a-113">The state of a semaphore is set to signaled when its count is greater than zero, and nonsignaled when its count is zero.</span></span>
- <span data-ttu-id="ec22a-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, che rappresenta un evento di sincronizzazione di thread e può trovarsi in uno stato segnalato o non segnalato.</span><span class="sxs-lookup"><span data-stu-id="ec22a-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, which represents a thread synchronization event and can be either in a signaled or unsignaled state.</span></span>
- <span data-ttu-id="ec22a-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, che deriva da <xref:System.Threading.EventWaitHandle> e, quando segnalata si reimposta automaticamente in uno stato non segnalato dopo il rilascio di un singolo thread in attesa.</span><span class="sxs-lookup"><span data-stu-id="ec22a-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, resets automatically to an unsignaled state after releasing a single waiting thread.</span></span>
- <span data-ttu-id="ec22a-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, che deriva da <xref:System.Threading.EventWaitHandle> e, quando segnalata, rimane in uno stato segnalato finché non viene chiamato il metodo <xref:System.Threading.EventWaitHandle.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="ec22a-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, stays in a signaled state until the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>

<span data-ttu-id="ec22a-117">In .NET Framework, poiché <xref:System.Threading.WaitHandle> deriva da <xref:System.MarshalByRefObject?displayProperty=nameWithType>, questi tipi possono essere usati per sincronizzare le attività dei thread tra limiti dei domini delle applicazioni.</span><span class="sxs-lookup"><span data-stu-id="ec22a-117">In the .NET Framework, because <xref:System.Threading.WaitHandle> derives from <xref:System.MarshalByRefObject?displayProperty=nameWithType>, these types can be used to synchronize the activities of threads across application domain boundaries.</span></span>

<span data-ttu-id="ec22a-118">In .NET Framework e .NET Core, alcuni di questi tipi possono rappresentare handle di sincronizzazione di sistema denominati, che sono visibili in tutto il sistema operativo e possono essere usati per la sincronizzazione interprocesso:</span><span class="sxs-lookup"><span data-stu-id="ec22a-118">In the .NET Framework and .NET Core, some of these types can represent named system synchronization handles, which are visible throughout the operating system and can be used for the inter-process synchronization:</span></span>

- <span data-ttu-id="ec22a-119"><xref:System.Threading.Mutex> (.NET Framework e .NET Core).</span><span class="sxs-lookup"><span data-stu-id="ec22a-119"><xref:System.Threading.Mutex> (.NET Framework and .NET Core),</span></span>
- <span data-ttu-id="ec22a-120"><xref:System.Threading.Semaphore> (.NET Framework e .NET Core in Windows).</span><span class="sxs-lookup"><span data-stu-id="ec22a-120"><xref:System.Threading.Semaphore> (.NET Framework and .NET Core on Windows),</span></span>
- <span data-ttu-id="ec22a-121"><xref:System.Threading.EventWaitHandle> (.NET Framework e .NET Core in Windows).</span><span class="sxs-lookup"><span data-stu-id="ec22a-121"><xref:System.Threading.EventWaitHandle> (.NET Framework and .NET Core on Windows).</span></span>

<span data-ttu-id="ec22a-122">Per altre informazioni, vedere le informazioni di riferimento sull'API <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="ec22a-122">For more information, see the <xref:System.Threading.WaitHandle> API reference.</span></span>

<span data-ttu-id="ec22a-123">I tipi di sincronizzazione leggeri non si basano su handle del sistema operativo sottostanti e in genere offrono prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="ec22a-123">Lightweight synchronization types don't rely on underlying operating system handles and typically provide better performance.</span></span> <span data-ttu-id="ec22a-124">Tuttavia, non possono essere usati per la sincronizzazione interprocesso.</span><span class="sxs-lookup"><span data-stu-id="ec22a-124">However, they cannot be used for the inter-process synchronization.</span></span> <span data-ttu-id="ec22a-125">Usare tali tipi per la sincronizzazione dei thread all'interno di un'applicazione.</span><span class="sxs-lookup"><span data-stu-id="ec22a-125">Use those types for thread synchronization within one application.</span></span>

<span data-ttu-id="ec22a-126">Alcuni di questi tipi rappresentano alternative ai tipi derivati da <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="ec22a-126">Some of those types are alternatives to the types derived from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="ec22a-127">Ad esempio, <xref:System.Threading.SemaphoreSlim> è un'alternativa leggera a <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="ec22a-127">For example, <xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore>.</span></span>

## <a name="synchronization-of-access-to-a-shared-resource"></a><span data-ttu-id="ec22a-128">Sincronizzazione dell'accesso a una risorsa condivisa</span><span class="sxs-lookup"><span data-stu-id="ec22a-128">Synchronization of access to a shared resource</span></span>

<span data-ttu-id="ec22a-129">.NET offre una gamma di primitive di sincronizzazione per controllare l'accesso a una risorsa condivisa da parte di più thread.</span><span class="sxs-lookup"><span data-stu-id="ec22a-129">.NET provides a range of synchronization primitives to control access to a shared resource by multiple threads.</span></span>

### <a name="monitor-class"></a><span data-ttu-id="ec22a-130">Monitor (classe)</span><span class="sxs-lookup"><span data-stu-id="ec22a-130">Monitor class</span></span>

<span data-ttu-id="ec22a-131">La classe <xref:System.Threading.Monitor?displayProperty=nameWithType> concede l'accesso con esclusione reciproca a una risorsa condivisa tramite l'acquisizione o il rilascio di un blocco sull'oggetto che identifica la risorsa.</span><span class="sxs-lookup"><span data-stu-id="ec22a-131">The <xref:System.Threading.Monitor?displayProperty=nameWithType> class grants mutually exclusive access to a shared resource by acquiring or releasing a lock on the object that identifies the resource.</span></span> <span data-ttu-id="ec22a-132">Mentre è attivo un blocco, il thread che contiene il blocco può ancora acquisire e rilasciare il blocco.</span><span class="sxs-lookup"><span data-stu-id="ec22a-132">While a lock is held, the thread that holds the lock can again acquire and release the lock.</span></span> <span data-ttu-id="ec22a-133">Gli altri thread non possono acquisire il blocco e il metodo <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> attende il rilascio del blocco.</span><span class="sxs-lookup"><span data-stu-id="ec22a-133">Any other thread is blocked from acquiring the lock and the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method waits until the lock is released.</span></span> <span data-ttu-id="ec22a-134">Il metodo <xref:System.Threading.Monitor.Enter%2A> acquisisce un blocco rilasciato.</span><span class="sxs-lookup"><span data-stu-id="ec22a-134">The <xref:System.Threading.Monitor.Enter%2A> method acquires a released lock.</span></span> <span data-ttu-id="ec22a-135">È anche possibile usare il metodo <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> per specificare l'intervallo di tempo durante il quale un thread cerca di acquisire un blocco.</span><span class="sxs-lookup"><span data-stu-id="ec22a-135">You can also use the <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> method to specify the amount of time during which a thread attempts to acquire a lock.</span></span> <span data-ttu-id="ec22a-136">Poiché la classe <xref:System.Threading.Monitor> presenta affinità di thread, il thread che ha acquisito un blocco deve rilasciare il blocco chiamando il metodo <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ec22a-136">Because the <xref:System.Threading.Monitor> class has thread affinity, the thread that acquired a lock must release the lock by calling the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="ec22a-137">È possibile coordinare l'interazione tra i thread che acquisiscono un blocco sullo stesso oggetto usando i metodi <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> e <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ec22a-137">You can coordinate the interaction of threads that acquire a lock on the same object by using the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>

<span data-ttu-id="ec22a-138">Per altre informazioni, vedere le informazioni di riferimento sull'API <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="ec22a-138">For more information, see the <xref:System.Threading.Monitor> API reference.</span></span>

> [!NOTE]
> <span data-ttu-id="ec22a-139">Usare l'istruzione [lock](../../csharp/language-reference/keywords/lock-statement.md) in C# e l'istruzione [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) in Visual Basic per sincronizzare l'accesso a una risorsa condivisa invece di usare direttamente la classe <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="ec22a-139">Use the [lock](../../csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic to synchronize access to a shared resource instead of using the <xref:System.Threading.Monitor> class directly.</span></span> <span data-ttu-id="ec22a-140">Queste istruzioni vengono implementate usando i metodi <xref:System.Threading.Monitor.Enter%2A> e <xref:System.Threading.Monitor.Exit%2A> e un blocco `try…finally` per garantire che il blocco acquisito venga sempre rilasciato.</span><span class="sxs-lookup"><span data-stu-id="ec22a-140">Those statements are implemented by using the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods and a `try…finally` block to ensure that the acquired lock is always released.</span></span>

### <a name="mutex-class"></a><span data-ttu-id="ec22a-141">Mutex (classe)</span><span class="sxs-lookup"><span data-stu-id="ec22a-141">Mutex class</span></span>

<span data-ttu-id="ec22a-142">La classe <xref:System.Threading.Mutex?displayProperty=nameWithType>, analogamente a <xref:System.Threading.Monitor>, concede l'accesso esclusivo a una risorsa condivisa.</span><span class="sxs-lookup"><span data-stu-id="ec22a-142">The <xref:System.Threading.Mutex?displayProperty=nameWithType> class, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource.</span></span> <span data-ttu-id="ec22a-143">Usare uno degli overload del metodo [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) per richiedere la proprietà di un mutex.</span><span class="sxs-lookup"><span data-stu-id="ec22a-143">Use one of the [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) method overloads to request the ownership of a mutex.</span></span> <span data-ttu-id="ec22a-144">Analogamente a <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> presenta affinità di thread e il thread che ha acquisito un mutex deve rilasciarlo chiamando il metodo <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ec22a-144">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity and the thread that acquired a mutex must release it by calling the <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="ec22a-145">A differenza di <xref:System.Threading.Monitor>, la classe <xref:System.Threading.Mutex> può essere usata per la sincronizzazione interprocesso.</span><span class="sxs-lookup"><span data-stu-id="ec22a-145">Unlike <xref:System.Threading.Monitor>, the <xref:System.Threading.Mutex> class can be used for inter-process synchronization.</span></span> <span data-ttu-id="ec22a-146">A tale scopo, usare un mutex denominato, visibile in tutto il sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="ec22a-146">To do that, use a named mutex, which is visible throughout the operating system.</span></span> <span data-ttu-id="ec22a-147">Per creare un'istanza di mutex denominata, usare un [costruttore di Mutex](<xref:System.Threading.Mutex.%23ctor%2A>) che specifica un nome.</span><span class="sxs-lookup"><span data-stu-id="ec22a-147">To create a named mutex instance, use a [Mutex constructor](<xref:System.Threading.Mutex.%23ctor%2A>) that specifies a name.</span></span> <span data-ttu-id="ec22a-148">È inoltre possibile <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> chiamare il metodo per aprire un mutex di sistema denominato esistente.</span><span class="sxs-lookup"><span data-stu-id="ec22a-148">You can also call the <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> method to open an existing named system mutex.</span></span>
  
<span data-ttu-id="ec22a-149">Per altre informazioni, vedere l'articolo [Mutex](mutexes.md) e le informazioni di riferimento sull'API <xref:System.Threading.Mutex>.</span><span class="sxs-lookup"><span data-stu-id="ec22a-149">For more information, see the [Mutexes](mutexes.md) article and the <xref:System.Threading.Mutex> API reference.</span></span>

### <a name="spinlock-structure"></a><span data-ttu-id="ec22a-150">Struttura SpinLock</span><span class="sxs-lookup"><span data-stu-id="ec22a-150">SpinLock structure</span></span>

<span data-ttu-id="ec22a-151">La struttura <xref:System.Threading.SpinLock?displayProperty=nameWithType>, analogamente a <xref:System.Threading.Monitor>, concede l'accesso esclusivo a una risorsa condivisa in base alla disponibilità di un blocco.</span><span class="sxs-lookup"><span data-stu-id="ec22a-151">The <xref:System.Threading.SpinLock?displayProperty=nameWithType> structure, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource based on the availability of a lock.</span></span> <span data-ttu-id="ec22a-152">Quando <xref:System.Threading.SpinLock> cerca di acquisire un blocco che non è disponibile, rimane in attesa in un ciclo eseguendo controlli ripetuti finché il blocco non diventa disponibile.</span><span class="sxs-lookup"><span data-stu-id="ec22a-152">When <xref:System.Threading.SpinLock> attempts to acquire a lock that is unavailable, it waits in a loop, repeatedly checking until the lock becomes available.</span></span>

<span data-ttu-id="ec22a-153">Per altre informazioni sui vantaggi e sugli svantaggi dell'uso del meccanismo di spinlock, vedere l'articolo [SpinLock](spinlock.md) e le informazioni di riferimento sull'API <xref:System.Threading.SpinLock>.</span><span class="sxs-lookup"><span data-stu-id="ec22a-153">For more information about the benefits and drawbacks of using spin lock, see the [SpinLock](spinlock.md) article and the <xref:System.Threading.SpinLock> API reference.</span></span>

### <a name="readerwriterlockslim-class"></a><span data-ttu-id="ec22a-154">Classe ReaderWriterLockSlim</span><span class="sxs-lookup"><span data-stu-id="ec22a-154">ReaderWriterLockSlim class</span></span>

<span data-ttu-id="ec22a-155">La classe <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> concede l'accesso esclusivo a una risorsa condivisa per la scrittura e permette a più thread di accedere alla risorsa simultaneamente per la lettura.</span><span class="sxs-lookup"><span data-stu-id="ec22a-155">The <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> class grants exclusive access to a shared resource for writing and allows multiple threads to access the resource simultaneously for reading.</span></span> <span data-ttu-id="ec22a-156">È possibile usare <xref:System.Threading.ReaderWriterLockSlim> per sincronizzare l'accesso a una struttura dei dati condivisa che supporta operazioni di lettura thread-safe, ma richiede accesso esclusivo per eseguire le operazioni di scrittura.</span><span class="sxs-lookup"><span data-stu-id="ec22a-156">You might want to use <xref:System.Threading.ReaderWriterLockSlim> to synchronize access to a shared data structure that supports thread-safe read operations, but requires exclusive access to perform write operation.</span></span> <span data-ttu-id="ec22a-157">Quando un thread richiede l'accesso esclusivo, ad esempio chiamando il metodo <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType>, le richieste di lettore e scrittore successive vengono bloccate finché tutti i lettori esistenti non escono dal blocco e lo scrittore non è entrato e uscito dal blocco.</span><span class="sxs-lookup"><span data-stu-id="ec22a-157">When a thread requests exclusive access (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> method), subsequent reader and writer requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>
  
<span data-ttu-id="ec22a-158">Per altre informazioni, vedere le informazioni di riferimento sull'API <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="ec22a-158">For more information, see the <xref:System.Threading.ReaderWriterLockSlim> API reference.</span></span>

### <a name="semaphore-and-semaphoreslim-classes"></a><span data-ttu-id="ec22a-159">Classi Semaphore e SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="ec22a-159">Semaphore and SemaphoreSlim classes</span></span>

<span data-ttu-id="ec22a-160">Le classi <xref:System.Threading.Semaphore?displayProperty=nameWithType> e <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> limitano il numero di thread che possono accedere simultaneamente a una risorsa condivisa o a un pool di risorse.</span><span class="sxs-lookup"><span data-stu-id="ec22a-160">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> classes limit the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="ec22a-161">I thread aggiuntivi che richiedono la risorsa rimangono in attesa finché un thread non rilascia il semaforo.</span><span class="sxs-lookup"><span data-stu-id="ec22a-161">Additional threads that request the resource wait until any thread releases the semaphore.</span></span> <span data-ttu-id="ec22a-162">Poiché il semaforo non presenta affinità di thread, un thread può acquisire il semaforo e un altro può rilasciarlo.</span><span class="sxs-lookup"><span data-stu-id="ec22a-162">Because the semaphore doesn't have thread affinity, a thread can acquire the semaphore and another one can release it.</span></span>

<span data-ttu-id="ec22a-163">La classe <xref:System.Threading.SemaphoreSlim> è un'alternativa leggera a <xref:System.Threading.Semaphore> e può essere usata solo per la sincronizzazione all'interno di un unico processo.</span><span class="sxs-lookup"><span data-stu-id="ec22a-163"><xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore> and can be used only for synchronization within a single process boundary.</span></span>

<span data-ttu-id="ec22a-164">In Windows è possibile usare <xref:System.Threading.Semaphore> per la sincronizzazione interprocesso.</span><span class="sxs-lookup"><span data-stu-id="ec22a-164">On Windows, you can use <xref:System.Threading.Semaphore> for the inter-process synchronization.</span></span> <span data-ttu-id="ec22a-165">A tale scopo, creare un'istanza di <xref:System.Threading.Semaphore> che rappresenta un semaforo di sistema denominato usando uno dei [costruttori di Semaphore](<xref:System.Threading.Semaphore.%23ctor%2A>) che specifica un nome o il metodo <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ec22a-165">To do that, create a <xref:System.Threading.Semaphore> instance that represents a named system semaphore by using one of the [Semaphore constructors](<xref:System.Threading.Semaphore.%23ctor%2A>) that specifies a name or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ec22a-166"><xref:System.Threading.SemaphoreSlim> non supporta semafori di sistema denominati.</span><span class="sxs-lookup"><span data-stu-id="ec22a-166"><xref:System.Threading.SemaphoreSlim> doesn't support named system semaphores.</span></span>

<span data-ttu-id="ec22a-167">Per altre informazioni, vedere l'articolo [Semaphore e SemaphoreSlim](semaphore-and-semaphoreslim.md) e le informazioni di riferimento sull'API <xref:System.Threading.Semaphore> o <xref:System.Threading.SemaphoreSlim>.</span><span class="sxs-lookup"><span data-stu-id="ec22a-167">For more information, see the [Semaphore and SemaphoreSlim](semaphore-and-semaphoreslim.md) article and the <xref:System.Threading.Semaphore> or <xref:System.Threading.SemaphoreSlim> API reference.</span></span>

## <a name="thread-interaction-or-signaling"></a><span data-ttu-id="ec22a-168">Interazione tra thread o segnalazione</span><span class="sxs-lookup"><span data-stu-id="ec22a-168">Thread interaction, or signaling</span></span>

<span data-ttu-id="ec22a-169">L'interazione tra thread (o segnalazione tra thread) significa che un thread deve attendere la notifica, o un segnale, da uno o più thread per procedere.</span><span class="sxs-lookup"><span data-stu-id="ec22a-169">Thread interaction (or thread signaling) means that a thread must wait for notification, or a signal, from one or more threads in order to proceed.</span></span> <span data-ttu-id="ec22a-170">Se, ad esempio, il thread A chiama il metodo <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> del thread B, il thread A è bloccato fino al completamento del thread B.</span><span class="sxs-lookup"><span data-stu-id="ec22a-170">For example, if thread A calls the <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> method of thread B, thread A is blocked until thread B completes.</span></span> <span data-ttu-id="ec22a-171">Le primitive di sincronizzazione descritte nella sezione precedente forniscono un meccanismo diverso per la segnalazione. Rilasciando un blocco, un thread notifica a un altro thread che quest'ultimo può procedere acquisendo il blocco.</span><span class="sxs-lookup"><span data-stu-id="ec22a-171">The synchronization primitives described in the preceding section provide a different mechanism for signaling: by releasing a lock, a thread notifies another thread that it can proceed by acquiring the lock.</span></span>

<span data-ttu-id="ec22a-172">Questa sezione descrive i costrutti di segnalazione aggiuntivi forniti da .NET.</span><span class="sxs-lookup"><span data-stu-id="ec22a-172">This section describes additional signaling constructs provided by .NET.</span></span>

### <a name="eventwaithandle-autoresetevent-manualresetevent-and-manualreseteventslim-classes"></a><span data-ttu-id="ec22a-173">Classi EventWaitHandle, AutoResetEvent, ManualResetEvent e ManualResetEventSlim</span><span class="sxs-lookup"><span data-stu-id="ec22a-173">EventWaitHandle, AutoResetEvent, ManualResetEvent, and ManualResetEventSlim classes</span></span>

<span data-ttu-id="ec22a-174">La classe <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> rappresenta un evento di sincronizzazione di thread.</span><span class="sxs-lookup"><span data-stu-id="ec22a-174">The <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> class represents a thread synchronization event.</span></span>

<span data-ttu-id="ec22a-175">Un evento di sincronizzazione può trovarsi in uno stato segnalato o non segnalato.</span><span class="sxs-lookup"><span data-stu-id="ec22a-175">A synchronization event can be either in an unsignaled or signaled state.</span></span> <span data-ttu-id="ec22a-176">Quando lo stato di un evento è non segnalato, un thread che chiama l'overload <xref:System.Threading.WaitHandle.WaitOne%2A?> dell'evento rimane bloccato fino a quando un evento non viene segnalato.</span><span class="sxs-lookup"><span data-stu-id="ec22a-176">When the state of an event is unsignaled, a thread that calls the event's <xref:System.Threading.WaitHandle.WaitOne%2A?> overload is blocked until an event is signaled.</span></span> <span data-ttu-id="ec22a-177">Il metodo <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> imposta lo stato di un evento come segnalato.</span><span class="sxs-lookup"><span data-stu-id="ec22a-177">The <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method sets the state of an event to signaled.</span></span>

<span data-ttu-id="ec22a-178">Il comportamento di un oggetto <xref:System.Threading.EventWaitHandle> che è stato segnalato dipende dalla modalità di reimpostazione:</span><span class="sxs-lookup"><span data-stu-id="ec22a-178">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode:</span></span>

- <span data-ttu-id="ec22a-179">Un oggetto <xref:System.Threading.EventWaitHandle> creato con il flag <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> si reimposta automaticamente dopo il rilascio di un singolo thread in attesa.</span><span class="sxs-lookup"><span data-stu-id="ec22a-179">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically after releasing a single waiting thread.</span></span> <span data-ttu-id="ec22a-180">Può essere paragonato a un tornello che lascia passare un solo thread ogni volta che viene segnalato.</span><span class="sxs-lookup"><span data-stu-id="ec22a-180">It's like a turnstile that allows only one thread through each time it's signaled.</span></span> <span data-ttu-id="ec22a-181">La classe <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, che deriva da <xref:System.Threading.EventWaitHandle>, rappresenta questo comportamento.</span><span class="sxs-lookup"><span data-stu-id="ec22a-181">The <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span>
- <span data-ttu-id="ec22a-182">Un oggetto <xref:System.Threading.EventWaitHandle> creato con il flag <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> rimane segnalato fino a quando non viene chiamato il relativo metodo <xref:System.Threading.EventWaitHandle.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="ec22a-182">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="ec22a-183">Può essere paragonato a un cancello che rimane chiuso fino a quando non viene segnalato e quindi rimane aperto fino a quando non viene chiuso.</span><span class="sxs-lookup"><span data-stu-id="ec22a-183">It's like a gate that is closed until signaled and then stays open until someone closes it.</span></span> <span data-ttu-id="ec22a-184">La classe <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, che deriva da <xref:System.Threading.EventWaitHandle>, rappresenta questo comportamento.</span><span class="sxs-lookup"><span data-stu-id="ec22a-184">The <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span> <span data-ttu-id="ec22a-185">La classe <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> è un'alternativa leggera a <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="ec22a-185">The <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> class is a lightweight alternative to <xref:System.Threading.ManualResetEvent>.</span></span>

<span data-ttu-id="ec22a-186">In Windows è possibile usare <xref:System.Threading.EventWaitHandle> per la sincronizzazione interprocesso.</span><span class="sxs-lookup"><span data-stu-id="ec22a-186">On Windows, you can use <xref:System.Threading.EventWaitHandle> for the inter-process synchronization.</span></span> <span data-ttu-id="ec22a-187">A tale scopo, creare un'istanza di <xref:System.Threading.EventWaitHandle> che rappresenta un evento di sincronizzazione di sistema denominato usando uno dei [costruttori di EventWaitHandle](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) che specifica un nome o il metodo <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ec22a-187">To do that, create a <xref:System.Threading.EventWaitHandle> instance that represents a named system synchronization event by using one of the [EventWaitHandle constructors](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) that specifies a name or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="ec22a-188">Per altre informazioni, vedere l'articolo [EventWaitHandle](eventwaithandle.md).</span><span class="sxs-lookup"><span data-stu-id="ec22a-188">For more information, see the [EventWaitHandle](eventwaithandle.md) article.</span></span> <span data-ttu-id="ec22a-189">Per informazioni di riferimento sulle API, vedere <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent> e <xref:System.Threading.ManualResetEventSlim>.</span><span class="sxs-lookup"><span data-stu-id="ec22a-189">For the API reference, see <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent>, and <xref:System.Threading.ManualResetEventSlim>.</span></span>

### <a name="countdownevent-class"></a><span data-ttu-id="ec22a-190">Classe CountdownEvent</span><span class="sxs-lookup"><span data-stu-id="ec22a-190">CountdownEvent class</span></span>

<span data-ttu-id="ec22a-191">La classe <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> rappresenta un evento che viene impostato quando il relativo conteggio è zero.</span><span class="sxs-lookup"><span data-stu-id="ec22a-191">The <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> class represents an event that becomes set when its count is zero.</span></span> <span data-ttu-id="ec22a-192">Quando <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> è maggiore di zero, un thread che chiama <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> viene bloccato.</span><span class="sxs-lookup"><span data-stu-id="ec22a-192">While <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> is greater than zero, a thread that calls <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> is blocked.</span></span> <span data-ttu-id="ec22a-193">Chiamare <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> per ridurre il conteggio di un evento.</span><span class="sxs-lookup"><span data-stu-id="ec22a-193">Call <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> to decrement an event's count.</span></span>

<span data-ttu-id="ec22a-194">A differenza di <xref:System.Threading.ManualResetEvent> o <xref:System.Threading.ManualResetEventSlim>, che è possibile usare per sbloccare più thread con un segnale da un thread, è possibile usare <xref:System.Threading.CountdownEvent> per sbloccare uno o più thread con segnali da più thread.</span><span class="sxs-lookup"><span data-stu-id="ec22a-194">In contrast to <xref:System.Threading.ManualResetEvent> or <xref:System.Threading.ManualResetEventSlim>, which you can use to unblock multiple threads with a signal from one thread, you can use <xref:System.Threading.CountdownEvent> to unblock one or more threads with signals from multiple threads.</span></span>

<span data-ttu-id="ec22a-195">Per altre informazioni, vedere l'articolo [CountdownEvent](countdownevent.md) e le informazioni di riferimento sull'API <xref:System.Threading.CountdownEvent>.</span><span class="sxs-lookup"><span data-stu-id="ec22a-195">For more information, see the [CountdownEvent](countdownevent.md) article and the <xref:System.Threading.CountdownEvent> API reference.</span></span>

### <a name="barrier-class"></a><span data-ttu-id="ec22a-196">Classe Barrier</span><span class="sxs-lookup"><span data-stu-id="ec22a-196">Barrier class</span></span>

<span data-ttu-id="ec22a-197">La classe <xref:System.Threading.Barrier?displayProperty=nameWithType> rappresenta una barriera di esecuzione di thread.</span><span class="sxs-lookup"><span data-stu-id="ec22a-197">The <xref:System.Threading.Barrier?displayProperty=nameWithType> class represents a thread execution barrier.</span></span> <span data-ttu-id="ec22a-198">Un thread che chiama il metodo <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> segnala di aver raggiunto la barriera e attende fino a quando gli altri thread partecipanti non raggiungono la barriera.</span><span class="sxs-lookup"><span data-stu-id="ec22a-198">A thread that calls the <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> method signals that it reached the barrier and waits until other participant threads reach the barrier.</span></span> <span data-ttu-id="ec22a-199">Quando tutti i thread partecipanti raggiungono la barriera, procedono e la barriera viene reimpostata e può essere usata di nuovo.</span><span class="sxs-lookup"><span data-stu-id="ec22a-199">When all participant threads reach the barrier, they proceed and the barrier is reset and can be used again.</span></span>

<span data-ttu-id="ec22a-200">È possibile usare <xref:System.Threading.Barrier> quando uno o più thread richiedono i risultati di altri thread prima di continuare con la fase di calcolo successiva.</span><span class="sxs-lookup"><span data-stu-id="ec22a-200">You might use <xref:System.Threading.Barrier> when one or more threads require the results of other threads before proceeding to the next computation phase.</span></span>

<span data-ttu-id="ec22a-201">Per altre informazioni, vedere l'articolo [Barrier](barrier.md) e le informazioni di riferimento sull'API <xref:System.Threading.Barrier>.</span><span class="sxs-lookup"><span data-stu-id="ec22a-201">For more information, see the [Barrier](barrier.md) article and the <xref:System.Threading.Barrier> API reference.</span></span>

## <a name="interlocked-class"></a><span data-ttu-id="ec22a-202">Interlocked (classe)</span><span class="sxs-lookup"><span data-stu-id="ec22a-202">Interlocked class</span></span>

<span data-ttu-id="ec22a-203">La classe <xref:System.Threading.Interlocked?displayProperty=nameWithType> fornisce metodi statici che eseguono operazioni atomiche semplici su una variabile.</span><span class="sxs-lookup"><span data-stu-id="ec22a-203">The <xref:System.Threading.Interlocked?displayProperty=nameWithType> class provides static methods that perform simple atomic operations on a variable.</span></span> <span data-ttu-id="ec22a-204">Queste operazioni atomiche includono addizione, incremento e decremento, scambio e scambio condizionale in base a un confronto, oltre che l'operazione di lettura di un valore intero a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="ec22a-204">Those atomic operations include addition, increment and decrement, exchange and conditional exchange that depends on a comparison, and read operation of a 64-bit integer value.</span></span>

<span data-ttu-id="ec22a-205">Per altre informazioni, vedere le informazioni di riferimento sull'API <xref:System.Threading.Interlocked>.</span><span class="sxs-lookup"><span data-stu-id="ec22a-205">For more information, see the <xref:System.Threading.Interlocked> API reference.</span></span>

## <a name="spinwait-structure"></a><span data-ttu-id="ec22a-206">Struttura SpinWait</span><span class="sxs-lookup"><span data-stu-id="ec22a-206">SpinWait structure</span></span>

<span data-ttu-id="ec22a-207">La struttura <xref:System.Threading.SpinWait?displayProperty=nameWithType> fornisce supporto per l'attesa basata su rotazione.</span><span class="sxs-lookup"><span data-stu-id="ec22a-207">The <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure provides support for spin-based waiting.</span></span> <span data-ttu-id="ec22a-208">È possibile usare questa struttura quando un thread deve attendere che un evento venga segnalato o una condizione soddisfatta, ma quando si prevede che il tempo di attesa effettivo sia inferiore a quello richiesto usando un handle di attesa o bloccando in altro modo il thread corrente.</span><span class="sxs-lookup"><span data-stu-id="ec22a-208">You might want to use it when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the thread.</span></span> <span data-ttu-id="ec22a-209">Usando <xref:System.Threading.SpinWait>, è possibile specificare un breve intervallo di tempo di rotazione durante l'attesa e quindi produrre un risultato (ad esempio, mediante l'attesa o la sospensione) solo se la condizione non viene soddisfatta nel tempo specificato.</span><span class="sxs-lookup"><span data-stu-id="ec22a-209">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>

<span data-ttu-id="ec22a-210">Per altre informazioni, vedere l'articolo [SpinWait](spinwait.md) e le informazioni di riferimento sull'API <xref:System.Threading.SpinWait>.</span><span class="sxs-lookup"><span data-stu-id="ec22a-210">For more information, see the [SpinWait](spinwait.md) article and the <xref:System.Threading.SpinWait> API reference.</span></span>

## <a name="see-also"></a><span data-ttu-id="ec22a-211">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="ec22a-211">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="ec22a-212">Raccolte thread-safe</span><span class="sxs-lookup"><span data-stu-id="ec22a-212">Thread-safe collections</span></span>](../collections/thread-safe/index.md)
- [<span data-ttu-id="ec22a-213">Oggetti e funzionalità del threading</span><span class="sxs-lookup"><span data-stu-id="ec22a-213">Threading objects and features</span></span>](threading-objects-and-features.md)
