---
title: Semaphore e SemaphoreSlim
description: Informazioni sul semaforo & SemaphoreSlim. Il semaforo della classe è un wrapper sottile intorno all'oggetto semaforo Win32. La classe SemaphoreSlim è un semaforo leggero veloce.
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- counting semaphores
- semaphores
- threading [.NET Framework], cross-process synchronization
- Semaphore class, about Semaphore class
- SemaphoreSlim class, about SemaphoreSlim class
- threading [.NET Framework], Semaphore class
ms.assetid: 7722a333-b974-47a2-a7c0-f09097fb644e
ms.openlocfilehash: 21f0d7e3fb446a7b750c45cfe8ef3f087a77888a
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/09/2020
ms.locfileid: "84600451"
---
# <a name="semaphore-and-semaphoreslim"></a><span data-ttu-id="17280-105">Semaphore e SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="17280-105">Semaphore and SemaphoreSlim</span></span>
<span data-ttu-id="17280-106">La classe <xref:System.Threading.Semaphore?displayProperty=nameWithType> rappresenta un semaforo denominato (systemwide) o locale.</span><span class="sxs-lookup"><span data-stu-id="17280-106">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> class represents a named (systemwide) or local semaphore.</span></span> <span data-ttu-id="17280-107">È un semplice wrapper per l'oggetto semaforo Win32.</span><span class="sxs-lookup"><span data-stu-id="17280-107">It is a thin wrapper around the Win32 semaphore object.</span></span> <span data-ttu-id="17280-108">I semafori Win32 sono semafori di conteggio che possono essere usati per controllare l'accesso a un pool di risorse.</span><span class="sxs-lookup"><span data-stu-id="17280-108">Win32 semaphores are counting semaphores, which can be used to control access to a pool of resources.</span></span>  
  
 <span data-ttu-id="17280-109">La classe <xref:System.Threading.SemaphoreSlim> rappresenta un semaforo leggero e veloce che può essere usato per l'attesa in un singolo processo quando si prevedono tempi di attesa molto brevi.</span><span class="sxs-lookup"><span data-stu-id="17280-109">The <xref:System.Threading.SemaphoreSlim> class represents a lightweight, fast semaphore that can be used for waiting within a single process when wait times are expected to be very short.</span></span> <span data-ttu-id="17280-110"><xref:System.Threading.SemaphoreSlim> si basa quanto più possibile sulle primitive di sincronizzazione fornite da Common Language Runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="17280-110"><xref:System.Threading.SemaphoreSlim> relies as much as possible on synchronization primitives provided by the common language runtime (CLR).</span></span> <span data-ttu-id="17280-111">Tuttavia, fornisce anche gli handle di attesa basati sul kernel e inizializzati in modo differito necessari per supportare l'attesa in più semafori.</span><span class="sxs-lookup"><span data-stu-id="17280-111">However, it also provides lazily initialized, kernel-based wait handles as necessary to support waiting on multiple semaphores.</span></span> <span data-ttu-id="17280-112"><xref:System.Threading.SemaphoreSlim> supporta anche l'utilizzo di token di annullamento, ma non supporta i semafori denominati né l'utilizzo di un handle di attesa per la sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="17280-112"><xref:System.Threading.SemaphoreSlim> also supports the use of cancellation tokens, but it does not support named semaphores or the use of a wait handle for synchronization.</span></span>  
  
## <a name="managing-a-limited-resource"></a><span data-ttu-id="17280-113">Gestione di una risorsa limitata</span><span class="sxs-lookup"><span data-stu-id="17280-113">Managing a Limited Resource</span></span>  
 <span data-ttu-id="17280-114">I thread entrano nel semaforo chiamando il metodo <xref:System.Threading.WaitHandle.WaitOne%2A>, che viene ereditato dalla classe <xref:System.Threading.WaitHandle>, nel caso di un oggetto <xref:System.Threading.Semaphore?displayProperty=nameWithType>, oppure il metodo <xref:System.Threading.SemaphoreSlim.Wait%2A?displayProperty=nameWithType> o <xref:System.Threading.SemaphoreSlim.WaitAsync%2A?displayProperty=nameWithType>, nel caso di un oggetto <xref:System.Threading.SemaphoreSlim>.</span><span class="sxs-lookup"><span data-stu-id="17280-114">Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, in the case of a <xref:System.Threading.Semaphore?displayProperty=nameWithType> object, or the <xref:System.Threading.SemaphoreSlim.Wait%2A?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A?displayProperty=nameWithType> method, in the case of a <xref:System.Threading.SemaphoreSlim> object.</span></span> <span data-ttu-id="17280-115">Al termine della chiamata, il conteggio del semaforo viene decrementato.</span><span class="sxs-lookup"><span data-stu-id="17280-115">When the call returns, the count on the semaphore is decremented.</span></span> <span data-ttu-id="17280-116">Quando un thread richiede accesso e il conteggio è zero, il thread si blocca.</span><span class="sxs-lookup"><span data-stu-id="17280-116">When a thread requests entry and the count is zero, the thread blocks.</span></span> <span data-ttu-id="17280-117">Quando i thread rilasciano il semaforo chiamando il metodo <xref:System.Threading.Semaphore.Release%2A?displayProperty=nameWithType> o <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType>, i thread bloccati potranno entrare.</span><span class="sxs-lookup"><span data-stu-id="17280-117">As threads release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> method, blocked threads are allowed to enter.</span></span> <span data-ttu-id="17280-118">Per i thread bloccati al semaforo non esiste alcun ordine garantito, ad esempio first-in, first-out (FIFO) o last-in, first-out (LIFO).</span><span class="sxs-lookup"><span data-stu-id="17280-118">There is no guaranteed order, such as first-in, first-out (FIFO) or last-in, first-out (LIFO), for blocked threads to enter the semaphore.</span></span>  
  
 <span data-ttu-id="17280-119">Un thread può entrare nel semaforo più volte chiamando il metodo <xref:System.Threading.Semaphore?displayProperty=nameWithType> dell'oggetto <xref:System.Threading.WaitHandle.WaitOne%2A> oppure il metodo <xref:System.Threading.SemaphoreSlim> dell'oggetto <xref:System.Threading.SemaphoreSlim.Wait%2A> ripetutamente.</span><span class="sxs-lookup"><span data-stu-id="17280-119">A thread can enter the semaphore multiple times by calling the <xref:System.Threading.Semaphore?displayProperty=nameWithType> object's <xref:System.Threading.WaitHandle.WaitOne%2A> method or the  <xref:System.Threading.SemaphoreSlim> object's <xref:System.Threading.SemaphoreSlim.Wait%2A> method repeatedly.</span></span> <span data-ttu-id="17280-120">Per rilasciare il semaforo, il thread può chiamare l'overload del metodo <xref:System.Threading.Semaphore.Release?displayProperty=nameWithType> o <xref:System.Threading.SemaphoreSlim.Release?displayProperty=nameWithType> per lo stesso numero di volte oppure chiamare l'overload del metodo <xref:System.Threading.Semaphore.Release%28System.Int32%29?displayProperty=nameWithType> o <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29?displayProperty=nameWithType> e specificare il numero di accessi da rilasciare.</span><span class="sxs-lookup"><span data-stu-id="17280-120">To release the semaphore, the thread can either call the <xref:System.Threading.Semaphore.Release?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release?displayProperty=nameWithType> method overload the same number of times, or call the <xref:System.Threading.Semaphore.Release%28System.Int32%29?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29?displayProperty=nameWithType> method overload and specify the number of entries to be released.</span></span>  
  
### <a name="semaphores-and-thread-identity"></a><span data-ttu-id="17280-121">Semafori e identità thread</span><span class="sxs-lookup"><span data-stu-id="17280-121">Semaphores and Thread Identity</span></span>  
 <span data-ttu-id="17280-122">I due tipi di semaforo non applicano l'identità thread alle chiamate ai metodi <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.Semaphore.Release%2A> e <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="17280-122">The two semaphore types do not enforce thread identity on calls to the <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.Semaphore.Release%2A>, and <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="17280-123">Ad esempio, uno scenario di utilizzo comune per i semafori implica un thread producer e un thread consumer, di cui uno incrementa sempre il conteggio del semaforo e l'altro lo decrementa sempre.</span><span class="sxs-lookup"><span data-stu-id="17280-123">For example, a common usage scenario for semaphores involves a producer thread and a consumer thread, with one thread always incrementing the semaphore count and the other always decrementing it.</span></span>  
  
 <span data-ttu-id="17280-124">È compito del programmatore garantire che un thread non rilasci il semaforo troppe volte.</span><span class="sxs-lookup"><span data-stu-id="17280-124">It is the programmer's responsibility to ensure that a thread does not release the semaphore too many times.</span></span> <span data-ttu-id="17280-125">Ad esempio, si consideri un semaforo con un conteggio massimo di due e il thread A e B accedano entrambi al semaforo.</span><span class="sxs-lookup"><span data-stu-id="17280-125">For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</span></span> <span data-ttu-id="17280-126">Se un errore di programmazione nel thread B fa sì che venga chiamato `Release` due volte, entrambe le chiamate hanno esito positivo.</span><span class="sxs-lookup"><span data-stu-id="17280-126">If a programming error in thread B causes it to call  `Release` twice, both calls succeed.</span></span> <span data-ttu-id="17280-127">Il conteggio sul semaforo è completo e quando il thread A alla fine chiama `Release`, viene generata un'eccezione <xref:System.Threading.SemaphoreFullException>.</span><span class="sxs-lookup"><span data-stu-id="17280-127">The count on the semaphore is full, and when thread A eventually calls `Release`, a <xref:System.Threading.SemaphoreFullException> is thrown.</span></span>  
  
## <a name="named-semaphores"></a><span data-ttu-id="17280-128">Semafori denominati</span><span class="sxs-lookup"><span data-stu-id="17280-128">Named Semaphores</span></span>  
 <span data-ttu-id="17280-129">Il sistema operativo Windows consente di assegnare nomi ai semafori.</span><span class="sxs-lookup"><span data-stu-id="17280-129">The Windows operating system allows semaphores to have names.</span></span> <span data-ttu-id="17280-130">Un semaforo denominato è a livello di sistema:</span><span class="sxs-lookup"><span data-stu-id="17280-130">A named semaphore is system wide.</span></span> <span data-ttu-id="17280-131">vale a dire che, una volta creato, il semaforo denominato è visibile a tutti i thread in tutti i processi.</span><span class="sxs-lookup"><span data-stu-id="17280-131">That is, once the named semaphore is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="17280-132">In questo modo, il semaforo denominato può essere usato per sincronizzare le attività di processi e thread.</span><span class="sxs-lookup"><span data-stu-id="17280-132">Thus, named semaphore can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="17280-133">È possibile creare un oggetto <xref:System.Threading.Semaphore> che rappresenta un semaforo di sistema denominato usando uno dei costruttori che specifica un nome.</span><span class="sxs-lookup"><span data-stu-id="17280-133">You can create a <xref:System.Threading.Semaphore> object that represents a named system semaphore by using one of the constructors that specifies a name.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="17280-134">Poiché i semafori denominati sono a livello di sistema, è possibile avere più oggetti <xref:System.Threading.Semaphore> che rappresentano lo stesso semaforo denominato.</span><span class="sxs-lookup"><span data-stu-id="17280-134">Because named semaphores are system wide, it is possible to have multiple <xref:System.Threading.Semaphore> objects that represent the same named semaphore.</span></span> <span data-ttu-id="17280-135">A ogni chiamata a un costruttore o al metodo <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> viene creato un nuovo oggetto <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="17280-135">Each time you call a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method, a new <xref:System.Threading.Semaphore> object is created.</span></span> <span data-ttu-id="17280-136">Specificando lo stesso nome ripetutamente verranno creati più oggetti che rappresentano lo stesso semaforo denominato.</span><span class="sxs-lookup"><span data-stu-id="17280-136">Specifying the same name repeatedly creates multiple objects that represent the same named semaphore.</span></span>  
  
 <span data-ttu-id="17280-137">Prestare attenzione quando si usano i semafori denominati:</span><span class="sxs-lookup"><span data-stu-id="17280-137">Be careful when you use named semaphores.</span></span> <span data-ttu-id="17280-138">siccome sono a livello di sistema, un altro processo che usa lo stesso nome può accedere al semaforo in modo imprevisto.</span><span class="sxs-lookup"><span data-stu-id="17280-138">Because they are system wide, another process that uses the same name can enter your semaphore unexpectedly.</span></span> <span data-ttu-id="17280-139">Il malware in esecuzione sullo stesso computer potrebbe sfruttare questa opportunità per un attacco Denial of Service.</span><span class="sxs-lookup"><span data-stu-id="17280-139">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="17280-140">Usare il controllo degli accessi per proteggere un oggetto <xref:System.Threading.Semaphore> che rappresenta un semaforo denominato, preferibilmente usando un costruttore che specifichi un oggetto <xref:System.Security.AccessControl.SemaphoreSecurity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="17280-140">Use access control security to protect a <xref:System.Threading.Semaphore> object that represents a named semaphore, preferably by using a constructor that specifies a <xref:System.Security.AccessControl.SemaphoreSecurity?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="17280-141">È anche possibile applicare la sicurezza del controllo degli accessi usando il metodo <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>, ma in tal modo verrà creata una finestra di vulnerabilità tra l'ora di creazione del semaforo e l'ora in cui viene protetto.</span><span class="sxs-lookup"><span data-stu-id="17280-141">You can also apply access control security using the <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> method, but this leaves a window of vulnerability between the time the semaphore is created and the time it is protected.</span></span> <span data-ttu-id="17280-142">La protezione dei semafori con la sicurezza del controllo degli accessi aiuta a impedire gli attacchi dannosi, ma non risolve il problema dei conflitti di nomi non intenzionali.</span><span class="sxs-lookup"><span data-stu-id="17280-142">Protecting semaphores with access control security helps prevent malicious attacks, but does not solve the problem of unintentional name collisions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="17280-143">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="17280-143">See also</span></span>

- <xref:System.Threading.Semaphore>
- <xref:System.Threading.SemaphoreSlim>
- [<span data-ttu-id="17280-144">Oggetti e funzionalità di threading</span><span class="sxs-lookup"><span data-stu-id="17280-144">Threading Objects and Features</span></span>](threading-objects-and-features.md)
