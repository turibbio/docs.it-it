---
title: Implementazione del modello asincrono basato su attività
description: Questo articolo illustra come implementare il modello asincrono basato su attività. È possibile usarlo per implementare operazioni asincrone con associazione di calcolo e I/O.
ms.date: 06/14/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework, and TAP
- asynchronous design patterns, .NET Framework
- TAP, .NET Framework support for
- Task-based Asynchronous Pattern, .NET Framework support for
- .NET Framework, asynchronous design patterns
ms.assetid: fab6bd41-91bd-44ad-86f9-d8319988aa78
ms.openlocfilehash: 7d031bab6ba0a4420062eff107aeb1262d9b3b40
ms.sourcegitcommit: 9a4488a3625866335e83a20da5e9c5286b1f034c
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 05/15/2020
ms.locfileid: "83421228"
---
# <a name="implementing-the-task-based-asynchronous-pattern"></a><span data-ttu-id="d132b-104">Implementazione del modello asincrono basato su attività</span><span class="sxs-lookup"><span data-stu-id="d132b-104">Implementing the Task-based Asynchronous Pattern</span></span>
<span data-ttu-id="d132b-105">È possibile implementare il modello asincrono basato su attività (TAP) in i tre modi: con i compilatori C# e Visual Basic in Visual Studio, manualmente oppure con una combinazione dei primi due.</span><span class="sxs-lookup"><span data-stu-id="d132b-105">You can implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span> <span data-ttu-id="d132b-106">Le sezioni seguenti illustrano in dettaglio ogni metodo.</span><span class="sxs-lookup"><span data-stu-id="d132b-106">The following sections discuss each method in detail.</span></span> <span data-ttu-id="d132b-107">È possibile usare il modello TAP per implementare operazioni asincrone di calcolo e di I/O.</span><span class="sxs-lookup"><span data-stu-id="d132b-107">You can use the TAP pattern to implement both compute-bound and I/O-bound asynchronous operations.</span></span> <span data-ttu-id="d132b-108">La sezione [Carichi di lavoro](#workloads) illustra ogni tipo di operazione.</span><span class="sxs-lookup"><span data-stu-id="d132b-108">The [Workloads](#workloads) section discusses each type of operation.</span></span>

## <a name="generating-tap-methods"></a><span data-ttu-id="d132b-109">Generazione di metodi TAP</span><span class="sxs-lookup"><span data-stu-id="d132b-109">Generating TAP methods</span></span>

### <a name="using-the-compilers"></a><span data-ttu-id="d132b-110">Uso dei compilatori</span><span class="sxs-lookup"><span data-stu-id="d132b-110">Using the compilers</span></span>
<span data-ttu-id="d132b-111">A partire da .NET Framework 4.5, qualsiasi metodo con la parola chiave `async` (`Async` in Visual Basic) viene considerato un metodo asincrono e i compilatori C# e Visual Basic eseguono le trasformazioni necessarie per implementare il metodo in modo asincrono tramite TAP.</span><span class="sxs-lookup"><span data-stu-id="d132b-111">Starting with .NET Framework 4.5, any method that is attributed with the `async` keyword (`Async` in Visual Basic) is considered an asynchronous method, and the C# and Visual Basic compilers perform the necessary transformations to implement the method asynchronously by using TAP.</span></span> <span data-ttu-id="d132b-112">Un metodo asincrono deve restituire un oggetto <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> o <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d132b-112">An asynchronous method should return either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="d132b-113">Nel secondo caso, il corpo della funzione deve restituire un oggetto `TResult` e il compilatore garantisce che il risultato sia reso disponibile tramite l'oggetto attività risultante.</span><span class="sxs-lookup"><span data-stu-id="d132b-113">For the latter, the body of the function should return a `TResult`, and the compiler ensures that this result is made available through the resulting task object.</span></span> <span data-ttu-id="d132b-114">Allo stesso modo, viene effettuato il marshalling di qualsiasi eccezione gestita all'interno del corpo del metodo per l'attività di output, per far sì che l'attività risultante termini con lo stato <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d132b-114">Similarly, any exceptions that go unhandled within the body of the method are marshaled to the output task and cause the resulting task to end in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state.</span></span> <span data-ttu-id="d132b-115">L'eccezione a questa regola è quando un <xref:System.OperationCanceledException> (o un tipo derivato) non viene gestito, nel qual caso l'attività risultante termina nello <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> stato.</span><span class="sxs-lookup"><span data-stu-id="d132b-115">The exception to this rule is when an <xref:System.OperationCanceledException> (or derived type) goes unhandled, in which case the resulting task ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>

### <a name="generating-tap-methods-manually"></a><span data-ttu-id="d132b-116">Generazione manuale di metodi TAP</span><span class="sxs-lookup"><span data-stu-id="d132b-116">Generating TAP methods manually</span></span>
<span data-ttu-id="d132b-117">È possibile implementare il modello TAP manualmente per un controllo migliore sull'implementazione.</span><span class="sxs-lookup"><span data-stu-id="d132b-117">You may implement the TAP pattern manually for better control over implementation.</span></span> <span data-ttu-id="d132b-118">Il compilatore si basa sull'area di superficie esposta dallo spazio dei nomi <xref:System.Threading.Tasks?displayProperty=nameWithType> e i tipi di supporto nello spazio dei nomi <xref:System.Runtime.CompilerServices?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d132b-118">The compiler relies on the public surface area exposed from the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace and supporting types in the <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="d132b-119">Per implementare autonomamente il modello TAP, creare un oggetto <xref:System.Threading.Tasks.TaskCompletionSource%601>, eseguire l'operazione asincrona e, al completamento, chiamare il metodo <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A> o <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> oppure la versione `Try` di uno di questi metodi.</span><span class="sxs-lookup"><span data-stu-id="d132b-119">To implement the TAP yourself, you create a <xref:System.Threading.Tasks.TaskCompletionSource%601> object, perform the asynchronous operation, and when it completes, call the <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, or <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> method, or the `Try` version of one of these methods.</span></span> <span data-ttu-id="d132b-120">Quando si implementa un metodo TAP manualmente, è necessario completare l'attività risultante al completamento dell'operazione asincrona rappresentata.</span><span class="sxs-lookup"><span data-stu-id="d132b-120">When you implement a TAP method manually, you must complete the resulting task when the represented asynchronous operation completes.</span></span> <span data-ttu-id="d132b-121">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="d132b-121">For example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#1)]
[!code-vb[Conceptual.TAP_Patterns#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#1)]

### <a name="hybrid-approach"></a><span data-ttu-id="d132b-122">Approccio ibrido</span><span class="sxs-lookup"><span data-stu-id="d132b-122">Hybrid approach</span></span>
 <span data-ttu-id="d132b-123">Potrebbe essere utile implementare manualmente il modello TAP, ma delegare la logica di base per l'implementazione al compilatore.</span><span class="sxs-lookup"><span data-stu-id="d132b-123">You may find it useful to implement the TAP pattern manually but to delegate the core logic for the implementation to the compiler.</span></span> <span data-ttu-id="d132b-124">Ad esempio, è possibile usare l'approccio ibrido per verificare gli argomenti all'esterno di un metodo asincrono generato dal compilatore, in modo che le eccezioni possano aggirare il metodo chiamante diretto anziché essere esposte tramite l'oggetto <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="d132b-124">For example, you may want to use the hybrid approach when you want to verify arguments outside a compiler-generated asynchronous method so that exceptions can escape to the method’s direct caller rather than being exposed through the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object:</span></span>

 [!code-csharp[Conceptual.TAP_Patterns#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#2)]
 [!code-vb[Conceptual.TAP_Patterns#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#2)]

 <span data-ttu-id="d132b-125">Un altro caso in cui tale delega è utile si verifica quando si implementa l'ottimizzazione fast-path e si vuole restituire un'attività nella cache.</span><span class="sxs-lookup"><span data-stu-id="d132b-125">Another case where such delegation is useful is when you're implementing fast-path optimization and want to return a cached task.</span></span>

## <a name="workloads"></a><span data-ttu-id="d132b-126">Carichi di lavoro</span><span class="sxs-lookup"><span data-stu-id="d132b-126">Workloads</span></span>
<span data-ttu-id="d132b-127">È possibile implementare le operazioni asincrone di solo calcolo e associate ai I/O come metodi TAP.</span><span class="sxs-lookup"><span data-stu-id="d132b-127">You may implement both compute-bound and I/O-bound asynchronous operations as TAP methods.</span></span> <span data-ttu-id="d132b-128">Tuttavia, quando i metodi TAP vengono esposti pubblicamente da una libreria, dovrebbero essere forniti solo per i carichi di lavoro che implicano operazioni associate a I/O (che possono anche implicare il calcolo, ma non devono essere puramente di calcolo).</span><span class="sxs-lookup"><span data-stu-id="d132b-128">However, when TAP methods are exposed publicly from a library, they should be provided only for workloads that involve I/O-bound operations (they may also involve computation, but should not be purely computational).</span></span> <span data-ttu-id="d132b-129">Se un metodo è di solo calcolo, deve essere esposto solo come implementazione sincrona.</span><span class="sxs-lookup"><span data-stu-id="d132b-129">If a method is purely compute-bound, it should be exposed only as a synchronous implementation.</span></span> <span data-ttu-id="d132b-130">Il codice che lo utilizza può quindi scegliere se eseguire il wrapping di una chiamata di tale metodo sincrono in un'attività per l'offload del lavoro in un altro thread oppure per ottenere parallelismo.</span><span class="sxs-lookup"><span data-stu-id="d132b-130">The code that consumes it may then choose whether to wrap an invocation of that synchronous method into a task to offload the work to another thread or to achieve parallelism.</span></span> <span data-ttu-id="d132b-131">Se invece un metodo è di I/O, deve essere esposto solo come implementazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="d132b-131">And if a method is I/O-bound, it should be exposed only as an asynchronous implementation.</span></span>

### <a name="compute-bound-tasks"></a><span data-ttu-id="d132b-132">Attività di calcolo</span><span class="sxs-lookup"><span data-stu-id="d132b-132">Compute-bound tasks</span></span>
<span data-ttu-id="d132b-133">La classe <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> è la soluzione ideale per la rappresentazione di operazioni con calcoli complessi.</span><span class="sxs-lookup"><span data-stu-id="d132b-133">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class is ideally suited for representing computationally intensive operations.</span></span> <span data-ttu-id="d132b-134">Per impostazione predefinita, consente di usufruire del supporto speciale all'interno della classe <xref:System.Threading.ThreadPool> per fornire un'esecuzione efficiente e fornisce anche un controllo significativo su quando, dove e come eseguire i calcoli asincroni.</span><span class="sxs-lookup"><span data-stu-id="d132b-134">By default, it takes advantage of special support within the <xref:System.Threading.ThreadPool> class to provide efficient execution, and it also provides significant control over when, where, and how asynchronous computations execute.</span></span>

<span data-ttu-id="d132b-135">È possibile generare attività di calcolo nei seguenti modi:</span><span class="sxs-lookup"><span data-stu-id="d132b-135">You can generate compute-bound tasks in the following ways:</span></span>

- <span data-ttu-id="d132b-136">In .NET Framework 4, usare il metodo <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>, che accetta l'esecuzione asincrona di un delegato (di solito <xref:System.Action%601> o <xref:System.Func%601>).</span><span class="sxs-lookup"><span data-stu-id="d132b-136">In the .NET Framework 4, use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, which accepts a delegate (typically an <xref:System.Action%601> or a <xref:System.Func%601>) to be executed asynchronously.</span></span> <span data-ttu-id="d132b-137">Se l'utente fornisce un delegato <xref:System.Action%601>, il metodo restituisce un oggetto <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> che rappresenta l'esecuzione asincrona di tale delegato.</span><span class="sxs-lookup"><span data-stu-id="d132b-137">If you provide an <xref:System.Action%601> delegate, the method returns a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object that represents the asynchronous execution of that delegate.</span></span> <span data-ttu-id="d132b-138">Se si fornisce un delegato <xref:System.Func%601>, il metodo restituisce un oggetto <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d132b-138">If you provide a <xref:System.Func%601> delegate, the method returns a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="d132b-139">Gli overload del metodo <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> accettano un token di annullamento (<xref:System.Threading.CancellationToken>), opzioni di creazione attività (<xref:System.Threading.Tasks.TaskCreationOptions>) e un'utilità di pianificazione delle attività (<xref:System.Threading.Tasks.TaskScheduler>), tutti i quali offrono un controllo granulare sulla pianificazione e l'esecuzione dell'attività.</span><span class="sxs-lookup"><span data-stu-id="d132b-139">Overloads of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method accept a cancellation token (<xref:System.Threading.CancellationToken>), task creation options (<xref:System.Threading.Tasks.TaskCreationOptions>), and a task scheduler (<xref:System.Threading.Tasks.TaskScheduler>), all of which provide fine-grained control over the scheduling and execution of the task.</span></span> <span data-ttu-id="d132b-140">Un'istanza della factory destinata all'utilità di pianificazione dell'attività corrente è disponibile come proprietà statica (<xref:System.Threading.Tasks.Task.Factory%2A>) della classe <xref:System.Threading.Tasks.Task>; ad esempio: `Task.Factory.StartNew(…)`.</span><span class="sxs-lookup"><span data-stu-id="d132b-140">A factory instance that targets the current task scheduler is available as a static property (<xref:System.Threading.Tasks.Task.Factory%2A>) of the <xref:System.Threading.Tasks.Task> class; for example: `Task.Factory.StartNew(…)`.</span></span>

- <span data-ttu-id="d132b-141">In .NET Framework 4.5 e versioni successive inclusi .NET Core e .NET Standard, usare il metodo statico <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> come collegamento a <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d132b-141">In the .NET Framework 4.5 and later versions (including .NET Core and .NET Standard), use the static <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method as a shortcut to <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d132b-142">È possibile usare <xref:System.Threading.Tasks.Task.Run%2A> per avviare facilmente un'attività di calcolo destinata al pool di thread.</span><span class="sxs-lookup"><span data-stu-id="d132b-142">You may use <xref:System.Threading.Tasks.Task.Run%2A> to easily launch a compute-bound task that targets the thread pool.</span></span> <span data-ttu-id="d132b-143">In .NET Framework 4.5 e versioni successive questo è il meccanismo preferenziale per l'avvio di un'attività di calcolo.</span><span class="sxs-lookup"><span data-stu-id="d132b-143">In the .NET Framework 4.5 and later versions, this is the preferred mechanism for launching a compute-bound task.</span></span> <span data-ttu-id="d132b-144">Usare `StartNew` direttamente solo quando si vuole controllare l'attività in modo più accurato.</span><span class="sxs-lookup"><span data-stu-id="d132b-144">Use `StartNew` directly only when you want more fine-grained control over the task.</span></span>

- <span data-ttu-id="d132b-145">Usare i costruttori del tipo `Task` o del metodo `Start` se si vuol generare e pianificare l'attività separatamente.</span><span class="sxs-lookup"><span data-stu-id="d132b-145">Use the constructors of the `Task` type or the `Start` method if you want to generate and schedule the task separately.</span></span> <span data-ttu-id="d132b-146">I metodi pubblici devono restituire solo operazioni già avviate.</span><span class="sxs-lookup"><span data-stu-id="d132b-146">Public methods must only return tasks that have already been started.</span></span>

- <span data-ttu-id="d132b-147">Usare gli overload del metodo <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d132b-147">Use the overloads of the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d132b-148">Questo metodo crea una nuova attività pianificata al completamento di un'altra attività.</span><span class="sxs-lookup"><span data-stu-id="d132b-148">This method creates a new task that is scheduled when another task completes.</span></span> <span data-ttu-id="d132b-149">Alcuni degli overload <xref:System.Threading.Tasks.Task.ContinueWith%2A> accettano un token di annullamento, opzioni di continuazione e un'utilità di pianificazione delle attività per un miglior un controllo sulla pianificazione e l'esecuzione dell'attività di continuazione.</span><span class="sxs-lookup"><span data-stu-id="d132b-149">Some of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> overloads accept a cancellation token, continuation options, and a task scheduler for better control over the scheduling and execution of the continuation task.</span></span>

- <span data-ttu-id="d132b-150">Usare i metodi <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> e <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d132b-150">Use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="d132b-151">Questi metodi creano una nuova attività pianificata al completamento di tutte o una qualsiasi delle attività di un set fornito.</span><span class="sxs-lookup"><span data-stu-id="d132b-151">These methods create a new task that is scheduled when all or any of a supplied set of tasks completes.</span></span> <span data-ttu-id="d132b-152">Questi metodi forniscono anche gli overload per controllare la pianificazione e l'esecuzione di queste attività.</span><span class="sxs-lookup"><span data-stu-id="d132b-152">These methods also provide overloads to control the scheduling and execution of these tasks.</span></span>

<span data-ttu-id="d132b-153">Nelle operazioni di calcolo, il sistema può impedire l'esecuzione di un'operazione pianificata se riceve una richiesta di annullamento prima dell'avvio dell'esecuzione dell'attività.</span><span class="sxs-lookup"><span data-stu-id="d132b-153">In compute-bound tasks, the system can prevent the execution of a scheduled task if it receives a cancellation request before it starts running the task.</span></span> <span data-ttu-id="d132b-154">In tal caso, se si fornisce un token di annullamento (oggetto <xref:System.Threading.CancellationToken>), è possibile passare tale token al codice asincrono che monitora il token.</span><span class="sxs-lookup"><span data-stu-id="d132b-154">As such, if you provide a cancellation token (<xref:System.Threading.CancellationToken> object), you can pass that token to the asynchronous code that monitors the token.</span></span> <span data-ttu-id="d132b-155">È anche possibile fornire il token a uno dei metodi indicati in precedenza, ad esempio `StartNew` o `Run` in modo che il runtime `Task` possa monitorare anche il token.</span><span class="sxs-lookup"><span data-stu-id="d132b-155">You can also provide the token to one of the previously mentioned methods such as `StartNew` or `Run` so that the `Task` runtime may also monitor the token.</span></span>

<span data-ttu-id="d132b-156">Si consideri ad esempio un metodo asincrono che esegue il rendering di un'immagine.</span><span class="sxs-lookup"><span data-stu-id="d132b-156">For example, consider an asynchronous method that renders an image.</span></span> <span data-ttu-id="d132b-157">Il corpo dell'attività può eseguire il polling del token di annullamento in modo che il codice esca anticipatamente se arriva una richiesta di annullamento durante il rendering.</span><span class="sxs-lookup"><span data-stu-id="d132b-157">The body of the task can poll the cancellation token so that the code may exit early if a cancellation request arrives during rendering.</span></span> <span data-ttu-id="d132b-158">Inoltre, se arriva la richiesta di annullamento prima dell'inizio del rendering, sarà opportuno evitare l'operazione di rendering:</span><span class="sxs-lookup"><span data-stu-id="d132b-158">In addition, if the cancellation request arrives before rendering starts, you'll want to prevent the rendering operation:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#3)]
[!code-vb[Conceptual.TAP_Patterns#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#3)]

<span data-ttu-id="d132b-159">Le attività di calcolo terminano in uno stato <xref:System.Threading.Tasks.TaskStatus.Canceled> se almeno una delle condizioni seguenti si verifica:</span><span class="sxs-lookup"><span data-stu-id="d132b-159">Compute-bound tasks end in a <xref:System.Threading.Tasks.TaskStatus.Canceled> state if at least one of the following conditions is true:</span></span>

- <span data-ttu-id="d132b-160">Una richiesta di annullamento arriva tramite l'oggetto <xref:System.Threading.CancellationToken>, fornito come argomento al metodo di creazione, (ad esempio `StartNew` o `Run`) prima che l'attività passi allo stato <xref:System.Threading.Tasks.TaskStatus.Running>.</span><span class="sxs-lookup"><span data-stu-id="d132b-160">A cancellation request arrives through the <xref:System.Threading.CancellationToken> object, which is provided as an argument to the creation method (for example, `StartNew` or `Run`) before the task transitions to the <xref:System.Threading.Tasks.TaskStatus.Running> state.</span></span>

- <span data-ttu-id="d132b-161">Un'eccezione <xref:System.OperationCanceledException> non viene gestita nel corpo di tale attività, tale eccezione contiene lo stesso oggetto <xref:System.Threading.CancellationToken> passato all'attività e il token indica che viene richiesto l'annullamento.</span><span class="sxs-lookup"><span data-stu-id="d132b-161">An <xref:System.OperationCanceledException> exception goes unhandled within the body of such a task, that exception contains the same <xref:System.Threading.CancellationToken> that is passed to the task, and that token shows that cancellation is requested.</span></span>

<span data-ttu-id="d132b-162">Se un'altra eccezione non viene gestita nel corpo dell'attività, l'attività termina nello stato <xref:System.Threading.Tasks.TaskStatus.Faulted> e tutti i tentativi di attesa dell'attività o di accesso al risultato causano la generazione di un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="d132b-162">If another exception goes unhandled within the body of the task, the task ends in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state, and any attempts to wait on the task or access its result causes an exception to be thrown.</span></span>

### <a name="io-bound-tasks"></a><span data-ttu-id="d132b-163">Attività di I/O</span><span class="sxs-lookup"><span data-stu-id="d132b-163">I/O-bound tasks</span></span>
<span data-ttu-id="d132b-164">Per creare un'attività che non deve essere supportata direttamente da un thread per l'intera esecuzione, usare il tipo <xref:System.Threading.Tasks.TaskCompletionSource%601>.</span><span class="sxs-lookup"><span data-stu-id="d132b-164">To create a task that should not be directly backed by a thread for the entirety of its execution, use the <xref:System.Threading.Tasks.TaskCompletionSource%601> type.</span></span> <span data-ttu-id="d132b-165">Questo tipo espone una proprietà <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> che restituisce un'istanza di <xref:System.Threading.Tasks.Task%601> associata.</span><span class="sxs-lookup"><span data-stu-id="d132b-165">This type exposes a <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> property that returns an associated <xref:System.Threading.Tasks.Task%601> instance.</span></span> <span data-ttu-id="d132b-166">Il ciclo di vita di questa attività viene controllato con i metodi <xref:System.Threading.Tasks.TaskCompletionSource%601> come <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> e relative varianti `TrySet`.</span><span class="sxs-lookup"><span data-stu-id="d132b-166">The life cycle of this task is controlled by <xref:System.Threading.Tasks.TaskCompletionSource%601> methods such as <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, and their `TrySet` variants.</span></span>

<span data-ttu-id="d132b-167">Si supponga di voler creare un'attività che verrà completata dopo un periodo di tempo specificato.</span><span class="sxs-lookup"><span data-stu-id="d132b-167">Let's say that you want to create a task that will complete after a specified period of time.</span></span> <span data-ttu-id="d132b-168">Ad esempio, è possibile ritardare un'attività nell'interfaccia utente.</span><span class="sxs-lookup"><span data-stu-id="d132b-168">For example, you may want to delay an activity in the user interface.</span></span> <span data-ttu-id="d132b-169">La classe <xref:System.Threading.Timer?displayProperty=nameWithType> consente già di richiamare in modo asincrono un delegato dopo un determinato periodo di tempo e usando <xref:System.Threading.Tasks.TaskCompletionSource%601> è possibile inserire un oggetto <xref:System.Threading.Tasks.Task%601> all'inizio del timer, ad esempio:</span><span class="sxs-lookup"><span data-stu-id="d132b-169">The <xref:System.Threading.Timer?displayProperty=nameWithType> class already provides the ability to asynchronously invoke a delegate after a specified period of time, and by using <xref:System.Threading.Tasks.TaskCompletionSource%601> you can put a <xref:System.Threading.Tasks.Task%601> front on the timer, for example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#4)]
[!code-vb[Conceptual.TAP_Patterns#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#4)]

<span data-ttu-id="d132b-170">A partire da .NET Framework 4.5, il metodo <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> viene specificato a questo scopo e può essere usato, ad esempio, in un altro metodo asincrono per implementare un ciclo asincrono di polling:</span><span class="sxs-lookup"><span data-stu-id="d132b-170">Starting with the .NET Framework 4.5, the <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method is provided for this purpose, and you can use it inside another asynchronous method, for example, to implement an asynchronous polling loop:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#5)]
[!code-vb[Conceptual.TAP_Patterns#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#5)]

<span data-ttu-id="d132b-171">La classe <xref:System.Threading.Tasks.TaskCompletionSource%601> non ha una controparte non generica.</span><span class="sxs-lookup"><span data-stu-id="d132b-171">The <xref:System.Threading.Tasks.TaskCompletionSource%601> class doesn't have a non-generic counterpart.</span></span> <span data-ttu-id="d132b-172">Tuttavia, <xref:System.Threading.Tasks.Task%601> deriva da <xref:System.Threading.Tasks.Task>, quindi è possibile usare l'oggetto generico <xref:System.Threading.Tasks.TaskCompletionSource%601> per i metodi associati a I/O che restituiscono semplicemente un'attività.</span><span class="sxs-lookup"><span data-stu-id="d132b-172">However, <xref:System.Threading.Tasks.Task%601> derives from <xref:System.Threading.Tasks.Task>, so you can use the generic <xref:System.Threading.Tasks.TaskCompletionSource%601> object for I/O-bound methods that simply return a task.</span></span> <span data-ttu-id="d132b-173">A questo scopo, è possibile usare un database di origine con oggetto `TResult` fittizio (<xref:System.Boolean> è una scelta ottimale predefinita, ma se si teme che l'utente di <xref:System.Threading.Tasks.Task> ne esegua il downcast in <xref:System.Threading.Tasks.Task%601>, è possibile usare un tipo privato `TResult`).</span><span class="sxs-lookup"><span data-stu-id="d132b-173">To do this, you can use a source with a dummy `TResult` (<xref:System.Boolean> is a good default choice, but if you're concerned about the user of the <xref:System.Threading.Tasks.Task> downcasting it to a <xref:System.Threading.Tasks.Task%601>, you can use a private `TResult` type instead).</span></span> <span data-ttu-id="d132b-174">Ad esempio, il metodo `Delay` nell'esempio precedente restituisce l'ora corrente con l'offset risultante (`Task<DateTimeOffset>`).</span><span class="sxs-lookup"><span data-stu-id="d132b-174">For example, the `Delay` method in the previous example returns the current time along with the resulting offset (`Task<DateTimeOffset>`).</span></span> <span data-ttu-id="d132b-175">Se tale valore non è necessario, il metodo potrebbe invece essere codificato come segue (notare la modifica del tipo restituito e la modifica dell'argomento in <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span><span class="sxs-lookup"><span data-stu-id="d132b-175">If such a result value is unnecessary, the method could instead be coded as follows (note the change of return type and the change of argument to <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span></span>

[!code-csharp[Conceptual.TAP_Patterns#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#6)]
[!code-vb[Conceptual.TAP_Patterns#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#6)]

### <a name="mixed-compute-bound-and-io-bound-tasks"></a><span data-ttu-id="d132b-176">Attività miste di calcolo e di I/O</span><span class="sxs-lookup"><span data-stu-id="d132b-176">Mixed compute-bound and I/O-bound tasks</span></span>
<span data-ttu-id="d132b-177">I metodi asincroni non sono limitati solo a operazioni associate a calcolo o I/O, ma possono rappresentare una combinazione di entrambe.</span><span class="sxs-lookup"><span data-stu-id="d132b-177">Asynchronous methods are not limited to just compute-bound or I/O-bound operations but may represent a mixture of the two.</span></span> <span data-ttu-id="d132b-178">Infatti, più operazioni asincrone vengono combinate spesso in operazioni miste di dimensioni maggiori.</span><span class="sxs-lookup"><span data-stu-id="d132b-178">In fact, multiple asynchronous operations are often combined into larger mixed operations.</span></span> <span data-ttu-id="d132b-179">In un esempio precedente, tramite il metodo `RenderAsync` era stata effettuata un'operazione complessa a livello di calcolo per eseguire il rendering di un'immagine basata su un input `imageData`.</span><span class="sxs-lookup"><span data-stu-id="d132b-179">For example, the `RenderAsync` method in a previous example performed a computationally intensive operation to render an image based on some input `imageData`.</span></span> <span data-ttu-id="d132b-180">Questi `imageData` possono provenire da un servizio Web a cui si accede in modo asincrono:</span><span class="sxs-lookup"><span data-stu-id="d132b-180">This `imageData` could come from a web service that you asynchronously access:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#7)]
[!code-vb[Conceptual.TAP_Patterns#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#7)]

<span data-ttu-id="d132b-181">In questo esempio viene illustrato come un unico token di annullamento può essere multithreading con più operazioni asincrone.</span><span class="sxs-lookup"><span data-stu-id="d132b-181">This example also demonstrates how a single cancellation token may be threaded through multiple asynchronous operations.</span></span> <span data-ttu-id="d132b-182">Per altre informazioni, vedere la sezione relativa all'annullamento in [Utilizzo del modello asincrono basato su attività](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="d132b-182">For more information, see the cancellation usage section in [Consuming the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="d132b-183">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="d132b-183">See also</span></span>

- [<span data-ttu-id="d132b-184">Modello asincrono basato su attività (TAP)</span><span class="sxs-lookup"><span data-stu-id="d132b-184">Task-based Asynchronous Pattern (TAP)</span></span>](../../../docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)
- [<span data-ttu-id="d132b-185">Consuming the Task-based Asynchronous Pattern</span><span class="sxs-lookup"><span data-stu-id="d132b-185">Consuming the Task-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)
- [<span data-ttu-id="d132b-186">Interoperabilità con altri tipi e modelli asincroni</span><span class="sxs-lookup"><span data-stu-id="d132b-186">Interop with Other Asynchronous Patterns and Types</span></span>](../../../docs/standard/asynchronous-programming-patterns/interop-with-other-asynchronous-patterns-and-types.md)
