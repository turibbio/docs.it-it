---
title: Modello asincrono basato su attività (TAP)
description: Informazioni sul modello asincrono basato su attività (TAP). TAP è il modello di progettazione asincrono consigliato per lo sviluppo in .NET.
ms.date: 02/26/2019
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework, and TAP
- asynchronous design patterns, .NET Framework
- TAP, .NET Framework support for
- Task-based Asynchronous Pattern, .NET Framework support for
- .NET Framework, asynchronous design patterns
ms.assetid: 8cef1fcf-6f9f-417c-b21f-3fd8bac75007
ms.openlocfilehash: 21675d26fa2f11d93801e2ba4ffec96b238b97b8
ms.sourcegitcommit: dc2feef0794cf41dbac1451a13b8183258566c0e
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/24/2020
ms.locfileid: "85325071"
---
# <a name="task-based-asynchronous-pattern"></a><span data-ttu-id="b34ab-104">Modello asincrono basato su attività</span><span class="sxs-lookup"><span data-stu-id="b34ab-104">Task-based asynchronous pattern</span></span>

<span data-ttu-id="b34ab-105">Il modello asincrono basato su attività (TAP) si basa sui <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> tipi e <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> nello <xref:System.Threading.Tasks?displayProperty=nameWithType> spazio dei nomi, usati per rappresentare operazioni asincrone arbitrarie.</span><span class="sxs-lookup"><span data-stu-id="b34ab-105">The task-based asynchronous pattern (TAP) is based on the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> types in the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace, which are used to represent arbitrary asynchronous operations.</span></span> <span data-ttu-id="b34ab-106">TAP è il modello di progettazione asincrono consigliato per le nuove attività di sviluppo.</span><span class="sxs-lookup"><span data-stu-id="b34ab-106">TAP is the recommended asynchronous design pattern for new development.</span></span>  
  
## <a name="naming-parameters-and-return-types"></a><span data-ttu-id="b34ab-107">Denominazione, parametri e tipi restituiti</span><span class="sxs-lookup"><span data-stu-id="b34ab-107">Naming, parameters, and return types</span></span>

<span data-ttu-id="b34ab-108">TAP usa un singolo metodo per rappresentare l'inizio e il completamento di un'operazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="b34ab-108">TAP uses a single method to represent the initiation and completion of an asynchronous operation.</span></span> <span data-ttu-id="b34ab-109">Tale comportamento è in contrasto sia con il modello di programmazione asincrona (APM o `IAsyncResult`) che con il modello asincrono basato su eventi (EAP).</span><span class="sxs-lookup"><span data-stu-id="b34ab-109">This contrasts with both the Asynchronous Programming Model (APM or `IAsyncResult`) pattern and the Event-based Asynchronous Pattern (EAP).</span></span> <span data-ttu-id="b34ab-110">Il modello di programmazione asincrona richiede i metodi `Begin` ed `End`.</span><span class="sxs-lookup"><span data-stu-id="b34ab-110">APM requires `Begin` and `End` methods.</span></span> <span data-ttu-id="b34ab-111">Il modello asincrono basato su eventi richiede un metodo con il suffisso `Async`, oltre a uno o più eventi, i tipi delegati del gestore eventi e i tipi derivati da `EventArg`.</span><span class="sxs-lookup"><span data-stu-id="b34ab-111">EAP requires a method that has the `Async` suffix and also requires one or more events, event handler delegate types, and `EventArg`-derived types.</span></span> <span data-ttu-id="b34ab-112">I metodi asincroni in TAP includono il suffisso `Async` dopo il nome dell'operazione per i metodi che restituiscono tipi awaitable, ad esempio, <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.ValueTask> e <xref:System.Threading.Tasks.ValueTask%601>.</span><span class="sxs-lookup"><span data-stu-id="b34ab-112">Asynchronous methods in TAP include the `Async` suffix after the operation name for methods that return awaitable types, such as <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.ValueTask>, and <xref:System.Threading.Tasks.ValueTask%601>.</span></span> <span data-ttu-id="b34ab-113">Ad esempio, un'operazione `Get` asincrona che restituisce `Task<String>` può essere denominata `GetAsync`.</span><span class="sxs-lookup"><span data-stu-id="b34ab-113">For example, an asynchronous `Get` operation that returns a `Task<String>` can be named `GetAsync`.</span></span> <span data-ttu-id="b34ab-114">Se si aggiunge un metodo TAP a una classe che contiene già il nome di un metodo EAP con il suffisso `Async`, usare invece il suffisso `TaskAsync`.</span><span class="sxs-lookup"><span data-stu-id="b34ab-114">If you're adding a TAP method to a class that already contains an EAP method name with the `Async` suffix, use the suffix `TaskAsync` instead.</span></span> <span data-ttu-id="b34ab-115">Ad esempio, se la classe dispone già di un metodo `GetAsync`, usare il nome `GetTaskAsync`.</span><span class="sxs-lookup"><span data-stu-id="b34ab-115">For example, if the class already has a `GetAsync` method, use the name `GetTaskAsync`.</span></span> <span data-ttu-id="b34ab-116">Se un metodo avvia un'operazione asincrona, ma non restituisce un tipo awaitable, il nome dovrebbe iniziare con `Begin`, `Start` o un altro verbo per suggerire che questo metodo non restituisce o genera il risultato dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="b34ab-116">If a method starts an asynchronous operation but does not return an awaitable type, its name should start with `Begin`, `Start`, or some other verb to suggest that this method does not return or throw the result of the operation.</span></span>  
  
 <span data-ttu-id="b34ab-117">Un metodo TAP restituisce <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> o <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, a seconda che il metodo sincrono corrispondente restituisca void o un tipo `TResult`.</span><span class="sxs-lookup"><span data-stu-id="b34ab-117">A TAP method returns either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, based on whether the corresponding synchronous method returns void or a type `TResult`.</span></span>  
  
 <span data-ttu-id="b34ab-118">I parametri di un metodo TAP devono corrispondere ai parametri della relativa controparte sincrona e devono essere forniti nello stesso ordine.</span><span class="sxs-lookup"><span data-stu-id="b34ab-118">The parameters of a TAP method should match the parameters of its synchronous counterpart and should be provided in the same order.</span></span>  <span data-ttu-id="b34ab-119">Tuttavia, i parametri `out` e `ref` sono esclusi da questa regola e dovrebbero essere evitati completamente.</span><span class="sxs-lookup"><span data-stu-id="b34ab-119">However, `out` and `ref` parameters are exempt from this rule and should be avoided entirely.</span></span> <span data-ttu-id="b34ab-120">Tutti i dati che dovrebbero venire restituiti da un parametro `out` o `ref` dovranno invece essere restituiti come parte di `TResult` restituito da <xref:System.Threading.Tasks.Task%601> e usare una tupla o una struttura dei dati personalizzata per contenere più valori.</span><span class="sxs-lookup"><span data-stu-id="b34ab-120">Any data that would have been returned through an `out` or `ref` parameter should instead be returned as part of the `TResult` returned by <xref:System.Threading.Tasks.Task%601>, and should use a tuple or a custom data structure to accommodate multiple values.</span></span> <span data-ttu-id="b34ab-121">Si consiglia inoltre di aggiungere un <xref:System.Threading.CancellationToken> parametro anche se la controparte sincrona del metodo TAP non ne offre una.</span><span class="sxs-lookup"><span data-stu-id="b34ab-121">Also, consider adding a <xref:System.Threading.CancellationToken> parameter even if the TAP method's synchronous counterpart does not offer one.</span></span>

 <span data-ttu-id="b34ab-122">I metodi dedicati esclusivamente alla creazione, modifica o combinazione di attività (dove l'intento asincrono del metodo risulta chiaro nel nome del metodo o nel nome del tipo a cui appartiene il metodo) non devono seguire questo modello di denominazione. Tali metodi vengono spesso definiti *combinatori*.</span><span class="sxs-lookup"><span data-stu-id="b34ab-122">Methods that are devoted exclusively to the creation, manipulation, or combination of tasks (where the asynchronous intent of the method is clear in the method name or in the name of the type to which the method belongs) need not follow this naming pattern; such methods are often referred to as *combinators*.</span></span> <span data-ttu-id="b34ab-123">Esempi di combinatori includono <xref:System.Threading.Tasks.Task.WhenAll%2A> e <xref:System.Threading.Tasks.Task.WhenAny%2A> e sono illustrati nella sezione [Utilizzo di combinatori incorporati basati su attività](consuming-the-task-based-asynchronous-pattern.md#combinators) dell'articolo [Utilizzo del modello asincrono basato su attività](consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="b34ab-123">Examples of combinators include <xref:System.Threading.Tasks.Task.WhenAll%2A> and <xref:System.Threading.Tasks.Task.WhenAny%2A>, and are discussed in the [Using the Built-in Task-based Combinators](consuming-the-task-based-asynchronous-pattern.md#combinators) section of the article [Consuming the Task-based Asynchronous Pattern](consuming-the-task-based-asynchronous-pattern.md).</span></span>  
  
 <span data-ttu-id="b34ab-124">Per esempi relativi alle differenze di sintassi di TAP rispetto ai modelli di programmazione asincrona legacy, come il modello di programmazione asincrono (APM) e il modello asincrono basato su eventi (EAP), vedere [Modelli di programmazione asincrona](index.md).</span><span class="sxs-lookup"><span data-stu-id="b34ab-124">For examples of how the TAP syntax differs from the syntax used in legacy asynchronous programming patterns such as the Asynchronous Programming Model (APM) and the Event-based Asynchronous Pattern (EAP), see [Asynchronous Programming Patterns](index.md).</span></span>  
  
## <a name="initiating-an-asynchronous-operation"></a><span data-ttu-id="b34ab-125">Avvio di un'operazione asincrona</span><span class="sxs-lookup"><span data-stu-id="b34ab-125">Initiating an asynchronous operation</span></span>  
 <span data-ttu-id="b34ab-126">Un metodo asincrono basato su TAP può eseguire una piccola quantità di lavoro in modo sincrono, ad esempio convalidare gli argomenti e avviare l'operazione asincrona, prima di restituire l'attività risultante.</span><span class="sxs-lookup"><span data-stu-id="b34ab-126">An asynchronous method that is based on TAP can do a small amount of work synchronously, such as validating arguments and initiating the asynchronous operation, before it returns the resulting task.</span></span> <span data-ttu-id="b34ab-127">Le attività sincrone devono essere minime in modo che il metodo asincrono possa eseguire rapidamente la restituzione.</span><span class="sxs-lookup"><span data-stu-id="b34ab-127">Synchronous work should be kept to the minimum so the asynchronous method can return quickly.</span></span> <span data-ttu-id="b34ab-128">I motivi di un ritorno rapido includono:</span><span class="sxs-lookup"><span data-stu-id="b34ab-128">Reasons for a quick return include:</span></span>  
  
- <span data-ttu-id="b34ab-129">I metodi asincroni possono essere richiamati dai thread dell'interfaccia utente e le attività sincrone a esecuzione prolungata potrebbero compromettere la velocità di risposta dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="b34ab-129">Asynchronous methods may be invoked from user interface (UI) threads, and any long-running synchronous work could harm the responsiveness of the application.</span></span>  
  
- <span data-ttu-id="b34ab-130">Più metodi asincroni possono essere avviati simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="b34ab-130">Multiple asynchronous methods may be launched concurrently.</span></span> <span data-ttu-id="b34ab-131">Pertanto, le attività a esecuzione prolungata nella parte sincrona di un metodo asincrono possono ritardare l'avvio di altre operazioni asincrone, riducendo quindi i vantaggi della concorrenza.</span><span class="sxs-lookup"><span data-stu-id="b34ab-131">Therefore, any long-running work in the synchronous portion of an asynchronous method could delay the initiation of other asynchronous operations, thereby decreasing the benefits of concurrency.</span></span>  
  
 <span data-ttu-id="b34ab-132">In alcuni casi, la quantità di lavoro richiesta per completare l'operazione è inferiore alla quantità di lavoro richiesta per avviare un'operazione in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="b34ab-132">In some cases, the amount of work required to complete the operation is less than the amount of work required to launch the operation asynchronously.</span></span> <span data-ttu-id="b34ab-133">La lettura da un flusso in cui l'operazione di lettura può essere soddisfatta dai dati che sono già stati memorizzati nel buffer in memoria è un esempio di tale scenario.</span><span class="sxs-lookup"><span data-stu-id="b34ab-133">Reading from a stream where the read operation can be satisfied by data that is already buffered in memory is an example of such a scenario.</span></span> <span data-ttu-id="b34ab-134">In tali casi, l'operazione può essere completata in modo sincrono e può restituire un'attività già completata.</span><span class="sxs-lookup"><span data-stu-id="b34ab-134">In such cases, the operation may complete synchronously, and may return a task that has already been completed.</span></span>  
  
## <a name="exceptions"></a><span data-ttu-id="b34ab-135">Eccezioni</span><span class="sxs-lookup"><span data-stu-id="b34ab-135">Exceptions</span></span>  
 <span data-ttu-id="b34ab-136">Un metodo asincrono dovrebbe generare un'eccezione utilizzabile da una chiamata al metodo asincrono solo in risposta a un errore di utilizzo.</span><span class="sxs-lookup"><span data-stu-id="b34ab-136">An asynchronous method should raise an exception to be thrown out of the asynchronous method call only in response to a usage error.</span></span> <span data-ttu-id="b34ab-137">Gli errori di utilizzo non devono mai verificarsi nel codice di produzione.</span><span class="sxs-lookup"><span data-stu-id="b34ab-137">Usage errors should never occur in production code.</span></span> <span data-ttu-id="b34ab-138">Se, ad esempio, il passaggio di un riferimento null ( `Nothing` in Visual Basic) come uno degli argomenti del metodo genera uno stato di errore, in genere rappresentato da un' <xref:System.ArgumentNullException> eccezione, è possibile modificare il codice chiamante per assicurarsi che non venga mai passato un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="b34ab-138">For example, if passing a null reference (`Nothing` in Visual Basic) as one of the method's arguments causes an error state (usually represented by an <xref:System.ArgumentNullException> exception), you can modify the calling code to ensure that a null reference is never passed.</span></span> <span data-ttu-id="b34ab-139">Per tutti gli altri errori, le eccezioni che si verificano quando un metodo asincrono è in esecuzione devono essere assegnate all'attività restituita, anche se il metodo asincrono viene completato in modo sincrono prima che l'attività venga restituita.</span><span class="sxs-lookup"><span data-stu-id="b34ab-139">For all other errors, exceptions that occur when an asynchronous method is running should be assigned to the returned task, even if the asynchronous method happens to complete synchronously before the task is returned.</span></span> <span data-ttu-id="b34ab-140">In genere, un'attività contiene al massimo un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b34ab-140">Typically, a task contains at most one exception.</span></span> <span data-ttu-id="b34ab-141">Tuttavia, se l'attività rappresenta più operazioni, (ad esempio <xref:System.Threading.Tasks.Task.WhenAll%2A>), più eccezioni possono essere associate a una singola attività.</span><span class="sxs-lookup"><span data-stu-id="b34ab-141">However, if the task represents multiple operations (for example, <xref:System.Threading.Tasks.Task.WhenAll%2A>), multiple exceptions may be associated with a single task.</span></span>  
  
## <a name="target-environment"></a><span data-ttu-id="b34ab-142">Ambiente di destinazione</span><span class="sxs-lookup"><span data-stu-id="b34ab-142">Target environment</span></span>  
 <span data-ttu-id="b34ab-143">Quando si implementa un metodo TAP, è possibile determinare quando si verifica l'esecuzione asincrona.</span><span class="sxs-lookup"><span data-stu-id="b34ab-143">When you implement a TAP method, you can determine where asynchronous execution occurs.</span></span> <span data-ttu-id="b34ab-144">È possibile scegliere di eseguire il carico di lavoro nel pool di thread, implementarlo utilizzando l'I/O asincrono (senza essere associato a un thread per la maggior parte dell'esecuzione dell'operazione), eseguirlo su un thread specifico, ad esempio il thread dell'interfaccia utente, oppure usare un numero qualsiasi di contesti potenziali.</span><span class="sxs-lookup"><span data-stu-id="b34ab-144">You may choose to execute the workload on the thread pool, implement it by using asynchronous I/O (without being bound to a thread for the majority of the operation's execution), run it on a specific thread (such as the UI thread), or use any number of potential contexts.</span></span> <span data-ttu-id="b34ab-145">Un metodo TAP può anche non avere alcun elemento da eseguire e restituire solo un <xref:System.Threading.Tasks.Task> che rappresenta l'occorrenza di una condizione in un'altra posizione nel sistema (ad esempio, un'attività che rappresenta i dati provenienti da una struttura di dati in coda).</span><span class="sxs-lookup"><span data-stu-id="b34ab-145">A TAP method may even have nothing to execute, and may just return a <xref:System.Threading.Tasks.Task> that represents the occurrence of a condition elsewhere in the system (for example, a task that represents data arriving at a queued data structure).</span></span>

 <span data-ttu-id="b34ab-146">Il chiamante del metodo TAP può smettere di attendere il completamento del metodo TAP rimanendo in attesa in modalità sincrona dell'attività risultante o potrebbe eseguire codice aggiuntivo (continuazione) al completamento dell'operazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="b34ab-146">The caller of the TAP method may block waiting for the TAP method to complete by synchronously waiting on the resulting task, or may run additional (continuation) code when the asynchronous operation completes.</span></span> <span data-ttu-id="b34ab-147">L'autore del codice di continuazione è in grado di controllare dove viene eseguito il codice.</span><span class="sxs-lookup"><span data-stu-id="b34ab-147">The creator of the continuation code has control over where that code executes.</span></span> <span data-ttu-id="b34ab-148">È possibile creare il codice di continuazione in modo esplicito, con i metodi della classe <xref:System.Threading.Tasks.Task>, (ad esempio <xref:System.Threading.Tasks.Task.ContinueWith%2A>), o in modo implicito, usando il supporto linguistico compilato sulla base delle continuazioni, (ad esempio `await` in C#, `Await` in Visual Basic, `AwaitValue` in F#).</span><span class="sxs-lookup"><span data-stu-id="b34ab-148">You may create the continuation code either explicitly, through methods on the <xref:System.Threading.Tasks.Task> class (for example, <xref:System.Threading.Tasks.Task.ContinueWith%2A>) or implicitly, by using language support built on top of continuations (for example, `await` in C#, `Await` in Visual Basic, `AwaitValue` in F#).</span></span>  
  
## <a name="task-status"></a><span data-ttu-id="b34ab-149">Stato dell'attività</span><span class="sxs-lookup"><span data-stu-id="b34ab-149">Task status</span></span>  
 <span data-ttu-id="b34ab-150">La classe <xref:System.Threading.Tasks.Task> fornisce un ciclo di vita per le operazioni asincrone e il ciclo è rappresentato dall'enumerazione <xref:System.Threading.Tasks.TaskStatus>.</span><span class="sxs-lookup"><span data-stu-id="b34ab-150">The <xref:System.Threading.Tasks.Task> class provides a life cycle for asynchronous operations, and that cycle is represented by the <xref:System.Threading.Tasks.TaskStatus> enumeration.</span></span> <span data-ttu-id="b34ab-151">Per supportare i casi estremi di tipi che derivano da <xref:System.Threading.Tasks.Task> e da <xref:System.Threading.Tasks.Task%601> e per supportare la separazione della costruzione dalla pianificazione, la classe <xref:System.Threading.Tasks.Task> espone un metodo <xref:System.Threading.Tasks.Task.Start%2A>.</span><span class="sxs-lookup"><span data-stu-id="b34ab-151">To support corner cases of types that derive from <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601>,  and to support the separation of construction from scheduling, the <xref:System.Threading.Tasks.Task> class exposes a <xref:System.Threading.Tasks.Task.Start%2A> method.</span></span> <span data-ttu-id="b34ab-152">Le attività create dai costruttori <xref:System.Threading.Tasks.Task> pubblici vengono definite *attività inattive*, poiché iniziano il ciclo di vita nello stato non pianificato <xref:System.Threading.Tasks.TaskStatus.Created> e vengono pianificate solo quando <xref:System.Threading.Tasks.Task.Start%2A> viene chiamato su queste istanze.</span><span class="sxs-lookup"><span data-stu-id="b34ab-152">Tasks that are created by the public <xref:System.Threading.Tasks.Task> constructors are referred to as *cold tasks*, because they begin their life cycle in the non-scheduled <xref:System.Threading.Tasks.TaskStatus.Created> state and are scheduled only when <xref:System.Threading.Tasks.Task.Start%2A> is called on these instances.</span></span>

 <span data-ttu-id="b34ab-153">Tutte le altre attività iniziano il ciclo di vita in uno stato attivo, ovvero le operazioni asincrone che rappresentano sono già state avviate e lo stato dell'attività è un valore di enumerazione diverso da <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b34ab-153">All other tasks begin their life cycle in a hot state, which means that the asynchronous operations they represent have already been initiated and their task status is an enumeration value other than <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b34ab-154">Tutte le attività che vengono restituite dai metodi TAP devono essere attivate.</span><span class="sxs-lookup"><span data-stu-id="b34ab-154">All tasks that are returned from TAP methods must be activated.</span></span> <span data-ttu-id="b34ab-155">**Se un metodo TAP usa internamente il costruttore di un'attività per creare un'istanza dell'attività da restituire, il metodo TAP deve chiamare <xref:System.Threading.Tasks.Task.Start%2A> sull' <xref:System.Threading.Tasks.Task> oggetto prima di restituirlo.**</span><span class="sxs-lookup"><span data-stu-id="b34ab-155">**If a TAP method internally uses a task's constructor to instantiate the task to be returned, the TAP method must call <xref:System.Threading.Tasks.Task.Start%2A> on the <xref:System.Threading.Tasks.Task> object before returning it.**</span></span> <span data-ttu-id="b34ab-156">I consumer di un metodo TAP possono presumere in modo sicuro che l'attività restituita sia attiva e non devono tentare di chiamare <xref:System.Threading.Tasks.Task.Start%2A> su alcun oggetto <xref:System.Threading.Tasks.Task> restituito da un metodo TAP.</span><span class="sxs-lookup"><span data-stu-id="b34ab-156">Consumers of a TAP method may safely assume that the returned task is active and should not try to call <xref:System.Threading.Tasks.Task.Start%2A> on any <xref:System.Threading.Tasks.Task> that is returned from a TAP method.</span></span> <span data-ttu-id="b34ab-157">Se si chiama <xref:System.Threading.Tasks.Task.Start%2A> su un'attività attiva, viene generata un'eccezione <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="b34ab-157">Calling <xref:System.Threading.Tasks.Task.Start%2A> on an active task results in an <xref:System.InvalidOperationException> exception.</span></span>  
  
## <a name="cancellation-optional"></a><span data-ttu-id="b34ab-158">Annullamento (facoltativo)</span><span class="sxs-lookup"><span data-stu-id="b34ab-158">Cancellation (optional)</span></span>  
 <span data-ttu-id="b34ab-159">In TAP, l'annullamento è facoltativo sia per gli implementatori di metodi asincroni che i consumer di metodi asincroni.</span><span class="sxs-lookup"><span data-stu-id="b34ab-159">In TAP, cancellation is optional for both asynchronous method implementers and asynchronous method consumers.</span></span> <span data-ttu-id="b34ab-160">Se un'operazione consente l'annullamento, espone un overload del metodo asincrono che accetta un token di annullamento (istanza di<xref:System.Threading.CancellationToken>).</span><span class="sxs-lookup"><span data-stu-id="b34ab-160">If an operation allows cancellation, it exposes an overload of the asynchronous method that accepts a cancellation token (<xref:System.Threading.CancellationToken> instance).</span></span> <span data-ttu-id="b34ab-161">Convenzionalmente, al parametro viene assegnato il nome `cancellationToken`.</span><span class="sxs-lookup"><span data-stu-id="b34ab-161">By convention, the parameter is named `cancellationToken`.</span></span>  
  
 [!code-csharp[Conceptual.TAP#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#1)]
 [!code-vb[Conceptual.TAP#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#1)]  
  
 <span data-ttu-id="b34ab-162">L'operazione asincrona esamina questo token per le richieste di annullamento.</span><span class="sxs-lookup"><span data-stu-id="b34ab-162">The asynchronous operation monitors this token for cancellation requests.</span></span> <span data-ttu-id="b34ab-163">Se riceve una richiesta di annullamento, può scegliere di soddisfarla e annullare l'operazione.</span><span class="sxs-lookup"><span data-stu-id="b34ab-163">If it receives a cancellation request, it may choose to honor that request and cancel the operation.</span></span> <span data-ttu-id="b34ab-164">Se la richiesta di annullamento determina la fine anticipata del lavoro, il metodo TAP restituisce un'attività che termina nello stato <xref:System.Threading.Tasks.TaskStatus.Canceled>; non esiste alcun risultato disponibile e non viene generata alcuna eccezione.</span><span class="sxs-lookup"><span data-stu-id="b34ab-164">If the cancellation request results in work being ended prematurely, the TAP method returns a task that ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state; there is no available result and no exception is thrown.</span></span>  <span data-ttu-id="b34ab-165">Lo stato <xref:System.Threading.Tasks.TaskStatus.Canceled> è considerato uno stato finale (o completato) per un task, insieme a <xref:System.Threading.Tasks.TaskStatus.Faulted> e <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>.</span><span class="sxs-lookup"><span data-stu-id="b34ab-165">The <xref:System.Threading.Tasks.TaskStatus.Canceled> state is considered to be a final (completed) state for a task, along with the <xref:System.Threading.Tasks.TaskStatus.Faulted> and <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> states.</span></span> <span data-ttu-id="b34ab-166">Pertanto, se un'attività è nello stato <xref:System.Threading.Tasks.TaskStatus.Canceled>, la proprietà <xref:System.Threading.Tasks.Task.IsCompleted%2A> restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="b34ab-166">Therefore, if a task is in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, its <xref:System.Threading.Tasks.Task.IsCompleted%2A> property returns `true`.</span></span> <span data-ttu-id="b34ab-167">Quando un'attività viene completata nello stato <xref:System.Threading.Tasks.TaskStatus.Canceled>, tutte le continuazioni registrate con l'attività vengono pianificate o eseguite, a meno che sia stata specificata un'opzione di continuazione come <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled> per escludere la continuazione.</span><span class="sxs-lookup"><span data-stu-id="b34ab-167">When a task completes in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, any continuations registered with the task are scheduled or executed, unless a continuation option such as <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled> was specified to opt out of continuation.</span></span> <span data-ttu-id="b34ab-168">Qualsiasi codice in attesa in modo asincrono di un'attività annullata tramite l'utilizzo di funzionalità del linguaggio continua a essere eseguito ma riceve <xref:System.OperationCanceledException> o un'eccezione derivata.</span><span class="sxs-lookup"><span data-stu-id="b34ab-168">Any code that is asynchronously waiting for a canceled task through use of language features continues to run but receives an <xref:System.OperationCanceledException> or an exception derived from it.</span></span> <span data-ttu-id="b34ab-169">Il codice bloccato in attesa in modo sincrono dell'attività tramite metodi come <xref:System.Threading.Tasks.Task.Wait%2A> e <xref:System.Threading.Tasks.Task.WaitAll%2A> continua anch'esso ad essere eseguito con un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b34ab-169">Code that is blocked synchronously waiting on the task through methods such as <xref:System.Threading.Tasks.Task.Wait%2A> and <xref:System.Threading.Tasks.Task.WaitAll%2A> also continue to run with an exception.</span></span>  
  
 <span data-ttu-id="b34ab-170">Se un token di annullamento ha richiesto l'annullamento prima che venga chiamato il metodo TAP che accetta il token, il metodo TAP deve restituire un'attività <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span><span class="sxs-lookup"><span data-stu-id="b34ab-170">If a cancellation token has requested cancellation before the TAP method that accepts that token is called, the TAP method should return a <xref:System.Threading.Tasks.TaskStatus.Canceled> task.</span></span>  <span data-ttu-id="b34ab-171">Tuttavia, se viene richiesto l'annullamento mentre l'operazione asincrona è in esecuzione, tale operazione non ha bisogno di accettare la richiesta di annullamento.</span><span class="sxs-lookup"><span data-stu-id="b34ab-171">However, if cancellation is requested while the asynchronous operation is running, the asynchronous operation need not accept the cancellation request.</span></span>  <span data-ttu-id="b34ab-172">L'attività restituita deve terminare nello stato <xref:System.Threading.Tasks.TaskStatus.Canceled> solo se l'operazione termina come risultato della richiesta di annullamento.</span><span class="sxs-lookup"><span data-stu-id="b34ab-172">The returned task should end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state only if the operation ends as a result of the cancellation request.</span></span> <span data-ttu-id="b34ab-173">Se viene richiesto l'annullamento ma viene comunque prodotto un risultato o un'eccezione, l'attività deve terminare nello stato <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> o <xref:System.Threading.Tasks.TaskStatus.Faulted>.</span><span class="sxs-lookup"><span data-stu-id="b34ab-173">If cancellation is requested but a result or an exception is still produced, the task should end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> or <xref:System.Threading.Tasks.TaskStatus.Faulted> state.</span></span>

 <span data-ttu-id="b34ab-174">Per i metodi asincroni che vogliono esporre la possibilità di essere annullati prima e prima, non è necessario fornire un overload che non accetta un token di annullamento.</span><span class="sxs-lookup"><span data-stu-id="b34ab-174">For asynchronous methods that want to expose the ability to be canceled first and foremost, you don't have to provide an overload that doesn't accept a cancellation token.</span></span> <span data-ttu-id="b34ab-175">Per i metodi che non possono essere annullati, non fornire gli overload che accettano un token di annullamento; ciò indica al chiamante se il metodo di destinazione è realmente annullabile.</span><span class="sxs-lookup"><span data-stu-id="b34ab-175">For methods that cannot be canceled, do not provide overloads that accept a cancellation token; this helps indicate to the caller whether the target method is actually cancelable.</span></span>  <span data-ttu-id="b34ab-176">Il codice del consumer che non richiede l'annullamento può chiamare un metodo che accetta <xref:System.Threading.CancellationToken> e fornisce <xref:System.Threading.CancellationToken.None%2A> come valore dell'argomento.</span><span class="sxs-lookup"><span data-stu-id="b34ab-176">Consumer code that does not desire cancellation may call a method that accepts a <xref:System.Threading.CancellationToken> and provide <xref:System.Threading.CancellationToken.None%2A> as the argument value.</span></span> <span data-ttu-id="b34ab-177"><xref:System.Threading.CancellationToken.None%2A> è equivalente dal punto di vista funzionale all'oggetto predefinito <xref:System.Threading.CancellationToken>.</span><span class="sxs-lookup"><span data-stu-id="b34ab-177"><xref:System.Threading.CancellationToken.None%2A> is functionally equivalent to the default <xref:System.Threading.CancellationToken>.</span></span>  
  
## <a name="progress-reporting-optional"></a><span data-ttu-id="b34ab-178">Creazione di report sullo stato di avanzamento (facoltativo)</span><span class="sxs-lookup"><span data-stu-id="b34ab-178">Progress reporting (optional)</span></span>  
 <span data-ttu-id="b34ab-179">Alcune operazioni asincrone prevedono il vantaggio dell'invio di notifiche sullo stato di avanzamento; queste vengono in genere usate per aggiornare un'interfaccia utente con informazioni sullo stato di avanzamento dell'operazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="b34ab-179">Some asynchronous operations benefit from providing progress notifications; these are typically used to update a user interface with information about the progress of the asynchronous operation.</span></span>

 <span data-ttu-id="b34ab-180">In TAP, lo stato di avanzamento viene gestito mediante un'interfaccia <xref:System.IProgress%601>, che viene passata al metodo asincrono come un parametro in genere denominato `progress`.</span><span class="sxs-lookup"><span data-stu-id="b34ab-180">In TAP, progress is handled through an <xref:System.IProgress%601> interface, which is passed to the asynchronous method as a parameter that is usually named `progress`.</span></span>  <span data-ttu-id="b34ab-181">La fornitura dell'interfaccia dello stato di avanzamento quando viene chiamato il metodo asincrono consente di eliminare le race condition che derivano da un utilizzo non corretto (ovvero quando gestori eventi non registrati correttamente dopo l'inizio delle operazioni possono non rilevare gli aggiornamenti).</span><span class="sxs-lookup"><span data-stu-id="b34ab-181">Providing the progress interface when the asynchronous method is called helps eliminate race conditions that result from incorrect usage (that is, when event handlers that are incorrectly registered after the operation starts may miss updates).</span></span>  <span data-ttu-id="b34ab-182">Ancora più importante, l'interfaccia dello stato di avanzamento supporta varie implementazioni dello stato di avanzamento, in base a quanto determinato dal codice consumer.</span><span class="sxs-lookup"><span data-stu-id="b34ab-182">More importantly, the progress interface supports varying implementations of progress, as determined by the consuming code.</span></span>  <span data-ttu-id="b34ab-183">Ad esempio, il codice consumer potrebbe controllare solo l'ultimo aggiornamento dello stato di avanzamento o memorizzare nel buffer tutti gli aggiornamenti o ancora richiamare un'azione per ogni aggiornamento oppure verificare che venga eseguito il marshalling della chiamata a un particolare thread.</span><span class="sxs-lookup"><span data-stu-id="b34ab-183">For example, the consuming code may only care about the latest progress update, or may want to buffer all updates, or may want to invoke an action for each update, or may want to control whether the invocation is marshaled to a particular thread.</span></span> <span data-ttu-id="b34ab-184">Tutte queste opzioni possono essere realizzate usando un'implementazione diversa dell'interfaccia, personalizzata in base alle esigenze specifiche del consumer.</span><span class="sxs-lookup"><span data-stu-id="b34ab-184">All these options may be achieved by using a different implementation of the interface, customized to the particular consumer's needs.</span></span>  <span data-ttu-id="b34ab-185">Come per l'annullamento, le implementazioni TAP devono fornire un parametro <xref:System.IProgress%601> solo se l'API supporta le notifiche dello stato di avanzamento.</span><span class="sxs-lookup"><span data-stu-id="b34ab-185">As with cancellation, TAP implementations should provide an <xref:System.IProgress%601> parameter only if the API supports progress notifications.</span></span>

 <span data-ttu-id="b34ab-186">Ad esempio, se il metodo `ReadAsync` illustrato in precedenza in questo articolo può segnalare lo stato di avanzamento intermedio sotto forma di numero di byte letti fino a qual momento, il callback dello stato di avanzamento può essere un'interfaccia <xref:System.IProgress%601>:</span><span class="sxs-lookup"><span data-stu-id="b34ab-186">For example, if the `ReadAsync` method discussed earlier in this article is able to report intermediate progress in the form of the number of bytes read thus far, the progress callback could be an <xref:System.IProgress%601> interface:</span></span>  
  
 [!code-csharp[Conceptual.TAP#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#2)]
 [!code-vb[Conceptual.TAP#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#2)]  
  
 <span data-ttu-id="b34ab-187">Se un `FindFilesAsync` metodo restituisce un elenco di tutti i file che soddisfano un determinato criterio di ricerca, il callback di stato può fornire una stima della percentuale di lavoro completato e il set corrente di risultati parziali.</span><span class="sxs-lookup"><span data-stu-id="b34ab-187">If a `FindFilesAsync` method returns a list of all files that meet a particular search pattern, the progress callback could provide an estimate of the percentage of work completed and the current set of partial results.</span></span> <span data-ttu-id="b34ab-188">Può fornire queste informazioni con una tupla:</span><span class="sxs-lookup"><span data-stu-id="b34ab-188">It could provide this information with either a tuple:</span></span>  
  
 [!code-csharp[Conceptual.TAP#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#3)]
 [!code-vb[Conceptual.TAP#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#3)]  
  
 <span data-ttu-id="b34ab-189">o con un tipo di dati specifico per l'API:</span><span class="sxs-lookup"><span data-stu-id="b34ab-189">or with a data type that's specific to the API:</span></span>  
  
 [!code-csharp[Conceptual.TAP#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#4)]
 [!code-vb[Conceptual.TAP#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#4)]  
  
 <span data-ttu-id="b34ab-190">Nel secondo caso, il tipo di dati speciale in genere presenta il suffisso `ProgressInfo`.</span><span class="sxs-lookup"><span data-stu-id="b34ab-190">In the latter case, the special data type is usually suffixed with `ProgressInfo`.</span></span>  
  
 <span data-ttu-id="b34ab-191">Se le implementazioni TAP forniscono overload che accettano un `progress` parametro, devono consentire che l'argomento sia `null` , nel qual caso non viene segnalato alcuno stato di avanzamento.</span><span class="sxs-lookup"><span data-stu-id="b34ab-191">If TAP implementations provide overloads that accept a `progress` parameter, they must allow the argument to be `null`, in which case no progress is reported.</span></span> <span data-ttu-id="b34ab-192">Le implementazioni TAP devono segnalare lo stato di avanzamento all'oggetto in modo <xref:System.Progress%601> sincrono, che consente al metodo asincrono di fornire rapidamente lo stato di avanzamento.</span><span class="sxs-lookup"><span data-stu-id="b34ab-192">TAP implementations should report the progress to the <xref:System.Progress%601> object synchronously, which enables the asynchronous method to quickly provide progress.</span></span> <span data-ttu-id="b34ab-193">Consente inoltre al consumer dello stato di avanzamento di determinare la modalità e la posizione migliore per gestire le informazioni.</span><span class="sxs-lookup"><span data-stu-id="b34ab-193">It also allows the consumer of the progress to determine how and where best to handle the information.</span></span> <span data-ttu-id="b34ab-194">Ad esempio, l'istanza dello stato di avanzamento può scegliere di effettuare il marshalling dei callback e generare eventi in un contesto di sincronizzazione acquisito.</span><span class="sxs-lookup"><span data-stu-id="b34ab-194">For example, the progress instance could choose to marshal callbacks and raise events on a captured synchronization context.</span></span>  
  
## <a name="iprogresst-implementations"></a><span data-ttu-id="b34ab-195">\<T>Implementazioni IProgress</span><span class="sxs-lookup"><span data-stu-id="b34ab-195">IProgress\<T> implementations</span></span>  
 <span data-ttu-id="b34ab-196">.NET Framework 4.5 offre un'unica implementazione di <xref:System.IProgress%601>: <xref:System.Progress%601>.</span><span class="sxs-lookup"><span data-stu-id="b34ab-196">The .NET Framework 4.5 provides a single <xref:System.IProgress%601> implementation: <xref:System.Progress%601>.</span></span> <span data-ttu-id="b34ab-197">La classe <xref:System.Progress%601> viene dichiarata nel modo seguente:</span><span class="sxs-lookup"><span data-stu-id="b34ab-197">The <xref:System.Progress%601> class is declared as follows:</span></span>  
  
```csharp  
public class Progress<T> : IProgress<T>  
{  
    public Progress();  
    public Progress(Action<T> handler);  
    protected virtual void OnReport(T value);  
    public event EventHandler<T> ProgressChanged;  
}  
```  
  
```vb  
Public Class Progress(Of T) : Inherits IProgress(Of T)  
    Public Sub New()  
    Public Sub New(handler As Action(Of T))  
    Protected Overridable Sub OnReport(value As T)  
    Public Event ProgressChanged As EventHandler(Of T>  
End Class  
```  
  
 <span data-ttu-id="b34ab-198">Un'istanza di <xref:System.Progress%601> espone un evento <xref:System.Progress%601.ProgressChanged>, che viene generato ogni volta che l'operazione asincrona segnala un aggiornamento di stato.</span><span class="sxs-lookup"><span data-stu-id="b34ab-198">An instance of <xref:System.Progress%601> exposes a <xref:System.Progress%601.ProgressChanged> event, which is raised every time the asynchronous operation reports a progress update.</span></span> <span data-ttu-id="b34ab-199">L'evento <xref:System.Progress%601.ProgressChanged> viene generato sull'oggetto <xref:System.Threading.SynchronizationContext> acquisito quando è stata creata l'istanza di <xref:System.Progress%601>.</span><span class="sxs-lookup"><span data-stu-id="b34ab-199">The <xref:System.Progress%601.ProgressChanged> event is raised on the <xref:System.Threading.SynchronizationContext> object that was captured when the <xref:System.Progress%601> instance was instantiated.</span></span> <span data-ttu-id="b34ab-200">Se non è disponibile alcun contesto di sincronizzazione, viene usato un contesto predefinito destinato al pool di thread.</span><span class="sxs-lookup"><span data-stu-id="b34ab-200">If no synchronization context was available, a default context that targets the thread pool is used.</span></span> <span data-ttu-id="b34ab-201">Gestori possono essere registrati con questo evento.</span><span class="sxs-lookup"><span data-stu-id="b34ab-201">Handlers may be registered with this event.</span></span> <span data-ttu-id="b34ab-202">Un singolo gestore può inoltre essere fornito al costruttore <xref:System.Progress%601> per praticità, comportandosi esattamente come un gestore per l'evento <xref:System.Progress%601.ProgressChanged>.</span><span class="sxs-lookup"><span data-stu-id="b34ab-202">A single handler may also be provided to the <xref:System.Progress%601> constructor for convenience, and behaves just like an event handler for the <xref:System.Progress%601.ProgressChanged> event.</span></span> <span data-ttu-id="b34ab-203">Gli aggiornamenti dello stato di avanzamento vengono generati in modo asincrono per evitare di ritardare l'operazione asincrona mentre sono in esecuzione i gestori eventi.</span><span class="sxs-lookup"><span data-stu-id="b34ab-203">Progress updates are raised asynchronously to avoid delaying the asynchronous operation while event handlers are executing.</span></span> <span data-ttu-id="b34ab-204">Un'altra implementazione <xref:System.IProgress%601> può scegliere di applicare semantiche differenti.</span><span class="sxs-lookup"><span data-stu-id="b34ab-204">Another <xref:System.IProgress%601> implementation could choose to apply different semantics.</span></span>  
  
## <a name="choosing-the-overloads-to-provide"></a><span data-ttu-id="b34ab-205">Scelta degli overload da fornire</span><span class="sxs-lookup"><span data-stu-id="b34ab-205">Choosing the overloads to provide</span></span>  
 <span data-ttu-id="b34ab-206">Se un'implementazione TAP usa i parametri facoltativi <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> e <xref:System.IProgress%601>, potrebbe richiedere fino a quattro overload:</span><span class="sxs-lookup"><span data-stu-id="b34ab-206">If a TAP implementation uses both the optional <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> and optional <xref:System.IProgress%601> parameters, it could potentially require up to four overloads:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, CancellationToken cancellationToken);  
public Task MethodNameAsync(…, IProgress<T> progress);
public Task MethodNameAsync(…,
    CancellationToken cancellationToken, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken cancellationToken) As Task  
Public MethodNameAsync(…, progress As IProgress(Of T)) As Task
Public MethodNameAsync(…, cancellationToken As CancellationToken,
                       progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="b34ab-207">Tuttavia, molte implementazioni TAP non forniscono funzionalità di annullamento o avanzamento, quindi richiedono un solo metodo:</span><span class="sxs-lookup"><span data-stu-id="b34ab-207">However, many TAP implementations don't provide cancellation or progress capabilities, so they require a single method:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
```  
  
 <span data-ttu-id="b34ab-208">Se l'implementazione TAP supporta l'annullamento o lo stato di avanzamento ma non entrambi, può fornire due overload:</span><span class="sxs-lookup"><span data-stu-id="b34ab-208">If a TAP implementation supports either cancellation or progress but not both, it may provide two overloads:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, CancellationToken cancellationToken);  
  
// … or …  
  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken) As Task  
  
' … or …  
  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="b34ab-209">Se l'implementazione TAP supporta sia l'annullamento che lo stato di avanzamento, può esporre tutti e quattro gli overload.</span><span class="sxs-lookup"><span data-stu-id="b34ab-209">If a TAP implementation supports both cancellation and progress, it may expose all four overloads.</span></span> <span data-ttu-id="b34ab-210">Tuttavia, può fornire solo i seguenti due:</span><span class="sxs-lookup"><span data-stu-id="b34ab-210">However, it may provide only the following two:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…,
    CancellationToken cancellationToken, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken,
                       progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="b34ab-211">Per compensare le due combinazioni intermedie mancanti, gli sviluppatori possono passare <xref:System.Threading.CancellationToken.None%2A> o un oggetto <xref:System.Threading.CancellationToken> predefinito per il parametro `cancellationToken` e `null` per il parametro `progress`.</span><span class="sxs-lookup"><span data-stu-id="b34ab-211">To compensate for the two missing intermediate combinations, developers may pass <xref:System.Threading.CancellationToken.None%2A> or a default <xref:System.Threading.CancellationToken> for the `cancellationToken` parameter and `null` for the `progress` parameter.</span></span>  
  
 <span data-ttu-id="b34ab-212">Se si prevede che ogni utilizzo del metodo TAP supporti l'annullamento o lo stato di avanzamento, è possibile omettere gli overload che non accettano il parametro pertinente.</span><span class="sxs-lookup"><span data-stu-id="b34ab-212">If you expect every usage of the TAP method to support cancellation or progress, you may omit the overloads that don't accept the relevant parameter.</span></span>  
  
 <span data-ttu-id="b34ab-213">Se si decide di esporre più overload per rendere facoltativo l'annullamento o lo stato di avanzamento, gli overload che non supportano l'annullamento o lo stato di avanzamento devono comportarsi come se fossero passati <xref:System.Threading.CancellationToken.None%2A> per l'annullamento o `null` per l'avanzamento dell'overload che li supporta.</span><span class="sxs-lookup"><span data-stu-id="b34ab-213">If you decide to expose multiple overloads to make cancellation or progress optional, the overloads that don't support cancellation or progress should behave as if they passed <xref:System.Threading.CancellationToken.None%2A> for cancellation or `null` for progress to the overload that does support these.</span></span>  
  
## <a name="related-articles"></a><span data-ttu-id="b34ab-214">Articoli correlati</span><span class="sxs-lookup"><span data-stu-id="b34ab-214">Related articles</span></span>
  
|<span data-ttu-id="b34ab-215">Titolo</span><span class="sxs-lookup"><span data-stu-id="b34ab-215">Title</span></span>|<span data-ttu-id="b34ab-216">Descrizione</span><span class="sxs-lookup"><span data-stu-id="b34ab-216">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="b34ab-217">Modelli di programmazione asincrona</span><span class="sxs-lookup"><span data-stu-id="b34ab-217">Asynchronous Programming Patterns</span></span>](index.md)|<span data-ttu-id="b34ab-218">Vengono illustrati i tre modelli per eseguire le operazioni asincrone: il modello asincrono basato su attività (TAP), il modello di programmazione asincrono (APM) e il modello asincrono basato su eventi (EAP).</span><span class="sxs-lookup"><span data-stu-id="b34ab-218">Introduces the three patterns for performing asynchronous operations: the Task-based Asynchronous Pattern (TAP), the Asynchronous Programming Model (APM), and the Event-based Asynchronous Pattern (EAP).</span></span>|  
|[<span data-ttu-id="b34ab-219">Implementazione del modello asincrono basato su attività</span><span class="sxs-lookup"><span data-stu-id="b34ab-219">Implementing the Task-based Asynchronous Pattern</span></span>](implementing-the-task-based-asynchronous-pattern.md)|<span data-ttu-id="b34ab-220">Vengono descritti i tre modi per implementare il modello asincrono basato su attività (TAP): tramite i compilatori C# e Visual Basic in Visual Studio, manualmente oppure mediante una combinazione dei primi due.</span><span class="sxs-lookup"><span data-stu-id="b34ab-220">Describes how to implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span>|  
|[<span data-ttu-id="b34ab-221">Consuming the Task-based Asynchronous Pattern</span><span class="sxs-lookup"><span data-stu-id="b34ab-221">Consuming the Task-based Asynchronous Pattern</span></span>](consuming-the-task-based-asynchronous-pattern.md)|<span data-ttu-id="b34ab-222">Viene descritto come usare le attività e i callback per ottenere l'attesa senza blocchi.</span><span class="sxs-lookup"><span data-stu-id="b34ab-222">Describes how you can use tasks and callbacks to achieve waiting without blocking.</span></span>|  
|[<span data-ttu-id="b34ab-223">Interoperabilità con altri tipi e modelli asincroni</span><span class="sxs-lookup"><span data-stu-id="b34ab-223">Interop with Other Asynchronous Patterns and Types</span></span>](interop-with-other-asynchronous-patterns-and-types.md)|<span data-ttu-id="b34ab-224">Viene descritto come usare il modello asincrono basato su attività (TAP) per implementare il modello di programmazione asincrono (APM) e il modello asincrono basato su eventi (EAP).</span><span class="sxs-lookup"><span data-stu-id="b34ab-224">Describes how to use the Task-based Asynchronous Pattern (TAP) to implement the Asynchronous Programming Model (APM) and Event-based Asynchronous Pattern (EAP).</span></span>|
