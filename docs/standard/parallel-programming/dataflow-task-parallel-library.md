---
title: Flusso di dati (Task Parallel Library)
description: Informazioni su come usare i componenti del flusso di data nel Task Parallel Library (TPL) per migliorare l'affidabilità delle applicazioni abilitate per la concorrenza.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Task Parallel Library, dataflows
- TPL dataflow library
ms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6
ms.openlocfilehash: 2c7bbc9bf935159ab66bd2a61a60b9484e67018a
ms.sourcegitcommit: 7137e12f54c4e83a94ae43ec320f8cf59c1772ea
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/10/2020
ms.locfileid: "84662550"
---
# <a name="dataflow-task-parallel-library"></a>Flusso di dati (Task Parallel Library)
La libreria Task Parallel Library (TPL) fornisce componenti del flusso di dati per aumentare l'affidabilità delle applicazioni abilitate per la concorrenza. Questi componenti del flusso di dati vengono definiti collettivamente *libreria del flusso di dati TPL*. Con questo modello del flusso di dati viene promossa la programmazione basata su attori fornendo il passaggio di messaggi in-process per attività di pipelining e per un flusso di dati con granularità grossolana. I componenti del flusso di dati sono basati sui tipi e sull'infrastruttura di pianificazione della libreria TPL e si integrano con il supporto dei linguaggi C#, Visual Basic e F# per la programmazione asincrona. Questi componenti sono utili qualora siano presenti più operazioni che devono comunicare tra loro in modo asincrono o qualora si desideri elaborare i dati non appena diventano disponibili. Si consideri, ad esempio, un'applicazione tramite cui vengono elaborati i dati immagine di una webcam. Tramite il modello del flusso di dati, l'applicazione è in grado di elaborare i fotogrammi delle immagini quando diventano disponibili. Se tramite l'applicazione vengono migliorati i fotogrammi dell'immagine, ad esempio, eseguendo la correzione della luce o la riduzione occhi rossi, è possibile creare una *pipeline* di componenti del flusso di dati. In ogni fase della pipeline è possibile utilizzare la funzionalità di parallelismo con maggiore granulosità grossolana, ad esempio la funzionalità fornita dalla libreria TPL, per trasformare l'immagine.  
  
 In questo documento viene fornita una panoramica della libreria del flusso di dati TPL. Vengono descritti il modello di programmazione e i tipi di blocchi di flussi di dati predefiniti e viene indicato come configurare i blocchi di flussi di dati per soddisfare specifici requisiti delle applicazioni.  

[!INCLUDE [tpl-install-instructions](../../../includes/tpl-install-instructions.md)]

## <a name="programming-model"></a>Modello di programmazione
 La libreria del flusso di dati TPL fornisce una base per il passaggio dei messaggi e per la parallelizzazione delle applicazioni con utilizzo intensivo di I/O e di CPU con velocità effettiva elevata e bassa latenza. Offre inoltre un controllo esplicito sul modo in cui i dati vengono memorizzati nel buffer e spostati nel sistema. Per comprendere meglio il modello di programmazione del flusso di dati, si consideri un'applicazione tramite cui vengono caricate in modo asincrono le immagini dal disco e viene creata una composizione di queste immagini. Per i modelli di programmazione tradizionali viene in genere richiesto l'utilizzo di callback e oggetti di sincronizzazione, ad esempio blocchi, per coordinare le attività e accedere ai dati condivisi. Tramite il modello di programmazione del flusso di dati è possibile creare oggetti del flusso di dati mediante i quali vengono elaborate le immagini mentre sono lette dal disco. Nel modello del flusso di dati è possibile dichiarare la modalità di gestione dei dati quando disponibili, nonché tutte le dipendenze tra i dati. Poiché le dipendenze tra i dati sono gestite dal runtime, è spesso possibile evitare la necessità di sincronizzare l'accesso ai dati condivisi. Inoltre, dal momento che tramite il runtime il lavoro viene pianificato in base all'arrivo asincrono di dati, con il flusso di dati è possibile migliorare la velocità di risposta e la velocità effettiva gestendo i thread sottostanti in modo efficiente. Per un esempio in cui si usa il modello di programmazione del flusso di dati per implementare l'elaborazione di immagini in un'applicazione Windows Forms, vedere [Procedura dettagliata: uso del flusso di dati in un'applicazione Windows Forms](walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
### <a name="sources-and-targets"></a>Origini e destinazioni  
 La libreria del flusso di dati TPL è costituita da *blocchi di flussi di dati*, vale a dire strutture dei dati in cui i dati vengono memorizzati nel buffer ed elaborati. Tramite la libreria TPL vengono definiti tre tipi di blocchi di flussi di dati: *blocchi di origine*, *blocchi di destinazione* e *blocchi di propagazione*. Un blocco di origine viene utilizzato come origine di dati da cui è possibile leggere. Un blocco di destinazione viene utilizzato come destinatario di dati in cui è possibile scrivere. Un blocco di propagazione viene utilizzato sia come blocco di origine sia come blocco di destinazione, quindi da cui è possibile leggere e in cui è possibile scrivere. Tramite la libreria TPL vengono definite le seguenti interfacce: <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=nameWithType> per rappresentare le origini, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=nameWithType> per rappresentare le destinazioni e <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=nameWithType> per rappresentare le propagazioni. L'interfaccia <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> eredita sia da <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> sia da <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 La libreria del flusso di dati TPL fornisce vari tipi di blocchi di flussi di dati predefiniti tramite cui vengono implementate le interfacce <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> e <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602>. Questi tipi di blocchi di flussi di dati sono descritti nella sezione [Tipi di blocchi di flussi di dati predefiniti](#predefined-dataflow-block-types) di questo documento.  
  
### <a name="connecting-blocks"></a>Connessione di blocchi  
 È possibile connettere i blocchi di flussi di dati per creare *pipeline*, che sono sequenze lineari di blocchi di flussi di dati, o *reti*, che sono grafici di blocchi di flussi di dati. Una pipeline è un tipo di rete. I dati di origini in una pipeline o in una rete vengono propagati nelle destinazioni in modo asincrono quando i dati in questione diventano disponibili. Tramite il metodo <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> un blocco di flussi di dati di origine viene connesso a un blocco di destinazione. Un'origine può essere collegata a zero o più destinazioni, mentre queste ultime possono essere collegate da zero o più origini. È possibile aggiungere o rimuovere contemporaneamente blocchi di flussi di dati a o da una pipeline o rete. Tramite i tipi di blocchi di flussi di dati predefiniti vengono gestiti tutti gli aspetti di collegamento e scollegamento thread safety.  
  
 Per un esempio di connessione di blocchi di flussi di dati per formare una pipeline di base, vedere [Procedura dettagliata: creazione di una pipeline del flusso di dati](walkthrough-creating-a-dataflow-pipeline.md). Per un esempio di connessione di blocchi di flussi di dati per formare una rete più complessa, vedere [Procedura dettagliata: uso del flusso di dati in un'applicazione Windows Forms](walkthrough-using-dataflow-in-a-windows-forms-application.md). Per un esempio di scollegamento di una destinazione da un'origine dopo l'offerta di un messaggio alla destinazione da parte dell'origine, vedere [Procedura: Scollegare i blocchi di flussi di dati](how-to-unlink-dataflow-blocks.md).  
  
#### <a name="filtering"></a>Filtro  
 Quando si chiama il metodo <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> per collegare un'origine a una destinazione, è possibile fornire un delegato tramite cui si stabilisce se da parte del blocco di destinazione viene accettato o rifiutato un messaggio in base al valore del messaggio in questione. Questo meccanismo di filtro è utile per garantire la ricezione solo di determinati valori da parte di un blocco di flussi di dati. Per la maggior parte dei tipi di blocchi di flussi di dati predefiniti, se un blocco di origine è connesso a più blocchi di destinazione, quando da parte di un blocco di destinazione viene rifiutato un messaggio, quest'ultimo tramite l'origine viene offerto alla destinazione successiva. L'ordine di offerta dei messaggi da parte dell'origine alle destinazioni viene definito dall'origine e può variare a seconda del tipo di origine. L'offerta di un messaggio da parte della maggior parte dei tipi di blocco di origine viene arrestata dopo l'accettazione del messaggio in questione da una destinazione. Un'eccezione a questa regola è la classe <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> mediante la quale ogni messaggio viene offerto a tutte le destinazioni, anche se viene rifiutato da alcune di queste. Per un esempio che usa il filtro per elaborare solo determinati messaggi, vedere [Procedura dettagliata: uso del flusso di dati in un'applicazione Windows Forms](walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
> [!IMPORTANT]
> Poiché ogni tipo di blocco di flussi di dati di origine predefinito garantisce la propagazione all'esterno di questi messaggi nell'ordine in cui vengono ricevuti, ogni messaggio deve essere letto dal blocco di origine prima che da parte di quest'ultimo possa essere elaborato il messaggio successivo. Di conseguenza, quando si utilizzano i filtri per connettere più destinazioni a un'origine, accertarsi che ogni messaggio venga ricevuto da almeno un blocco di destinazione. In caso contrario, si potrebbe verificare un deadlock dell'applicazione.  
  
### <a name="message-passing"></a>Passaggio dei messaggi  
 Il modello di programmazione del flusso di dati è correlato al concetto di *passaggio dei messaggi*, in base al quale i componenti indipendenti di un programma comunicano con un altro programma inviando messaggi. Un modo per propagare i messaggi tra i componenti dell'applicazione consiste nel chiamare i metodi <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> e <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=nameWithType> per inviare messaggi ai post di blocchi di flussi di dati di destinazione (<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> funziona in modo sincrono, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> funziona in modo asincrono) e i metodi <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A> e <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> per ricevere messaggi dai blocchi di origine. È possibile combinare questi metodi con pipeline o reti del flusso di dati inviando i dati di input al nodo principale (blocco di destinazione) e ricevendo i dati di output dal nodo terminale della pipeline o dai nodi terminali della rete (uno o più blocchi di origine). È inoltre possibile utilizzare il metodo <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> per leggere dalla prima delle origini fornite con dati disponibili ed eseguire azioni sui dati in questione.  
  
 I blocchi di origine offrono dati ai blocchi di destinazione chiamando il metodo <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=nameWithType>. La risposta a un messaggio offerto viene fornita dal blocco di destinazione in tre modalità: il messaggio può essere accettato, rifiutato o posticipato. Quando il messaggio viene accettato dalla destinazione, il metodo <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> restituisce <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted>. Quando il messaggio viene rifiutato dalla destinazione, il metodo <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> restituisce <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined>. Quando da parte della destinazione viene richiesto di non ricevere più messaggi dall'origine, il metodo <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> restituisce <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently>. I tipi di blocchi di origine predefiniti non offrono messaggi alle destinazioni collegate dopo la ricezione di un valore restituito di questo tipo e vengono scollegati automaticamente da queste destinazioni.  
  
 Quando tramite un blocco di destinazione il messaggio viene posticipato per un utilizzo successivo, il metodo <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> restituisce <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed>. Un blocco di destinazione che posticipa un messaggio può chiamare successivamente il metodo <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=nameWithType> per provare a prenotare il messaggio offerto. A questo punto, il messaggio è ancora disponibile e può essere utilizzato dal blocco di destinazione oppure è stato accettato da un'altra destinazione. Quando il messaggio viene richiesto dal blocco di destinazione in un secondo momento o non è più necessario, viene chiamato rispettivamente il metodo <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> o <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A>. La prenotazione dei messaggi viene in genere utilizzata dai tipi di blocchi di flussi di dati che operano in modalità non greedy. La modalità non greedy verrà illustrata più avanti in questo documento. Anziché riservare un messaggio posposto, in un blocco di destinazione può inoltre essere utilizzato il metodo <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> per tentare di utilizzare direttamente il messaggio posposto.  
  
### <a name="dataflow-block-completion"></a>Completamento dei blocchi di flussi di dati  
 I blocchi di flussi di dati supportano inoltre il concetto di *completamento*. Non viene eseguito alcun lavoro ulteriore da parte di un blocco di flussi di dati che si trova nello stato completato. A ogni blocco di flussi di dati è associato un oggetto <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>, noto come *attività di completamento*, che rappresenta lo stato di completamento del blocco. Dal momento che è possibile attendere il completamento di un oggetto <xref:System.Threading.Tasks.Task>, tramite le attività di completamento è possibile attendere il completamento di uno o più nodi terminali di una rete del flusso di dati. Tramite l'interfaccia <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> vengono definiti il metodo <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A>, mediante il quale il blocco di flussi di dati viene informato del completamento di una relativa richiesta, e la proprietà <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A>, che restituisce l'attività di completamento del blocco di flussi di dati. Sia <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> sia <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> ereditano l'interfaccia <xref:System.Threading.Tasks.Dataflow.IDataflowBlock>.  
  
 Sono disponibili due modalità per determinare se un blocco di flussi di dati viene completato correttamente, se tramite esso vengono rilevati uno o più errori o se è stato annullato. La prima consiste nel chiamare il metodo <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> sull'attività di completamento in un blocco `try`-`catch` (`Try`-`Catch` in Visual Basic). Nell'esempio seguente viene creato un oggetto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> tramite cui viene generato <xref:System.ArgumentOutOfRangeException> se il valore di input è minore di zero. <xref:System.AggregateException> viene generato quando in questo esempio viene chiamato il metodo <xref:System.Threading.Tasks.Task.Wait%2A> sull'attività di completamento. È possibile accedere a <xref:System.ArgumentOutOfRangeException> tramite la proprietà <xref:System.AggregateException.InnerExceptions%2A> dell'oggetto <xref:System.AggregateException>.  
  
 [!code-csharp[TPLDataflow_Overview#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#10)]
 [!code-vb[TPLDataflow_Overview#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#10)]  
  
 In questo esempio viene illustrato il caso in cui un'eccezione non gestita viene inserita nel delegato di un blocco di flussi di dati di esecuzione. Si consiglia di gestire le eccezioni nei corpi di blocchi di questo tipo. In caso contrario, tuttavia, il comportamento del blocco è simile a quello di un annullamento e i messaggi in ingresso non vengono elaborati.  
  
 Quando un blocco di flussi di dati viene annullato in modo esplicito, nell'oggetto <xref:System.AggregateException> è contenuto <xref:System.OperationCanceledException> nella proprietà <xref:System.AggregateException.InnerExceptions%2A>. Per altre informazioni sull'annullamento del flusso di dati, vedere la sezione [Abilitazione dell'annullamento](#enabling-cancellation).  
  
 La seconda modalità per determinare lo stato di completamento di un blocco di flussi di dati consiste nell'usare una continuazione dell'attività di completamento o le funzionalità asincrone dei linguaggi C# e Visual Basic per attendere in modo asincrono l'attività di completamento. Il delegato fornito al metodo <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> accetta un oggetto <xref:System.Threading.Tasks.Task> che rappresenta l'attività precedente. Nel caso della proprietà <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A>, il delegato per la continuazione accetta l'attività di completamento stessa. L'esempio seguente è simile al precedente, tranne per il fatto che viene usato anche il metodo <xref:System.Threading.Tasks.Task.ContinueWith%2A> per creare un'attività di continuazione che stampa lo stato dell'operazione globale del flusso di dati.  
  
 [!code-csharp[TPLDataflow_Overview#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#11)]
 [!code-vb[TPLDataflow_Overview#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#11)]  
  
 È inoltre possibile utilizzare proprietà come <xref:System.Threading.Tasks.Task.IsCanceled%2A> nel corpo dell'attività di continuazione per determinare informazioni aggiuntive sullo stato di completamento di un blocco di flussi di dati. Per altre informazioni sulle attività di continuazione e il modo in cui interagiscono con l'annullamento e la gestione degli errori, vedere [Concatenamento di attività tramite attività di continuazione](chaining-tasks-by-using-continuation-tasks.md), [Annullamento delle attività](task-cancellation.md) e [Gestione delle eccezioni](exception-handling-task-parallel-library.md).  

## <a name="predefined-dataflow-block-types"></a>Tipi di blocchi di flussi di dati predefiniti  
 La libreria del flusso di dati TPL fornisce vari tipi di blocchi di flussi di dati predefiniti. Questi tipi sono suddivisi in tre categorie: *blocchi di buffering*, *blocchi di esecuzione* e *blocchi di raggruppamento*. Nelle sezioni seguenti vengono descritti i tipi di blocchi che compongono queste categorie.  
  
### <a name="buffering-blocks"></a>Blocchi di buffering  
 Nei blocchi di buffering sono contenuti i dati utilizzati dai consumer di dati. La libreria del flusso di dati TPL fornisce tre tipi di blocco di buffering: <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=nameWithType> e <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=nameWithType>.  
  
#### <a name="bufferblockt"></a>BufferBlock(T)  
 La classe <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> rappresenta una struttura di messaggistica asincrona di utilizzo generale. Questa classe archivia una coda di messaggi FIFO (First In, First Out) che possono essere letti da più destinazioni o in cui possono scrivere più origini. Quando da parte di una destinazione viene ricevuto un messaggio da un oggetto <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>, il messaggio viene rimosso dalla coda di messaggi. Pertanto, sebbene a un oggetto <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> possano essere associate più destinazioni, ogni messaggio verrà ricevuto da una sola destinazione. La classe <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> è utile quando si vogliono passare più messaggi a un altro componente e tale componente deve ricevere ogni messaggio.  
  
 Nell'esempio di base seguente vengono inseriti alcuni valori <xref:System.Int32> in un oggetto <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> che, successivamente, vengono riletti dall'oggetto in questione.  
  
 [!code-csharp[TPLDataflow_Overview#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#1)]
 [!code-vb[TPLDataflow_Overview#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#1)]  
  
 Per un esempio completo in cui viene illustrato come scrivere e leggere i messaggi in un oggetto <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>, vedere [Procedura: Scrivere messaggi in un blocco di flussi di dati e leggere messaggi da un blocco di flussi di dati](how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md).  
  
#### <a name="broadcastblockt"></a>BroadcastBlock(T)  
 La classe <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> è utile quando è necessario passare più messaggi a un altro componente, ma il componente necessita solo del valore più recente. Questa classe è utile anche quando si vuole trasmettere un messaggio a più componenti.  
  
 Nell'esempio di base seguente viene inserito un valore <xref:System.Double> in un oggetto <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> che, successivamente, viene riletto più volte dall'oggetto in questione. Dal momento che, dopo essere stati letti, i valori non vengono rimossi dagli oggetti <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>, lo stesso valore è disponibile ogni volta.  
  
 [!code-csharp[TPLDataflow_Overview#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#2)]
 [!code-vb[TPLDataflow_Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#2)]  
  
 Per un esempio completo che illustra come usare la classe <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> per trasmettere un messaggio a più blocchi di destinazione, vedere [Procedura: Specificare un'utilità di pianificazione in un blocco di flussi di dati](how-to-specify-a-task-scheduler-in-a-dataflow-block.md).  
  
#### <a name="writeonceblockt"></a>WriteOnceBlock(T)  
 La classe <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> è simile alla classe <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>, con la differenza che in un oggetto <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> è possibile scrivere una sola volta. L'oggetto <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> può essere considerato come la parola chiave C# [readonly](../../csharp/language-reference/keywords/readonly.md) ([ReadOnly](../../visual-basic/language-reference/modifiers/readonly.md) in Visual Basic), con la differenza che un oggetto <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> diventa non modificabile dopo la ricezione di un valore invece che in fase di costruzione. Come per la classe <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>, quando da una destinazione riceve un messaggio da un oggetto <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>, il messaggio viene rimosso dalla coda di messaggi. Pertanto, più destinazioni riceveranno una copia del messaggio. La classe <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> è utile quando si desidera propagare solo il primo di più messaggi.  
  
 Nell'esempio di base seguente vengono inseriti valori <xref:System.String> in un oggetto <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> che, successivamente, vengono riletti dall'oggetto in questione. Poiché un oggetto <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> può essere scritto una sola volta, dopo la ricezione di un oggetto <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>, i messaggi successivi vengono rimossi.  
  
 [!code-csharp[TPLDataflow_Overview#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#3)]
 [!code-vb[TPLDataflow_Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#3)]  
  
 Per un esempio completo in cui viene illustrato l'uso dell'oggetto <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> per ricevere il valore della prima operazione completata, vedere [Procedura: Scollegare i blocchi di flussi di dati](how-to-unlink-dataflow-blocks.md).  
  
### <a name="execution-blocks"></a>Blocchi di esecuzione  
 Tramite i blocchi di esecuzione viene chiamato un delegato fornito dall'utente per ogni blocco di dati ricevuti. La libreria del flusso di dati TPL fornisce tre tipi di blocco di esecuzione: <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=nameWithType> e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=nameWithType>.  
  
#### <a name="actionblockt"></a>ActionBlock(T)  
 La classe <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> è un blocco di destinazione tramite cui viene chiamato un delegato alla ricezione dei dati. Si consideri un oggetto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> come un delegato eseguito in modo asincrono quando i dati diventano disponibili. Il delegato fornito a un oggetto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> può essere di tipo <xref:System.Action%601> o di tipo `System.Func<TInput, Task>`. Quando si utilizza un oggetto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> con <xref:System.Action%601>, l'elaborazione di ogni elemento di input viene considerata completata alla restituzione del delegato. Quando si utilizza un oggetto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> con `System.Func<TInput, Task>`, l'elaborazione di ogni elemento di input viene considerata completata solo quando l'oggetto restituito <xref:System.Threading.Tasks.Task> viene completato. Tramite questi due meccanismi è possibile utilizzare <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> sia per l'elaborazione sincrona sia per quella asincrona di ogni elemento di input.  
  
 Nell'esempio di base seguente vengono inseriti più valori <xref:System.Int32> in un oggetto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>. Tramite l'oggetto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> i valori in questione vengono stampati sulla console. In questo esempio il blocco viene quindi impostato sullo stato completato e attende il completamento di tutte le attività del flusso di dati.  
  
 [!code-csharp[TPLDataflow_Overview#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#4)]
 [!code-vb[TPLDataflow_Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#4)]  
  
 Per esempi completi in cui viene illustrato l'uso dei delegati con la classe <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, vedere [Procedura: Eseguire un'azione alla ricezione di dati in un blocco di flussi di dati](how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
#### <a name="transformblocktinput-toutput"></a>TransformBlock(TInput, TOutput)  
 La classe <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> è simile alla classe <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, con la differenza che viene utilizzata sia come origine sia come destinazione. Il delegato passato a un oggetto <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> restituisce un valore di tipo `TOutput`. Il delegato fornito a un oggetto <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> può essere di tipo `System.Func<TInput, TOutput>` o di tipo `System.Func<TInput, Task<TOutput>>`. Quando si utilizza un oggetto <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> con `System.Func<TInput, TOutput>`, l'elaborazione di ogni elemento di input viene considerata completata alla restituzione del delegato. Quando si utilizza un oggetto <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> utilizzato con `System.Func<TInput, Task<TOutput>>`, l'elaborazione di ogni elemento di input viene considerata completata solo quando l'oggetto restituito <xref:System.Threading.Tasks.Task%601> viene completato. Analogamente all'oggetto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, tramite questi due meccanismi, è possibile utilizzare <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> sia per l'elaborazione sincrona sia per quella asincrona di ogni elemento di input.  
  
 Nell'esempio di base seguente viene creato un oggetto <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> con cui si calcola la radice quadrata dell'input. L'oggetto <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> accetta valori <xref:System.Int32> come input e tramite esso vengono generati valori <xref:System.Double> come output.  
  
 [!code-csharp[TPLDataflow_Overview#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#5)]
 [!code-vb[TPLDataflow_Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#5)]  
  
 Per esempi completi in cui si usa l'oggetto <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> in una rete di blocchi di flussi di dati nella quale viene eseguita l'elaborazione di immagini in un'applicazione Windows Forms, vedere [Procedura dettagliata: Uso del flusso di dati in un'applicazione Windows Forms](walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
#### <a name="transformmanyblocktinput-toutput"></a>TransformManyBlock(TInput, TOutput)  
 La classe <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> è simile alla classe <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, ad eccezione del fatto che tramite l'oggetto <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> vengono generati zero o più valori di output per ogni valore di input anziché un solo valore di output per ogni valore di input. Il delegato fornito a un oggetto <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> può essere di tipo `System.Func<TInput, IEnumerable<TOutput>>` o di tipo `System.Func<TInput, Task<IEnumerable<TOutput>>>`. Quando si utilizza un oggetto <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> con `System.Func<TInput, IEnumerable<TOutput>>`, l'elaborazione di ogni elemento di input viene considerata completata alla restituzione del delegato. Quando si utilizza un oggetto <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> con `System.Func<TInput, Task<IEnumerable<TOutput>>>`, l'elaborazione di ogni elemento di input viene considerata completa solo quando l'oggetto restituito `System.Threading.Tasks.Task<IEnumerable<TOutput>>` viene completato.  
  
 Nell'esempio di base seguente viene creato un oggetto <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> tramite cui le stringhe vengono suddivise in singole sequenze di caratteri. L'oggetto <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> accetta valori <xref:System.String> come input e tramite esso vengono generati valori <xref:System.Char> come output.  
  
 [!code-csharp[TPLDataflow_Overview#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#6)]
 [!code-vb[TPLDataflow_Overview#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#6)]  
  
 Per esempi completi in cui si usa <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> per generare più output indipendenti per ogni input in una pipeline del flusso di dati, vedere [Procedura dettagliata: Creazione di una pipeline del flusso di dati](walkthrough-creating-a-dataflow-pipeline.md).  
  
#### <a name="degree-of-parallelism"></a>Grado di parallelismo  
 Tramite ogni oggetto <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> i messaggi di input vengono inseriti nel buffer finché il blocco non è pronto per elaborarli. Per impostazione predefinita, i messaggi vengono elaborati da queste classi nell'ordine in cui vengono ricevuti, un messaggio alla volta. È inoltre possibile specificare il grado di parallelismo per consentire l'elaborazione simultanea di più messaggi da parte degli oggetti <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>. Per ulteriori informazioni sull'esecuzione simultanea, vedere la sezione Specifica del grado di parallelismo più avanti in questo documento. Per un esempio in cui viene impostato il grado di parallelismo per consentire l'elaborazione di più di un messaggio alla volta da parte di un blocco di flussi di dati di esecuzione, vedere [Procedura: specificare il grado di parallelismo in un blocco di flussi di dati](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
#### <a name="summary-of-delegate-types"></a>Riepilogo dei tipi delegati  
 Nella tabella seguente vengono riepilogati i tipi delegati che possono essere forniti agli oggetti <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>. Viene inoltre specificato se il tipo delegato viene eseguito in modo sincrono o asincrono.  
  
|Type|Tipo delegato sincrono|Tipo delegato asincrono|  
|----------|-------------------------------|--------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|`System.Action`|`System.Func<TInput, Task>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|`System.Func<TInput, TOutput>`|`System.Func<TInput, Task<TOutput>>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|`System.Func<TInput, IEnumerable<TOutput>>`|`System.Func<TInput, Task<IEnumerable<TOutput>>>`|  
  
 È inoltre possibile utilizzare le espressioni lambda quando si utilizzano tipi di blocchi di esecuzione. Per un esempio in cui viene illustrato l'uso di un'espressione lambda con un blocco di esecuzione, vedere [Procedura: eseguire un'azione alla ricezione di dati in un blocco di flussi di dati](how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
### <a name="grouping-blocks"></a>Blocchi di raggruppamento  
 Con i blocchi di raggruppamento è possibile combinare i dati da una o più origini e con vari vincoli. La libreria del flusso di dati TPL fornisce tre tipi di blocchi join: <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> e <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>.  
  
#### <a name="batchblockt"></a>BatchBlock(T)  
 Tramite la classe <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> vengono combinati set di dati di input, noti come batch, in matrici di dati di output. È possibile specificare le dimensioni di ciascun batch quando si crea un oggetto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>. Quando tramite l'oggetto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> si riceve il numero specificato di elementi di input, viene propagata all'esterno in modo asincrono una matrice contenente gli elementi in questione. Se un oggetto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> è impostato sullo stato completato ma in esso non sono contenuti elementi sufficienti per formare un batch, viene propagata all'esterno una matrice finale contenente gli elementi di input rimanenti.  
  
 La classe <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> viene eseguita in modalità *greedy* o *non greedy*. In modalità greedy, vale a dire l'impostazione predefinita, un oggetto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> accetta ogni messaggio che viene offerto e propaga all'esterno una matrice dopo la ricezione del numero specificato di elementi. In modalità non greedy, tramite un oggetto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> vengono posticipati tutti i messaggi in ingresso finché da parte di un numero sufficiente di origini non vengono offerti messaggi al blocco per formare un batch. L'esecuzione in modalità greedy è in genere migliore rispetto a quella non greedy dal momento che necessita di un sovraccarico inferiore di elaborazione. Tuttavia, è possibile utilizzare la modalità non greedy quando è necessario coordinare l'utilizzo da più origini in modo atomico. Specificare la modalità non greedy impostando la proprietà <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> su `False` nel parametro `dataflowBlockOptions` nel costruttore <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A>.  
  
 Nell'esempio di base seguente vengono inseriti alcuni valori <xref:System.Int32> in un oggetto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> contenente dieci elementi in un batch. Per garantire che tutti i valori vengano propagati all'esterno dell'oggetto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, in questo esempio viene chiamato il metodo <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A>. Tramite il metodo <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> viene impostato l'oggetto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> sullo stato completato e, pertanto, tramite l'oggetto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> vengono propagati all'esterno tutti gli elementi rimanenti come batch finale.  
  
 [!code-csharp[TPLDataflow_Overview#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#7)]
 [!code-vb[TPLDataflow_Overview#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#7)]  
  
 Per un esempio completo in cui si usa <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> per migliorare l'efficienza delle operazioni di inserimento del database, vedere [Procedura dettagliata: Uso di BatchBlock e BatchedJoinBlock per migliorare l'efficienza](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
#### <a name="joinblockt1-t2-"></a>JoinBlock(T1, T2, ...)  
 Tramite le classi <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> e <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> vengono raccolti elementi di input e propagati all'esterno oggetti <xref:System.Tuple%602?displayProperty=nameWithType> o <xref:System.Tuple%603?displayProperty=nameWithType> contenenti gli elementi in questione. Le classi <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> e <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> non ereditano da <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. Forniscono invece proprietà, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A> e <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A>, tramite cui viene implementato l'oggetto <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 Come <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> e <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> operano in modalità greedy o non greedy. In modalità greedy, vale a dire l'impostazione predefinita, un oggetto <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> o <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> accetta ogni messaggio che viene offerto e tramite esso viene propagata all'esterno una tupla dopo che da ciascuna delle relative destinazioni viene ricevuto almeno un messaggio. In modalità non greedy, tramite un oggetto <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> o <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> vengono posticipati tutti i messaggi in ingresso finché a tutte le destinazioni non sono stati offerti i dati richiesti per creare una tupla. A questo punto, nel blocco viene utilizzato un protocollo di commit a due fasi per recuperare atomicamente tutti gli elementi richiesti dalle origini. Questo rinvio consente a un'altra entità di utilizzare i dati nel frattempo per permettere al sistema complessivo di avanzare.  
  
 Nell'esempio di base seguente viene illustrato un caso in cui per un oggetto <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> sono richiesti più dati per il calcolo di un valore. In questo esempio viene creato un oggetto <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> per cui sono richiesti due valori <xref:System.Int32> e un valore <xref:System.Char> per eseguire un'operazione aritmetica.  
  
 [!code-csharp[TPLDataflow_Overview#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#8)]
 [!code-vb[TPLDataflow_Overview#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#8)]  
  
 Per un esempio completo in cui vengono usati oggetti <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> in modalità non greedy per condividere una risorsa in modo cooperativo, vedere [Procedura: Usare JoinBlock per leggere dati da più origini](how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
#### <a name="batchedjoinblockt1-t2-"></a>BatchedJoinBlock(T1, T2, ...)  
 Tramite le classi <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> e <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> vengono raccolti batch di elementi di input e vengono propagati all'esterno oggetti `System.Tuple(IList(T1), IList(T2))` o `System.Tuple(IList(T1), IList(T2), IList(T3))` contenenti gli elementi in questione. Si consideri <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> come una combinazione di <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> e <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>. Specificare le dimensioni di ciascun batch quando si crea un oggetto <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>. <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> fornisce inoltre le proprietà, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> e <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>, tramite cui viene implementato <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. Quando il numero specificato di elementi di input viene ricevuto attraverso tutte le destinazioni, tramite l'oggetto <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> viene propagato all'esterno in modo asincrono un oggetto `System.Tuple(IList(T1), IList(T2))` contenente gli elementi in questione.  
  
 Nell'esempio di base seguente viene creato un oggetto <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> contenente i risultati, i valori <xref:System.Int32> e gli errori che sono oggetti <xref:System.Exception>. In questo esempio vengono eseguite più operazioni e vengono scritti i risultati nella proprietà <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> e gli errori nella proprietà <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> dell'oggetto <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>. Poiché il conteggio delle operazioni riuscite e non riuscite non è noto in anticipo, gli oggetti <xref:System.Collections.Generic.IList%601> consentono a ogni destinazione di ricevere zero o più valori.  
  
 [!code-csharp[TPLDataflow_Overview#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#9)]
 [!code-vb[TPLDataflow_Overview#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#9)]  
  
 Per un esempio completo in cui si usa <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> per acquisire sia i risultati che tutte le eccezioni che si verificano durante la lettura da database da parte del programma, vedere [Procedura dettagliata: Uso di BatchBlock e BatchedJoinBlock per migliorare l'efficienza](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  

## <a name="configuring-dataflow--block-behavior"></a>Configurazione del comportamento dei blocchi di flussi di dati  
 È possibile abilitare opzioni aggiuntive fornendo un oggetto <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType> al costruttore dei tipi di blocchi di flussi di dati. Tramite queste opzioni viene controllato il comportamento dell'utilità di pianificazione mediante la quale vengono gestiti l'attività sottostante e il grado di parallelismo. L'oggetto <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> dispone inoltre di tipi derivati tramite cui viene fornito il comportamento specifico di determinati tipi di blocchi di flussi di dati. Nella tabella seguente viene riepilogato il tipo di opzioni associato a ogni tipo di blocco di flussi di dati.  
  
|Tipo di blocco di flussi di dati|Tipo di<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.BufferBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.JoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
  
 Nelle sezioni seguenti vengono fornite informazioni aggiuntive sui principali tipi di opzioni dei blocchi di flussi di dati disponibili nelle classi <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=nameWithType> e <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=nameWithType>.  
  
### <a name="specifying-the-task-scheduler"></a>Specifica dell'Utilità di pianificazione  
 In ogni blocco di flussi di dati predefinito viene utilizzato il meccanismo di pianificazione delle attività TPL per eseguire attività quali la propagazione dei dati in una destinazione, la ricezione dei dati da un'origine e l'esecuzione di delegati definiti dall'utente quando i dati diventano disponibili. <xref:System.Threading.Tasks.TaskScheduler> è una classe astratta che rappresenta un'Utilità di pianificazione mediante la quale vengono inserite in coda le attività nei thread. Tramite l'Utilità di pianificazione predefinita, <xref:System.Threading.Tasks.TaskScheduler.Default%2A>, viene utilizzata la classe <xref:System.Threading.ThreadPool> per l'inserimento in coda e l'esecuzione del lavoro. È possibile eseguire l'override dell'Utilità di pianificazione predefinita impostando la proprietà <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> quando si costruisce un oggetto del blocco di flussi di dati.  
  
 Quando tramite la stessa Utilità di pianificazione vengono gestiti più blocchi di flussi di dati, è possibile applicarvi dei criteri. Ad esempio, se più blocchi di flussi di dati sono configurati ognuno per utilizzare l'utilità di pianificazione in esclusiva dello stesso oggetto <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair>, tutto il lavoro eseguito tramite questi blocchi viene serializzato. Analogamente, se questi blocchi sono configurati per utilizzare l'utilità di pianificazione in concorrenza dello stesso oggetto <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> e l'utilità in questione è configurata per disporre di un livello massimo di concorrenza, tutto il lavoro di questi blocchi è limitato a quel numero di operazioni simultanee. Per un esempio in cui si usa la classe <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> per consentire l'esecuzione in parallelo delle operazioni di lettura, mentre le operazioni di scrittura vengono eseguite separatamente da tutte le altre operazioni, vedere [Procedura: Specificare un'utilità di pianificazione in un blocco di flussi di dati](how-to-specify-a-task-scheduler-in-a-dataflow-block.md). Per altre informazioni sulle utilità di pianificazione delle attività in TPL, vedere l'argomento della classe <xref:System.Threading.Tasks.TaskScheduler>.  
  
### <a name="specifying-the-degree-of-parallelism"></a>Specifica del grado di parallelismo  
 Per impostazione predefinita, tramite i tre tipi di blocchi di esecuzione forniti dalla libreria del flusso di dati TPL, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, viene elaborato un messaggio alla volta. Tramite questi tipi di blocchi di flussi di dati i messaggi vengono inoltre elaborati nell'ordine in cui vengono ricevuti. Per consentire a questi blocchi di flussi di dati di elaborare i messaggi contemporaneamente, impostare la proprietà <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=nameWithType> quando si crea l'oggetto del blocco di flussi di dati.  
  
 Il valore predefinito di <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> è 1, che garantisce l'elaborazione di un solo messaggio per volta da parte del blocco di flussi di dati. Impostando questa proprietà su un valore maggiore di 1 possono essere elaborati più messaggi contemporaneamente da parte del blocco di flussi di dati. Impostando questa proprietà su <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> è possibile la gestione del livello massimo di concorrenza da parte dell'Utilità di pianificazione sottostante.  
  
> [!IMPORTANT]
> Quando si specifica un grado massimo di parallelismo maggiore di 1, vengono elaborati contemporaneamente più messaggi, pertanto questi ultimi potrebbero non essere elaborati nell'ordine in cui vengono ricevuti. L'ordine in cui i messaggi vengono restituiti dal blocco è, tuttavia, lo stesso in cui vengono ricevuti.  
  
 Poiché la proprietà <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> rappresenta il grado massimo di parallelismo, il blocco di flussi di dati può essere eseguito con un grado di parallelismo minore rispetto a quello specificato. È possibile che nel blocco di flussi di dati venga utilizzato un grado di parallelismo minore per soddisfare i requisiti funzionali o perché vi è una mancanza di risorse di sistema disponibili. Da parte di un blocco di flussi di dati non viene mai scelto un parallelismo maggiore di quello specificato.  
  
 Il valore della proprietà <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> è esclusivo per ogni oggetto del blocco di flussi di dati. Ad esempio, se da ognuno dei quattro oggetti del blocco di flussi di dati viene specificato 1 come massimo grado di parallelismo, tutti e quattro gli oggetti del blocco di flussi di dati possono essere potenzialmente eseguiti in parallelo.  
  
 Per un esempio in cui si imposta il grado massimo di parallelismo per consentire l'esecuzione in parallelo di operazioni lunghe, vedere [Procedura: specificare il grado di parallelismo in un blocco di flussi di dati](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
### <a name="specifying-the-number-of-messages-per-task"></a>Specifica del numero di messaggi per attività  
 Nei tipi di blocchi di flussi di dati predefiniti vengono utilizzate attività per elaborare più elementi di input. In questo modo è possibile ridurre il numero di oggetti di attività necessari per elaborare i dati, consentendo alle applicazioni un'esecuzione più efficiente. Tuttavia, quando tramite le attività di un set di blocchi di flussi di dati vengono elaborati i dati, è possibile che le attività di altri blocchi di flussi di dati debbano attendere il tempo di elaborazione inserendo in coda i messaggi. Per abilitare la migliore equità tra attività del flusso di dati, impostare la proprietà <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A>. Quando la proprietà <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> è impostata su <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType>, vale a dire l'impostazione predefinita, tramite l'attività utilizzata da un blocco di flussi di dati vengono elaborati tutti i messaggi che sono disponibili. Quando la proprietà <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> è impostata su un valore diverso da <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded>, tramite il blocco di flusso di dati viene elaborato al massimo questo numero di messaggi per l'oggetto <xref:System.Threading.Tasks.Task>. Sebbene l'impostazione della proprietà <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> possa aumentare l'equità tra le attività, può causare la generazione di più attività rispetto al necessario, che possono ridurre le prestazioni.  
  
### <a name="enabling-cancellation"></a>Abilitazione dell'annullamento  
 TPL fornisce un meccanismo che consente alle attività di coordinare l'annullamento in modo cooperativo. Per consentire ai blocchi di flussi di dati di far parte di questo meccanismo di annullamento, impostare la proprietà <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A>. Quando l'oggetto <xref:System.Threading.CancellationToken> è impostato sullo stato di annullamento, da parte di tutti i blocchi di flussi di dati che controllano questo token viene terminata l'esecuzione dell'elemento corrente ma non viene avviata l'elaborazione degli elementi successivi. Tramite questi blocchi di flussi di dati vengono inoltre cancellati tutti i messaggi memorizzati nel buffer, vengono rilasciate le connessioni a tutti i blocchi di origine e di destinazione e viene eseguita la transizione allo stato di annullamento. Con la transizione allo stato di annullamento, alla proprietà <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> è associata la proprietà <xref:System.Threading.Tasks.Task.Status%2A> impostata su <xref:System.Threading.Tasks.TaskStatus.Canceled>, a meno che non venga generata un'eccezione durante l'elaborazione. In questo caso, la proprietà <xref:System.Threading.Tasks.Task.Status%2A> è impostata su <xref:System.Threading.Tasks.TaskStatus.Faulted>.  
  
 Per un esempio che illustri l'uso dell'annullamento in un'applicazione Windows Forms, vedere [Procedura: annullare un blocco di flussi di dati](how-to-cancel-a-dataflow-block.md). Per altre informazioni sull'annullamento in TPL, vedere [Annullamento delle attività](task-cancellation.md).  
  
### <a name="specifying-greedy-versus-non-greedy-behavior"></a>Specifica del comportamento greedy e non greedy a confronto  
 Diversi tipi di blocchi di flussi di dati di raggruppamento possono essere eseguiti in modalità *greedy* o *non-greedy*. Per impostazione predefinita, i tipi di blocchi di flussi di dati predefiniti vengono eseguiti in modalità greedy.  
  
 Per i tipi di blocchi join come <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, la modalità greedy indica che il blocco accetta immediatamente i dati anche se quelli corrispondenti con cui è stato creato un join non sono ancora disponibili. La modalità non greedy indica che nel blocco vengono posticipati tutti i messaggi in ingresso finché non ne è disponibile uno per ciascuna delle relative destinazioni per completare il join. Se uno dei messaggi posposti non è più disponibile, tramite il blocco join vengono rilasciati tutti i messaggi posposti e viene riavviato il processo. Per la classe <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, il comportamento greedy e non greedy è simile, ad eccezione del fatto che nella modalità non greedy, tramite un oggetto <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> vengono posticipati tutti i messaggi in ingresso finché non è disponibile un numero sufficiente da origini diverse per completare un batch.  
  
 Per specificare la modalità non greedy per un blocco di flussi di dati, impostare la proprietà <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> su `False`. Per un esempio in cui viene illustrato l'uso della modalità non-greedy per consentire la condivisione di un'origine dati in modo più efficiente da parte di più blocchi join, vedere [Procedura: usare JoinBlock per leggere dati da più origini](how-to-use-joinblock-to-read-data-from-multiple-sources.md).

## <a name="custom-dataflow-blocks"></a>Blocchi di flussi di dati personalizzati  
 Anche se la libreria del flusso di dati TPL fornisce molti tipi di blocchi predefiniti, è possibile crearne degli altri tramite cui eseguire comportamenti personalizzati. Implementare le interfacce <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> o <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> direttamente o utilizzare il metodo <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> per compilare un blocco complesso in cui viene incapsulato il comportamento di tipi di blocchi esistenti. Per esempi in cui viene illustrata l'implementazione delle funzionalità personalizzate dei blocchi di flussi di dati, vedere [Procedura dettagliata: creazione di un tipo di blocco di flussi di dati personalizzato](walkthrough-creating-a-custom-dataflow-block-type.md).

## <a name="related-topics"></a>Argomenti correlati  
  
|Titolo|Descrizione|  
|-----------|-----------------|  
|[Procedura: scrivere messaggi in un blocco di flussi di dati e leggere messaggi da un blocco di flussi di dati](how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)|Viene illustrato come scrivere messaggi in un oggetto <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> e come leggerli da quest'ultimo.|  
|[Procedura: implementare un modello di flusso di dati producer-consumer](how-to-implement-a-producer-consumer-dataflow-pattern.md)|Viene descritto come utilizzare il modello di flusso di dati per implementare uno schema producer-consumer, in cui il producer invia messaggi a un blocco di flussi di dati e il consumer legge i messaggi dal blocco in questione.|  
|[Procedura: eseguire un'azione alla ricezione di dati in un blocco di flussi di dati](how-to-perform-action-when-a-dataflow-block-receives-data.md)|Viene descritto come fornire delegati ai tipi di blocchi di flussi di dati di esecuzione, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>.|  
|[Procedura dettagliata: Creazione di una pipeline del flusso di dati](walkthrough-creating-a-dataflow-pipeline.md)|Viene descritto come creare una pipeline di flusso di dati tramite cui viene scaricato un testo dal Web e vengono eseguite operazioni su questo testo.|  
|[Procedura: scollegare i blocchi di flussi di dati](how-to-unlink-dataflow-blocks.md)|Illustra come usare il metodo <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> per scollegare un blocco di destinazione dall'origine dopo che l'origine ha offerto un messaggio alla destinazione.|  
|[Procedura dettagliata: Uso del flusso di dati in un'applicazione Windows Forms](walkthrough-using-dataflow-in-a-windows-forms-application.md)|Viene illustrato come creare una rete di blocchi di flussi di dati tramite cui viene eseguita l'elaborazione di immagini in un'applicazione Windows Form.|  
|[Procedura: Annullare un blocco di flussi di dati](how-to-cancel-a-dataflow-block.md)|Viene illustrato come utilizzare l'annullamento in un'applicazione Windows Form.|  
|[Procedura: usare JoinBlock per leggere dati da più origini](how-to-use-joinblock-to-read-data-from-multiple-sources.md)|Viene illustrato come utilizzare la classe <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> per eseguire un'operazione quando i dati sono disponibili da più origini e come utilizzare la modalità non greedy per consentire a più blocchi join di condividere in modo più efficiente un'origine dati.|  
|[Procedura: specificare il grado di parallelismo in un blocco di flussi di dati](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)|Viene illustrato come impostare la proprietà <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> per consentire a un blocco di flussi di dati di esecuzione di elaborare più messaggi alla volta.|  
|[Procedura: Specificare un'utilità di pianificazione in un blocco di flussi di dati](how-to-specify-a-task-scheduler-in-a-dataflow-block.md)|Viene illustrato come associare una specifica Utilità di pianificazione quando si utilizza il flusso di dati nell'applicazione.|  
|[Procedura dettagliata: uso di BatchBlock e BatchedJoinBlock per migliorare l'efficienza](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)|Viene descritto come utilizzare la classe <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> per migliorare l'efficienza delle operazioni di inserimento nel database e come utilizzare la classe <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> per acquisire i risultati e tutte le eccezioni che si verificano durante la lettura da un database da parte del programma.|  
|[Procedura dettagliata: creazione di un tipo di blocco di flussi di dati personalizzato](walkthrough-creating-a-custom-dataflow-block-type.md)|Vengono illustrati due modi per creare un tipo di blocco di flussi di dati tramite cui viene implementato il comportamento personalizzato.|  
|[Task Parallel Library (TPL)](task-parallel-library-tpl.md)|Viene introdotta TPL, una libreria tramite cui viene semplificata la programmazione parallela e concorrente nelle applicazioni .NET Framework.|
