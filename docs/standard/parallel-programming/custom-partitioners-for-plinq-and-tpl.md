---
title: Partitioner personalizzati per PLINQ e TPL
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, partitioners
ms.assetid: 96153688-9a01-47c4-8430-909cee9a2887
ms.openlocfilehash: 50553aab30d5a1bc5880ae0fe39c34508e57d0e5
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/02/2020
ms.locfileid: "84276725"
---
# <a name="custom-partitioners-for-plinq-and-tpl"></a><span data-ttu-id="507f9-102">Partitioner personalizzati per PLINQ e TPL</span><span class="sxs-lookup"><span data-stu-id="507f9-102">Custom Partitioners for PLINQ and TPL</span></span>

<span data-ttu-id="507f9-103">Per parallelizzare un'operazione in un'origine dati, è essenziale *partizionare* l'origine in più sezioni a cui è possibile accedere contemporaneamente da più thread.</span><span class="sxs-lookup"><span data-stu-id="507f9-103">To parallelize an operation on a data source, one of the essential steps is to *partition* the source into multiple sections that can be accessed concurrently by multiple threads.</span></span> <span data-ttu-id="507f9-104">PLINQ e Task Parallel Library (TPL) forniscono partitioner predefiniti che funzionano in modo trasparente quando si scrive una query o un ciclo <xref:System.Threading.Tasks.Parallel.ForEach%2A> parallelo.</span><span class="sxs-lookup"><span data-stu-id="507f9-104">PLINQ and the Task Parallel Library (TPL) provide default partitioners that work transparently when you write a parallel query or <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span> <span data-ttu-id="507f9-105">Per scenari più avanzati, è possibile collegare il proprio partitioner.</span><span class="sxs-lookup"><span data-stu-id="507f9-105">For more advanced scenarios, you can plug in your own partitioner.</span></span>

## <a name="kinds-of-partitioning"></a><span data-ttu-id="507f9-106">Tipi di partizionamento</span><span class="sxs-lookup"><span data-stu-id="507f9-106">Kinds of Partitioning</span></span>

<span data-ttu-id="507f9-107">Esistono diversi modi per partizionare un'origine dati.</span><span class="sxs-lookup"><span data-stu-id="507f9-107">There are many ways to partition a data source.</span></span> <span data-ttu-id="507f9-108">Negli approcci più efficienti, più thread cooperano per elaborare la sequenza di origine originale, invece di separare fisicamente l'origine in più sottosequenze.</span><span class="sxs-lookup"><span data-stu-id="507f9-108">In the most efficient approaches, multiple threads cooperate to process the original source sequence, rather than physically separating the source into multiple subsequences.</span></span> <span data-ttu-id="507f9-109">Per le matrici e le altre origini indicizzate, ad esempio le raccolte <xref:System.Collections.IList> in cui la lunghezza è nota in anticipo, il *partizionamento per intervalli* è il tipo più semplice di partizionamento.</span><span class="sxs-lookup"><span data-stu-id="507f9-109">For arrays and other indexed sources such as <xref:System.Collections.IList> collections where the length is known in advance, *range partitioning* is the simplest kind of partitioning.</span></span> <span data-ttu-id="507f9-110">Ogni thread riceve indici iniziali e finali univoci, in modo che possa elaborare l'intervallo dell'origine senza sovrascrivere un altro thread o esserne sovrascritto.</span><span class="sxs-lookup"><span data-stu-id="507f9-110">Every thread receives unique beginning and ending indexes, so that it can process its range of the source without overwriting or being overwritten by any other thread.</span></span> <span data-ttu-id="507f9-111">L'unico sovraccarico che si verifica nel partizionamento per intervalli è dovuto all'attività iniziale di creazione degli intervalli, dopo la quale non sono necessarie altre operazioni di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="507f9-111">The only overhead involved in range partitioning is the initial work of creating the ranges; no additional synchronization is required after that.</span></span> <span data-ttu-id="507f9-112">Può quindi offrire buone prestazioni purché il carico di lavoro sia suddiviso equamente.</span><span class="sxs-lookup"><span data-stu-id="507f9-112">Therefore, it can provide good performance as long as the workload is divided evenly.</span></span> <span data-ttu-id="507f9-113">Uno svantaggio del partizionamento per intervalli è che, se un thread termina prima del previsto, non può supportare il completamento degli altri thread.</span><span class="sxs-lookup"><span data-stu-id="507f9-113">A disadvantage of range partitioning is that if one thread finishes early, it cannot help the other threads finish their work.</span></span>

<span data-ttu-id="507f9-114">Per gli elenchi collegati o altre raccolte la cui lunghezza non è nota, è possibile usare il *partizionamento in blocchi*.</span><span class="sxs-lookup"><span data-stu-id="507f9-114">For linked lists or other collections whose length is not known, you can use *chunk partitioning*.</span></span> <span data-ttu-id="507f9-115">Nel partizionamento in blocchi ogni thread o attività in un ciclo o una query parallela usa un determinato numero di elementi di origine in un blocco, li elabora e quindi torna a recuperare altri elementi.</span><span class="sxs-lookup"><span data-stu-id="507f9-115">In chunk partitioning, every thread or task in a parallel loop or query consumes some number of source elements in one chunk, processes them, and then comes back to retrieve additional elements.</span></span> <span data-ttu-id="507f9-116">Il partitioner garantisce che tutti gli elementi vengano distribuiti e che non siano presenti duplicati.</span><span class="sxs-lookup"><span data-stu-id="507f9-116">The partitioner ensures that all elements are distributed and that there are no duplicates.</span></span> <span data-ttu-id="507f9-117">Un blocco può essere di qualsiasi dimensione.</span><span class="sxs-lookup"><span data-stu-id="507f9-117">A chunk may be any size.</span></span> <span data-ttu-id="507f9-118">Ad esempio, il partitioner illustrato in [Procedura: Implementare partizioni dinamiche](how-to-implement-dynamic-partitions.md) crea blocchi che contengono un solo elemento.</span><span class="sxs-lookup"><span data-stu-id="507f9-118">For example, the partitioner that is demonstrated in [How to: Implement Dynamic Partitions](how-to-implement-dynamic-partitions.md) creates chunks that contain just one element.</span></span> <span data-ttu-id="507f9-119">Purché i blocchi non siano troppo grandi, questo tipo di partizionamento esegue di per sé il bilanciamento del carico perché l'assegnazione di elementi ai thread non è predeterminata.</span><span class="sxs-lookup"><span data-stu-id="507f9-119">As long as the chunks are not too large, this kind of partitioning is inherently load-balancing because the assignment of elements to threads is not pre-determined.</span></span> <span data-ttu-id="507f9-120">Il partitioner, tuttavia, comporta il sovraccarico di sincronizzazione ogni volta che il thread deve ottenere un altro blocco.</span><span class="sxs-lookup"><span data-stu-id="507f9-120">However, the partitioner does incur the synchronization overhead each time the thread needs to get another chunk.</span></span> <span data-ttu-id="507f9-121">La quantità di operazioni di sincronizzazione eseguite in questi casi è inversamente proporzionale alle dimensioni dei blocchi.</span><span class="sxs-lookup"><span data-stu-id="507f9-121">The amount of synchronization incurred in these cases is inversely proportional to the size of the chunks.</span></span>

<span data-ttu-id="507f9-122">Il partizionamento per intervalli è in generale più veloce solo quando il tempo di esecuzione del delegato è da breve a medio, l'origine ha un numero elevato di elementi e il lavoro totale di ogni partizione è quasi equivalente.</span><span class="sxs-lookup"><span data-stu-id="507f9-122">In general, range partitioning is only faster when the execution time of the delegate is small to moderate, and the source has a large number of elements, and the total work of each partition is roughly equivalent.</span></span> <span data-ttu-id="507f9-123">Il partizionamento in blocchi è quindi in genere più veloce nella maggior parte dei casi.</span><span class="sxs-lookup"><span data-stu-id="507f9-123">Chunk partitioning is therefore generally faster in most cases.</span></span> <span data-ttu-id="507f9-124">Nelle origini con un numero limitato di elementi o tempi di esecuzione più lunghi per il delegato le prestazioni del partizionamento in blocchi e per intervalli sono più o meno uguali.</span><span class="sxs-lookup"><span data-stu-id="507f9-124">On sources with a small number of elements or longer execution times for the delegate, then the performance of chunk and range partitioning is about equal.</span></span>

<span data-ttu-id="507f9-125">I partitioner TPL supportano anche un numero di partizioni dinamico.</span><span class="sxs-lookup"><span data-stu-id="507f9-125">The TPL partitioners also support a dynamic number of partitions.</span></span> <span data-ttu-id="507f9-126">Ciò significa che possono creare le partizioni immediatamente, ad esempio, quando il ciclo <xref:System.Threading.Tasks.Parallel.ForEach%2A> genera una nuova attività.</span><span class="sxs-lookup"><span data-stu-id="507f9-126">This means they can create partitions on-the-fly, for example, when the <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop spawns a new task.</span></span> <span data-ttu-id="507f9-127">Questa funzionalità consente al partitioner di essere ridimensionato con il ciclo stesso.</span><span class="sxs-lookup"><span data-stu-id="507f9-127">This feature enables the partitioner to scale together with the loop itself.</span></span> <span data-ttu-id="507f9-128">I partitioner dinamici eseguono anche implicitamente il bilanciamento del carico.</span><span class="sxs-lookup"><span data-stu-id="507f9-128">Dynamic partitioners are also inherently load-balancing.</span></span> <span data-ttu-id="507f9-129">Quando si crea un partitioner personalizzato, è necessario supportare il partizionamento dinamico perché sia utilizzabile da un ciclo <xref:System.Threading.Tasks.Parallel.ForEach%2A>.</span><span class="sxs-lookup"><span data-stu-id="507f9-129">When you create a custom partitioner, you must support dynamic partitioning to be consumable from a <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span>

### <a name="configuring-load-balancing-partitioners-for-plinq"></a><span data-ttu-id="507f9-130">Configurazione di partitioner di bilanciamento del carico per PLINQ</span><span class="sxs-lookup"><span data-stu-id="507f9-130">Configuring Load Balancing Partitioners for PLINQ</span></span>

<span data-ttu-id="507f9-131">Alcuni overload del metodo <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> consentono di creare un partitioner per una matrice o un'origine <xref:System.Collections.IList> e di specificare se deve provare a bilanciare il carico di lavoro tra i thread.</span><span class="sxs-lookup"><span data-stu-id="507f9-131">Some overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> method let you create a partitioner for an array or <xref:System.Collections.IList> source and specify whether it should attempt to balance the workload among the threads.</span></span> <span data-ttu-id="507f9-132">Quando il partitioner è configurato per il bilanciamento del carico, viene usato il partizionamento in blocchi e gli elementi vengono passati a ogni partizione in piccoli blocchi quando vengono richiesti.</span><span class="sxs-lookup"><span data-stu-id="507f9-132">When the partitioner is configured to load-balance, chunk partitioning is used, and the elements are handed off to each partition in small chunks as they are requested.</span></span> <span data-ttu-id="507f9-133">Questo approccio consente di garantire che tutte le partizioni abbiano elementi da elaborare finché l'intero ciclo o query non viene completata.</span><span class="sxs-lookup"><span data-stu-id="507f9-133">This approach helps ensure that all partitions have elements to process until the entire loop or query is completed.</span></span> <span data-ttu-id="507f9-134">Si può usare un overload aggiuntivo per fornire il partizionamento del bilanciamento del carico di qualsiasi origine <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="507f9-134">An additional overload can be used to provide load-balancing partitioning of any <xref:System.Collections.IEnumerable> source.</span></span>

<span data-ttu-id="507f9-135">Per il bilanciamento del carico le partizioni devono in genere richiedere gli elementi al partitioner relativamente spesso.</span><span class="sxs-lookup"><span data-stu-id="507f9-135">In general, load balancing requires the partitions to request elements relatively frequently from the partitioner.</span></span> <span data-ttu-id="507f9-136">Al contrario, un partitioner che esegue il partizionamento statico può assegnare tutti gli elementi a ogni partitioner contemporaneamente usando il partizionamento per intervalli o in blocchi.</span><span class="sxs-lookup"><span data-stu-id="507f9-136">By contrast, a partitioner that does static partitioning can assign the elements to each partitioner all at once by using either range or chunk partitioning.</span></span> <span data-ttu-id="507f9-137">Ciò comporta un sovraccarico minore rispetto al bilanciamento del carico, ma l'esecuzione potrebbe richiedere più tempo se un thread termina con molte più attività rispetto agli altri.</span><span class="sxs-lookup"><span data-stu-id="507f9-137">This requires less overhead than load balancing, but it might take longer to execute if one thread ends up with significantly more work than the others.</span></span> <span data-ttu-id="507f9-138">Per impostazione predefinita, quando viene passato un elemento IList o una matrice, PLINQ usa sempre il partizionamento per intervalli senza bilanciamento del carico.</span><span class="sxs-lookup"><span data-stu-id="507f9-138">By default when it is passed an IList or an array, PLINQ always uses range partitioning without load balancing.</span></span> <span data-ttu-id="507f9-139">Per abilitare il bilanciamento del carico per PLINQ, usare il metodo `Partitioner.Create`, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="507f9-139">To enable load balancing for PLINQ, use the `Partitioner.Create` method, as shown in the following example.</span></span>

[!code-csharp[TPL_Partitioners#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioners.cs#02)]
[!code-vb[TPL_Partitioners#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionsnippets_vb.vb#02)]

<span data-ttu-id="507f9-140">Il modo migliore per stabilire se è opportuno usare il bilanciamento del carico in qualsiasi scenario specificato consiste nello sperimentare e misurare il tempo necessario per il completamento delle operazioni con carichi e configurazioni di computer rappresentativi.</span><span class="sxs-lookup"><span data-stu-id="507f9-140">The best way to determine whether to use load balancing in any given scenario is to experiment and measure how long it takes operations to complete under representative loads and computer configurations.</span></span> <span data-ttu-id="507f9-141">Il partizionamento statico, ad esempio, potrebbe offrire un considerevole aumento di velocità in un computer con solo pochi core, ma potrebbe comportare rallentamenti nei computer con un numero relativamente elevato di core.</span><span class="sxs-lookup"><span data-stu-id="507f9-141">For example, static partitioning might provide significant speedup on a multi-core computer that has only a few cores, but it might result in slowdowns on computers that have relatively many cores.</span></span>

<span data-ttu-id="507f9-142">Nella tabella seguente sono elencati gli overload disponibili del metodo <xref:System.Collections.Concurrent.Partitioner.Create%2A>.</span><span class="sxs-lookup"><span data-stu-id="507f9-142">The following table lists the available overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> method.</span></span> <span data-ttu-id="507f9-143">Questi partitioner non sono limitati all'uso con PLINQ o <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="507f9-143">These partitioners are not limited to use only with PLINQ or <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="507f9-144">Possono essere usati anche con qualsiasi costrutto parallelo personalizzato.</span><span class="sxs-lookup"><span data-stu-id="507f9-144">They can also be used with any custom parallel construct.</span></span>

|<span data-ttu-id="507f9-145">Overload</span><span class="sxs-lookup"><span data-stu-id="507f9-145">Overload</span></span>|<span data-ttu-id="507f9-146">Usa il bilanciamento del carico</span><span class="sxs-lookup"><span data-stu-id="507f9-146">Uses load balancing</span></span>|
|--------------|-------------------------|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>|<span data-ttu-id="507f9-147">Sempre</span><span class="sxs-lookup"><span data-stu-id="507f9-147">Always</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28%60%600%5B%5D%2CSystem.Boolean%29>|<span data-ttu-id="507f9-148">Quando l'argomento booleano viene specificato come true</span><span class="sxs-lookup"><span data-stu-id="507f9-148">When the Boolean argument is specified as true</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IList%7B%60%600%7D%2CSystem.Boolean%29>|<span data-ttu-id="507f9-149">Quando l'argomento booleano viene specificato come true</span><span class="sxs-lookup"><span data-stu-id="507f9-149">When the Boolean argument is specified as true</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%29>|<span data-ttu-id="507f9-150">Mai</span><span class="sxs-lookup"><span data-stu-id="507f9-150">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%2CSystem.Int32%29>|<span data-ttu-id="507f9-151">Mai</span><span class="sxs-lookup"><span data-stu-id="507f9-151">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%29>|<span data-ttu-id="507f9-152">Mai</span><span class="sxs-lookup"><span data-stu-id="507f9-152">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%2CSystem.Int64%29>|<span data-ttu-id="507f9-153">Mai</span><span class="sxs-lookup"><span data-stu-id="507f9-153">Never</span></span>|

### <a name="configuring-static-range-partitioners-for-parallelforeach"></a><span data-ttu-id="507f9-154">Configurazione di partitioner per intervalli statici per Parallel.ForEach</span><span class="sxs-lookup"><span data-stu-id="507f9-154">Configuring Static Range Partitioners for Parallel.ForEach</span></span>

<span data-ttu-id="507f9-155">In un ciclo <xref:System.Threading.Tasks.Parallel.For%2A> il corpo del ciclo viene fornito al metodo come delegato.</span><span class="sxs-lookup"><span data-stu-id="507f9-155">In a <xref:System.Threading.Tasks.Parallel.For%2A> loop, the body of the loop is provided to the method as a delegate.</span></span> <span data-ttu-id="507f9-156">Il costo della chiamata a tale delegato è più o meno lo stesso di una chiamata a un metodo virtuale.</span><span class="sxs-lookup"><span data-stu-id="507f9-156">The cost of invoking that delegate is about the same as a virtual method call.</span></span> <span data-ttu-id="507f9-157">In alcuni scenari il corpo di un ciclo parallelo potrebbe essere tanto piccolo che il costo della chiamata al delegato a ogni iterazione del ciclo diventa considerevole.</span><span class="sxs-lookup"><span data-stu-id="507f9-157">In some scenarios, the body of a parallel loop might be small enough that the cost of the delegate invocation on each loop iteration becomes significant.</span></span> <span data-ttu-id="507f9-158">In tali situazioni, è possibile usare uno degli overload <xref:System.Collections.Concurrent.Partitioner.Create%2A> per creare un'interfaccia <xref:System.Collections.Generic.IEnumerable%601> di partizioni a intervalli sugli elementi di origine.</span><span class="sxs-lookup"><span data-stu-id="507f9-158">In such situations, you can use one of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads to create an <xref:System.Collections.Generic.IEnumerable%601> of range partitions over the source elements.</span></span> <span data-ttu-id="507f9-159">È quindi possibile passare questa raccolta di intervalli a un metodo <xref:System.Threading.Tasks.Parallel.ForEach%2A> il cui corpo è costituito da un normale ciclo `for`.</span><span class="sxs-lookup"><span data-stu-id="507f9-159">Then, you can pass this collection of ranges to a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method whose body consists of a regular `for` loop.</span></span> <span data-ttu-id="507f9-160">Il vantaggio di questo approccio è che il costo della chiamata al delegato viene applicato una sola volta per intervallo, invece che una volta per elemento.</span><span class="sxs-lookup"><span data-stu-id="507f9-160">The benefit of this approach is that the delegate invocation cost is incurred only once per range, rather than once per element.</span></span> <span data-ttu-id="507f9-161">L'esempio seguente illustra il modello di base.</span><span class="sxs-lookup"><span data-stu-id="507f9-161">The following example demonstrates the basic pattern.</span></span>

[!code-csharp[TPL_Partitioners#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioner01.cs#01)]
[!code-vb[TPL_Partitioners#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionercreate01.vb#01)]

<span data-ttu-id="507f9-162">Ogni thread nel ciclo riceve la propria classe <xref:System.Tuple%602> che contiene i valori degli indici iniziali e finali dell'intervallo secondario specificato.</span><span class="sxs-lookup"><span data-stu-id="507f9-162">Every thread in the loop receives its own <xref:System.Tuple%602> that contains the starting and ending index values in the specified sub-range.</span></span> <span data-ttu-id="507f9-163">Il ciclo `for` interno usa i valori `fromInclusive` e `toExclusive` per eseguire il ciclo direttamente sulla matrice o sull'interfaccia <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="507f9-163">The inner `for` loop uses the `fromInclusive` and `toExclusive` values to loop over the array or the <xref:System.Collections.IList> directly.</span></span>

<span data-ttu-id="507f9-164">Uno degli overload <xref:System.Collections.Concurrent.Partitioner.Create%2A> consente di specificare le dimensioni delle partizioni e il numero di partizioni.</span><span class="sxs-lookup"><span data-stu-id="507f9-164">One of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads lets you specify the size of the partitions, and the number of partitions.</span></span> <span data-ttu-id="507f9-165">Questo overload può essere usato negli scenari in cui il lavoro per ogni elemento è così ridotto che anche una sola chiamata a un metodo virtuale per ogni elemento ha un impatto notevole sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="507f9-165">This overload can be used in scenarios where the work per element is so low that even one virtual method call per element has a noticeable impact on performance.</span></span>

## <a name="custom-partitioners"></a><span data-ttu-id="507f9-166">Partitioner personalizzati</span><span class="sxs-lookup"><span data-stu-id="507f9-166">Custom Partitioners</span></span>

<span data-ttu-id="507f9-167">In alcuni scenari, potrebbe essere utile o anche necessario implementare un partitioner personalizzato.</span><span class="sxs-lookup"><span data-stu-id="507f9-167">In some scenarios, it might be worthwhile or even required to implement your own partitioner.</span></span> <span data-ttu-id="507f9-168">Si potrebbe, ad esempio, avere una classe di raccolte personalizzata che è possibile partizionare in modo più efficiente di quanto possono fare i partitioner predefiniti, in base alla propria conoscenza della struttura interna della classe.</span><span class="sxs-lookup"><span data-stu-id="507f9-168">For example, you might have a custom collection class that you can partition more efficiently than the default partitioners can, based on your knowledge of the internal structure of the class.</span></span> <span data-ttu-id="507f9-169">In altri casi, può rivelarsi utile creare partizioni a intervalli di dimensioni variabili a seconda del tempo necessario per elaborare gli elementi in posizioni diverse della raccolta di origine.</span><span class="sxs-lookup"><span data-stu-id="507f9-169">Or, you may want to create range partitions of varying sizes based on your knowledge of how long it will take to process elements at different locations in the source collection.</span></span>

<span data-ttu-id="507f9-170">Per creare un partitioner personalizzato di base, derivare una classe da <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> ed eseguire l'override dei metodi virtuali, come illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="507f9-170">To create a basic custom partitioner, derive a class from <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> and override the virtual methods, as described in the following table.</span></span>

|||
|-|-|
|<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>|<span data-ttu-id="507f9-171">Questo metodo viene chiamato una volta dal thread principale e restituisce un'interfaccia IList(IEnumerator(TSource)).</span><span class="sxs-lookup"><span data-stu-id="507f9-171">This method is called once by the main thread and returns an IList(IEnumerator(TSource)).</span></span> <span data-ttu-id="507f9-172">Ogni thread di lavoro nel ciclo o nella query può chiamare `GetEnumerator` sull'elenco per recuperare un'interfaccia <xref:System.Collections.Generic.IEnumerator%601> su una partizione distinta.</span><span class="sxs-lookup"><span data-stu-id="507f9-172">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="507f9-173">Restituisce `true` se si implementa <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>. In caso contrario, `false`.</span><span class="sxs-lookup"><span data-stu-id="507f9-173">Return `true` if you implement <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, otherwise, `false`.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="507f9-174">Se <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> è `true`, si può chiamare questo metodo invece di <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="507f9-174">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|

<span data-ttu-id="507f9-175">Se i risultati devono essere ordinabili o è necessario l'accesso indicizzato agli elementi, derivare da <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> ed eseguire l'override dei metodi virtuali, come illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="507f9-175">If the results must be sortable or you require indexed access into the elements, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> and override its virtual methods as described in the following table.</span></span>

|||
|-|-|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetPartitions%2A>|<span data-ttu-id="507f9-176">Questo metodo viene chiamato una volta dal thread principale e restituisce un'interfaccia `IList(IEnumerator(TSource))`.</span><span class="sxs-lookup"><span data-stu-id="507f9-176">This method is called once by the main thread and returns an `IList(IEnumerator(TSource))`.</span></span> <span data-ttu-id="507f9-177">Ogni thread di lavoro nel ciclo o nella query può chiamare `GetEnumerator` sull'elenco per recuperare un'interfaccia <xref:System.Collections.Generic.IEnumerator%601> su una partizione distinta.</span><span class="sxs-lookup"><span data-stu-id="507f9-177">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="507f9-178">Restituisce `true` se si implementa <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>. In caso contrario, false.</span><span class="sxs-lookup"><span data-stu-id="507f9-178">Return `true` if you implement <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; otherwise, false.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="507f9-179">In genere, si limita a chiamare <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="507f9-179">Typically, this just calls <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>|<span data-ttu-id="507f9-180">Se <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> è `true`, si può chiamare questo metodo invece di <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="507f9-180">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|

<span data-ttu-id="507f9-181">La tabella seguente fornisce altri dettagli su come i tre tipi di partitioner di bilanciamento del carico implementano la classe <xref:System.Collections.Concurrent.OrderablePartitioner%601>.</span><span class="sxs-lookup"><span data-stu-id="507f9-181">The following table provides additional details about how the three kinds of load-balancing partitioners implement the <xref:System.Collections.Concurrent.OrderablePartitioner%601> class.</span></span>

|<span data-ttu-id="507f9-182">Metodo/Proprietà</span><span class="sxs-lookup"><span data-stu-id="507f9-182">Method/Property</span></span>|<span data-ttu-id="507f9-183">IList/Matrice senza bilanciamento del carico</span><span class="sxs-lookup"><span data-stu-id="507f9-183">IList / Array without Load Balancing</span></span>|<span data-ttu-id="507f9-184">IList/Matrice con bilanciamento del carico</span><span class="sxs-lookup"><span data-stu-id="507f9-184">IList / Array with Load Balancing</span></span>|<span data-ttu-id="507f9-185">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="507f9-185">IEnumerable</span></span>|
|----------------------|-------------------------------------------|----------------------------------------|-----------------|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>|<span data-ttu-id="507f9-186">Usa il partizionamento per intervalli</span><span class="sxs-lookup"><span data-stu-id="507f9-186">Uses range partitioning</span></span>|<span data-ttu-id="507f9-187">Usa il partizionamento in blocchi ottimizzato per gli elenchi del partitionCount specificato</span><span class="sxs-lookup"><span data-stu-id="507f9-187">Uses chunk partitioning optimized for Lists for the partitionCount specified</span></span>|<span data-ttu-id="507f9-188">Usa il partizionamento in blocchi creando un numero statico di partizioni.</span><span class="sxs-lookup"><span data-stu-id="507f9-188">Uses chunk partitioning by creating a static number of partitions.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A?displayProperty=nameWithType>|<span data-ttu-id="507f9-189">Genera un'eccezione non supportata</span><span class="sxs-lookup"><span data-stu-id="507f9-189">Throws not-supported exception</span></span>|<span data-ttu-id="507f9-190">Usa il partizionamento in blocchi ottimizzato per gli elenchi e le partizioni dinamiche</span><span class="sxs-lookup"><span data-stu-id="507f9-190">Uses chunk partitioning optimized for Lists and dynamic partitions</span></span>|<span data-ttu-id="507f9-191">Usa il partizionamento in blocchi creando un numero dinamico di partizioni.</span><span class="sxs-lookup"><span data-stu-id="507f9-191">Uses chunk partitioning by creating a dynamic number of partitions.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedInEachPartition%2A>|<span data-ttu-id="507f9-192">Restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="507f9-192">Returns `true`</span></span>|<span data-ttu-id="507f9-193">Restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="507f9-193">Returns `true`</span></span>|<span data-ttu-id="507f9-194">Restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="507f9-194">Returns `true`</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedAcrossPartitions%2A>|<span data-ttu-id="507f9-195">Restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="507f9-195">Returns `true`</span></span>|<span data-ttu-id="507f9-196">Restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="507f9-196">Returns `false`</span></span>|<span data-ttu-id="507f9-197">Restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="507f9-197">Returns `false`</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysNormalized%2A>|<span data-ttu-id="507f9-198">Restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="507f9-198">Returns `true`</span></span>|<span data-ttu-id="507f9-199">Restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="507f9-199">Returns `true`</span></span>|<span data-ttu-id="507f9-200">Restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="507f9-200">Returns `true`</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="507f9-201">Restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="507f9-201">Returns `false`</span></span>|<span data-ttu-id="507f9-202">Restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="507f9-202">Returns `true`</span></span>|<span data-ttu-id="507f9-203">Restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="507f9-203">Returns `true`</span></span>|

### <a name="dynamic-partitions"></a><span data-ttu-id="507f9-204">Partizioni dinamiche</span><span class="sxs-lookup"><span data-stu-id="507f9-204">Dynamic Partitions</span></span>

<span data-ttu-id="507f9-205">Se si prevede che il partitioner venga usato in un metodo <xref:System.Threading.Tasks.Parallel.ForEach%2A>, è necessario poter restituire un numero dinamico di partizioni.</span><span class="sxs-lookup"><span data-stu-id="507f9-205">If you intend the partitioner to be used in a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method, you must be able to return a dynamic number of partitions.</span></span> <span data-ttu-id="507f9-206">Questo significa che il partitioner può fornire un enumeratore per una nuova partizione on demand in qualsiasi momento durante l'esecuzione del ciclo.</span><span class="sxs-lookup"><span data-stu-id="507f9-206">This means that the partitioner can supply an enumerator for a new partition on-demand at any time during loop execution.</span></span> <span data-ttu-id="507f9-207">In sostanza, quando il ciclo aggiunge una nuova attività parallela, richiede una nuova partizione per tale attività.</span><span class="sxs-lookup"><span data-stu-id="507f9-207">Basically, whenever the loop adds a new parallel task, it requests a new partition for that task.</span></span> <span data-ttu-id="507f9-208">Se è necessario che i dati siano ordinabili, derivare da <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> in modo che a ogni elemento in ogni partizione venga assegnato un indice univoco.</span><span class="sxs-lookup"><span data-stu-id="507f9-208">If you require the data to be orderable, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> so that each item in each partition is assigned a unique index.</span></span>

<span data-ttu-id="507f9-209">Per altre informazioni e per un esempio, vedere [Procedura: Implementare partizioni dinamiche](how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="507f9-209">For more information, and an example, see [How to: Implement Dynamic Partitions](how-to-implement-dynamic-partitions.md).</span></span>

### <a name="contract-for-partitioners"></a><span data-ttu-id="507f9-210">Contratto per i partitioner</span><span class="sxs-lookup"><span data-stu-id="507f9-210">Contract for Partitioners</span></span>

<span data-ttu-id="507f9-211">Quando si implementa un partitioner personalizzato, seguire queste linee guida per assicurare la corretta interazione con PLINQ e <xref:System.Threading.Tasks.Parallel.ForEach%2A> in TPL:</span><span class="sxs-lookup"><span data-stu-id="507f9-211">When you implement a custom partitioner, follow these guidelines to help ensure correct interaction with PLINQ and <xref:System.Threading.Tasks.Parallel.ForEach%2A> in the TPL:</span></span>

- <span data-ttu-id="507f9-212">Se <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> viene chiamato con un argomento pari a zero o meno per `partitionsCount`, generare <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="507f9-212">If <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> is called with an argument of zero or less for `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="507f9-213">Anche se PLINQ e TPL non passeranno mai un `partitionCount` uguale a 0, è tuttavia consigliabile proteggersi da questa possibilità.</span><span class="sxs-lookup"><span data-stu-id="507f9-213">Although PLINQ and TPL will never pass in a `partitionCount` equal to 0, we nevertheless recommend that you guard against the possibility.</span></span>

- <span data-ttu-id="507f9-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> e <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> devono restituire sempre un numero di partizioni pari a `partitionsCount`.</span><span class="sxs-lookup"><span data-stu-id="507f9-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> should always return `partitionsCount` number of partitions.</span></span> <span data-ttu-id="507f9-215">Se il partitioner non ha dati sufficienti e non può creare tutte le partizioni richieste, il metodo deve restituire un enumeratore vuoto per ogni partizione rimanente.</span><span class="sxs-lookup"><span data-stu-id="507f9-215">If the partitioner runs out of data and cannot create as many partitions as requested, then the method should return an empty enumerator for each of the remaining partitions.</span></span> <span data-ttu-id="507f9-216">In caso contrario, sia PLINQ che TPL genereranno un'eccezione <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="507f9-216">Otherwise, both PLINQ and TPL will throw an <xref:System.InvalidOperationException>.</span></span>

- <span data-ttu-id="507f9-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A> e <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> non devono mai restituire `null` (`Nothing` in Visual Basic),</span><span class="sxs-lookup"><span data-stu-id="507f9-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> should never return `null` (`Nothing` in Visual Basic).</span></span> <span data-ttu-id="507f9-218">altrimenti PLINQ/TPL genererà un'eccezione <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="507f9-218">If they do, PLINQ / TPL will throw an <xref:System.InvalidOperationException>.</span></span>

- <span data-ttu-id="507f9-219">I metodi che restituiscono partizioni devono sempre restituire partizioni che possano enumerare l'origine dati in modo completo e univoco.</span><span class="sxs-lookup"><span data-stu-id="507f9-219">Methods that return partitions should always return partitions that can fully and uniquely enumerate the data source.</span></span> <span data-ttu-id="507f9-220">Non devono essere presenti duplicazioni nell'origine dati o elementi ignorati se non specificamente richiesto dalla progettazione del partitioner.</span><span class="sxs-lookup"><span data-stu-id="507f9-220">There should be no duplication in the data source or skipped items unless specifically required by the design of the partitioner.</span></span> <span data-ttu-id="507f9-221">Se questa regola non viene seguita, l'ordine dell'output potrebbe non risultare corretto.</span><span class="sxs-lookup"><span data-stu-id="507f9-221">If this rule is not followed, then the output order may be scrambled.</span></span>

- <span data-ttu-id="507f9-222">I getter booleani seguenti devono sempre restituire in modo accurato i valori seguenti in modo che l'ordine dell'output sia corretto:</span><span class="sxs-lookup"><span data-stu-id="507f9-222">The following Boolean getters must always accurately return the following values so that the output order is not scrambled:</span></span>

  - <span data-ttu-id="507f9-223">`KeysOrderedInEachPartition`: ogni partizione restituisce elementi con indici di chiave crescenti.</span><span class="sxs-lookup"><span data-stu-id="507f9-223">`KeysOrderedInEachPartition`: Each partition returns elements with increasing key indices.</span></span>

  - <span data-ttu-id="507f9-224">`KeysOrderedAcrossPartitions`: per tutte le partizioni restituite, gli indici di chiave della partizione *i* hanno un valore superiore rispetto a quelli nella partizione *i*-1.</span><span class="sxs-lookup"><span data-stu-id="507f9-224">`KeysOrderedAcrossPartitions`: For all partitions that are returned, the key indices in partition *i* are higher than the key indices in partition *i*-1.</span></span>

  - <span data-ttu-id="507f9-225">`KeysNormalized`: tutti gli indici di chiave sono a incremento progressivo costante senza gap, a partire da zero.</span><span class="sxs-lookup"><span data-stu-id="507f9-225">`KeysNormalized`: All key indices are monotonically increasing without gaps, starting from zero.</span></span>

- <span data-ttu-id="507f9-226">Tutti gli indici devono essere univoci.</span><span class="sxs-lookup"><span data-stu-id="507f9-226">All indices must be unique.</span></span> <span data-ttu-id="507f9-227">Non possono essere presenti indici duplicati.</span><span class="sxs-lookup"><span data-stu-id="507f9-227">There may not be duplicate indices.</span></span> <span data-ttu-id="507f9-228">Se questa regola non viene seguita, l'ordine dell'output potrebbe non risultare corretto.</span><span class="sxs-lookup"><span data-stu-id="507f9-228">If this rule is not followed, then the output order may be scrambled.</span></span>

- <span data-ttu-id="507f9-229">Tutti gli indici devono essere non negativi.</span><span class="sxs-lookup"><span data-stu-id="507f9-229">All indices must be nonnegative.</span></span> <span data-ttu-id="507f9-230">Se questa regola non viene rispettata, PLINQ/TPL può generare eccezioni.</span><span class="sxs-lookup"><span data-stu-id="507f9-230">If this rule is not followed, then PLINQ/TPL may throw exceptions.</span></span>

## <a name="see-also"></a><span data-ttu-id="507f9-231">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="507f9-231">See also</span></span>

- [<span data-ttu-id="507f9-232">Programmazione parallela</span><span class="sxs-lookup"><span data-stu-id="507f9-232">Parallel Programming</span></span>](index.md)
- [<span data-ttu-id="507f9-233">Procedura: Implementare partizioni dinamiche</span><span class="sxs-lookup"><span data-stu-id="507f9-233">How to: Implement Dynamic Partitions</span></span>](how-to-implement-dynamic-partitions.md)
- [<span data-ttu-id="507f9-234">Procedura: Implementare un partitioner per il partizionamento statico</span><span class="sxs-lookup"><span data-stu-id="507f9-234">How to: Implement a Partitioner for Static Partitioning</span></span>](how-to-implement-a-partitioner-for-static-partitioning.md)
