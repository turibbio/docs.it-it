---
title: Backtracking nelle espressioni regolari .NET
description: Informazioni su come controllare l'uso del backtracking nei criteri di ricerca delle espressioni regolari.
ms.date: 11/12/2018
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework regular expressions, backtracking
- alternative matching patterns
- optional matching patterns
- searching with regular expressions, backtracking
- pattern-matching with regular expressions, backtracking
- backtracking
- regular expressions [.NET Framework], backtracking
- strings [.NET Framework], regular expressions
- parsing text with regular expressions, backtracking
ms.assetid: 34df1152-0b22-4a1c-a76c-3c28c47b70d8
ms.openlocfilehash: d9fb976c73891646df60b5329beb09493acbae8a
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/02/2020
ms.locfileid: "84277804"
---
# <a name="backtracking-in-regular-expressions"></a><span data-ttu-id="30b93-103">Backtracking nelle espressioni regolari</span><span class="sxs-lookup"><span data-stu-id="30b93-103">Backtracking in Regular Expressions</span></span>
<span data-ttu-id="30b93-104">Il backtracking si verifica quando un modello di espressione regolare contiene [quantificatori](quantifiers-in-regular-expressions.md) o [costrutti di alternanza](alternation-constructs-in-regular-expressions.md) facoltativi e il motore delle espressioni regolari torna a uno stato salvato in precedenza per continuare la ricerca di una corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-104">Backtracking occurs when a regular expression pattern contains optional [quantifiers](quantifiers-in-regular-expressions.md) or [alternation constructs](alternation-constructs-in-regular-expressions.md), and the regular expression engine returns to a previous saved state to continue its search for a match.</span></span> <span data-ttu-id="30b93-105">Il backtracking è fondamentale per la potenza delle espressioni regolari. Consente alle espressioni di essere potenti e flessibili e di cercare una corrispondenza di modelli molto complessi.</span><span class="sxs-lookup"><span data-stu-id="30b93-105">Backtracking is central to the power of regular expressions; it makes it possible for expressions to be powerful and flexible, and to match very complex patterns.</span></span> <span data-ttu-id="30b93-106">Questa tecnica presenta tuttavia anche alcuni svantaggi.</span><span class="sxs-lookup"><span data-stu-id="30b93-106">At the same time, this power comes at a cost.</span></span> <span data-ttu-id="30b93-107">Il backtracking spesso è il fattore più importante che influisce sulle prestazioni del motore delle espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="30b93-107">Backtracking is often the single most important factor that affects the performance of the regular expression engine.</span></span> <span data-ttu-id="30b93-108">Fortunatamente, lo sviluppatore è in grado di controllare il comportamento del motore delle espressioni regolari e il modo in cui viene utilizzato il backtracking.</span><span class="sxs-lookup"><span data-stu-id="30b93-108">Fortunately, the developer has control over the behavior of the regular expression engine and how it uses backtracking.</span></span> <span data-ttu-id="30b93-109">In questo argomento viene illustrato il funzionamento del backtracking e il modo in cui può essere controllato.</span><span class="sxs-lookup"><span data-stu-id="30b93-109">This topic explains how backtracking works and how it can be controlled.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="30b93-110">In generale, un motore NFA (Nondeterministic Finite Automaton) come il motore delle espressioni regolari .NET affida la responsabilità della creazione di espressioni regolari efficienti e veloci allo sviluppatore.</span><span class="sxs-lookup"><span data-stu-id="30b93-110">In general, a Nondeterministic Finite Automaton (NFA) engine like .NET regular expression engine places the responsibility for crafting efficient, fast regular expressions on the developer.</span></span>  

## <a name="linear-comparison-without-backtracking"></a><span data-ttu-id="30b93-111">Confronto lineare senza backtracking</span><span class="sxs-lookup"><span data-stu-id="30b93-111">Linear Comparison Without Backtracking</span></span>  
 <span data-ttu-id="30b93-112">Se un modello di espressione regolare non contiene quantificatori facoltativi o costrutti di alternanza, il motore delle espressioni regolari viene eseguito in un tempo lineare,</span><span class="sxs-lookup"><span data-stu-id="30b93-112">If a regular expression pattern has no optional quantifiers or alternation constructs, the regular expression engine executes in linear time.</span></span> <span data-ttu-id="30b93-113">ovvero dopo che il motore delle espressioni regolari trova una corrispondenza tra il primo elemento del linguaggio del modello e il testo della stringa di input, prova a trovare una corrispondenza tra l'elemento del linguaggio successivo del modello e il carattere o il gruppo di caratteri successivi della stringa di input.</span><span class="sxs-lookup"><span data-stu-id="30b93-113">That is, after the regular expression engine matches the first language element in the pattern with text in the input string, it tries to match the next language element in the pattern with the next character or group of characters in the input string.</span></span> <span data-ttu-id="30b93-114">Il processo continua finché la ricerca della corrispondenza non avrà esito positivo o negativo.</span><span class="sxs-lookup"><span data-stu-id="30b93-114">This continues until the match either succeeds or fails.</span></span> <span data-ttu-id="30b93-115">In entrambi i casi, il motore delle espressioni regolari avanza di un carattere alla volta nella stringa di input.</span><span class="sxs-lookup"><span data-stu-id="30b93-115">In either case, the regular expression engine advances by one character at a time in the input string.</span></span>  
  
 <span data-ttu-id="30b93-116">Di seguito ne viene illustrato un esempio.</span><span class="sxs-lookup"><span data-stu-id="30b93-116">The following example provides an illustration.</span></span> <span data-ttu-id="30b93-117">L'espressione regolare `e{2}\w\b` cerca due occorrenze della lettera "e", seguite da qualsiasi carattere alfanumerico, seguito da un confine di parola.</span><span class="sxs-lookup"><span data-stu-id="30b93-117">The regular expression `e{2}\w\b` looks for two occurrences of the letter "e" followed by any word character followed by a word boundary.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking1.cs#1)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking1.vb#1)]  
  
 <span data-ttu-id="30b93-118">Benché questa espressione regolare includa il quantificatore `{2}`, viene valutata in modo lineare.</span><span class="sxs-lookup"><span data-stu-id="30b93-118">Although this regular expression includes the quantifier `{2}`, it is evaluated in a linear manner.</span></span> <span data-ttu-id="30b93-119">Il motore delle espressioni regolari non esegue il backtracking perché `{2}` non è un quantificatore facoltativo, ma specifica un numero esatto e non un numero variabile di volte in cui trovare la corrispondenza della sottoespressione precedente.</span><span class="sxs-lookup"><span data-stu-id="30b93-119">The regular expression engine does not backtrack because `{2}` is not an optional quantifier; it specifies an exact number and not a variable number of times that the previous subexpression must match.</span></span> <span data-ttu-id="30b93-120">Di conseguenza, il motore delle espressioni regolari tenta di trovare una corrispondenza tra il modello di espressione regolare e la stringa di input come illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="30b93-120">As a result, the regular expression engine tries to match the regular expression pattern with the input string as shown in the following table.</span></span>  
  
|<span data-ttu-id="30b93-121">Operazione</span><span class="sxs-lookup"><span data-stu-id="30b93-121">Operation</span></span>|<span data-ttu-id="30b93-122">Posizione nel modello</span><span class="sxs-lookup"><span data-stu-id="30b93-122">Position in pattern</span></span>|<span data-ttu-id="30b93-123">Posizione nella stringa</span><span class="sxs-lookup"><span data-stu-id="30b93-123">Position in string</span></span>|<span data-ttu-id="30b93-124">Risultato</span><span class="sxs-lookup"><span data-stu-id="30b93-124">Result</span></span>|  
|---------------|-------------------------|------------------------|------------|  
|<span data-ttu-id="30b93-125">1</span><span class="sxs-lookup"><span data-stu-id="30b93-125">1</span></span>|<span data-ttu-id="30b93-126">e</span><span class="sxs-lookup"><span data-stu-id="30b93-126">e</span></span>|<span data-ttu-id="30b93-127">"needing a reed" (indice 0)</span><span class="sxs-lookup"><span data-stu-id="30b93-127">"needing a reed" (index 0)</span></span>|<span data-ttu-id="30b93-128">Nessuna corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-128">No match.</span></span>|  
|<span data-ttu-id="30b93-129">2</span><span class="sxs-lookup"><span data-stu-id="30b93-129">2</span></span>|<span data-ttu-id="30b93-130">e</span><span class="sxs-lookup"><span data-stu-id="30b93-130">e</span></span>|<span data-ttu-id="30b93-131">"eeding a reed" (indice 1)</span><span class="sxs-lookup"><span data-stu-id="30b93-131">"eeding a reed" (index 1)</span></span>|<span data-ttu-id="30b93-132">Possibile corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-132">Possible match.</span></span>|  
|<span data-ttu-id="30b93-133">3</span><span class="sxs-lookup"><span data-stu-id="30b93-133">3</span></span>|<span data-ttu-id="30b93-134">e{2}</span><span class="sxs-lookup"><span data-stu-id="30b93-134">e{2}</span></span>|<span data-ttu-id="30b93-135">"eding a reed" (indice 2)</span><span class="sxs-lookup"><span data-stu-id="30b93-135">"eding a reed" (index 2)</span></span>|<span data-ttu-id="30b93-136">Possibile corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-136">Possible match.</span></span>|  
|<span data-ttu-id="30b93-137">4</span><span class="sxs-lookup"><span data-stu-id="30b93-137">4</span></span>|<span data-ttu-id="30b93-138">\w</span><span class="sxs-lookup"><span data-stu-id="30b93-138">\w</span></span>|<span data-ttu-id="30b93-139">"ding a reed" (indice 3)</span><span class="sxs-lookup"><span data-stu-id="30b93-139">"ding a reed" (index 3)</span></span>|<span data-ttu-id="30b93-140">Possibile corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-140">Possible match.</span></span>|  
|<span data-ttu-id="30b93-141">5</span><span class="sxs-lookup"><span data-stu-id="30b93-141">5</span></span>|<span data-ttu-id="30b93-142">\b</span><span class="sxs-lookup"><span data-stu-id="30b93-142">\b</span></span>|<span data-ttu-id="30b93-143">"ing a reed" (indice 4)</span><span class="sxs-lookup"><span data-stu-id="30b93-143">"ing a reed" (index 4)</span></span>|<span data-ttu-id="30b93-144">Possibile corrispondenza non riuscita.</span><span class="sxs-lookup"><span data-stu-id="30b93-144">Possible match fails.</span></span>|  
|<span data-ttu-id="30b93-145">6</span><span class="sxs-lookup"><span data-stu-id="30b93-145">6</span></span>|<span data-ttu-id="30b93-146">e</span><span class="sxs-lookup"><span data-stu-id="30b93-146">e</span></span>|<span data-ttu-id="30b93-147">"eding a reed" (indice 2)</span><span class="sxs-lookup"><span data-stu-id="30b93-147">"eding a reed" (index 2)</span></span>|<span data-ttu-id="30b93-148">Possibile corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-148">Possible match.</span></span>|  
|<span data-ttu-id="30b93-149">7</span><span class="sxs-lookup"><span data-stu-id="30b93-149">7</span></span>|<span data-ttu-id="30b93-150">e{2}</span><span class="sxs-lookup"><span data-stu-id="30b93-150">e{2}</span></span>|<span data-ttu-id="30b93-151">"ding a reed" (indice 3)</span><span class="sxs-lookup"><span data-stu-id="30b93-151">"ding a reed" (index 3)</span></span>|<span data-ttu-id="30b93-152">Possibile corrispondenza non riuscita.</span><span class="sxs-lookup"><span data-stu-id="30b93-152">Possible match fails.</span></span>|  
|<span data-ttu-id="30b93-153">8</span><span class="sxs-lookup"><span data-stu-id="30b93-153">8</span></span>|<span data-ttu-id="30b93-154">e</span><span class="sxs-lookup"><span data-stu-id="30b93-154">e</span></span>|<span data-ttu-id="30b93-155">"ding a reed" (indice 3)</span><span class="sxs-lookup"><span data-stu-id="30b93-155">"ding a reed" (index 3)</span></span>|<span data-ttu-id="30b93-156">La corrispondenza ha esito negativo.</span><span class="sxs-lookup"><span data-stu-id="30b93-156">Match fails.</span></span>|  
|<span data-ttu-id="30b93-157">9</span><span class="sxs-lookup"><span data-stu-id="30b93-157">9</span></span>|<span data-ttu-id="30b93-158">e</span><span class="sxs-lookup"><span data-stu-id="30b93-158">e</span></span>|<span data-ttu-id="30b93-159">"ing a reed" (indice 4)</span><span class="sxs-lookup"><span data-stu-id="30b93-159">"ing a reed" (index 4)</span></span>|<span data-ttu-id="30b93-160">Nessuna corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-160">No match.</span></span>|  
|<span data-ttu-id="30b93-161">10</span><span class="sxs-lookup"><span data-stu-id="30b93-161">10</span></span>|<span data-ttu-id="30b93-162">e</span><span class="sxs-lookup"><span data-stu-id="30b93-162">e</span></span>|<span data-ttu-id="30b93-163">"ng a reed" (indice 5)</span><span class="sxs-lookup"><span data-stu-id="30b93-163">"ng a reed" (index 5)</span></span>|<span data-ttu-id="30b93-164">Nessuna corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-164">No match.</span></span>|  
|<span data-ttu-id="30b93-165">11</span><span class="sxs-lookup"><span data-stu-id="30b93-165">11</span></span>|<span data-ttu-id="30b93-166">e</span><span class="sxs-lookup"><span data-stu-id="30b93-166">e</span></span>|<span data-ttu-id="30b93-167">"g a reed" (indice 6)</span><span class="sxs-lookup"><span data-stu-id="30b93-167">"g a reed" (index 6)</span></span>|<span data-ttu-id="30b93-168">Nessuna corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-168">No match.</span></span>|  
|<span data-ttu-id="30b93-169">12</span><span class="sxs-lookup"><span data-stu-id="30b93-169">12</span></span>|<span data-ttu-id="30b93-170">e</span><span class="sxs-lookup"><span data-stu-id="30b93-170">e</span></span>|<span data-ttu-id="30b93-171">" a reed" (indice 7)</span><span class="sxs-lookup"><span data-stu-id="30b93-171">" a reed" (index 7)</span></span>|<span data-ttu-id="30b93-172">Nessuna corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-172">No match.</span></span>|  
|<span data-ttu-id="30b93-173">13</span><span class="sxs-lookup"><span data-stu-id="30b93-173">13</span></span>|<span data-ttu-id="30b93-174">e</span><span class="sxs-lookup"><span data-stu-id="30b93-174">e</span></span>|<span data-ttu-id="30b93-175">"a reed" (indice 8)</span><span class="sxs-lookup"><span data-stu-id="30b93-175">"a reed" (index 8)</span></span>|<span data-ttu-id="30b93-176">Nessuna corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-176">No match.</span></span>|  
|<span data-ttu-id="30b93-177">14</span><span class="sxs-lookup"><span data-stu-id="30b93-177">14</span></span>|<span data-ttu-id="30b93-178">e</span><span class="sxs-lookup"><span data-stu-id="30b93-178">e</span></span>|<span data-ttu-id="30b93-179">" reed" (indice 9)</span><span class="sxs-lookup"><span data-stu-id="30b93-179">" reed" (index 9)</span></span>|<span data-ttu-id="30b93-180">Nessuna corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-180">No match.</span></span>|  
|<span data-ttu-id="30b93-181">15</span><span class="sxs-lookup"><span data-stu-id="30b93-181">15</span></span>|<span data-ttu-id="30b93-182">e</span><span class="sxs-lookup"><span data-stu-id="30b93-182">e</span></span>|<span data-ttu-id="30b93-183">"reed" (indice 10)</span><span class="sxs-lookup"><span data-stu-id="30b93-183">"reed" (index 10)</span></span>|<span data-ttu-id="30b93-184">Nessuna corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-184">No match</span></span>|  
|<span data-ttu-id="30b93-185">16</span><span class="sxs-lookup"><span data-stu-id="30b93-185">16</span></span>|<span data-ttu-id="30b93-186">e</span><span class="sxs-lookup"><span data-stu-id="30b93-186">e</span></span>|<span data-ttu-id="30b93-187">"eed" (indice 11)</span><span class="sxs-lookup"><span data-stu-id="30b93-187">"eed" (index 11)</span></span>|<span data-ttu-id="30b93-188">Possibile corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-188">Possible match.</span></span>|  
|<span data-ttu-id="30b93-189">17</span><span class="sxs-lookup"><span data-stu-id="30b93-189">17</span></span>|<span data-ttu-id="30b93-190">e{2}</span><span class="sxs-lookup"><span data-stu-id="30b93-190">e{2}</span></span>|<span data-ttu-id="30b93-191">"ed" (indice 12)</span><span class="sxs-lookup"><span data-stu-id="30b93-191">"ed" (index 12)</span></span>|<span data-ttu-id="30b93-192">Possibile corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-192">Possible match.</span></span>|  
|<span data-ttu-id="30b93-193">18</span><span class="sxs-lookup"><span data-stu-id="30b93-193">18</span></span>|<span data-ttu-id="30b93-194">\w</span><span class="sxs-lookup"><span data-stu-id="30b93-194">\w</span></span>|<span data-ttu-id="30b93-195">"d" (indice 13)</span><span class="sxs-lookup"><span data-stu-id="30b93-195">"d" (index 13)</span></span>|<span data-ttu-id="30b93-196">Possibile corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-196">Possible match.</span></span>|  
|<span data-ttu-id="30b93-197">19</span><span class="sxs-lookup"><span data-stu-id="30b93-197">19</span></span>|<span data-ttu-id="30b93-198">\b</span><span class="sxs-lookup"><span data-stu-id="30b93-198">\b</span></span>|<span data-ttu-id="30b93-199">"" (indice 14)</span><span class="sxs-lookup"><span data-stu-id="30b93-199">"" (index 14)</span></span>|<span data-ttu-id="30b93-200">Corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-200">Match.</span></span>|  
  
 <span data-ttu-id="30b93-201">Se un modello di espressione regolare non include quantificatori facoltativi o costrutti di alternanza, il numero massimo di confronti necessari per trovare una corrispondenza tra il modello di espressione regolare e la stringa di input equivale approssimativamente al numero di caratteri della stringa di input.</span><span class="sxs-lookup"><span data-stu-id="30b93-201">If a regular expression pattern includes no optional quantifiers or alternation constructs, the maximum number of comparisons required to match the regular expression pattern with the input string is roughly equivalent to the number of characters in the input string.</span></span> <span data-ttu-id="30b93-202">In questo caso, l'espressione regolare utilizza 19 confronti per identificare le possibili corrispondenze nella stringa di 13 caratteri.</span><span class="sxs-lookup"><span data-stu-id="30b93-202">In this case, the regular expression engine uses 19 comparisons to identify possible matches in this 13-character string.</span></span>  <span data-ttu-id="30b93-203">In altre parole, il motore delle espressioni regolari viene eseguito in un tempo quasi lineare se non contiene quantificatori facoltativi o costrutti di alternanza.</span><span class="sxs-lookup"><span data-stu-id="30b93-203">In other words, the regular expression engine runs in near-linear time if it contains no optional quantifiers or alternation constructs.</span></span>

## <a name="backtracking-with-optional-quantifiers-or-alternation-constructs"></a><span data-ttu-id="30b93-204">Backtracking con quantificatori facoltativi o costrutti di alternanza</span><span class="sxs-lookup"><span data-stu-id="30b93-204">Backtracking with Optional Quantifiers or Alternation Constructs</span></span>  
 <span data-ttu-id="30b93-205">Quando un'espressione regolare include quantificatori facoltativi o costrutti di alternanza, la valutazione della stringa di input non è più lineare.</span><span class="sxs-lookup"><span data-stu-id="30b93-205">When a regular expression includes optional quantifiers or alternation constructs, the evaluation of the input string is no longer linear.</span></span> <span data-ttu-id="30b93-206">La corrispondenza dei modelli con un motore NFA è determinata dagli elementi del linguaggio nell'espressione regolare e non dai caratteri con cui trovare una corrispondenza nella stringa di input.</span><span class="sxs-lookup"><span data-stu-id="30b93-206">Pattern matching with an NFA engine is driven by the language elements in the regular expression and not by the characters to be matched in the input string.</span></span> <span data-ttu-id="30b93-207">Il motore delle espressioni regolari prova pertanto a trovare una piena corrispondenza con le sottoespressioni facoltative o alternative.</span><span class="sxs-lookup"><span data-stu-id="30b93-207">Therefore, the regular expression engine tries to fully match optional or alternative subexpressions.</span></span> <span data-ttu-id="30b93-208">Quando avanza all'elemento del linguaggio successivo nella sottoespressione e la corrispondenza ha esito negativo, il motore delle espressioni regolari può abbandonare una parte della corrispondenza esatta e tornare a uno stato salvato in precedenza al fine di trovare una corrispondenza tra l'intera espressione regolare e la stringa di input.</span><span class="sxs-lookup"><span data-stu-id="30b93-208">When it advances to the next language element in the subexpression and the match is unsuccessful, the regular expression engine can abandon a portion of its successful match and return to an earlier saved state in the interest of matching the regular expression as a whole with the input string.</span></span> <span data-ttu-id="30b93-209">Questo processo di tornare a uno stato salvato in precedenza per trovare una corrispondenza è noto come backtracking.</span><span class="sxs-lookup"><span data-stu-id="30b93-209">This process of returning to a previous saved state to find a match is known as backtracking.</span></span>  
  
 <span data-ttu-id="30b93-210">Si consideri, ad esempio, il modello di espressione regolare `.*(es)`che cerca una corrispondenza con i caratteri "es" e tutti i caratteri che li precedono.</span><span class="sxs-lookup"><span data-stu-id="30b93-210">For example, consider the regular expression pattern `.*(es)`, which matches the characters "es" and all the characters that precede it.</span></span> <span data-ttu-id="30b93-211">Come illustrato nell'esempio seguente, se la stringa di input è "Essential services are provided by regular expressions.", il modello cerca una corrispondenza con l'intera stringa fino ai caratteri "es" in "expressions" compresi.</span><span class="sxs-lookup"><span data-stu-id="30b93-211">As the following example shows, if the input string is "Essential services are provided by regular expressions.", the pattern matches the whole string up to and including the "es" in "expressions".</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking2.cs#2)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking2.vb#2)]  
  
 <span data-ttu-id="30b93-212">A tale scopo, il motore delle espressioni regolari utilizza il backtracking come segue:</span><span class="sxs-lookup"><span data-stu-id="30b93-212">To do this, the regular expression engine uses backtracking as follows:</span></span>  
  
- <span data-ttu-id="30b93-213">Trova la corrispondenza di `.*` , ovvero di zero, uno o più occorrenze di qualsiasi carattere, con l'intera stringa di input.</span><span class="sxs-lookup"><span data-stu-id="30b93-213">It matches the `.*` (which matches zero, one, or more occurrences of any character) with the whole input string.</span></span>  
  
- <span data-ttu-id="30b93-214">Tenta di trovare una corrispondenza di "e" nel modello di espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="30b93-214">It attempts to match "e" in the regular expression pattern.</span></span> <span data-ttu-id="30b93-215">Tuttavia, nella stringa di input non sono presenti altri caratteri di cui cercare una corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-215">However, the input string has no remaining characters available to match.</span></span>  
  
- <span data-ttu-id="30b93-216">Esegue il backtracking fino all'ultima corrispondenza esatta, "Essential services are provided by regular expressions", e tenta di trovare una corrispondenza di "e" con il punto alla fine della frase.</span><span class="sxs-lookup"><span data-stu-id="30b93-216">It backtracks to its last successful match, "Essential services are provided by regular expressions", and attempts to match "e" with the period at the end of the sentence.</span></span> <span data-ttu-id="30b93-217">La corrispondenza ha esito negativo.</span><span class="sxs-lookup"><span data-stu-id="30b93-217">The match fails.</span></span>  
  
- <span data-ttu-id="30b93-218">Continua a eseguire il backtracking fino a una corrispondenza esatta precedente, un carattere alla volta, finché la sottostringa temporaneamente corrispondente non è "Essential services are provided by regular expr".</span><span class="sxs-lookup"><span data-stu-id="30b93-218">It continues to backtrack to a previous successful match one character at a time until the tentatively matched substring is "Essential services are provided by regular expr".</span></span> <span data-ttu-id="30b93-219">Confronta quindi la "e" nel modello con la seconda "e" in "expressions" e trova una corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-219">It then compares the "e" in the pattern to the second "e" in "expressions" and finds a match.</span></span>  
  
- <span data-ttu-id="30b93-220">Confronta la "s" nel modello con la "s" che segue il carattere "e" corrispondente (la prima "s" in "expressions").</span><span class="sxs-lookup"><span data-stu-id="30b93-220">It compares "s" in the pattern to the "s" that follows the matched "e" character (the first "s" in "expressions").</span></span> <span data-ttu-id="30b93-221">La corrispondenza ha esito positivo.</span><span class="sxs-lookup"><span data-stu-id="30b93-221">The match is successful.</span></span>  
  
 <span data-ttu-id="30b93-222">Quando si utilizza il backtracking, la ricerca di una corrispondenza tra il modello di espressione regolare e la stringa di input, con una lunghezza pari a 55 caratteri, richiede 67 operazioni di confronto.</span><span class="sxs-lookup"><span data-stu-id="30b93-222">When you use backtracking, matching the regular expression pattern with the input string, which is 55 characters long, requires 67 comparison operations.</span></span> <span data-ttu-id="30b93-223">In genere, se un modello di espressione regolare include un singolo costrutto di alternanza o un singolo quantificatore facoltativo, il numero di operazioni di confronto necessarie per trovare una corrispondenza del modello è più del doppio rispetto al numero di caratteri della stringa di input.</span><span class="sxs-lookup"><span data-stu-id="30b93-223">Generally, if a regular expression pattern has a single alternation construct or a single optional quantifier, the number of comparison operations required to match the pattern is more than twice the number of characters in the input string.</span></span>

## <a name="backtracking-with-nested-optional-quantifiers"></a><span data-ttu-id="30b93-224">Backtracking con quantificatori facoltativi annidati</span><span class="sxs-lookup"><span data-stu-id="30b93-224">Backtracking with Nested Optional Quantifiers</span></span>  
 <span data-ttu-id="30b93-225">Il numero di operazioni di confronto necessarie per trovare una corrispondenza di un modello di espressione regolare può aumentare in modo esponenziale se il modello include un numero elevato di costrutti di alternanza, se include costrutti di alternanza annidati o se include sopratutto quantificatori facoltativi annidati.</span><span class="sxs-lookup"><span data-stu-id="30b93-225">The number of comparison operations required to match a regular expression pattern can increase exponentially if the pattern includes a large number of alternation constructs, if it includes nested alternation constructs, or, most commonly, if it includes nested optional quantifiers.</span></span> <span data-ttu-id="30b93-226">Il modello di espressione regolare `^(a+)+$` , ad esempio, è progettato per cercare una corrispondenza con una stringa completa contenente uno o più caratteri "a".</span><span class="sxs-lookup"><span data-stu-id="30b93-226">For example, the regular expression pattern `^(a+)+$` is designed to match a complete string that contains one or more "a" characters.</span></span> <span data-ttu-id="30b93-227">Nell'esempio vengono fornite due stringhe di input di lunghezza identica, ma solo la prima stringa corrisponde al modello.</span><span class="sxs-lookup"><span data-stu-id="30b93-227">The example provides two input strings of identical length, but only the first string matches the pattern.</span></span> <span data-ttu-id="30b93-228">La classe <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> viene utilizzata per determinare il tempo richiesto dall'operazione di corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-228">The <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> class is used to determine how long the match operation takes.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking3.cs#3)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking3.vb#3)]  
  
 <span data-ttu-id="30b93-229">Come illustrato nell'output dell'esempio, il motore delle espressioni regolari ha impiegato il doppio del tempo per rilevare che una stringa di input non corrisponde al modello rispetto al tempo impiegato per identificare una stringa corrispondente.</span><span class="sxs-lookup"><span data-stu-id="30b93-229">As the output from the example shows, the regular expression engine took about twice as long to find that an input string did not match the pattern as it did to identify a matching string.</span></span> <span data-ttu-id="30b93-230">Ciò è dovuto al fatto che una corrispondenza negativa rappresenta sempre lo scenario peggiore.</span><span class="sxs-lookup"><span data-stu-id="30b93-230">This is because an unsuccessful match always represents a worst-case scenario.</span></span> <span data-ttu-id="30b93-231">Il motore delle espressioni regolari deve utilizzare l'espressione regolare per seguire tutti i percorsi possibili nei dati prima di poter concludere che la corrispondenza è negativa e le parentesi annidate creano molti percorsi aggiuntivi nei dati.</span><span class="sxs-lookup"><span data-stu-id="30b93-231">The regular expression engine must use the regular expression to follow all possible paths through the data before it can conclude that the match is unsuccessful, and the nested parentheses create many additional paths through the data.</span></span> <span data-ttu-id="30b93-232">Il motore delle espressioni regolari conclude che la seconda stringa non corrisponde al modello effettuando le operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="30b93-232">The regular expression engine concludes that the second string did not match the pattern by doing the following:</span></span>  
  
- <span data-ttu-id="30b93-233">Verifica di essere all'inizio della stringa, quindi cerca una corrispondenza tra i primi cinque caratteri della stringa e il modello `a+`.</span><span class="sxs-lookup"><span data-stu-id="30b93-233">It checks that it was at the beginning of the string, and then matches the first five characters in the string with the pattern `a+`.</span></span> <span data-ttu-id="30b93-234">Determina quindi che non esistono altri gruppi di caratteri "a" nella stringa.</span><span class="sxs-lookup"><span data-stu-id="30b93-234">It then determines that there are no additional groups of "a" characters in the string.</span></span> <span data-ttu-id="30b93-235">Infine, verifica la fine della stringa.</span><span class="sxs-lookup"><span data-stu-id="30b93-235">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="30b93-236">Poiché nella stringa rimane un ulteriore carattere, la corrispondenza ha esito negativo.</span><span class="sxs-lookup"><span data-stu-id="30b93-236">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="30b93-237">La corrispondenza non riuscita richiede 9 confronti.</span><span class="sxs-lookup"><span data-stu-id="30b93-237">This failed match requires 9 comparisons.</span></span> <span data-ttu-id="30b93-238">Il motore delle espressioni regolari salva inoltre le informazioni di stato dalle relative corrispondenze di "a" (che chiameremo corrispondenza 1), "aa" (corrispondenza 2), "aaa" (corrispondenza 3) e "aaaa" (corrispondenza 4).</span><span class="sxs-lookup"><span data-stu-id="30b93-238">The regular expression engine also saves state information from its matches of "a" (which we will call match 1), "aa" (match 2), "aaa" (match 3), and "aaaa" (match 4).</span></span>  
  
- <span data-ttu-id="30b93-239">Torna alla corrispondenza 4 salvata in precedenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-239">It returns to the previously saved match 4.</span></span> <span data-ttu-id="30b93-240">Determina che esiste un altro carattere "a" da assegnare a un gruppo acquisito aggiuntivo.</span><span class="sxs-lookup"><span data-stu-id="30b93-240">It determines that there is one additional "a" character to assign to an additional captured group.</span></span> <span data-ttu-id="30b93-241">Infine, verifica la fine della stringa.</span><span class="sxs-lookup"><span data-stu-id="30b93-241">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="30b93-242">Poiché nella stringa rimane un ulteriore carattere, la corrispondenza ha esito negativo.</span><span class="sxs-lookup"><span data-stu-id="30b93-242">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="30b93-243">La corrispondenza non riuscita richiede 4 confronti.</span><span class="sxs-lookup"><span data-stu-id="30b93-243">This failed match requires 4 comparisons.</span></span> <span data-ttu-id="30b93-244">Fino a questo momento sono stati eseguiti complessivamente 13 confronti.</span><span class="sxs-lookup"><span data-stu-id="30b93-244">So far, a total of 13 comparisons have been performed.</span></span>  
  
- <span data-ttu-id="30b93-245">Torna alla corrispondenza 3 salvata in precedenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-245">It returns to the previously saved match 3.</span></span> <span data-ttu-id="30b93-246">Determina che esistono sono altri due caratteri "a" da assegnare a un gruppo acquisito aggiuntivo.</span><span class="sxs-lookup"><span data-stu-id="30b93-246">It determines that there are two additional "a" characters to assign to an additional captured group.</span></span> <span data-ttu-id="30b93-247">Tuttavia, il test di fine della stringa ha esito negativo.</span><span class="sxs-lookup"><span data-stu-id="30b93-247">However, the end-of-string test fails.</span></span> <span data-ttu-id="30b93-248">Torna quindi alla corrispondenza 3 e tenta di trovare una corrispondenza degli altri due caratteri "a" nei due gruppi acquisiti aggiuntivi.</span><span class="sxs-lookup"><span data-stu-id="30b93-248">It then returns to match3 and tries to match the two additional "a" characters in two additional captured groups.</span></span> <span data-ttu-id="30b93-249">Il test di fine della stringa ha ancora esito negativo.</span><span class="sxs-lookup"><span data-stu-id="30b93-249">The end-of-string test still fails.</span></span> <span data-ttu-id="30b93-250">Le corrispondenza non riuscite richiedono 12 confronti.</span><span class="sxs-lookup"><span data-stu-id="30b93-250">These failed matches require 12 comparisons.</span></span> <span data-ttu-id="30b93-251">Fino a questo punto, sono stati eseguiti complessivamente 25 confronti.</span><span class="sxs-lookup"><span data-stu-id="30b93-251">So far, a total of 25 comparisons have been performed.</span></span>  
  
 <span data-ttu-id="30b93-252">Il confronto della stringa di input con l'espressione regolare continua in questo modo fino a quando il motore delle espressioni regolari non ha tentato tutte le combinazioni di corrispondenze possibili, concludendo infine che non vi è alcuna corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="30b93-252">Comparison of the input string with the regular expression continues in this way until the regular expression engine has tried all possible combinations of matches, and then concludes that there is no match.</span></span> <span data-ttu-id="30b93-253">A causa dei quantificatori annidati, questo confronto è un'operazione O(2<sup>n</sup>) o un'operazione esponenziale, dove *n* è il numero di caratteri all'interno della stringa di input.</span><span class="sxs-lookup"><span data-stu-id="30b93-253">Because of the nested quantifiers, this comparison is an O(2<sup>n</sup>) or an exponential operation, where *n* is the number of characters in the input string.</span></span> <span data-ttu-id="30b93-254">Ciò significa che nei casi peggiori una stringa di input di 30 caratteri richiede circa 1.073.741.824 confronti e una stringa di input di 40 caratteri richiede circa 1.099.511.627.776 confronti.</span><span class="sxs-lookup"><span data-stu-id="30b93-254">This means that in the worst case, an input string of 30 characters requires approximately 1,073,741,824 comparisons, and an input string of 40 characters requires approximately 1,099,511,627,776 comparisons.</span></span> <span data-ttu-id="30b93-255">Se si utilizzano stringhe di queste lunghezze o di lunghezze ancora maggiore, i metodi delle espressioni regolari possono richiedere una quantità di tempo eccessiva per il completamento quando elaborano un input che non corrisponde al modello di espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="30b93-255">If you use strings of these or even greater lengths, regular expression methods can take an extremely long time to complete when they process input that does not match the regular expression pattern.</span></span>

## <a name="controlling-backtracking"></a><span data-ttu-id="30b93-256">Controllo del backtracking</span><span class="sxs-lookup"><span data-stu-id="30b93-256">Controlling Backtracking</span></span>  
 <span data-ttu-id="30b93-257">Il backtracking consente di creare espressioni regolari potenti e flessibili.</span><span class="sxs-lookup"><span data-stu-id="30b93-257">Backtracking lets you create powerful, flexible regular expressions.</span></span> <span data-ttu-id="30b93-258">Tuttavia, come illustrato nella sezione precedente, insieme a questi vantaggi si ottiene una notevole riduzione delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="30b93-258">However, as the previous section showed, these benefits may be coupled with unacceptably poor performance.</span></span> <span data-ttu-id="30b93-259">Per evitare un utilizzo eccessivo del backtracking, è necessario definire un intervallo di timeout quando si crea un'istanza di un oggetto <xref:System.Text.RegularExpressions.Regex> o si chiama un metodo di espressione regolare statica corrispondente.</span><span class="sxs-lookup"><span data-stu-id="30b93-259">To prevent excessive backtracking, you should define a time-out interval when you instantiate a <xref:System.Text.RegularExpressions.Regex> object or call a static regular expression matching method.</span></span> <span data-ttu-id="30b93-260">Questo è discusso nella sezione seguente.</span><span class="sxs-lookup"><span data-stu-id="30b93-260">This is discussed in the next section.</span></span> <span data-ttu-id="30b93-261">.NET supporta inoltre tre elementi del linguaggio di espressioni regolari che limitano o eliminano il backtracking e che supportano espressioni regolari complesse con una riduzione delle prestazioni minima o ridotta: [gruppi atomici](#atomic-groups), [asserzioni lookbehind](#lookbehind-assertions)e [asserzioni lookahead](#lookahead-assertions).</span><span class="sxs-lookup"><span data-stu-id="30b93-261">In addition, .NET supports three regular expression language elements that limit or suppress backtracking and that support complex regular expressions with little or no performance penalty: [atomic groups](#atomic-groups), [lookbehind assertions](#lookbehind-assertions), and [lookahead assertions](#lookahead-assertions).</span></span> <span data-ttu-id="30b93-262">Per altre informazioni su ogni elemento del linguaggio, vedere [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="30b93-262">For more information about each language element, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>  

### <a name="defining-a-time-out-interval"></a><span data-ttu-id="30b93-263">Definizione di un intervallo di timeout</span><span class="sxs-lookup"><span data-stu-id="30b93-263">Defining a Time-out Interval</span></span>  
 <span data-ttu-id="30b93-264">A partire da .NET Framework 4.5, è possibile impostare un valore di timeout che rappresenta l'intervallo più lungo durante il quale il motore delle espressioni regolari cercherà una singola corrispondenza prima di abbandonare il tentativo e generare un'eccezione <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>.</span><span class="sxs-lookup"><span data-stu-id="30b93-264">Starting with the .NET Framework 4.5, you can set a time-out value that represents the longest interval the regular expression engine will search for a single match before it abandons the attempt and throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="30b93-265">Specificare l'intervallo di timeout fornendo un valore <xref:System.TimeSpan> al costruttore <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> per instanziare espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="30b93-265">You specify the time-out interval by supplying a <xref:System.TimeSpan> value to the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor for instance regular expressions.</span></span> <span data-ttu-id="30b93-266">Inoltre, ogni metodo statico di criteri di ricerca ha un overload con un parametro <xref:System.TimeSpan> che consente di specificare un valore di timeout.</span><span class="sxs-lookup"><span data-stu-id="30b93-266">In addition, each static pattern matching method has an overload with a <xref:System.TimeSpan> parameter that allows you to specify a time-out value.</span></span> <span data-ttu-id="30b93-267">Per impostazione predefinita, l'intervallo di timeout viene impostato su <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> e il motore delle espressioni regolari non ha timeout.</span><span class="sxs-lookup"><span data-stu-id="30b93-267">By default, the time-out interval is set to <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> and the regular expression engine does not time out.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="30b93-268">È consigliabile impostare sempre un intervallo di timeout se l'espressione regolare si basa sul backtracking.</span><span class="sxs-lookup"><span data-stu-id="30b93-268">We recommend that you always set a time-out interval if your regular expression relies on backtracking.</span></span>  
  
 <span data-ttu-id="30b93-269">Un'eccezione <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> indica che il motore delle espressioni regolari non è in grado di trovare una corrispondenza nell'intervallo di timeout specificato, ma non indica perché è stata generata l'eccezione.</span><span class="sxs-lookup"><span data-stu-id="30b93-269">A <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception indicates that the regular expression engine was unable to find a match within the specified time-out interval but does not indicate why the exception was thrown.</span></span> <span data-ttu-id="30b93-270">Il motivo può essere l'utilizzo eccessivo del backtracking, ma è anche possibile che l'intervallo di timeout sia stato impostato troppo basso dato il carico di sistema al momento in cui l'eccezione è stata generata.</span><span class="sxs-lookup"><span data-stu-id="30b93-270">The reason might be excessive backtracking, but it is also possible that the time-out interval was set too low given the system load at the time the exception was thrown.</span></span> <span data-ttu-id="30b93-271">Quando si gestisce l'eccezione, è possibile scegliere di ignorare ulteriori corrispondenze con la stringa di input o aumentare l'intervallo di timeout e ritentare l'operazione corrispondente.</span><span class="sxs-lookup"><span data-stu-id="30b93-271">When you handle the exception, you can choose to abandon further matches with the input string or increase the time-out interval and retry the matching operation.</span></span>  
  
 <span data-ttu-id="30b93-272">Ad esempio, il codice seguente chiama il costruttore <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> per creare un'istanza di un oggetto <xref:System.Text.RegularExpressions.Regex> con un valore di timeout di un secondo.</span><span class="sxs-lookup"><span data-stu-id="30b93-272">For example, the following code calls the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor to instantiate a <xref:System.Text.RegularExpressions.Regex> object with a time-out value of one second.</span></span> <span data-ttu-id="30b93-273">Il modello di espressione regolare `(a+)+$`, che corrisponde a uno o più sequenze di uno o più caratteri "a" alla fine di una riga, è soggetto all'utilizzo eccessivo del backtracking.</span><span class="sxs-lookup"><span data-stu-id="30b93-273">The regular expression pattern `(a+)+$`, which matches one or more sequences of one or more "a" characters at the end of a line, is subject to excessive backtracking.</span></span> <span data-ttu-id="30b93-274">Se <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> viene generato, l'esempio aumenta il valore di timeout fino a un intervallo massimo di tre secondi.</span><span class="sxs-lookup"><span data-stu-id="30b93-274">If a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> is thrown, the example increases the time-out value up to a maximum interval of three seconds.</span></span> <span data-ttu-id="30b93-275">Successivamente, ignora il tentativo di corrispondere al modello.</span><span class="sxs-lookup"><span data-stu-id="30b93-275">After that, it abandons the attempt to match the pattern.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  

### <a name="atomic-groups"></a><span data-ttu-id="30b93-276">Gruppi atomici</span><span class="sxs-lookup"><span data-stu-id="30b93-276">Atomic groups</span></span>
 <span data-ttu-id="30b93-277">L' `(?>` elemento del linguaggio *sottoespressione* `)` Elimina il backtracking nella sottoespressione.</span><span class="sxs-lookup"><span data-stu-id="30b93-277">The `(?>` *subexpression*`)` language element suppresses backtracking into the subexpression.</span></span> <span data-ttu-id="30b93-278">Una volta completata la corrispondenza, non verrà restituita alcuna parte della relativa corrispondenza al backtracking successivo.</span><span class="sxs-lookup"><span data-stu-id="30b93-278">Once it has successfully matched, it will not give up any part of its match to subsequent backtracking.</span></span> <span data-ttu-id="30b93-279">Ad esempio, nel modello `(?>\w*\d*)1` , se non è `1` possibile trovare una corrispondenza per, `\d*` non verrà restituita alcuna corrispondenza anche se ciò significa che la corrispondenza potrebbe essere `1` corretta.</span><span class="sxs-lookup"><span data-stu-id="30b93-279">For example, in the pattern `(?>\w*\d*)1`, if the `1` cannot be matched, the `\d*` will not give up any of its match even if that means it would allow the `1` to successfully match.</span></span> <span data-ttu-id="30b93-280">I gruppi atomici possono aiutare a evitare i problemi di prestazioni associati alle corrispondenze non riuscite.</span><span class="sxs-lookup"><span data-stu-id="30b93-280">Atomic groups can help prevent the performance problems associated with failed matches.</span></span>
  
 <span data-ttu-id="30b93-281">Nell'esempio seguente vengono illustrati i miglioramenti nelle prestazioni con i quantificatori annidati quando non si utilizza il backtracking.</span><span class="sxs-lookup"><span data-stu-id="30b93-281">The following example illustrates how suppressing backtracking improves performance when using nested quantifiers.</span></span> <span data-ttu-id="30b93-282">Viene calcolato il tempo impiegato dal motore delle espressioni regolari per determinare che una stringa di input non corrisponde a due espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="30b93-282">It measures the time required for the regular expression engine to determine that an input string does not match two regular expressions.</span></span> <span data-ttu-id="30b93-283">La prima espressione regolare utilizza il backtracking per tentare di trovare una corrispondenza con una stringa contenente una o più occorrenze di una o più cifre esadecimali seguite da due punti, seguiti da una o più cifre esadecimali, seguite da un doppio due punti.</span><span class="sxs-lookup"><span data-stu-id="30b93-283">The first regular expression uses backtracking to attempt to match a string that contains one or more occurrences of one or more hexadecimal digits, followed by a colon, followed by one or more hexadecimal digits, followed by two colons.</span></span> <span data-ttu-id="30b93-284">La seconda espressione regolare è identica alla prima, con la differenza che il backtracking è disabilitato.</span><span class="sxs-lookup"><span data-stu-id="30b93-284">The second regular expression is identical to the first, except that it disables backtracking.</span></span> <span data-ttu-id="30b93-285">Come illustrato nell'output dell'esempio, il miglioramento delle prestazioni derivante dalla disabilitazione del backtracking è significativo.</span><span class="sxs-lookup"><span data-stu-id="30b93-285">As the output from the example shows, the performance improvement from disabling backtracking is significant.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking4.cs#4)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking4.vb#4)]  

### <a name="lookbehind-assertions"></a><span data-ttu-id="30b93-286">asserzioni lookbehind</span><span class="sxs-lookup"><span data-stu-id="30b93-286">Lookbehind Assertions</span></span>  
 <span data-ttu-id="30b93-287">.NET include due elementi del linguaggio, `(?<=` *sottoespressione* `)` e `(?<!` *sottoespressione* `)` , che corrispondono al carattere o ai caratteri precedenti nella stringa di input.</span><span class="sxs-lookup"><span data-stu-id="30b93-287">.NET includes two language elements, `(?<=`*subexpression*`)` and `(?<!`*subexpression*`)`, that match the previous character or characters in the input string.</span></span> <span data-ttu-id="30b93-288">Entrambi gli elementi di linguaggio sono asserzioni di larghezza zero, ovvero determinano se il carattere o i caratteri che precedono immediatamente il carattere corrente possono essere trovati da una *sottoespressione*, senza avanzamento o backtracking.</span><span class="sxs-lookup"><span data-stu-id="30b93-288">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately precede the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="30b93-289">`(?<=`*sottoespressione* `)` è un'asserzione lookbehind positiva; ovvero il carattere o i caratteri prima della posizione corrente devono corrispondere alla *sottoespressione*.</span><span class="sxs-lookup"><span data-stu-id="30b93-289">`(?<=` *subexpression* `)` is a positive lookbehind assertion; that is, the character or characters before the current position must match *subexpression*.</span></span> <span data-ttu-id="30b93-290">`(?<!`*sottoespressione* `)` è un'asserzione lookbehind negativa. ovvero il carattere o i caratteri prima della posizione corrente non devono corrispondere alla *sottoespressione*.</span><span class="sxs-lookup"><span data-stu-id="30b93-290">`(?<!`*subexpression*`)` is a negative lookbehind assertion; that is, the character or characters before the current position must not match *subexpression*.</span></span> <span data-ttu-id="30b93-291">Le asserzioni lookbehind positive e negative sono entrambe particolarmente utili quando *sottoespressione* è un subset della sottoespressione precedente.</span><span class="sxs-lookup"><span data-stu-id="30b93-291">Both positive and negative lookbehind assertions are most useful when *subexpression* is a subset of the previous subexpression.</span></span>  
  
 <span data-ttu-id="30b93-292">L'esempio seguente usa due modelli di espressione regolare equivalenti che convalidano il nome utente in un indirizzo di posta elettronica.</span><span class="sxs-lookup"><span data-stu-id="30b93-292">The following example uses two equivalent regular expression patterns that validate the user name in an email address.</span></span> <span data-ttu-id="30b93-293">Il primo modello è soggetto a una riduzione delle prestazioni a causa di un utilizzo eccessivo del backtracking.</span><span class="sxs-lookup"><span data-stu-id="30b93-293">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="30b93-294">Il secondo modello modifica la prima espressione regolare sostituendo un quantificatore annidato con un'asserzione lookbehind positiva.</span><span class="sxs-lookup"><span data-stu-id="30b93-294">The second pattern modifies the first regular expression by replacing a nested quantifier with a positive lookbehind assertion.</span></span> <span data-ttu-id="30b93-295">Nell'output dell'esempio viene visualizzato il tempo di esecuzione del metodo <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="30b93-295">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking5.cs#5)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking5.vb#5)]  
  
 <span data-ttu-id="30b93-296">Il primo criterio di espressione regolare, `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`, è definito nel modo illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="30b93-296">The first regular expression pattern, `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="30b93-297">Modello</span><span class="sxs-lookup"><span data-stu-id="30b93-297">Pattern</span></span>|<span data-ttu-id="30b93-298">Descrizione</span><span class="sxs-lookup"><span data-stu-id="30b93-298">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="30b93-299">Inizia la ricerca della corrispondenza all'inizio della stringa.</span><span class="sxs-lookup"><span data-stu-id="30b93-299">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="30b93-300">Trova la corrispondenza di un carattere alfanumerico.</span><span class="sxs-lookup"><span data-stu-id="30b93-300">Match an alphanumeric character.</span></span> <span data-ttu-id="30b93-301">Poiché il metodo <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> viene richiamato con l'opzione <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> , il confronto non rileva la distinzione tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="30b93-301">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="30b93-302">Trova la corrispondenza di zero, una o più occorrenze di un trattino, un punto o un carattere alfanumerico.</span><span class="sxs-lookup"><span data-stu-id="30b93-302">Match zero, one, or more occurrences of a hyphen, period, or word character.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="30b93-303">Trova la corrispondenza di un carattere alfanumerico.</span><span class="sxs-lookup"><span data-stu-id="30b93-303">Match an alphanumeric character.</span></span>|  
|`([-.\w]*[0-9A-Z])*`|<span data-ttu-id="30b93-304">Trova la corrispondenza di zero o più occorrenze della combinazione di zero o più trattini, punti o caratteri alfanumerici seguiti da un carattere alfanumerico.</span><span class="sxs-lookup"><span data-stu-id="30b93-304">Match zero or more occurrences of the combination of zero or more hyphens, periods, or word characters, followed by an alphanumeric character.</span></span> <span data-ttu-id="30b93-305">Equivale al primo gruppo di acquisizione.</span><span class="sxs-lookup"><span data-stu-id="30b93-305">This is the first capturing group.</span></span>|  
|`@`|<span data-ttu-id="30b93-306">Trova la corrispondenza di una chiocciola ("\@").</span><span class="sxs-lookup"><span data-stu-id="30b93-306">Match an at sign ("\@").</span></span>|  
  
 <span data-ttu-id="30b93-307">Il secondo criterio di espressione regolare, `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`, usa un'asserzione lookbehind positiva</span><span class="sxs-lookup"><span data-stu-id="30b93-307">The second regular expression pattern, `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`, uses a positive lookbehind assertion.</span></span> <span data-ttu-id="30b93-308">e viene definito come illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="30b93-308">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="30b93-309">Modello</span><span class="sxs-lookup"><span data-stu-id="30b93-309">Pattern</span></span>|<span data-ttu-id="30b93-310">Descrizione</span><span class="sxs-lookup"><span data-stu-id="30b93-310">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="30b93-311">Inizia la ricerca della corrispondenza all'inizio della stringa.</span><span class="sxs-lookup"><span data-stu-id="30b93-311">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="30b93-312">Trova la corrispondenza di un carattere alfanumerico.</span><span class="sxs-lookup"><span data-stu-id="30b93-312">Match an alphanumeric character.</span></span> <span data-ttu-id="30b93-313">Poiché il metodo <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> viene richiamato con l'opzione <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> , il confronto non rileva la distinzione tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="30b93-313">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="30b93-314">Trova la corrispondenza di zero o più occorrenze di un trattino, un punto o un carattere alfanumerico.</span><span class="sxs-lookup"><span data-stu-id="30b93-314">Match zero or more occurrences of a hyphen, period, or word character.</span></span>|  
|`(?<=[0-9A-Z])`|<span data-ttu-id="30b93-315">Esegue la ricerca dell'ultimo carattere corrispondente e continua la ricerca della corrispondenza se si tratta di un carattere alfanumerico.</span><span class="sxs-lookup"><span data-stu-id="30b93-315">Look back at the last matched character and continue the match if it is alphanumeric.</span></span> <span data-ttu-id="30b93-316">Si noti che i caratteri alfanumerici sono un subset del set costituito da punti, trattini e tutti i caratteri alfanumerici.</span><span class="sxs-lookup"><span data-stu-id="30b93-316">Note that alphanumeric characters are a subset of the set that consists of periods, hyphens, and all word characters.</span></span>|  
|`@`|<span data-ttu-id="30b93-317">Trova la corrispondenza di una chiocciola ("\@").</span><span class="sxs-lookup"><span data-stu-id="30b93-317">Match an at sign ("\@").</span></span>|  

### <a name="lookahead-assertions"></a><span data-ttu-id="30b93-318">asserzioni lookahead</span><span class="sxs-lookup"><span data-stu-id="30b93-318">Lookahead Assertions</span></span>  
 <span data-ttu-id="30b93-319">.NET include due elementi del linguaggio, `(?=` *sottoespressione* `)` e `(?!` *sottoespressione* `)` , che corrispondono al carattere o ai caratteri successivi nella stringa di input.</span><span class="sxs-lookup"><span data-stu-id="30b93-319">.NET includes two language elements, `(?=`*subexpression*`)` and `(?!`*subexpression*`)`, that match the next character or characters in the input string.</span></span> <span data-ttu-id="30b93-320">Entrambi gli elementi di linguaggio sono asserzioni di larghezza zero, ovvero determinano se il carattere o i caratteri che seguono immediatamente il carattere corrente possono essere trovati dalla *sottoespressione*, senza avanzamento o backtracking.</span><span class="sxs-lookup"><span data-stu-id="30b93-320">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately follow the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="30b93-321">`(?=`*sottoespressione* `)` è un'asserzione lookahead positiva; ovvero il carattere o i caratteri successivi alla posizione corrente devono corrispondere alla *sottoespressione*.</span><span class="sxs-lookup"><span data-stu-id="30b93-321">`(?=` *subexpression* `)` is a positive lookahead assertion; that is, the character or characters after the current position must match *subexpression*.</span></span> <span data-ttu-id="30b93-322">`(?!`*sottoespressione* `)` è un'asserzione lookahead negativa. ovvero il carattere o i caratteri successivi alla posizione corrente non devono corrispondere alla *sottoespressione*.</span><span class="sxs-lookup"><span data-stu-id="30b93-322">`(?!`*subexpression*`)` is a negative lookahead assertion; that is, the character or characters after the current position must not match *subexpression*.</span></span> <span data-ttu-id="30b93-323">Le asserzioni lookahead positive e negative sono entrambe particolarmente utili quando *sottoespressione* è un subset della sottoespressione successiva.</span><span class="sxs-lookup"><span data-stu-id="30b93-323">Both positive and negative lookahead assertions are most useful when *subexpression* is a subset of the next subexpression.</span></span>  
  
 <span data-ttu-id="30b93-324">Nell'esempio seguente vengono utilizzati due modelli di espressione regolare equivalenti per verificare un nome di tipo completo.</span><span class="sxs-lookup"><span data-stu-id="30b93-324">The following example uses two equivalent regular expression patterns that validate a fully qualified type name.</span></span> <span data-ttu-id="30b93-325">Il primo modello è soggetto a una riduzione delle prestazioni a causa di un utilizzo eccessivo del backtracking.</span><span class="sxs-lookup"><span data-stu-id="30b93-325">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="30b93-326">Il secondo modello modifica la prima espressione regolare sostituendo un quantificatore annidato con un'asserzione lookahead positiva.</span><span class="sxs-lookup"><span data-stu-id="30b93-326">The second modifies the first regular expression by replacing a nested quantifier with a positive lookahead assertion.</span></span> <span data-ttu-id="30b93-327">Nell'output dell'esempio viene visualizzato il tempo di esecuzione del metodo <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="30b93-327">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking6.cs#6)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking6.vb#6)]  
  
 <span data-ttu-id="30b93-328">Il primo criterio di espressione regolare, `^(([A-Z]\w*)+\.)*[A-Z]\w*$`, è definito nel modo illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="30b93-328">The first regular expression pattern, `^(([A-Z]\w*)+\.)*[A-Z]\w*$`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="30b93-329">Modello</span><span class="sxs-lookup"><span data-stu-id="30b93-329">Pattern</span></span>|<span data-ttu-id="30b93-330">Descrizione</span><span class="sxs-lookup"><span data-stu-id="30b93-330">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="30b93-331">Inizia la ricerca della corrispondenza all'inizio della stringa.</span><span class="sxs-lookup"><span data-stu-id="30b93-331">Start the match at the beginning of the string.</span></span>|  
|`([A-Z]\w*)+\.`|<span data-ttu-id="30b93-332">Trova la corrispondenza di un carattere alfabetico (A-Z) seguito da zero o più caratteri alfanumerici una o più volte seguiti da un punto.</span><span class="sxs-lookup"><span data-stu-id="30b93-332">Match an alphabetical character (A-Z) followed by zero or more word characters one or more times, followed by a period.</span></span> <span data-ttu-id="30b93-333">Poiché il metodo <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> viene richiamato con l'opzione <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> , il confronto non rileva la distinzione tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="30b93-333">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`(([A-Z]\w*)+\.)*`|<span data-ttu-id="30b93-334">Trova la corrispondenza del modello precedente zero o più volte.</span><span class="sxs-lookup"><span data-stu-id="30b93-334">Match the previous pattern zero or more times.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="30b93-335">Trova la corrispondenza di un carattere alfabetico seguito da zero o più caratteri alfanumerici.</span><span class="sxs-lookup"><span data-stu-id="30b93-335">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="30b93-336">Termina la ricerca della corrispondenza alla fine della stringa di input.</span><span class="sxs-lookup"><span data-stu-id="30b93-336">End the match at the end of the input string.</span></span>|  
  
 <span data-ttu-id="30b93-337">Il secondo criterio di espressione regolare, `^((?=[A-Z])\w+\.)*[A-Z]\w*$`, usa un'asserzione lookahead positiva</span><span class="sxs-lookup"><span data-stu-id="30b93-337">The second regular expression pattern, `^((?=[A-Z])\w+\.)*[A-Z]\w*$`, uses a positive lookahead assertion.</span></span> <span data-ttu-id="30b93-338">e viene definito come illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="30b93-338">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="30b93-339">Modello</span><span class="sxs-lookup"><span data-stu-id="30b93-339">Pattern</span></span>|<span data-ttu-id="30b93-340">Descrizione</span><span class="sxs-lookup"><span data-stu-id="30b93-340">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="30b93-341">Inizia la ricerca della corrispondenza all'inizio della stringa.</span><span class="sxs-lookup"><span data-stu-id="30b93-341">Start the match at the beginning of the string.</span></span>|  
|`(?=[A-Z])`|<span data-ttu-id="30b93-342">Esegue la ricerca fino primo carattere e continua la ricerca della corrispondenza se si tratta di un carattere alfabetico (A-Z).</span><span class="sxs-lookup"><span data-stu-id="30b93-342">Look ahead to the first character and continue the match if it is alphabetical (A-Z).</span></span> <span data-ttu-id="30b93-343">Poiché il metodo <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> viene richiamato con l'opzione <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> , il confronto non rileva la distinzione tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="30b93-343">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`\w+\.`|<span data-ttu-id="30b93-344">Trova la corrispondenza di uno o più caratteri alfanumerici seguiti da un punto.</span><span class="sxs-lookup"><span data-stu-id="30b93-344">Match one or more word characters followed by a period.</span></span>|  
|`((?=[A-Z])\w+\.)*`|<span data-ttu-id="30b93-345">Trova la corrispondenza del modello di uno o più caratteri alfanumerici seguiti da un punto zero o più volte.</span><span class="sxs-lookup"><span data-stu-id="30b93-345">Match the pattern of one or more word characters followed by a period zero or more times.</span></span> <span data-ttu-id="30b93-346">Il carattere alfanumerico iniziale deve essere alfabetico.</span><span class="sxs-lookup"><span data-stu-id="30b93-346">The initial word character must be alphabetical.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="30b93-347">Trova la corrispondenza di un carattere alfabetico seguito da zero o più caratteri alfanumerici.</span><span class="sxs-lookup"><span data-stu-id="30b93-347">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="30b93-348">Termina la ricerca della corrispondenza alla fine della stringa di input.</span><span class="sxs-lookup"><span data-stu-id="30b93-348">End the match at the end of the input string.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="30b93-349">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="30b93-349">See also</span></span>

- [<span data-ttu-id="30b93-350">Espressioni regolari .NET</span><span class="sxs-lookup"><span data-stu-id="30b93-350">.NET Regular Expressions</span></span>](regular-expressions.md)
- [<span data-ttu-id="30b93-351">Linguaggio di espressioni regolari - Riferimento rapido</span><span class="sxs-lookup"><span data-stu-id="30b93-351">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)
- [<span data-ttu-id="30b93-352">Quantificatori</span><span class="sxs-lookup"><span data-stu-id="30b93-352">Quantifiers</span></span>](quantifiers-in-regular-expressions.md)
- [<span data-ttu-id="30b93-353">Costrutti di alternanza</span><span class="sxs-lookup"><span data-stu-id="30b93-353">Alternation Constructs</span></span>](alternation-constructs-in-regular-expressions.md)
- [<span data-ttu-id="30b93-354">Costrutti di raggruppamento</span><span class="sxs-lookup"><span data-stu-id="30b93-354">Grouping Constructs</span></span>](grouping-constructs-in-regular-expressions.md)
