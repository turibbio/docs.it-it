---
title: quantificatori in espressioni regolari
description: Informazioni sui quantificatori di espressioni regolari, che specificano il numero di istanze di un carattere, un gruppo o una classe di caratteri che deve essere presente nell'input per la corrispondenza.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, quantifiers
- metacharacters, quantifiers
- minimal matching quantifiers
- quantifiers in regular expressions
- .NET Framework regular expressions, quantifiers
- quantifiers
- lazy quantifiers
ms.assetid: 36b81212-6511-49ed-a8f1-ff080415312f
ms.openlocfilehash: 2fc47a834f8f5b18021aa4f321345b8d7e4e8459
ms.sourcegitcommit: 7137e12f54c4e83a94ae43ec320f8cf59c1772ea
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/10/2020
ms.locfileid: "84662888"
---
# <a name="quantifiers-in-regular-expressions"></a><span data-ttu-id="d51ea-103">quantificatori in espressioni regolari</span><span class="sxs-lookup"><span data-stu-id="d51ea-103">Quantifiers in Regular Expressions</span></span>
<span data-ttu-id="d51ea-104">I quantificatori specificano il numero di istanze di un carattere, un gruppo o una classe di caratteri che deve essere presente nell'input affinché venga trovata una corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="d51ea-104">Quantifiers specify how many instances of a character, group, or character class must be present in the input for a match to be found.</span></span>  <span data-ttu-id="d51ea-105">Nella tabella seguente vengono elencati i quantificatori supportati da .NET.</span><span class="sxs-lookup"><span data-stu-id="d51ea-105">The following table lists the quantifiers supported by .NET.</span></span>  
  
|<span data-ttu-id="d51ea-106">Quantificatore greedy</span><span class="sxs-lookup"><span data-stu-id="d51ea-106">Greedy quantifier</span></span>|<span data-ttu-id="d51ea-107">Quantificatore lazy</span><span class="sxs-lookup"><span data-stu-id="d51ea-107">Lazy quantifier</span></span>|<span data-ttu-id="d51ea-108">Descrizione</span><span class="sxs-lookup"><span data-stu-id="d51ea-108">Description</span></span>|  
|-----------------------|---------------------|-----------------|  
|`*`|`*?`|<span data-ttu-id="d51ea-109">Trova la corrispondenza zero o più volte.</span><span class="sxs-lookup"><span data-stu-id="d51ea-109">Match zero or more times.</span></span>|  
|`+`|`+?`|<span data-ttu-id="d51ea-110">Trova la corrispondenza una o più volte.</span><span class="sxs-lookup"><span data-stu-id="d51ea-110">Match one or more times.</span></span>|  
|`?`|`??`|<span data-ttu-id="d51ea-111">Trova la corrispondenza zero o una volta.</span><span class="sxs-lookup"><span data-stu-id="d51ea-111">Match zero or one time.</span></span>|  
|<span data-ttu-id="d51ea-112">`{`*n*`}`</span><span class="sxs-lookup"><span data-stu-id="d51ea-112">`{` *n* `}`</span></span>|<span data-ttu-id="d51ea-113">`{`*n*`}?`</span><span class="sxs-lookup"><span data-stu-id="d51ea-113">`{` *n* `}?`</span></span>|<span data-ttu-id="d51ea-114">Trova la corrispondenza esatta *n* volte.</span><span class="sxs-lookup"><span data-stu-id="d51ea-114">Match exactly *n* times.</span></span>|  
|<span data-ttu-id="d51ea-115">`{`*n*`,}`</span><span class="sxs-lookup"><span data-stu-id="d51ea-115">`{` *n* `,}`</span></span>|<span data-ttu-id="d51ea-116">`{`*n*`,}?`</span><span class="sxs-lookup"><span data-stu-id="d51ea-116">`{` *n* `,}?`</span></span>|<span data-ttu-id="d51ea-117">Trova la corrispondenza almeno *n* volte.</span><span class="sxs-lookup"><span data-stu-id="d51ea-117">Match at least *n* times.</span></span>|  
|<span data-ttu-id="d51ea-118">`{`*n* `,` *m*`}`</span><span class="sxs-lookup"><span data-stu-id="d51ea-118">`{` *n* `,` *m* `}`</span></span>|<span data-ttu-id="d51ea-119">`{`*n* `,` *m*`}?`</span><span class="sxs-lookup"><span data-stu-id="d51ea-119">`{` *n* `,` *m* `}?`</span></span>|<span data-ttu-id="d51ea-120">Trova la corrispondenza da *n* a *m* volte.</span><span class="sxs-lookup"><span data-stu-id="d51ea-120">Match from *n* to *m* times.</span></span>|  
  
 <span data-ttu-id="d51ea-121">Le quantità `n` e `m` sono costanti integer.</span><span class="sxs-lookup"><span data-stu-id="d51ea-121">The quantities `n` and `m` are integer constants.</span></span> <span data-ttu-id="d51ea-122">In genere, i quantificatori sono greedy: il motore delle espressioni regolari trova la corrispondenza con il maggior numero possibile di determinati criteri.</span><span class="sxs-lookup"><span data-stu-id="d51ea-122">Ordinarily, quantifiers are greedy; they cause the regular expression engine to match as many occurrences of particular patterns as possible.</span></span> <span data-ttu-id="d51ea-123">L'aggiunta del carattere `?` rende un quantificatore lazy: il motore delle espressioni regolari trova la corrispondenza con il minor numero possibile di occorrenze.</span><span class="sxs-lookup"><span data-stu-id="d51ea-123">Appending the `?` character to a quantifier makes it lazy; it causes the regular expression engine to match as few occurrences as possible.</span></span> <span data-ttu-id="d51ea-124">Per una descrizione completa della differenza tra quantificatori greedy e lazy, vedere la sezione [Quantificatori greedy e lazy](#Greedy) più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="d51ea-124">For a complete description of the difference between greedy and lazy quantifiers, see the section [Greedy and Lazy Quantifiers](#Greedy) later in this topic.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="d51ea-125">Annidare i quantificatori, come nel caso del criterio di espressione regolare `(a*)*`, può aumentare il numero dei confronti che deve eseguire il motore delle espressioni regolari, come una funzione esponenziale del numero di caratteri nella stringa di input.</span><span class="sxs-lookup"><span data-stu-id="d51ea-125">Nesting quantifiers (for example, as the regular expression pattern `(a*)*` does) can increase the number of comparisons that the regular expression engine must perform, as an exponential function of the number of characters in the input string.</span></span> <span data-ttu-id="d51ea-126">Per altre informazioni su questo comportamento e sulle relative soluzioni alternative, vedere [Backtracking](backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="d51ea-126">For more information about this behavior and its workarounds, see [Backtracking](backtracking-in-regular-expressions.md).</span></span>  
  
## <a name="regular-expression-quantifiers"></a><span data-ttu-id="d51ea-127">Quantificatori delle espressioni regolari</span><span class="sxs-lookup"><span data-stu-id="d51ea-127">Regular Expression Quantifiers</span></span>  
 <span data-ttu-id="d51ea-128">Nelle sezioni seguenti sono riportati i quantificatori supportati dalle espressioni regolari in .NET.</span><span class="sxs-lookup"><span data-stu-id="d51ea-128">The following sections list the quantifiers supported by .NET regular expressions.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="d51ea-129">Se vengono rilevati i caratteri \*, +,?, { e} in un criterio di espressione regolare, il motore delle espressioni regolari li interpreta come quantificatori o parte di costrutti di quantificatori a meno che non siano inclusi in una [classe di caratteri](character-classes-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="d51ea-129">If the \*, +, ?, {, and } characters are encountered in a regular expression pattern, the regular expression engine interprets them as quantifiers or part of quantifier constructs unless they are included in a [character class](character-classes-in-regular-expressions.md).</span></span> <span data-ttu-id="d51ea-130">Per interpretarli come caratteri letterali all'esterno di una classe di caratteri, è necessaria una sequenza di escape con i caratteri preceduti da una barra rovesciata.</span><span class="sxs-lookup"><span data-stu-id="d51ea-130">To interpret these as literal characters outside a character class, you must escape them by preceding them with a backslash.</span></span> <span data-ttu-id="d51ea-131">Ad esempio, la stringa `\*` in un'espressione regolare viene interpretata come carattere letterale asterisco ("\*").</span><span class="sxs-lookup"><span data-stu-id="d51ea-131">For example, the string `\*` in a regular expression pattern is interpreted as a literal asterisk ("\*") character.</span></span>  
  
### <a name="match-zero-or-more-times-"></a><span data-ttu-id="d51ea-132">Trova la corrispondenza zero o più volte: \*</span><span class="sxs-lookup"><span data-stu-id="d51ea-132">Match Zero or More Times: \*</span></span>  
 <span data-ttu-id="d51ea-133">Il quantificatore `*` trova la corrispondenza con l'elemento precedente zero o più volte.</span><span class="sxs-lookup"><span data-stu-id="d51ea-133">The `*` quantifier matches the preceding element zero or more times.</span></span> <span data-ttu-id="d51ea-134">È equivalente al quantificatore `{0,}`.</span><span class="sxs-lookup"><span data-stu-id="d51ea-134">It is equivalent to the `{0,}` quantifier.</span></span> <span data-ttu-id="d51ea-135">`*` è un quantificatore greedy il cui equivalente lazy è `*?`.</span><span class="sxs-lookup"><span data-stu-id="d51ea-135">`*` is a greedy quantifier whose lazy equivalent is `*?`.</span></span>  
  
 <span data-ttu-id="d51ea-136">L'esempio seguente illustra questa espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="d51ea-136">The following example illustrates this regular expression.</span></span> <span data-ttu-id="d51ea-137">Delle nove cifre nella stringa di input, cinque corrispondono al criterio e quattro (`95`, `929`, `9219` e `9919`) no.</span><span class="sxs-lookup"><span data-stu-id="d51ea-137">Of the nine digits in the input string, five match the pattern and four (`95`, `929`, `9219`, and `9919`) do not.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#1)]  
  
 <span data-ttu-id="d51ea-138">Il criterio di ricerca di espressioni regolari è definito nel modo illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="d51ea-138">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d51ea-139">Modello</span><span class="sxs-lookup"><span data-stu-id="d51ea-139">Pattern</span></span>|<span data-ttu-id="d51ea-140">Descrizione</span><span class="sxs-lookup"><span data-stu-id="d51ea-140">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d51ea-141">Inizia dal confine di una parola.</span><span class="sxs-lookup"><span data-stu-id="d51ea-141">Start at a word boundary.</span></span>|  
|`91*`|<span data-ttu-id="d51ea-142">Trova un "9" seguito da zero o più caratteri "1".</span><span class="sxs-lookup"><span data-stu-id="d51ea-142">Match a "9" followed by zero or more "1" characters.</span></span>|  
|`9*`|<span data-ttu-id="d51ea-143">Trova la corrispondenza con zero o più caratteri "9".</span><span class="sxs-lookup"><span data-stu-id="d51ea-143">Match zero or more "9" characters.</span></span>|  
|`\b`|<span data-ttu-id="d51ea-144">Terminare al confine di una parola.</span><span class="sxs-lookup"><span data-stu-id="d51ea-144">End at a word boundary.</span></span>|  
  
### <a name="match-one-or-more-times-"></a><span data-ttu-id="d51ea-145">Trova la corrispondenza una o più volte: +</span><span class="sxs-lookup"><span data-stu-id="d51ea-145">Match One or More Times: +</span></span>  
 <span data-ttu-id="d51ea-146">Il quantificatore `+` trova la corrispondenza con l'elemento precedente una o più volte.</span><span class="sxs-lookup"><span data-stu-id="d51ea-146">The `+` quantifier matches the preceding element one or more times.</span></span> <span data-ttu-id="d51ea-147">Equivale a `{1,}`.</span><span class="sxs-lookup"><span data-stu-id="d51ea-147">It is equivalent to `{1,}`.</span></span> <span data-ttu-id="d51ea-148">`+` è un quantificatore greedy il cui equivalente lazy è `+?`.</span><span class="sxs-lookup"><span data-stu-id="d51ea-148">`+` is a greedy quantifier whose lazy equivalent is `+?`.</span></span>  
  
 <span data-ttu-id="d51ea-149">Ad esempio, l'espressione regolare `\ban+\w*?\b` tenta di trovare la corrispondenza con intere parole che iniziano con la lettera `a` seguita da una o più istanze della lettera `n`.</span><span class="sxs-lookup"><span data-stu-id="d51ea-149">For example, the regular expression `\ban+\w*?\b` tries to match entire words that begin with the letter `a` followed by one or more instances of the letter `n`.</span></span> <span data-ttu-id="d51ea-150">L'esempio seguente illustra questa espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="d51ea-150">The following example illustrates this regular expression.</span></span> <span data-ttu-id="d51ea-151">L'espressione regolare trova le parole `an`, `annual`, `announcement`, `antique` e, correttamente, non riesce a trovare `autumn` e `all`.</span><span class="sxs-lookup"><span data-stu-id="d51ea-151">The regular expression matches the words `an`, `annual`, `announcement`, and `antique`, and correctly fails to match `autumn` and `all`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#2)]  
  
 <span data-ttu-id="d51ea-152">Il criterio di ricerca di espressioni regolari è definito nel modo illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="d51ea-152">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d51ea-153">Modello</span><span class="sxs-lookup"><span data-stu-id="d51ea-153">Pattern</span></span>|<span data-ttu-id="d51ea-154">Descrizione</span><span class="sxs-lookup"><span data-stu-id="d51ea-154">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d51ea-155">Inizia dal confine di una parola.</span><span class="sxs-lookup"><span data-stu-id="d51ea-155">Start at a word boundary.</span></span>|  
|`an+`|<span data-ttu-id="d51ea-156">Trova una "a" seguita da uno o più caratteri "n".</span><span class="sxs-lookup"><span data-stu-id="d51ea-156">Match an "a" followed by one or more "n" characters.</span></span>|  
|`\w*?`|<span data-ttu-id="d51ea-157">Trova la corrispondenza con un carattere alfanumerico o più volte, ma il minor numero di volte possibile.</span><span class="sxs-lookup"><span data-stu-id="d51ea-157">Match a word character zero or more times, but as few times as possible.</span></span>|  
|`\b`|<span data-ttu-id="d51ea-158">Terminare al confine di una parola.</span><span class="sxs-lookup"><span data-stu-id="d51ea-158">End at a word boundary.</span></span>|  
  
### <a name="match-zero-or-one-time-"></a><span data-ttu-id="d51ea-159">Trova la corrispondenza zero o una volta: ?</span><span class="sxs-lookup"><span data-stu-id="d51ea-159">Match Zero or One Time: ?</span></span>  
 <span data-ttu-id="d51ea-160">`?` trova la corrispondenza con l'elemento precedente zero o una volta.</span><span class="sxs-lookup"><span data-stu-id="d51ea-160">The `?` quantifier matches the preceding element zero or one time.</span></span> <span data-ttu-id="d51ea-161">Equivale a `{0,1}`.</span><span class="sxs-lookup"><span data-stu-id="d51ea-161">It is equivalent to `{0,1}`.</span></span> <span data-ttu-id="d51ea-162">`?` è un quantificatore greedy il cui equivalente lazy è `??`.</span><span class="sxs-lookup"><span data-stu-id="d51ea-162">`?` is a greedy quantifier whose lazy equivalent is `??`.</span></span>  
  
 <span data-ttu-id="d51ea-163">Ad esempio, l'espressione regolare `\ban?\b` tenta di trovare la corrispondenza con intere parole che iniziano con la lettera `a` seguita da zero o una istanza della lettera `n`.</span><span class="sxs-lookup"><span data-stu-id="d51ea-163">For example, the regular expression `\ban?\b` tries to match entire words that begin with the letter `a` followed by zero or one instances of the letter `n`.</span></span> <span data-ttu-id="d51ea-164">In altre parole, tenta di trovare la corrispondenza con le parole `a` e `an`.</span><span class="sxs-lookup"><span data-stu-id="d51ea-164">In other words, it tries to match the words `a` and `an`.</span></span> <span data-ttu-id="d51ea-165">L'esempio seguente illustra questa espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="d51ea-165">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#3](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#3)]
 [!code-vb[RegularExpressions.Quantifiers#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#3)]  
  
 <span data-ttu-id="d51ea-166">Il criterio di ricerca di espressioni regolari è definito nel modo illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="d51ea-166">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d51ea-167">Modello</span><span class="sxs-lookup"><span data-stu-id="d51ea-167">Pattern</span></span>|<span data-ttu-id="d51ea-168">Descrizione</span><span class="sxs-lookup"><span data-stu-id="d51ea-168">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d51ea-169">Inizia dal confine di una parola.</span><span class="sxs-lookup"><span data-stu-id="d51ea-169">Start at a word boundary.</span></span>|  
|`an?`|<span data-ttu-id="d51ea-170">Trova una "a" seguita da zero o un carattere "n".</span><span class="sxs-lookup"><span data-stu-id="d51ea-170">Match an "a" followed by zero or one "n" character.</span></span>|  
|`\b`|<span data-ttu-id="d51ea-171">Terminare al confine di una parola.</span><span class="sxs-lookup"><span data-stu-id="d51ea-171">End at a word boundary.</span></span>|  
  
### <a name="match-exactly-n-times-n"></a><span data-ttu-id="d51ea-172">Trova la corrispondenza esatta n volte: {n}</span><span class="sxs-lookup"><span data-stu-id="d51ea-172">Match Exactly n Times: {n}</span></span>  
 <span data-ttu-id="d51ea-173">Il `{` *n* `}` quantificatore n trova la corrispondenza con l'elemento precedente esattamente *n* volte, dove *n* è qualsiasi numero intero.</span><span class="sxs-lookup"><span data-stu-id="d51ea-173">The `{`*n*`}` quantifier matches the preceding element exactly *n* times, where *n* is any integer.</span></span> <span data-ttu-id="d51ea-174">`{`*n* `}` è un quantificatore greedy il cui equivalente lazy è `{` *n* `}?` .</span><span class="sxs-lookup"><span data-stu-id="d51ea-174">`{`*n*`}` is a greedy quantifier whose lazy equivalent is `{`*n*`}?`.</span></span>  
  
 <span data-ttu-id="d51ea-175">Ad esempio, l'espressione regolare `\b\d+\,\d{3}\b` tenta di trovare la corrispondenza con il confine di una parola seguito da una o più cifre decimali seguite da tre cifre decimali seguite dal confine di una parola.</span><span class="sxs-lookup"><span data-stu-id="d51ea-175">For example, the regular expression `\b\d+\,\d{3}\b` tries to match a word boundary followed by one or more decimal digits followed by three decimal digits followed by a word boundary.</span></span> <span data-ttu-id="d51ea-176">L'esempio seguente illustra questa espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="d51ea-176">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#4](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#4)]
 [!code-vb[RegularExpressions.Quantifiers#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#4)]  
  
 <span data-ttu-id="d51ea-177">Il criterio di ricerca di espressioni regolari è definito nel modo illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="d51ea-177">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d51ea-178">Modello</span><span class="sxs-lookup"><span data-stu-id="d51ea-178">Pattern</span></span>|<span data-ttu-id="d51ea-179">Descrizione</span><span class="sxs-lookup"><span data-stu-id="d51ea-179">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d51ea-180">Inizia dal confine di una parola.</span><span class="sxs-lookup"><span data-stu-id="d51ea-180">Start at a word boundary.</span></span>|  
|`\d+`|<span data-ttu-id="d51ea-181">Trova la corrispondenza con una o più cifre decimali.</span><span class="sxs-lookup"><span data-stu-id="d51ea-181">Match one or more decimal digits.</span></span>|  
|`\,`|<span data-ttu-id="d51ea-182">Trova la corrispondenza con un carattere virgola.</span><span class="sxs-lookup"><span data-stu-id="d51ea-182">Match a comma character.</span></span>|  
|`\d{3}`|<span data-ttu-id="d51ea-183">Trova la corrispondenza con tre cifre decimali.</span><span class="sxs-lookup"><span data-stu-id="d51ea-183">Match three decimal digits.</span></span>|  
|`\b`|<span data-ttu-id="d51ea-184">Terminare al confine di una parola.</span><span class="sxs-lookup"><span data-stu-id="d51ea-184">End at a word boundary.</span></span>|  
  
### <a name="match-at-least-n-times-n"></a><span data-ttu-id="d51ea-185">Trova la corrispondenza almeno n volte: {n,}</span><span class="sxs-lookup"><span data-stu-id="d51ea-185">Match at Least n Times: {n,}</span></span>  
 <span data-ttu-id="d51ea-186">Il `{` *n* `,}` quantificatore n trova la corrispondenza con l'elemento precedente almeno *n* volte, dove *n* è qualsiasi numero intero.</span><span class="sxs-lookup"><span data-stu-id="d51ea-186">The `{`*n*`,}` quantifier matches the preceding element at least *n* times, where *n* is any integer.</span></span> <span data-ttu-id="d51ea-187">`{`*n* `,}` è un quantificatore greedy il cui equivalente lazy è `{` *n* `,}?` .</span><span class="sxs-lookup"><span data-stu-id="d51ea-187">`{`*n*`,}` is a greedy quantifier whose lazy equivalent is `{`*n*`,}?`.</span></span>  
  
 <span data-ttu-id="d51ea-188">Ad esempio, l'espressione regolare `\b\d{2,}\b\D+` tenta di trovare la corrispondenza con il confine di una parola seguito da almeno due cifre seguite dal confine di una parola e un carattere non numerico.</span><span class="sxs-lookup"><span data-stu-id="d51ea-188">For example, the regular expression `\b\d{2,}\b\D+` tries to match a word boundary followed by at least two digits followed by a word boundary and a non-digit character.</span></span> <span data-ttu-id="d51ea-189">L'esempio seguente illustra questa espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="d51ea-189">The following example illustrates this regular expression.</span></span> <span data-ttu-id="d51ea-190">L'espressione regolare non riesce a trovare la frase `"7 days"` perché contiene solo una cifra decimale, ma trova la corrispondenza con le frasi `"10 weeks and 300 years"`.</span><span class="sxs-lookup"><span data-stu-id="d51ea-190">The regular expression fails to match the phrase `"7 days"` because it contains just one decimal digit, but it successfully matches the phrases `"10 weeks and 300 years"`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#5](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#5)]
 [!code-vb[RegularExpressions.Quantifiers#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#5)]  
  
 <span data-ttu-id="d51ea-191">Il criterio di ricerca di espressioni regolari è definito nel modo illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="d51ea-191">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d51ea-192">Modello</span><span class="sxs-lookup"><span data-stu-id="d51ea-192">Pattern</span></span>|<span data-ttu-id="d51ea-193">Descrizione</span><span class="sxs-lookup"><span data-stu-id="d51ea-193">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d51ea-194">Inizia dal confine di una parola.</span><span class="sxs-lookup"><span data-stu-id="d51ea-194">Start at a word boundary.</span></span>|  
|`\d{2,}`|<span data-ttu-id="d51ea-195">Trova la corrispondenza con almeno due cifre decimali.</span><span class="sxs-lookup"><span data-stu-id="d51ea-195">Match at least two decimal digits.</span></span>|  
|`\b`|<span data-ttu-id="d51ea-196">Trova la corrispondenza di un confine di parola.</span><span class="sxs-lookup"><span data-stu-id="d51ea-196">Match a word boundary.</span></span>|  
|`\D+`|<span data-ttu-id="d51ea-197">Trova la corrispondenza con almeno una cifra non decimale.</span><span class="sxs-lookup"><span data-stu-id="d51ea-197">Match at least one non-decimal digit.</span></span>|  
  
### <a name="match-between-n-and-m-times-nm"></a><span data-ttu-id="d51ea-198">Trova la corrispondenza tra n e m volte: {n,m}</span><span class="sxs-lookup"><span data-stu-id="d51ea-198">Match Between n and m Times: {n,m}</span></span>  
 <span data-ttu-id="d51ea-199">Il `{` *n* `,` *m* `}` quantificatore n m trova la corrispondenza con l'elemento precedente almeno *n* volte, ma non più di *m* volte, dove *n* e *m* sono numeri interi.</span><span class="sxs-lookup"><span data-stu-id="d51ea-199">The `{`*n*`,`*m*`}` quantifier matches the preceding element at least *n* times, but no more than *m* times, where *n* and *m* are integers.</span></span> <span data-ttu-id="d51ea-200">`{`*n* `,` *m* `}` è un quantificatore greedy il cui equivalente lazy è `{` *n* `,` *m* `}?` .</span><span class="sxs-lookup"><span data-stu-id="d51ea-200">`{`*n*`,`*m*`}` is a greedy quantifier whose lazy equivalent is `{`*n*`,`*m*`}?`.</span></span>  
  
 <span data-ttu-id="d51ea-201">Nell'esempio seguente, l'espressione regolare `(00\s){2,4}` tenta di trovare una corrispondenza tra due e quattro occorrenze di due cifre zero seguite da uno spazio.</span><span class="sxs-lookup"><span data-stu-id="d51ea-201">In the following example, the regular expression `(00\s){2,4}` tries to match between two and four occurrences of two zero digits followed by a space.</span></span> <span data-ttu-id="d51ea-202">Si noti che la parte finale della stringa di input include questo criterio cinque volte anziché il numero massimo di quattro.</span><span class="sxs-lookup"><span data-stu-id="d51ea-202">Note that the final portion of the input string includes this pattern five times rather than the maximum of four.</span></span> <span data-ttu-id="d51ea-203">Tuttavia, solo la parte iniziale della sottostringa (fino allo spazio e alla quinta coppia di zeri) corrisponde al criterio dell'espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="d51ea-203">However, only the initial portion of this substring (up to the space and the fifth pair of zeros) matches the regular expression pattern.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#6](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#6)]
 [!code-vb[RegularExpressions.Quantifiers#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#6)]  
  
### <a name="match-zero-or-more-times-lazy-match-"></a><span data-ttu-id="d51ea-204">Trova la corrispondenza zero o più volte (corrispondenza lazy): \*?</span><span class="sxs-lookup"><span data-stu-id="d51ea-204">Match Zero or More Times (Lazy Match): \*?</span></span>  
 <span data-ttu-id="d51ea-205">Il quantificatore `*?` trova la corrispondenza con l'elemento precedente zero o più volte, ma il minor numero di volte possibile.</span><span class="sxs-lookup"><span data-stu-id="d51ea-205">The `*?` quantifier matches the preceding element zero or more times, but as few times as possible.</span></span> <span data-ttu-id="d51ea-206">Si tratta della controparte lazy del quantificatore greedy `*`.</span><span class="sxs-lookup"><span data-stu-id="d51ea-206">It is the lazy counterpart of the greedy quantifier `*`.</span></span>  
  
 <span data-ttu-id="d51ea-207">Nell'esempio seguente l'espressione regolare `\b\w*?oo\w*?\b` corrisponde a tutte le parole contenenti la stringa `oo`.</span><span class="sxs-lookup"><span data-stu-id="d51ea-207">In the following example, the regular expression `\b\w*?oo\w*?\b` matches all words that contain the string `oo`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#7](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#7)]
 [!code-vb[RegularExpressions.Quantifiers#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#7)]  
  
 <span data-ttu-id="d51ea-208">Il criterio di ricerca di espressioni regolari è definito nel modo illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="d51ea-208">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d51ea-209">Modello</span><span class="sxs-lookup"><span data-stu-id="d51ea-209">Pattern</span></span>|<span data-ttu-id="d51ea-210">Descrizione</span><span class="sxs-lookup"><span data-stu-id="d51ea-210">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d51ea-211">Inizia dal confine di una parola.</span><span class="sxs-lookup"><span data-stu-id="d51ea-211">Start at a word boundary.</span></span>|  
|`\w*?`|<span data-ttu-id="d51ea-212">Trova la corrispondenza con zero o più caratteri alfanumerici, ma il minor numero di caratteri possibile.</span><span class="sxs-lookup"><span data-stu-id="d51ea-212">Match zero or more word characters, but as few characters as possible.</span></span>|  
|`oo`|<span data-ttu-id="d51ea-213">Trova la corrispondenza con la stringa "oo".</span><span class="sxs-lookup"><span data-stu-id="d51ea-213">Match the string "oo".</span></span>|  
|`\w*?`|<span data-ttu-id="d51ea-214">Trova la corrispondenza con zero o più caratteri alfanumerici, ma il minor numero di caratteri possibile.</span><span class="sxs-lookup"><span data-stu-id="d51ea-214">Match zero or more word characters, but as few characters as possible.</span></span>|  
|`\b`|<span data-ttu-id="d51ea-215">Termina al confine di una parola.</span><span class="sxs-lookup"><span data-stu-id="d51ea-215">End on a word boundary.</span></span>|  
  
### <a name="match-one-or-more-times-lazy-match-"></a><span data-ttu-id="d51ea-216">Trova la corrispondenza una o più volte (corrispondenza lazy): +?</span><span class="sxs-lookup"><span data-stu-id="d51ea-216">Match One or More Times (Lazy Match): +?</span></span>  
 <span data-ttu-id="d51ea-217">Il quantificatore `+?` trova la corrispondenza con l'elemento precedente una o più volte, ma il minor numero di volte possibile.</span><span class="sxs-lookup"><span data-stu-id="d51ea-217">The `+?` quantifier matches the preceding element one or more times, but as few times as possible.</span></span> <span data-ttu-id="d51ea-218">Si tratta della controparte lazy del quantificatore greedy `+`.</span><span class="sxs-lookup"><span data-stu-id="d51ea-218">It is the lazy counterpart of the greedy quantifier `+`.</span></span>  
  
 <span data-ttu-id="d51ea-219">Ad esempio, l'espressione regolare `\b\w+?\b` trova la corrispondenza con uno o più caratteri separati confini di parole.</span><span class="sxs-lookup"><span data-stu-id="d51ea-219">For example, the regular expression `\b\w+?\b` matches one or more characters separated by word boundaries.</span></span> <span data-ttu-id="d51ea-220">L'esempio seguente illustra questa espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="d51ea-220">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#8](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#8)]
 [!code-vb[RegularExpressions.Quantifiers#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#8)]  
  
### <a name="match-zero-or-one-time-lazy-match-"></a><span data-ttu-id="d51ea-221">Trova la corrispondenza zero o una volta (corrispondenza lazy): ??</span><span class="sxs-lookup"><span data-stu-id="d51ea-221">Match Zero or One Time (Lazy Match): ??</span></span>  
 <span data-ttu-id="d51ea-222">Il quantificatore `??` trova la corrispondenza con l'elemento precedente zero o una volta, ma il minor numero di volte possibile.</span><span class="sxs-lookup"><span data-stu-id="d51ea-222">The `??` quantifier matches the preceding element zero or one time, but as few times as possible.</span></span> <span data-ttu-id="d51ea-223">Si tratta della controparte lazy del quantificatore greedy `?`.</span><span class="sxs-lookup"><span data-stu-id="d51ea-223">It is the lazy counterpart of the greedy quantifier `?`.</span></span>  
  
 <span data-ttu-id="d51ea-224">Ad esempio, l'espressione regolare `^\s*(System.)??Console.Write(Line)??\(??` tenta di trovare la corrispondenza con le stringhe "Console.Write" o "Console.WriteLine".</span><span class="sxs-lookup"><span data-stu-id="d51ea-224">For example, the regular expression `^\s*(System.)??Console.Write(Line)??\(??` attempts to match the strings "Console.Write" or "Console.WriteLine".</span></span> <span data-ttu-id="d51ea-225">La stringa può anche includere "System."</span><span class="sxs-lookup"><span data-stu-id="d51ea-225">The string can also include "System."</span></span> <span data-ttu-id="d51ea-226">prima di "Console" e può essere seguita da una parentesi di apertura.</span><span class="sxs-lookup"><span data-stu-id="d51ea-226">before "Console", and it can be followed by an opening parenthesis.</span></span> <span data-ttu-id="d51ea-227">La stringa deve essere all'inizio di una riga, anche se può essere preceduta da uno spazio vuoto.</span><span class="sxs-lookup"><span data-stu-id="d51ea-227">The string must be at the beginning of a line, although it can be preceded by white space.</span></span> <span data-ttu-id="d51ea-228">L'esempio seguente illustra questa espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="d51ea-228">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#9](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#9)]
 [!code-vb[RegularExpressions.Quantifiers#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#9)]  
  
 <span data-ttu-id="d51ea-229">Il criterio di ricerca di espressioni regolari è definito nel modo illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="d51ea-229">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d51ea-230">Modello</span><span class="sxs-lookup"><span data-stu-id="d51ea-230">Pattern</span></span>|<span data-ttu-id="d51ea-231">Descrizione</span><span class="sxs-lookup"><span data-stu-id="d51ea-231">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="d51ea-232">Trova la corrispondenza con l'inizio del flusso di input.</span><span class="sxs-lookup"><span data-stu-id="d51ea-232">Match the start of the input stream.</span></span>|  
|`\s*`|<span data-ttu-id="d51ea-233">Trovare la corrispondenza di zero o più spazi vuoti.</span><span class="sxs-lookup"><span data-stu-id="d51ea-233">Match zero or more white-space characters.</span></span>|  
|`(System.)??`|<span data-ttu-id="d51ea-234">Trova la corrispondenza con zero o una occorrenza della stringa "System.".</span><span class="sxs-lookup"><span data-stu-id="d51ea-234">Match zero or one occurrence of the string "System.".</span></span>|  
|`Console.Write`|<span data-ttu-id="d51ea-235">Trova la corrispondenza con la stringa "Console.Write".</span><span class="sxs-lookup"><span data-stu-id="d51ea-235">Match the string "Console.Write".</span></span>|  
|`(Line)??`|<span data-ttu-id="d51ea-236">Trova la corrispondenza con zero o una occorrenza della stringa "Line".</span><span class="sxs-lookup"><span data-stu-id="d51ea-236">Match zero or one occurrence of the string "Line".</span></span>|  
|`\(??`|<span data-ttu-id="d51ea-237">Trova la corrispondenza con zero o una occorrenza della parentesi di apertura.</span><span class="sxs-lookup"><span data-stu-id="d51ea-237">Match zero or one occurrence of the opening parenthesis.</span></span>|  
  
### <a name="match-exactly-n-times-lazy-match-n"></a><span data-ttu-id="d51ea-238">Trova la corrispondenza esatta n volte (corrispondenza lazy): {n}?</span><span class="sxs-lookup"><span data-stu-id="d51ea-238">Match Exactly n Times (Lazy Match): {n}?</span></span>  
 <span data-ttu-id="d51ea-239">Il `{` *n* `}?` quantificatore n trova la corrispondenza con l'elemento precedente esattamente `n` volte, dove *n* è qualsiasi numero intero.</span><span class="sxs-lookup"><span data-stu-id="d51ea-239">The `{`*n*`}?` quantifier matches the preceding element exactly `n` times, where *n* is any integer.</span></span> <span data-ttu-id="d51ea-240">Si tratta della controparte Lazy del quantificatore greedy `{` *n* `}` .</span><span class="sxs-lookup"><span data-stu-id="d51ea-240">It is the lazy counterpart of the greedy quantifier `{`*n*`}`.</span></span>  
  
 <span data-ttu-id="d51ea-241">Nell'esempio seguente viene usata l'espressione regolare `\b(\w{3,}?\.){2}?\w{3,}?\b` per identificare un indirizzo di sito Web.</span><span class="sxs-lookup"><span data-stu-id="d51ea-241">In the following example, the regular expression `\b(\w{3,}?\.){2}?\w{3,}?\b` is used to identify a Web site address.</span></span> <span data-ttu-id="d51ea-242">Si noti che corrisponde a "www.microsoft.com" e "msdn.microsoft.com", ma non a "mywebsite" o "mycompany.com".</span><span class="sxs-lookup"><span data-stu-id="d51ea-242">Note that it matches "www.microsoft.com" and "msdn.microsoft.com", but does not match "mywebsite" or "mycompany.com".</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#10](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#10)]
 [!code-vb[RegularExpressions.Quantifiers#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#10)]  
  
 <span data-ttu-id="d51ea-243">Il criterio di ricerca di espressioni regolari è definito nel modo illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="d51ea-243">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d51ea-244">Modello</span><span class="sxs-lookup"><span data-stu-id="d51ea-244">Pattern</span></span>|<span data-ttu-id="d51ea-245">Descrizione</span><span class="sxs-lookup"><span data-stu-id="d51ea-245">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d51ea-246">Inizia dal confine di una parola.</span><span class="sxs-lookup"><span data-stu-id="d51ea-246">Start at a word boundary.</span></span>|  
|`(\w{3,}?\.)`|<span data-ttu-id="d51ea-247">Trova la corrispondenza con almeno 3 caratteri alfanumerici, ma il minor numero di caratteri possibile, seguiti da un carattere punto.</span><span class="sxs-lookup"><span data-stu-id="d51ea-247">Match at least 3 word characters, but as few characters as possible, followed by a dot or period character.</span></span> <span data-ttu-id="d51ea-248">Equivale al primo gruppo di acquisizione.</span><span class="sxs-lookup"><span data-stu-id="d51ea-248">This is the first capturing group.</span></span>|  
|`(\w{3,}?\.){2}?`|<span data-ttu-id="d51ea-249">Corrisponde al criterio nel primo gruppo due volte, ma il minor numero di volte possibile.</span><span class="sxs-lookup"><span data-stu-id="d51ea-249">Match the pattern in the first group two times, but as few times as possible.</span></span>|  
|`\b`|<span data-ttu-id="d51ea-250">Termina la corrispondenza sul confine di parola.</span><span class="sxs-lookup"><span data-stu-id="d51ea-250">End the match on a word boundary.</span></span>|  
  
### <a name="match-at-least-n-times-lazy-match-n"></a><span data-ttu-id="d51ea-251">Trova la corrispondenza almeno n volte (corrispondenza lazy): {n,}?</span><span class="sxs-lookup"><span data-stu-id="d51ea-251">Match at Least n Times (Lazy Match): {n,}?</span></span>  
 <span data-ttu-id="d51ea-252">Il `{` *n* `,}?` quantificatore n trova la corrispondenza con l'elemento precedente almeno `n` volte, dove *n* è qualsiasi numero intero, ma il minor numero di volte possibile.</span><span class="sxs-lookup"><span data-stu-id="d51ea-252">The `{`*n*`,}?` quantifier matches the preceding element at least `n` times, where *n* is any integer, but as few times as possible.</span></span> <span data-ttu-id="d51ea-253">Si tratta della controparte Lazy del quantificatore greedy `{` *n* `,}` .</span><span class="sxs-lookup"><span data-stu-id="d51ea-253">It is the lazy counterpart of the greedy quantifier `{`*n*`,}`.</span></span>  
  
 <span data-ttu-id="d51ea-254">Vedere l'esempio per il `{` *n* `}?` quantificatore n nella sezione precedente per un'illustrazione.</span><span class="sxs-lookup"><span data-stu-id="d51ea-254">See the example for the `{`*n*`}?` quantifier in the previous section for an illustration.</span></span> <span data-ttu-id="d51ea-255">L'espressione regolare in tale esempio usa il `{` *n* `,}` quantificatore n per trovare la corrispondenza con una stringa che contiene almeno tre caratteri seguiti da un punto.</span><span class="sxs-lookup"><span data-stu-id="d51ea-255">The regular expression in that example uses the `{`*n*`,}` quantifier to match a string that has at least three characters followed by a period.</span></span>  
  
### <a name="match-between-n-and-m-times-lazy-match-nm"></a><span data-ttu-id="d51ea-256">Trova la corrispondenza tra n e m volte (corrispondenza lazy): {n,m}?</span><span class="sxs-lookup"><span data-stu-id="d51ea-256">Match Between n and m Times (Lazy Match): {n,m}?</span></span>  
 <span data-ttu-id="d51ea-257">Il `{` *n* `,` *m* `}?` quantificatore n m trova la corrispondenza con l'elemento precedente tra `n` e `m` Times, dove *n* e *m* sono numeri interi, ma il minor numero di volte possibile.</span><span class="sxs-lookup"><span data-stu-id="d51ea-257">The `{`*n*`,`*m*`}?` quantifier matches the preceding element between `n` and `m` times, where *n* and *m* are integers, but as few times as possible.</span></span> <span data-ttu-id="d51ea-258">Si tratta della controparte Lazy del quantificatore greedy `{` *n* `,` *m* `}` .</span><span class="sxs-lookup"><span data-stu-id="d51ea-258">It is the lazy counterpart of the greedy quantifier `{`*n*`,`*m*`}`.</span></span>  
  
 <span data-ttu-id="d51ea-259">Nell'esempio seguente l'espressione regolare `\b[A-Z](\w*?\s*?){1,10}[.!?]` corrisponde alle frasi che contengono da una a dieci parole.</span><span class="sxs-lookup"><span data-stu-id="d51ea-259">In the following example, the regular expression `\b[A-Z](\w*?\s*?){1,10}[.!?]` matches sentences that contain between one and ten words.</span></span> <span data-ttu-id="d51ea-260">Trova la corrispondenza con tutte le frasi nella stringa di input, ad eccezione di una frase che contiene 18 parole.</span><span class="sxs-lookup"><span data-stu-id="d51ea-260">It matches all the sentences in the input string except for one sentence that contains 18 words.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#12](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#12)]
 [!code-vb[RegularExpressions.Quantifiers#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#12)]  
  
 <span data-ttu-id="d51ea-261">Il criterio di ricerca di espressioni regolari è definito nel modo illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="d51ea-261">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d51ea-262">Modello</span><span class="sxs-lookup"><span data-stu-id="d51ea-262">Pattern</span></span>|<span data-ttu-id="d51ea-263">Descrizione</span><span class="sxs-lookup"><span data-stu-id="d51ea-263">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d51ea-264">Inizia dal confine di una parola.</span><span class="sxs-lookup"><span data-stu-id="d51ea-264">Start at a word boundary.</span></span>|  
|`[A-Z]`|<span data-ttu-id="d51ea-265">Trova la corrispondenza con un carattere maiuscolo da A a Z.</span><span class="sxs-lookup"><span data-stu-id="d51ea-265">Match an uppercase character from A to Z.</span></span>|  
|`(\w*?\s*?)`|<span data-ttu-id="d51ea-266">Trova la corrispondenza con uno o più caratteri alfanumerici seguiti da uno o più caratteri spazio vuoto, ma il minor numero di volte possibile.</span><span class="sxs-lookup"><span data-stu-id="d51ea-266">Match zero or more word characters, followed by one or more white-space characters, but as few times as possible.</span></span> <span data-ttu-id="d51ea-267">Equivale al primo gruppo di acquisizione.</span><span class="sxs-lookup"><span data-stu-id="d51ea-267">This is the first capture group.</span></span>|  
|`{1,10}`|<span data-ttu-id="d51ea-268">Trova la corrispondenza con il criterio precedente da 1 a 10 volte.</span><span class="sxs-lookup"><span data-stu-id="d51ea-268">Match the previous pattern between 1 and 10 times.</span></span>|  
|`[.!?]`|<span data-ttu-id="d51ea-269">Trova la corrispondenza con uno dei caratteri di punteggiatura ".", "!" o "?".</span><span class="sxs-lookup"><span data-stu-id="d51ea-269">Match any one of the punctuation characters ".", "!", or "?".</span></span>|  
  
<a name="Greedy"></a>
## <a name="greedy-and-lazy-quantifiers"></a><span data-ttu-id="d51ea-270">Quantificatori greedy e lazy</span><span class="sxs-lookup"><span data-stu-id="d51ea-270">Greedy and Lazy Quantifiers</span></span>  
 <span data-ttu-id="d51ea-271">Alcuni quantificatori hanno due versioni:</span><span class="sxs-lookup"><span data-stu-id="d51ea-271">A number of the quantifiers have two versions:</span></span>  
  
- <span data-ttu-id="d51ea-272">Una versione greedy.</span><span class="sxs-lookup"><span data-stu-id="d51ea-272">A greedy version.</span></span>  
  
     <span data-ttu-id="d51ea-273">Un quantificatore greedy tenta di trovare la corrispondenza con un elemento il maggior numero di volte possibile.</span><span class="sxs-lookup"><span data-stu-id="d51ea-273">A greedy quantifier tries to match an element as many times as possible.</span></span>  
  
- <span data-ttu-id="d51ea-274">Una versione non greedy (o lazy).</span><span class="sxs-lookup"><span data-stu-id="d51ea-274">A non-greedy (or lazy) version.</span></span>  
  
     <span data-ttu-id="d51ea-275">Un quantificatore non greedy tenta di trovare la corrispondenza con un elemento il minor numero di volte possibile.</span><span class="sxs-lookup"><span data-stu-id="d51ea-275">A non-greedy quantifier tries to match an element as few times as possible.</span></span> <span data-ttu-id="d51ea-276">È possibile trasformare un quantificatore greedy in un quantificatore lazy aggiungendo semplicemente un `?`.</span><span class="sxs-lookup"><span data-stu-id="d51ea-276">You can turn a greedy quantifier into a lazy quantifier by simply adding a `?`.</span></span>  
  
 <span data-ttu-id="d51ea-277">Si consideri un'espressione regolare semplice progettata per estrarre le ultime quattro cifre da una stringa di numeri, ad esempio un numero di carta di credito.</span><span class="sxs-lookup"><span data-stu-id="d51ea-277">Consider a simple regular expression that is intended to extract the last four digits from a string of numbers such as a credit card number.</span></span> <span data-ttu-id="d51ea-278">La versione dell'espressione regolare che usa il quantificatore greedy `*` è `\b.*([0-9]{4})\b`.</span><span class="sxs-lookup"><span data-stu-id="d51ea-278">The version of the regular expression that uses the `*` greedy quantifier is `\b.*([0-9]{4})\b`.</span></span> <span data-ttu-id="d51ea-279">Se tuttavia una stringa contiene due numeri, come illustrato nell'esempio seguente, l'espressione regolare trova la corrispondenza solo con le ultime quattro cifre secondo numero.</span><span class="sxs-lookup"><span data-stu-id="d51ea-279">However, if a string contains two numbers, this regular expression matches the last four digits of the second number only, as the following example shows.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#1)]  
  
 <span data-ttu-id="d51ea-280">L'espressione regolare non è in grado di trovare il primo numero perché il quantificatore `*` tenta di trovare la corrispondenza con l'elemento precedente il maggior numero di volte possibile nell'intera stringa, quindi trova la corrispondenza alla fine della stringa.</span><span class="sxs-lookup"><span data-stu-id="d51ea-280">The regular expression fails to match the first number because the `*` quantifier tries to match the previous element as many times as possible in the entire string, and so it finds its match at the end of the string.</span></span>  
  
 <span data-ttu-id="d51ea-281">Questo non è il comportamento desiderato.</span><span class="sxs-lookup"><span data-stu-id="d51ea-281">This is not the desired behavior.</span></span> <span data-ttu-id="d51ea-282">È invece possibile usare il quantificatore lazy `*?` per estrarre cifre da entrambi i numeri, come illustra l'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="d51ea-282">Instead, you can use the `*?`lazy quantifier to extract digits from both numbers, as the following example shows.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#2)]  
  
 <span data-ttu-id="d51ea-283">Nella maggior parte dei casi le espressioni regolari con quantificatori greedy e lazy restituiscono le stesse corrispondenze.</span><span class="sxs-lookup"><span data-stu-id="d51ea-283">In most cases, regular expressions with greedy and lazy quantifiers return the same matches.</span></span> <span data-ttu-id="d51ea-284">In genere restituiscono risultati diversi quando vengono usate con il metacarattere jolly (`.`), che corrisponde a qualsiasi carattere.</span><span class="sxs-lookup"><span data-stu-id="d51ea-284">They most commonly return different results when they are used with the wildcard (`.`) metacharacter, which matches any character.</span></span>  
  
## <a name="quantifiers-and-empty-matches"></a><span data-ttu-id="d51ea-285">Quantificatori e corrispondenze vuote</span><span class="sxs-lookup"><span data-stu-id="d51ea-285">Quantifiers and Empty Matches</span></span>  
 <span data-ttu-id="d51ea-286">I quantificatori `*` , `+` e `{` *n* `,` *m* `}` e le relative controparti lazy non si ripetono mai dopo una corrispondenza vuota quando è stato trovato il numero minimo di acquisizioni.</span><span class="sxs-lookup"><span data-stu-id="d51ea-286">The quantifiers `*`, `+`, and `{`*n*`,`*m*`}` and their lazy counterparts never repeat after an empty match when the minimum number of captures has been found.</span></span> <span data-ttu-id="d51ea-287">Questa regola impedisce ai quantificatori di avviare cicli infiniti su corrispondenze di sottoespressioni vuote quando il numero massimo di acquisizioni possibili per il gruppo possibili è infinito o quasi infinito.</span><span class="sxs-lookup"><span data-stu-id="d51ea-287">This rule prevents quantifiers from entering infinite loops on empty subexpression matches when the maximum number of possible group captures is infinite or near infinite.</span></span>  
  
 <span data-ttu-id="d51ea-288">Ad esempio, il codice seguente presenta il risultato di una chiamata al metodo <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> con il criterio di espressione regolare `(a?)*` che trova la corrispondenza con uno o nessun carattere "a" zero o più volte.</span><span class="sxs-lookup"><span data-stu-id="d51ea-288">For example, the following code shows the result of a call to the <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> method with the regular expression pattern `(a?)*`, which matches zero or one "a" character zero or more times.</span></span> <span data-ttu-id="d51ea-289">Si noti che il singolo gruppo di acquisizione acquisisce ogni "a" nonché <xref:System.String.Empty?displayProperty=nameWithType>, ma che non esiste una seconda corrispondenza vuota, perché la prima corrispondenza vuota induce il quantificatore a interrompere la ripetizione.</span><span class="sxs-lookup"><span data-stu-id="d51ea-289">Note that the single capturing group captures each "a" as well as <xref:System.String.Empty?displayProperty=nameWithType>, but that there is no second empty match, because the first empty match causes the quantifier to stop repeating.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch1.vb#1)]  
  
 <span data-ttu-id="d51ea-290">Per vedere in pratica la differenza tra un gruppo di acquisizione che definisce un numero minimo e massimo di acquisizioni e uno che definisce un numero fisso di acquisizioni, considerare i criteri di espressione regolare `(a\1|(?(1)\1)){0,2}` e `(a\1|(?(1)\1)){2}`.</span><span class="sxs-lookup"><span data-stu-id="d51ea-290">To see the practical difference between a capturing group that defines a minimum and a maximum number of captures and one that defines a fixed number of captures, consider the regular expression patterns `(a\1|(?(1)\1)){0,2}` and `(a\1|(?(1)\1)){2}`.</span></span> <span data-ttu-id="d51ea-291">Entrambe le espressioni regolari sono costituite da un singolo gruppo di acquisizione, definito come illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="d51ea-291">Both regular expressions consist of a single capturing group, which is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d51ea-292">Modello</span><span class="sxs-lookup"><span data-stu-id="d51ea-292">Pattern</span></span>|<span data-ttu-id="d51ea-293">Descrizione</span><span class="sxs-lookup"><span data-stu-id="d51ea-293">Description</span></span>|  
|-------------|-----------------|  
|`(a\1`|<span data-ttu-id="d51ea-294">Trova la corrispondenza con "a" insieme al valore del primo gruppo acquisito...</span><span class="sxs-lookup"><span data-stu-id="d51ea-294">Either match "a" along with the value of the first captured group …</span></span>|  
|<code>&#124;(?(1)</code>|<span data-ttu-id="d51ea-295">…</span><span class="sxs-lookup"><span data-stu-id="d51ea-295">…</span></span> <span data-ttu-id="d51ea-296">o verifica se è stato definito il primo gruppo acquisito.</span><span class="sxs-lookup"><span data-stu-id="d51ea-296">or test whether the first captured group has been defined.</span></span> <span data-ttu-id="d51ea-297">Si noti che il costrutto `(?(1)` non definisce un gruppo di acquisizione.</span><span class="sxs-lookup"><span data-stu-id="d51ea-297">(Note that the `(?(1)` construct does not define a capturing group.)</span></span>|  
|`\1))`|<span data-ttu-id="d51ea-298">Se il primo gruppo acquisito esiste, trovare la corrispondenza con il relativo valore.</span><span class="sxs-lookup"><span data-stu-id="d51ea-298">If the first captured group exists, match its value.</span></span> <span data-ttu-id="d51ea-299">Se non esiste, il gruppo corrisponderà a <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d51ea-299">If the group does not exist, the group will match <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|  
  
 <span data-ttu-id="d51ea-300">La prima espressione regolare tenta di trovare la corrispondenza con questo criterio da zero a due volte, la seconda esattamente due volte.</span><span class="sxs-lookup"><span data-stu-id="d51ea-300">The first regular expression tries to match this pattern between zero and two times; the second, exactly two times.</span></span> <span data-ttu-id="d51ea-301">Poiché il primo criterio raggiunge il numero minimo di acquisizioni con la prima acquisizione di <xref:System.String.Empty?displayProperty=nameWithType>, non ripete mai il tentativo di trovare una corrispondenza con `a\1` e il quantificatore `{0,2}` consente solo corrispondenze vuote nell'ultima iterazione.</span><span class="sxs-lookup"><span data-stu-id="d51ea-301">Because the first pattern reaches its minimum number of captures with its first capture of <xref:System.String.Empty?displayProperty=nameWithType>, it never repeats to try to match `a\1`; the `{0,2}` quantifier allows only empty matches in the last iteration.</span></span> <span data-ttu-id="d51ea-302">Al contrario, la seconda espressione regolare trova la corrispondenza con "a" perché restituisce `a\1` una seconda volta. Il numero minimo di iterazioni, 2, impone al motore la ripetizione dopo una corrispondenza vuota.</span><span class="sxs-lookup"><span data-stu-id="d51ea-302">In contrast, the second regular expression does match "a" because it evaluates `a\1` a second time; the minimum number of iterations, 2, forces the engine to repeat after an empty match.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch4.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch4.vb#2)]  
  
## <a name="see-also"></a><span data-ttu-id="d51ea-303">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="d51ea-303">See also</span></span>

- [<span data-ttu-id="d51ea-304">Linguaggio di espressioni regolari - Riferimento rapido</span><span class="sxs-lookup"><span data-stu-id="d51ea-304">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)
- [<span data-ttu-id="d51ea-305">Backtracking</span><span class="sxs-lookup"><span data-stu-id="d51ea-305">Backtracking</span></span>](backtracking-in-regular-expressions.md)
