---
title: Procedure consigliate per le espressioni regolari in .NET
description: Informazioni su come creare espressioni regolari efficienti in .NET.
ms.date: 06/30/2020
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework regular expressions, best practices
- regular expressions, best practices
ms.assetid: 618e5afb-3a97-440d-831a-70e4c526a51c
ms.openlocfilehash: 30d4a8f6ddc4ae1f83f5c0802e872661cbe6c6f1
ms.sourcegitcommit: c23d9666ec75b91741da43ee3d91c317d68c7327
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/01/2020
ms.locfileid: "85802927"
---
# <a name="best-practices-for-regular-expressions-in-net"></a><span data-ttu-id="e730f-103">Procedure consigliate per le espressioni regolari in .NET</span><span class="sxs-lookup"><span data-stu-id="e730f-103">Best practices for regular expressions in .NET</span></span>

<span data-ttu-id="e730f-104">Il motore delle espressioni regolari in .NET è uno strumento potente e completo che consente di elaborare il testo in base alle corrispondenze dei modelli anziché in base al confronto e alla corrispondenza con il testo letterale.</span><span class="sxs-lookup"><span data-stu-id="e730f-104">The regular expression engine in .NET is a powerful, full-featured tool that processes text based on pattern matches rather than on comparing and matching literal text.</span></span> <span data-ttu-id="e730f-105">Nella maggior parte dei casi, la corrispondenza dei modelli viene applicata in modo rapido ed efficiente.</span><span class="sxs-lookup"><span data-stu-id="e730f-105">In most cases, it performs pattern matching rapidly and efficiently.</span></span> <span data-ttu-id="e730f-106">In alcuni casi, tuttavia, il motore delle espressioni regolari può risultare molto lento.</span><span class="sxs-lookup"><span data-stu-id="e730f-106">However, in some cases, the regular expression engine can appear to be very slow.</span></span> <span data-ttu-id="e730f-107">In casi estremi, può anche sembrare che il motore non risponda durante l'elaborazione di un input relativamente piccolo per ore o perfino giorni.</span><span class="sxs-lookup"><span data-stu-id="e730f-107">In extreme cases, it can even appear to stop responding as it processes a relatively small input over the course of hours or even days.</span></span>

<span data-ttu-id="e730f-108">In questo argomento vengono illustrate alcune procedure consigliate che possono essere adottate dagli sviluppatori per ottenere prestazioni ottimali con le espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="e730f-108">This topic outlines some of the best practices that developers can adopt to ensure that their regular expressions achieve optimal performance.</span></span>

[!INCLUDE [regex](../../../includes/regex.md)]

## <a name="consider-the-input-source"></a><span data-ttu-id="e730f-109">Esaminare l'origine di input</span><span class="sxs-lookup"><span data-stu-id="e730f-109">Consider the input source</span></span>

<span data-ttu-id="e730f-110">In generale, le espressioni regolari possono accettare due tipi di input: vincolato o non vincolato.</span><span class="sxs-lookup"><span data-stu-id="e730f-110">In general, regular expressions can accept two types of input: constrained or unconstrained.</span></span> <span data-ttu-id="e730f-111">Per input vincolato si intende un testo che proviene da un'origine conosciuta o affidabile e segue un formato predefinito.</span><span class="sxs-lookup"><span data-stu-id="e730f-111">Constrained input is text that originates from a known or reliable source and follows a predefined format.</span></span> <span data-ttu-id="e730f-112">Per input non vincolato si intende un testo che proviene da un'origine non inaffidabile, ad esempio un utente Web, e non può seguire un formato predefinito o previsto.</span><span class="sxs-lookup"><span data-stu-id="e730f-112">Unconstrained input is text that originates from an unreliable source, such as a web user, and may not follow a predefined or expected format.</span></span>

<span data-ttu-id="e730f-113">I modelli di espressione regolare vengono scritti in genere in modo da corrispondere all'input valido,</span><span class="sxs-lookup"><span data-stu-id="e730f-113">Regular expression patterns are typically written to match valid input.</span></span> <span data-ttu-id="e730f-114">ovvero gli sviluppatori esaminano il testo per il quale desiderano trovare una corrispondenza e scrivono quindi un modello di espressione regolare a esso corrispondente.</span><span class="sxs-lookup"><span data-stu-id="e730f-114">That is, developers examine the text that they want to match and then write a regular expression pattern that matches it.</span></span> <span data-ttu-id="e730f-115">Gli sviluppatori determinano infine se questo modello richiede una correzione o un'ulteriore elaborazione testandolo con più elementi di input validi.</span><span class="sxs-lookup"><span data-stu-id="e730f-115">Developers then determine whether this pattern requires correction or further elaboration by testing it with multiple valid input items.</span></span> <span data-ttu-id="e730f-116">Se il modello corrisponde a tutti gli input considerati validi, viene dichiarato pronto per la produzione e può essere incluso in un'applicazione rilasciata.</span><span class="sxs-lookup"><span data-stu-id="e730f-116">When the pattern matches all presumed valid inputs, it is declared to be production-ready and can be included in a released application.</span></span> <span data-ttu-id="e730f-117">In tal modo, un modello di espressione regolare viene considerato appropriato per la corrispondenza con un input vincolato.</span><span class="sxs-lookup"><span data-stu-id="e730f-117">This makes a regular expression pattern suitable for matching constrained input.</span></span> <span data-ttu-id="e730f-118">Tuttavia, non verrà considerato appropriato per la corrispondenza con un input non vincolato.</span><span class="sxs-lookup"><span data-stu-id="e730f-118">However, it does not make it suitable for matching unconstrained input.</span></span>

<span data-ttu-id="e730f-119">Per corrispondere a un input non vincolato, un'espressione regolare deve potere gestire efficientemente tre tipi di testo:</span><span class="sxs-lookup"><span data-stu-id="e730f-119">To match unconstrained input, a regular expression must be able to efficiently handle three kinds of text:</span></span>

- <span data-ttu-id="e730f-120">Testo che corrisponde al modello di espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="e730f-120">Text that matches the regular expression pattern.</span></span>

- <span data-ttu-id="e730f-121">Testo che non corrisponde al modello di espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="e730f-121">Text that does not match the regular expression pattern.</span></span>

- <span data-ttu-id="e730f-122">Testo che corrisponde quasi al modello di espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="e730f-122">Text that nearly matches the regular expression pattern.</span></span>

<span data-ttu-id="e730f-123">L'ultimo tipo di testo è particolarmente problematico per un'espressione regolare scritta per gestire l'input vincolato.</span><span class="sxs-lookup"><span data-stu-id="e730f-123">The last text type is especially problematic for a regular expression that has been written to handle constrained input.</span></span> <span data-ttu-id="e730f-124">Se tale espressione regolare si basa anche sul [backtracking](backtracking-in-regular-expressions.md) esteso, il motore delle espressioni regolari può richiedere una quantità eccessiva di tempo, in alcuni casi molte ore o giorni, per l'elaborazione di un testo apparentemente irrilevante.</span><span class="sxs-lookup"><span data-stu-id="e730f-124">If that regular expression also relies on extensive [backtracking](backtracking-in-regular-expressions.md), the regular expression engine can spend an inordinate amount of time (in some cases, many hours or days) processing seemingly innocuous text.</span></span>

> [!WARNING]
> <span data-ttu-id="e730f-125">Nell'esempio seguente viene utilizzata un'espressione regolare soggetta a un backtracking eccessivo e che con tutta probabilità rifiuta indirizzi di posta elettronica validi.</span><span class="sxs-lookup"><span data-stu-id="e730f-125">The following example uses a regular expression that is prone to excessive backtracking and that is likely to reject valid email addresses.</span></span> <span data-ttu-id="e730f-126">Non utilizzarla in una routine di convalida di posta elettronica.</span><span class="sxs-lookup"><span data-stu-id="e730f-126">You should not use it in an email validation routine.</span></span> <span data-ttu-id="e730f-127">Per un'espressione regolare che convalida gli indirizzi di posta elettronica, vedere [Procedura: Verificare che le stringhe siano in formato di posta elettronica valido](how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="e730f-127">If you would like a regular expression that validates email addresses, see [How to: Verify that Strings Are in Valid Email Format](how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

<span data-ttu-id="e730f-128">Si consideri, ad esempio, un'espressione regolare comunemente utilizzata ma estremamente problematica per la convalida dell'alias di un indirizzo di posta elettronica.</span><span class="sxs-lookup"><span data-stu-id="e730f-128">For example, consider a very commonly used but extremely problematic regular expression for validating the alias of an email address.</span></span> <span data-ttu-id="e730f-129">L'espressione regolare `^[0-9A-Z]([-.\w]*[0-9A-Z])*$` viene scritta per elaborare gli indirizzi di posta elettronica ritenuti validi, composti da un carattere alfanumerico seguito da zero o più caratteri che possono essere alfanumerici, punti o trattini.</span><span class="sxs-lookup"><span data-stu-id="e730f-129">The regular expression `^[0-9A-Z]([-.\w]*[0-9A-Z])*$` is written to process what is considered to be a valid email address, which consists of an alphanumeric character, followed by zero or more characters that can be alphanumeric, periods, or hyphens.</span></span> <span data-ttu-id="e730f-130">L'espressione regolare deve terminare con un carattere alfanumerico.</span><span class="sxs-lookup"><span data-stu-id="e730f-130">The regular expression must end with an alphanumeric character.</span></span> <span data-ttu-id="e730f-131">Tuttavia, come illustrato nell'esempio seguente, sebbene questa espressione regolare gestisca facilmente l'input valido, le prestazioni risulteranno molto inefficienti quando viene elaborato un input quasi valido.</span><span class="sxs-lookup"><span data-stu-id="e730f-131">However, as the following example shows, although this regular expression handles valid input easily, its performance is very inefficient when it is processing nearly valid input.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/design2.cs#1)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/design2.vb#1)]

<span data-ttu-id="e730f-132">Come illustrato nell'output dell'esempio, il motore delle espressioni regolari elabora l'alias di posta elettronica valido nello stesso intervallo di tempo indipendentemente dalla lunghezza.</span><span class="sxs-lookup"><span data-stu-id="e730f-132">As the output from the example shows, the regular expression engine processes the valid email alias in about the same time interval regardless of its length.</span></span> <span data-ttu-id="e730f-133">D'altra parte, quando l'indirizzo di posta elettronica quasi valido ha più di cinque caratteri, il tempo di elaborazione raddoppia approssimativamente per ogni carattere aggiuntivo nella stringa.</span><span class="sxs-lookup"><span data-stu-id="e730f-133">On the other hand, when the nearly valid email address has more than five characters, processing time approximately doubles for each additional character in the string.</span></span> <span data-ttu-id="e730f-134">Ciò significa che l'elaborazione di una stringa di 28 caratteri quasi valida richiederebbe più di un'ora e l'elaborazione di una stringa di 33 caratteri quasi valida richiederebbe quasi un giorno.</span><span class="sxs-lookup"><span data-stu-id="e730f-134">This means that a nearly valid 28-character string would take over an hour to process, and a nearly valid 33-character string would take nearly a day to process.</span></span>

<span data-ttu-id="e730f-135">Poiché questa espressione regolare è stata sviluppata considerando unicamente la corrispondenza con il formato di input, l'input che non corrisponde al modello non viene preso in considerazione.</span><span class="sxs-lookup"><span data-stu-id="e730f-135">Because this regular expression was developed solely by considering the format of input to be matched, it fails to take account of input that does not match the pattern.</span></span> <span data-ttu-id="e730f-136">Di conseguenza, è possibile consentire a un input non vincolato che corrisponde quasi al modello di espressione regolare di ridurre significativamente le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="e730f-136">This, in turn, can allow unconstrained input that nearly matches the regular expression pattern to significantly degrade performance.</span></span>

<span data-ttu-id="e730f-137">Per risolvere tale problema, è possibile effettuare le operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="e730f-137">To solve this problem, you can do the following:</span></span>

- <span data-ttu-id="e730f-138">Durante lo sviluppo di un modello, è consigliabile considerare il modo in cui il backtracking potrebbe influire sulle prestazioni del motore delle espressioni regolari, soprattutto se l'espressione regolare è progettata per elaborare un input non vincolato.</span><span class="sxs-lookup"><span data-stu-id="e730f-138">When developing a pattern, you should consider how backtracking might affect the performance of the regular expression engine, particularly if your regular expression is designed to process unconstrained input.</span></span> <span data-ttu-id="e730f-139">Per ulteriori informazioni, vedere la sezione assumere il controllo [del backtracking](#take-charge-of-backtracking) .</span><span class="sxs-lookup"><span data-stu-id="e730f-139">For more information, see the [Take Charge of Backtracking](#take-charge-of-backtracking) section.</span></span>

- <span data-ttu-id="e730f-140">Testare in modo approfondito l'espressione regolare utilizzando un input non valido e quasi valido nonché un input valido.</span><span class="sxs-lookup"><span data-stu-id="e730f-140">Thoroughly test your regular expression using invalid and near-valid input as well as valid input.</span></span> <span data-ttu-id="e730f-141">Per generare casualmente input per un'espressione regolare specifica, è possibile usare [Rex](https://www.microsoft.com/research/project/rex-regular-expression-exploration/), uno strumento di analisi delle espressioni regolari di Microsoft Research.</span><span class="sxs-lookup"><span data-stu-id="e730f-141">To generate input for a particular regular expression randomly, you can use [Rex](https://www.microsoft.com/research/project/rex-regular-expression-exploration/), which is a regular expression exploration tool from Microsoft Research.</span></span>

## <a name="handle-object-instantiation-appropriately"></a><span data-ttu-id="e730f-142">Gestire la creazione di istanze degli oggetti in modo appropriato</span><span class="sxs-lookup"><span data-stu-id="e730f-142">Handle object instantiation appropriately</span></span>

<span data-ttu-id="e730f-143">Il modello a oggetti delle espressioni regolari di .NET è basato sulla classe <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType>, che rappresenta il motore delle espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="e730f-143">At the heart of .NET’s regular expression object model is the <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class, which represents the regular expression engine.</span></span> <span data-ttu-id="e730f-144">Il fattore principale che spesso influisce sulle prestazioni delle espressioni regolari è il modo in cui viene utilizzato il motore <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="e730f-144">Often, the single greatest factor that affects regular expression performance is the way in which the <xref:System.Text.RegularExpressions.Regex> engine is used.</span></span> <span data-ttu-id="e730f-145">Per definire un'espressione regolare è necessario associare il motore delle espressioni regolari a un modello di espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="e730f-145">Defining a regular expression involves tightly coupling the regular expression engine with a regular expression pattern.</span></span> <span data-ttu-id="e730f-146">Tale processo di associazione, indipendentemente dal fatto che comporti la creazione di un'istanza di un oggetto <xref:System.Text.RegularExpressions.Regex> passando al relativo costruttore un modello di espressione regolare o la chiamata a un metodo statico passando il modello di espressione regolare con una stringa da analizzare, è necessariamente dispendioso.</span><span class="sxs-lookup"><span data-stu-id="e730f-146">That coupling process, whether it involves instantiating a <xref:System.Text.RegularExpressions.Regex> object by passing its constructor a regular expression pattern or calling a static method by passing it the regular expression pattern along with the string to be analyzed, is by necessity an expensive one.</span></span>

> [!NOTE]
> <span data-ttu-id="e730f-147">Per informazioni più dettagliate sull'impatto che può avere l'uso delle espressioni regolari interpretate e compilate sulle prestazioni, vedere [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) (Ottimizzazione delle prestazioni delle espressioni regolari, Parte II: Controllo del backtracking) nel blog del team BCL.</span><span class="sxs-lookup"><span data-stu-id="e730f-147">For a more detailed discussion of the performance implications of using interpreted and compiled regular expressions, see [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) in the BCL Team blog.</span></span>

<span data-ttu-id="e730f-148">È possibile associare il motore delle espressioni regolari a un modello di espressione regolare specifico e quindi usare il motore per trovare una corrispondenza con il testo in diversi modi:</span><span class="sxs-lookup"><span data-stu-id="e730f-148">You can couple the regular expression engine with a particular regular expression pattern and then use the engine to match text in several ways:</span></span>

- <span data-ttu-id="e730f-149">È possibile chiamare un metodo statico di corrispondenza dei modelli, ad esempio <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e730f-149">You can call a static pattern-matching method, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e730f-150">Non è richiesta la creazione di un'istanza di un oggetto di espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="e730f-150">This does not require instantiation of a regular expression object.</span></span>

- <span data-ttu-id="e730f-151">È possibile creare un'istanza di un oggetto <xref:System.Text.RegularExpressions.Regex> e chiamare un metodo di corrispondenza dei modelli dell'istanza di un'espressione regolare interpretata.</span><span class="sxs-lookup"><span data-stu-id="e730f-151">You can instantiate a <xref:System.Text.RegularExpressions.Regex> object and call an instance pattern-matching method of an interpreted regular expression.</span></span> <span data-ttu-id="e730f-152">È il metodo predefinito per associare il motore delle espressioni regolari a un modello di espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="e730f-152">This is the default method for binding the regular expression engine to a regular expression pattern.</span></span> <span data-ttu-id="e730f-153">Viene utilizzato quando l'istanza di un oggetto <xref:System.Text.RegularExpressions.Regex> viene creata senza un argomento `options` che include il flag <xref:System.Text.RegularExpressions.RegexOptions.Compiled>.</span><span class="sxs-lookup"><span data-stu-id="e730f-153">It results when a <xref:System.Text.RegularExpressions.Regex> object is instantiated without an `options` argument that includes the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flag.</span></span>

- <span data-ttu-id="e730f-154">È possibile creare un'istanza di un oggetto <xref:System.Text.RegularExpressions.Regex> e chiamare un metodo di corrispondenza dei modelli dell'istanza di un'espressione regolare compilata.</span><span class="sxs-lookup"><span data-stu-id="e730f-154">You can instantiate a <xref:System.Text.RegularExpressions.Regex> object and call an instance pattern-matching method of a compiled regular expression.</span></span> <span data-ttu-id="e730f-155">Gli oggetti di espressioni regolari rappresentano i modelli compilati quando l'istanza di un oggetto <xref:System.Text.RegularExpressions.Regex> viene creata con un argomento `options` che include il flag <xref:System.Text.RegularExpressions.RegexOptions.Compiled>.</span><span class="sxs-lookup"><span data-stu-id="e730f-155">Regular expression objects represent compiled patterns when a <xref:System.Text.RegularExpressions.Regex> object is instantiated with an `options` argument that includes the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flag.</span></span>

- <span data-ttu-id="e730f-156">È possibile creare un oggetto <xref:System.Text.RegularExpressions.Regex> specifico strettamente associato a un modello di espressione regolare specifico, compilarlo e salvarlo in un assembly autonomo.</span><span class="sxs-lookup"><span data-stu-id="e730f-156">You can create a special-purpose <xref:System.Text.RegularExpressions.Regex> object that is tightly coupled with a particular regular expression pattern, compile it, and save it to a standalone assembly.</span></span> <span data-ttu-id="e730f-157">A tale scopo, è possibile chiamare il metodo <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e730f-157">You do this by calling the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="e730f-158">La modalità utilizzata per chiamare i metodi di corrispondenza delle espressioni regolari può avere un impatto notevole sull'applicazione.</span><span class="sxs-lookup"><span data-stu-id="e730f-158">The particular way in which you call regular expression matching methods can have a significant impact on your application.</span></span> <span data-ttu-id="e730f-159">Nelle sezioni seguenti viene illustrato quando utilizzare le chiamate al metodo statico, le espressioni regolari interpretate e le espressioni regolari compilate per migliorare le prestazioni dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="e730f-159">The following sections discuss when to use static method calls, interpreted regular expressions, and compiled regular expressions to improve your application's performance.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="e730f-160">Il formato della chiamata al metodo (statico, interpretato, compilato) influisce sulle prestazioni se la stessa espressione regolare viene utilizzata più volte nelle chiamate al metodo oppure se in un'applicazione vengono utilizzati spesso gli oggetti di espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="e730f-160">The form of the method call (static, interpreted, compiled) affects performance if the same regular expression is used repeatedly in method calls, or if an application makes extensive use of regular expression objects.</span></span>

### <a name="static-regular-expressions"></a><span data-ttu-id="e730f-161">Espressioni regolari statiche</span><span class="sxs-lookup"><span data-stu-id="e730f-161">Static regular expressions</span></span>

<span data-ttu-id="e730f-162">I metodi con espressioni regolari statiche sono consigliati come alternativa alla creazione ripetuta di un'istanza di un oggetto di espressione regolare con la stessa espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="e730f-162">Static regular expression methods are recommended as an alternative to repeatedly instantiating a regular expression object with the same regular expression.</span></span> <span data-ttu-id="e730f-163">A differenza dei modelli di espressione regolare usati dagli oggetti di espressione regolare, i codici operativi o il linguaggio MSIL (Microsoft Intermediate Language) compilato dei modelli usati nelle chiamate al metodo statico vengono memorizzati nella cache interna dal motore delle espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="e730f-163">Unlike regular expression patterns used by regular expression objects, either the operation codes or the compiled Microsoft intermediate language (MSIL) from patterns used in static method calls is cached internally by the regular expression engine.</span></span>

<span data-ttu-id="e730f-164">Ad esempio, un gestore eventi chiama frequentemente un altro metodo per convalidare l'input dell'utente.</span><span class="sxs-lookup"><span data-stu-id="e730f-164">For example, an event handler frequently calls another method to validate user input.</span></span> <span data-ttu-id="e730f-165">Tale situazione viene riportata nel codice seguente, in cui l'evento <xref:System.Windows.Forms.Button> di un controllo <xref:System.Windows.Forms.Control.Click> viene utilizzato per chiamare un metodo denominato `IsValidCurrency`, che controlla se l'utente ha immesso un simbolo di valuta seguito da almeno una cifra decimale.</span><span class="sxs-lookup"><span data-stu-id="e730f-165">This is reflected in the following code, in which a <xref:System.Windows.Forms.Button> control's <xref:System.Windows.Forms.Control.Click> event is used to call a method named `IsValidCurrency`, which checks whether the user has entered a currency symbol followed by at least one decimal digit.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static1.cs#2)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static1.vb#2)]

<span data-ttu-id="e730f-166">Nell'esempio seguente viene illustrata un'implementazione molto inefficiente del metodo `IsValidCurrency`.</span><span class="sxs-lookup"><span data-stu-id="e730f-166">A very inefficient implementation of the `IsValidCurrency` method is shown in the following example.</span></span> <span data-ttu-id="e730f-167">Si noti che ogni chiamata al metodo crea una nuova istanza dell'oggetto <xref:System.Text.RegularExpressions.Regex> con lo stesso modello.</span><span class="sxs-lookup"><span data-stu-id="e730f-167">Note that each method call reinstantiates a <xref:System.Text.RegularExpressions.Regex> object with the same pattern.</span></span> <span data-ttu-id="e730f-168">Di conseguenza, il modello di espressione regolare deve essere ricompilato ogni volta che viene chiamato il metodo.</span><span class="sxs-lookup"><span data-stu-id="e730f-168">This, in turn, means that the regular expression pattern must be recompiled each time the method is called.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static1.cs#3)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static1.vb#3)]

<span data-ttu-id="e730f-169">È consigliabile sostituire questo codice inefficiente con una chiamata al metodo statico <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e730f-169">You should replace this inefficient code with a call to the static <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="e730f-170">In tal modo si evita di dover creare un'istanza di un oggetto <xref:System.Text.RegularExpressions.Regex> ogni volta che si desidera chiamare un metodo di corrispondenza dei modelli e si consente al motore delle espressioni regolari di recuperare una versione compilata dell'espressione regolare dalla cache.</span><span class="sxs-lookup"><span data-stu-id="e730f-170">This eliminates the need to instantiate a <xref:System.Text.RegularExpressions.Regex> object each time you want to call a pattern-matching method, and enables the regular expression engine to retrieve a compiled version of the regular expression from its cache.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static2.cs#4)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static2.vb#4)]

<span data-ttu-id="e730f-171">Per impostazione predefinita, nella cache vengono memorizzati gli ultimi 15 modelli di espressione regolare statica usati più di recente.</span><span class="sxs-lookup"><span data-stu-id="e730f-171">By default, the last 15 most recently used static regular expression patterns are cached.</span></span> <span data-ttu-id="e730f-172">Per le applicazioni che richiedono un numero maggiore di espressioni regolari statiche memorizzate nella cache, la dimensione della cache può essere modificata impostando la proprietà <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e730f-172">For applications that require a larger number of cached static regular expressions, the size of the cache can be adjusted by setting the <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> property.</span></span>

<span data-ttu-id="e730f-173">L'espressione regolare `\p{Sc}+\s*\d+` usata in questo esempio verifica che la stringa di input sia costituita da un simbolo di valuta e da almeno una cifra decimale.</span><span class="sxs-lookup"><span data-stu-id="e730f-173">The regular expression `\p{Sc}+\s*\d+` that is used in this example verifies that the input string consists of a currency symbol and at least one decimal digit.</span></span> <span data-ttu-id="e730f-174">Il modello viene definito come illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="e730f-174">The pattern is defined as shown in the following table.</span></span>

|<span data-ttu-id="e730f-175">Modello</span><span class="sxs-lookup"><span data-stu-id="e730f-175">Pattern</span></span>|<span data-ttu-id="e730f-176">Descrizione</span><span class="sxs-lookup"><span data-stu-id="e730f-176">Description</span></span>|
|-------------|-----------------|
|`\p{Sc}+`|<span data-ttu-id="e730f-177">Trova la corrispondenza di uno o più caratteri nella categoria Unicode Symbol, Currency.</span><span class="sxs-lookup"><span data-stu-id="e730f-177">Match one or more characters in the Unicode Symbol, Currency category.</span></span>|
|`\s*`|<span data-ttu-id="e730f-178">Trovare la corrispondenza di zero o più spazi vuoti.</span><span class="sxs-lookup"><span data-stu-id="e730f-178">Match zero or more white-space characters.</span></span>|
|`\d+`|<span data-ttu-id="e730f-179">Trova la corrispondenza con una o più cifre decimali.</span><span class="sxs-lookup"><span data-stu-id="e730f-179">Match one or more decimal digits.</span></span>|

### <a name="interpreted-vs-compiled-regular-expressions"></a><span data-ttu-id="e730f-180">Espressioni regolari interpretate ed espressioni regolari compilate</span><span class="sxs-lookup"><span data-stu-id="e730f-180">Interpreted vs. compiled regular expressions</span></span>

<span data-ttu-id="e730f-181">I modelli di espressione regolare che non sono associati al motore delle espressioni mediante l'opzione <xref:System.Text.RegularExpressions.RegexOptions.Compiled> vengono interpretati.</span><span class="sxs-lookup"><span data-stu-id="e730f-181">Regular expression patterns that are not bound to the regular expression engine through the specification of the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> option are interpreted.</span></span> <span data-ttu-id="e730f-182">Quando viene creata un'istanza di un oggetto di espressione regolare, il motore delle espressioni regolari converte l'espressione regolare in un set di codici operativi.</span><span class="sxs-lookup"><span data-stu-id="e730f-182">When a regular expression object is instantiated, the regular expression engine converts the regular expression to a set of operation codes.</span></span> <span data-ttu-id="e730f-183">Quando viene chiamato un metodo di istanza, i codici operativi vengono convertiti in MSIL ed eseguiti dal compilatore JIT.</span><span class="sxs-lookup"><span data-stu-id="e730f-183">When an instance method is called, the operation codes are converted to MSIL and executed by the JIT compiler.</span></span> <span data-ttu-id="e730f-184">Analogamente, quando viene chiamato un metodo con espressioni regolari statiche e l'espressione regolare non è presente nella cache, il motore delle espressioni regolari converte l'espressione regolare in un set di codici operativi che memorizza nella cache.</span><span class="sxs-lookup"><span data-stu-id="e730f-184">Similarly, when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to a set of operation codes and stores them in the cache.</span></span> <span data-ttu-id="e730f-185">Converte quindi i codici operativi in MSIL in modo tale che possano essere eseguiti dal compilatore JIT.</span><span class="sxs-lookup"><span data-stu-id="e730f-185">It then converts these operation codes to MSIL so that the JIT compiler can execute them.</span></span> <span data-ttu-id="e730f-186">Le espressioni regolari interpretate consentono di ridurre il tempo di avvio ma implicano tempi di esecuzione più lenti.</span><span class="sxs-lookup"><span data-stu-id="e730f-186">Interpreted regular expressions reduce startup time at the cost of slower execution time.</span></span> <span data-ttu-id="e730f-187">Per questo motivo, risultano particolarmente adatte quando l'espressione regolare viene utilizzata in un numero limitato di chiamate al metodo o se il numero esatto di chiamate ai metodi delle espressioni regolari è sconosciuto ma si prevede che sia esiguo.</span><span class="sxs-lookup"><span data-stu-id="e730f-187">Because of this, they are best used when the regular expression is used in a small number of method calls, or if the exact number of calls to regular expression methods is unknown but is expected to be small.</span></span> <span data-ttu-id="e730f-188">Man mano che aumenta il numero di chiamate al metodo, il miglioramento delle prestazioni rispetto alla riduzione del tempo di avvio viene superato dalla minore velocità di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="e730f-188">As the number of method calls increases, the performance gain from reduced startup time is outstripped by the slower execution speed.</span></span>

<span data-ttu-id="e730f-189">I modelli di espressione regolare che sono associati al motore delle espressioni regolari mediante l'opzione <xref:System.Text.RegularExpressions.RegexOptions.Compiled> vengono compilati.</span><span class="sxs-lookup"><span data-stu-id="e730f-189">Regular expression patterns that are bound to the regular expression engine through the specification of the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> option are compiled.</span></span> <span data-ttu-id="e730f-190">Ciò significa che quando viene creata un'istanza di un oggetto di espressione regolare o quando viene chiamato un metodo con espressioni regolari statiche e l'espressione regolare non è presente nella cache, il motore delle espressioni regolari converte l'espressione regolare in un set intermedio di codici operativi, il quale viene quindi convertito in MSIL.</span><span class="sxs-lookup"><span data-stu-id="e730f-190">This means that, when a regular expression object is instantiated, or when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to an intermediary set of operation codes, which it then converts to MSIL.</span></span> <span data-ttu-id="e730f-191">Il codice MSIL viene eseguito dal compilatore JIT non appena viene chiamato un metodo.</span><span class="sxs-lookup"><span data-stu-id="e730f-191">When a method is called, the JIT compiler executes the MSIL.</span></span> <span data-ttu-id="e730f-192">A differenza delle espressioni regolari interpretate, le espressioni regolari compilate aumentano il tempo di avvio eseguendo i singoli metodi di corrispondenza dei modelli più velocemente.</span><span class="sxs-lookup"><span data-stu-id="e730f-192">In contrast to interpreted regular expressions, compiled regular expressions increase startup time but execute individual pattern-matching methods faster.</span></span> <span data-ttu-id="e730f-193">Di conseguenza, il vantaggio in termini di prestazioni che risulta dalla compilazione dell'espressione regolare aumenta proporzionalmente al numero di metodi dell'espressione regolare chiamati.</span><span class="sxs-lookup"><span data-stu-id="e730f-193">As a result, the performance benefit that results from compiling the regular expression increases in proportion to the number of regular expression methods called.</span></span>

<span data-ttu-id="e730f-194">Riepilogando, è consigliabile utilizzare le espressioni regolari interpretate quando i metodi dell'espressione regolare vengono chiamati raramente con un'espressione regolare specifica</span><span class="sxs-lookup"><span data-stu-id="e730f-194">To summarize, we recommend that you use interpreted regular expressions when you call regular expression methods with a specific regular expression relatively infrequently.</span></span> <span data-ttu-id="e730f-195">e le espressioni regolari compilate quando i metodi dell'espressione regolare vengono chiamati frequentemente con un'espressione regolare specifica.</span><span class="sxs-lookup"><span data-stu-id="e730f-195">You should use compiled regular expressions when you call regular expression methods with a specific regular expression relatively frequently.</span></span> <span data-ttu-id="e730f-196">È difficile determinare la soglia esatta oltre la quale la minore velocità di esecuzione delle espressioni regolari interpretate supera i vantaggi offerti dalla riduzione del tempo di avvio o la soglia oltre la quale la riduzione del tempo di avvio delle espressioni regolari compilate supera i vantaggi offerti dalla maggiore velocità di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="e730f-196">The exact threshold at which the slower execution speeds of interpreted regular expressions outweigh gains from their reduced startup time, or the threshold at which the slower startup times of compiled regular expressions outweigh gains from their faster execution speeds, is difficult to determine.</span></span> <span data-ttu-id="e730f-197">Dipende da vari fattori, tra cui la complessità dell'espressione regolare e i dati specifici che vengono elaborati.</span><span class="sxs-lookup"><span data-stu-id="e730f-197">It depends on a variety of factors, including the complexity of the regular expression and the specific data that it processes.</span></span> <span data-ttu-id="e730f-198">Per determinare se le espressioni regolari interpretate o compilate offrono le migliori prestazioni per lo scenario specifico dell'applicazione, è possibile utilizzare la classe <xref:System.Diagnostics.Stopwatch> per confrontare i rispettivi tempi di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="e730f-198">To determine whether interpreted or compiled regular expressions offer the best performance for your particular application scenario, you can use the <xref:System.Diagnostics.Stopwatch> class to compare their execution times.</span></span>

<span data-ttu-id="e730f-199">Nell'esempio seguente vengono confrontate le prestazioni delle espressioni regolari compilate e interpretate durante la lettura delle prime dieci frasi e durante la lettura di tutte le frasi del testo di *The Financier* di Theodore Dreiser.</span><span class="sxs-lookup"><span data-stu-id="e730f-199">The following example compares the performance of compiled and interpreted regular expressions when reading the first ten sentences and when reading all the sentences in the text of Theodore Dreiser's *The Financier*.</span></span> <span data-ttu-id="e730f-200">Come illustrato nell'output dell'esempio, quando vengono effettuate solo dieci chiamate ai metodi di corrispondenza delle espressioni regolari, un'espressione regolare interpretata offre prestazioni migliori rispetto a un'espressione regolare compilata.</span><span class="sxs-lookup"><span data-stu-id="e730f-200">As the output from the example shows, when only ten calls are made to regular expression matching methods, an interpreted regular expression offers better performance than a compiled regular expression.</span></span> <span data-ttu-id="e730f-201">Tuttavia, un'espressione regolare compilata offre prestazioni migliori quando viene effettuato un numero di chiamate maggiore, in questo caso oltre 13.000.</span><span class="sxs-lookup"><span data-stu-id="e730f-201">However, a compiled regular expression offers better performance when a large number of calls (in this case, over 13,000) are made.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compare1.cs#5)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compare1.vb#5)]

<span data-ttu-id="e730f-202">Il criterio di espressione regolare usato nell'esempio, `\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`, è definito nel modo illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="e730f-202">The regular expression pattern used in the example, `\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`, is defined as shown in the following table.</span></span>

|<span data-ttu-id="e730f-203">Modello</span><span class="sxs-lookup"><span data-stu-id="e730f-203">Pattern</span></span>|<span data-ttu-id="e730f-204">Descrizione</span><span class="sxs-lookup"><span data-stu-id="e730f-204">Description</span></span>|
|-------------|-----------------|
|`\b`|<span data-ttu-id="e730f-205">Inizia la corrispondenza sul confine di parola.</span><span class="sxs-lookup"><span data-stu-id="e730f-205">Begin the match at a word boundary.</span></span>|
|`\w+`|<span data-ttu-id="e730f-206">Trova la corrispondenza di uno o più caratteri alfanumerici.</span><span class="sxs-lookup"><span data-stu-id="e730f-206">Match one or more word characters.</span></span>|
|<code>(\r?\n)&#124;,?\s)</code>|<span data-ttu-id="e730f-207">Trova la corrispondenza di uno o nessun ritorno a capo seguito da un carattere di nuova riga o di una o nessuna virgola seguita da uno spazio vuoto.</span><span class="sxs-lookup"><span data-stu-id="e730f-207">Match either zero or one carriage return followed by a newline character, or zero or one comma followed by a white-space character.</span></span>|
|<code>(\w+((\r?\n)&#124;,?\s))*</code>|<span data-ttu-id="e730f-208">Trova la corrispondenza di zero o più occorrenze di uno o più caratteri alfanumerici seguiti da uno o nessun ritorno a capo e un carattere di nuova riga o da una o nessuna virgola seguita da uno spazio vuoto.</span><span class="sxs-lookup"><span data-stu-id="e730f-208">Match zero or more occurrences of one or more word characters that are followed either by zero or one carriage return and a newline character, or by zero or one comma followed by a white-space character.</span></span>|
|`\w+`|<span data-ttu-id="e730f-209">Trova la corrispondenza di uno o più caratteri alfanumerici.</span><span class="sxs-lookup"><span data-stu-id="e730f-209">Match one or more word characters.</span></span>|
|`[.?:;!]`|<span data-ttu-id="e730f-210">Trova la corrispondenza di un punto, un punto interrogativo, due punti, un punto e virgola o un punto esclamativo.</span><span class="sxs-lookup"><span data-stu-id="e730f-210">Match a period, question mark, colon, semicolon, or exclamation point.</span></span>|

### <a name="regular-expressions-compiled-to-an-assembly"></a><span data-ttu-id="e730f-211">Espressioni regolari: compilate in un assembly</span><span class="sxs-lookup"><span data-stu-id="e730f-211">Regular expressions: Compiled to an assembly</span></span>

<span data-ttu-id="e730f-212">.NET consente anche di creare un assembly che contiene le espressioni regolari compilate.</span><span class="sxs-lookup"><span data-stu-id="e730f-212">.NET also enables you to create an assembly that contains compiled regular expressions.</span></span> <span data-ttu-id="e730f-213">In questo modo il calo di prestazioni della compilazione delle espressioni regolari viene spostato dalla fase di esecuzione alla fase di progettazione.</span><span class="sxs-lookup"><span data-stu-id="e730f-213">This moves the performance hit of regular expression compilation from run time to design time.</span></span> <span data-ttu-id="e730f-214">Vengono tuttavia richieste alcune operazioni aggiuntive: è necessario definire in anticipo le espressioni regolari e compilarle in un assembly.</span><span class="sxs-lookup"><span data-stu-id="e730f-214">However, it also involves some additional work: You must define the regular expressions in advance and compile them to an assembly.</span></span> <span data-ttu-id="e730f-215">Il compilatore può quindi fare riferimento all'assembly durante la compilazione del codice sorgente che utilizza le espressioni regolari dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="e730f-215">The compiler can then reference this assembly when compiling source code that uses the assembly’s regular expressions.</span></span> <span data-ttu-id="e730f-216">Ogni espressione regolare compilata inclusa nell'assembly viene rappresentata da una classe derivata da <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="e730f-216">Each compiled regular expression in the assembly is represented by a class that derives from <xref:System.Text.RegularExpressions.Regex>.</span></span>

<span data-ttu-id="e730f-217">Per compilare le espressioni regolari in un assembly, è necessario chiamare il metodo <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29?displayProperty=nameWithType> e passare una matrice di oggetti <xref:System.Text.RegularExpressions.RegexCompilationInfo> che rappresentano le espressioni regolari da compilare e un oggetto <xref:System.Reflection.AssemblyName> che contiene le informazioni sull'assembly da creare.</span><span class="sxs-lookup"><span data-stu-id="e730f-217">To compile regular expressions to an assembly, you call the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29?displayProperty=nameWithType> method and pass it an array of <xref:System.Text.RegularExpressions.RegexCompilationInfo> objects that represent the regular expressions to be compiled, and an <xref:System.Reflection.AssemblyName> object that contains information about the assembly to be created.</span></span>

<span data-ttu-id="e730f-218">È consigliabile compilare le espressioni regolari in un assembly nelle situazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="e730f-218">We recommend that you compile regular expressions to an assembly in the following situations:</span></span>

- <span data-ttu-id="e730f-219">Se si è uno sviluppatore di componenti e si desidera creare una libreria di espressioni regolari riutilizzabili.</span><span class="sxs-lookup"><span data-stu-id="e730f-219">If you are a component developer who wants to create a library of reusable regular expressions.</span></span>

- <span data-ttu-id="e730f-220">Se si prevede di chiamare i metodi di corrispondenza dei modelli delle espressioni regolari un numero indeterminato di volte, da una o due volte a migliaia o decine di migliaia di volte.</span><span class="sxs-lookup"><span data-stu-id="e730f-220">If you expect your regular expression's pattern-matching methods to be called an indeterminate number of times -- anywhere from once or twice to thousands or tens of thousands of times.</span></span> <span data-ttu-id="e730f-221">A differenza delle espressioni regolari compilate o interpretate, le espressioni regolari compilate in assembly separati offrono prestazioni coerenti indipendentemente dal numero di chiamate al metodo.</span><span class="sxs-lookup"><span data-stu-id="e730f-221">Unlike compiled or interpreted regular expressions, regular expressions that are compiled to separate assemblies offer performance that is consistent regardless of the number of method calls.</span></span>

<span data-ttu-id="e730f-222">Se si usano le espressioni regolari compilate per ottimizzare le prestazioni, è consigliabile non usare la reflection per creare l'assembly, caricare il motore delle espressioni regolari ed eseguire i metodi di corrispondenza dei modelli.</span><span class="sxs-lookup"><span data-stu-id="e730f-222">If you are using compiled regular expressions to optimize performance, you should not use reflection to create the assembly, load the regular expression engine, and execute its pattern-matching methods.</span></span> <span data-ttu-id="e730f-223">A tale scopo occorre evitare di compilare i modelli di espressione regolare in modo dinamico e occorre specificare le opzioni di corrispondenza dei modelli, ad esempio la corrispondenza dei modelli senza distinzione tra maiuscole e minuscole, al momento della creazione dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="e730f-223">This requires that you avoid building regular expression patterns dynamically, and that you specify any pattern-matching options (such as case-insensitive pattern matching) at the time the assembly is created.</span></span> <span data-ttu-id="e730f-224">È inoltre necessario separare il codice mediante cui viene creato l'assembly dal codice che utilizza l'espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="e730f-224">It also requires that you separate the code that creates the assembly from the code that uses the regular expression.</span></span>

<span data-ttu-id="e730f-225">Nell'esempio seguente viene illustrato come creare un assembly contenente un'espressione regolare compilata.</span><span class="sxs-lookup"><span data-stu-id="e730f-225">The following example shows how to create an assembly that contains a compiled regular expression.</span></span> <span data-ttu-id="e730f-226">Viene creato un assembly denominato `RegexLib.dll` con una singola classe di espressioni regolari, `SentencePattern` , che contiene il modello di espressione regolare per la corrispondenza delle frasi usato nella sezione [confronto tra espressioni regolari interpretate e compilate](#interpreted-vs-compiled-regular-expressions) .</span><span class="sxs-lookup"><span data-stu-id="e730f-226">It creates an assembly named `RegexLib.dll` with a single regular expression class, `SentencePattern`, that contains the sentence-matching regular expression pattern used in the [Interpreted vs. Compiled Regular Expressions](#interpreted-vs-compiled-regular-expressions) section.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compile1.cs#6)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compile1.vb#6)]

<span data-ttu-id="e730f-227">Quando l'esempio viene compilato in un eseguibile ed eseguito, viene creato un assembly denominato `RegexLib.dll`.</span><span class="sxs-lookup"><span data-stu-id="e730f-227">When the example is compiled to an executable and run, it creates an assembly named `RegexLib.dll`.</span></span> <span data-ttu-id="e730f-228">L'espressione regolare viene rappresentata da una classe denominata `Utilities.RegularExpressions.SentencePattern` derivata da <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="e730f-228">The regular expression is represented by a class named `Utilities.RegularExpressions.SentencePattern` that is derived from <xref:System.Text.RegularExpressions.Regex>.</span></span> <span data-ttu-id="e730f-229">Nell'esempio seguente viene quindi usata l'espressione regolare compilata per estrarre le frasi dal testo di *The Financier* di Theodore Dreiser.</span><span class="sxs-lookup"><span data-stu-id="e730f-229">The following example then uses the compiled regular expression to extract the sentences from the text of Theodore Dreiser's *The Financier*.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compile2.cs#7)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compile2.vb#7)]

## <a name="take-charge-of-backtracking"></a><span data-ttu-id="e730f-230">Assumere il controllo del backtracking</span><span class="sxs-lookup"><span data-stu-id="e730f-230">Take charge of backtracking</span></span>

<span data-ttu-id="e730f-231">In genere, il motore delle espressioni regolari usa la progressione lineare per spostarsi in una stringa di input e confrontarla con un modello di espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="e730f-231">Ordinarily, the regular expression engine uses linear progression to move through an input string and compare it to a regular expression pattern.</span></span> <span data-ttu-id="e730f-232">Tuttavia, quando in un modello di espressione regolare vengono usati quantificatori indeterminati come `*`, `+` e `?`, il motore delle espressioni regolari può tralasciare una parte delle corrispondenze parziali corrette e tornare a uno stato salvato in precedenza per cercare una corrispondenza corretta per l'intero modello.</span><span class="sxs-lookup"><span data-stu-id="e730f-232">However, when indeterminate quantifiers such as `*`, `+`, and `?` are used in a regular expression pattern, the regular expression engine may give up a portion of successful partial matches and return to a previously saved state in order to search for a successful match for the entire pattern.</span></span> <span data-ttu-id="e730f-233">Questo processo è noto come backtracking.</span><span class="sxs-lookup"><span data-stu-id="e730f-233">This process is known as backtracking.</span></span>

> [!NOTE]
> <span data-ttu-id="e730f-234">Per altre informazioni sul backtracking, vedere [Dettagli sul comportamento delle espressioni regolari](details-of-regular-expression-behavior.md) e [Backtracking](backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="e730f-234">For more information on backtracking, see [Details of Regular Expression Behavior](details-of-regular-expression-behavior.md) and [Backtracking](backtracking-in-regular-expressions.md).</span></span> <span data-ttu-id="e730f-235">Per informazioni più dettagliate sul backtracking, vedere [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) (Ottimizzazione delle prestazioni delle espressioni regolari, Parte II: Controllo del backtracking) sul blog del team BCL.</span><span class="sxs-lookup"><span data-stu-id="e730f-235">For a detailed discussion of backtracking, see [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) in the BCL Team blog.</span></span>

<span data-ttu-id="e730f-236">Il supporto del backtracking fornisce alle espressioni regolari potenza e flessibilità.</span><span class="sxs-lookup"><span data-stu-id="e730f-236">Support for backtracking gives regular expressions power and flexibility.</span></span> <span data-ttu-id="e730f-237">Inoltre la responsabilità del controllo del funzionamento del motore delle espressioni regolari viene affidata agli sviluppatori delle espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="e730f-237">It also places the responsibility for controlling the operation of the regular expression engine in the hands of regular expression developers.</span></span> <span data-ttu-id="e730f-238">Poiché spesso gli sviluppatori non sono consapevoli di questa responsabilità, un utilizzo improprio del backtracking o un utilizzo eccessivo del backtracking rappresenta spesso la causa principale della riduzione delle prestazioni delle espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="e730f-238">Because developers are often not aware of this responsibility, their misuse of backtracking or reliance on excessive backtracking often plays the most significant role in degrading regular expression performance.</span></span> <span data-ttu-id="e730f-239">Nello scenario peggiore, il tempo di esecuzione può raddoppiarsi per ogni carattere aggiuntivo nella stringa di input.</span><span class="sxs-lookup"><span data-stu-id="e730f-239">In a worst-case scenario, execution time can double for each additional character in the input string.</span></span> <span data-ttu-id="e730f-240">Utilizzando infatti il backtracking in modo eccessivo, è facile creare l'equivalente a livello di codice di un ciclo infinito se l'input corrisponde quasi al modello di espressione regolare. Il motore delle espressioni regolari può richiedere ore o persino giorni per l'elaborazione di una stringa di input relativamente breve.</span><span class="sxs-lookup"><span data-stu-id="e730f-240">In fact, by using backtracking excessively, it is easy to create the programmatic equivalent of an endless loop if input nearly matches the regular expression pattern; the regular expression engine may take hours or even days to process a relatively short input string.</span></span>

<span data-ttu-id="e730f-241">L'utilizzo del backtracking comporta spesso una riduzione delle prestazioni delle applicazioni sebbene il backtracking non sia essenziale per una corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="e730f-241">Often, applications pay a performance penalty for using backtracking despite the fact that backtracking is not essential for a match.</span></span> <span data-ttu-id="e730f-242">Ad esempio, l'espressione regolare `\b\p{Lu}\w*\b` cerca una corrispondenza di tutte le parole che iniziano con un carattere maiuscolo, come illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="e730f-242">For example, the regular expression `\b\p{Lu}\w*\b` matches all words that begin with an uppercase character, as the following table shows.</span></span>

|<span data-ttu-id="e730f-243">Modello</span><span class="sxs-lookup"><span data-stu-id="e730f-243">Pattern</span></span>|<span data-ttu-id="e730f-244">Descrizione</span><span class="sxs-lookup"><span data-stu-id="e730f-244">Description</span></span>|
|-|-|
|`\b`|<span data-ttu-id="e730f-245">Inizia la corrispondenza sul confine di parola.</span><span class="sxs-lookup"><span data-stu-id="e730f-245">Begin the match at a word boundary.</span></span>|
|`\p{Lu}`|<span data-ttu-id="e730f-246">Trova la corrispondenza di un carattere maiuscolo.</span><span class="sxs-lookup"><span data-stu-id="e730f-246">Match an uppercase character.</span></span>|
|`\w*`|<span data-ttu-id="e730f-247">Trova la corrispondenza di zero o più caratteri alfanumerici.</span><span class="sxs-lookup"><span data-stu-id="e730f-247">Match zero or more word characters.</span></span>|
|`\b`|<span data-ttu-id="e730f-248">Termina la corrispondenza sul confine di parola.</span><span class="sxs-lookup"><span data-stu-id="e730f-248">End the match at a word boundary.</span></span>|

<span data-ttu-id="e730f-249">Poiché un confine di parola non è uguale a un carattere alfanumerico né è un subset di tali caratteri, non è possibile che il motore delle espressioni regolari attraversi un confine di parola quando viene trovata una corrispondenza con i caratteri alfanumerici.</span><span class="sxs-lookup"><span data-stu-id="e730f-249">Because a word boundary is not the same as, or a subset of, a word character, there is no possibility that the regular expression engine will cross a word boundary when matching word characters.</span></span> <span data-ttu-id="e730f-250">Ciò significa che per questa espressione regolare, il backtracking non potrà mai contribuire alla riuscita dell'operazione ma potrà solo ridurre le prestazioni poiché il motore delle espressioni regolari deve salvare lo stato per ogni corrispondenza preliminare corretta di un carattere alfanumerico.</span><span class="sxs-lookup"><span data-stu-id="e730f-250">This means that for this regular expression, backtracking can never contribute to the overall success of any match -- it can only degrade performance, because the regular expression engine is forced to save its state for each successful preliminary match of a word character.</span></span>

<span data-ttu-id="e730f-251">Se si determina che il backtracking non è necessario, è possibile disabilitarlo usando l' `(?>subexpression)` elemento del linguaggio, noto come gruppo atomico.</span><span class="sxs-lookup"><span data-stu-id="e730f-251">If you determine that backtracking is not necessary, you can disable it by using the `(?>subexpression)` language element, known as an atomic group.</span></span> <span data-ttu-id="e730f-252">Nell'esempio seguente viene analizzata una stringa di input utilizzando due espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="e730f-252">The following example parses an input string by using two regular expressions.</span></span> <span data-ttu-id="e730f-253">La prima, `\b\p{Lu}\w*\b`, si basa sul backtracking.</span><span class="sxs-lookup"><span data-stu-id="e730f-253">The first, `\b\p{Lu}\w*\b`, relies on backtracking.</span></span> <span data-ttu-id="e730f-254">La seconda, `\b\p{Lu}(?>\w*)\b`, disabilita il backtracking.</span><span class="sxs-lookup"><span data-stu-id="e730f-254">The second, `\b\p{Lu}(?>\w*)\b`, disables backtracking.</span></span> <span data-ttu-id="e730f-255">Come illustrato nell'output dell'esempio, entrambe producono lo stesso risultato.</span><span class="sxs-lookup"><span data-stu-id="e730f-255">As the output from the example shows, they both produce the same result.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/backtrack2.cs#10)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/backtrack2.vb#10)]

<span data-ttu-id="e730f-256">In molti casi, il backtracking è essenziale per la corrispondenza di un modello di espressione regolare con il testo di input.</span><span class="sxs-lookup"><span data-stu-id="e730f-256">In many cases, backtracking is essential for matching a regular expression pattern to input text.</span></span> <span data-ttu-id="e730f-257">Tuttavia, un utilizzo eccessivo del backtracking può ridurre notevolmente le prestazioni e dare l'impressione che un'applicazione non risponda.</span><span class="sxs-lookup"><span data-stu-id="e730f-257">However, excessive backtracking can severely degrade performance and create the impression that an application has stopped responding.</span></span> <span data-ttu-id="e730f-258">In particolare, tale situazione si verifica quando vengono annidati i quantificatori e il testo che corrisponde alla sottoespressione esterna è un subset del testo che corrisponde alla sottoespressione interna.</span><span class="sxs-lookup"><span data-stu-id="e730f-258">In particular, this happens when quantifiers are nested and the text that matches the outer subexpression is a subset of the text that matches the inner subexpression.</span></span>

> [!WARNING]
> <span data-ttu-id="e730f-259">Oltre a evitare un eccessivo utilizzo del backtracking, è necessario utilizzare la funzionalità di timeout per assicurarsi che l'eccessivo backtracking non comprometta troppo le prestazioni dell'espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="e730f-259">In addition to avoiding excessive backtracking, you should use the timeout feature to ensure that excessive backtracking does not severely degrade regular expression performance.</span></span> <span data-ttu-id="e730f-260">Per altre informazioni, vedere la sezione [usare valori di timeout](#use-time-out-values) .</span><span class="sxs-lookup"><span data-stu-id="e730f-260">For more information, see the [Use Time-out Values](#use-time-out-values) section.</span></span>

<span data-ttu-id="e730f-261">Ad esempio, il criterio di espressione regolare `^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$` viene usato per trovare la corrispondenza con un numero parte costituito da almeno un carattere alfanumerico.</span><span class="sxs-lookup"><span data-stu-id="e730f-261">For example, the regular expression pattern `^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$` is intended to match a part number that consists of at least one alphanumeric character.</span></span> <span data-ttu-id="e730f-262">Tutti i caratteri aggiuntivi possono essere costituiti da un carattere alfanumerico, un trattino, un carattere di sottolineatura o un punto, sebbene l'ultimo carattere debba essere alfanumerico.</span><span class="sxs-lookup"><span data-stu-id="e730f-262">Any additional characters can consist of an alphanumeric character, a hyphen, an underscore, or a period, though the last character must be alphanumeric.</span></span> <span data-ttu-id="e730f-263">Il numero parte termina con il simbolo del dollaro.</span><span class="sxs-lookup"><span data-stu-id="e730f-263">A dollar sign terminates the part number.</span></span> <span data-ttu-id="e730f-264">In alcuni casi, il criterio di espressione regolare può presentare prestazioni estremamente insufficienti perché vengono annidati i quantificatori e perché la sottoespressione `[0-9A-Z]` è un subset della sottoespressione `[-.\w]*`.</span><span class="sxs-lookup"><span data-stu-id="e730f-264">In some cases, this regular expression pattern can exhibit extremely poor performance because quantifiers are nested, and because the subexpression `[0-9A-Z]` is a subset of the subexpression `[-.\w]*`.</span></span>

<span data-ttu-id="e730f-265">In questi casi, è possibile ottimizzare le prestazioni dell'espressione regolare rimuovendo i quantificatori annidati e sostituendo la sottoespressione esterna con un'asserzione lookahead o lookbehind di larghezza zero.</span><span class="sxs-lookup"><span data-stu-id="e730f-265">In these cases, you can optimize regular expression performance by removing the nested quantifiers and replacing the outer subexpression with a zero-width lookahead or lookbehind assertion.</span></span> <span data-ttu-id="e730f-266">Le asserzioni lookahead e lookbehind sono ancoraggi; non spostano il puntatore nella stringa di input, ma eseguono il lookahead e lookbehind per verificare se è stata soddisfatta una condizione specificata.</span><span class="sxs-lookup"><span data-stu-id="e730f-266">Lookahead and lookbehind assertions are anchors; they do not move the pointer in the input string, but instead look ahead or behind to check whether a specified condition is met.</span></span> <span data-ttu-id="e730f-267">Ad esempio, l'espressione regolare del numero parte può essere riscritta come `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$`.</span><span class="sxs-lookup"><span data-stu-id="e730f-267">For example, the part number regular expression can be rewritten as `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$`.</span></span> <span data-ttu-id="e730f-268">Tale modello di espressione regolare viene definito come illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="e730f-268">This regular expression pattern is defined as shown in the following table.</span></span>

|<span data-ttu-id="e730f-269">Modello</span><span class="sxs-lookup"><span data-stu-id="e730f-269">Pattern</span></span>|<span data-ttu-id="e730f-270">Descrizione</span><span class="sxs-lookup"><span data-stu-id="e730f-270">Description</span></span>|
|-------------|-----------------|
|`^`|<span data-ttu-id="e730f-271">Inizia la corrispondenza all'inizio della stringa di input.</span><span class="sxs-lookup"><span data-stu-id="e730f-271">Begin the match at the beginning of the input string.</span></span>|
|`[0-9A-Z]`|<span data-ttu-id="e730f-272">Trova la corrispondenza di un carattere alfanumerico.</span><span class="sxs-lookup"><span data-stu-id="e730f-272">Match an alphanumeric character.</span></span> <span data-ttu-id="e730f-273">Il numero parte deve essere costituito da almeno uno di questi caratteri.</span><span class="sxs-lookup"><span data-stu-id="e730f-273">The part number must consist of at least this character.</span></span>|
|`[-.\w]*`|<span data-ttu-id="e730f-274">Trova la corrispondenza di zero o più occorrenze di un carattere alfanumerico, un trattino o un punto.</span><span class="sxs-lookup"><span data-stu-id="e730f-274">Match zero or more occurrences of any word character, hyphen, or period.</span></span>|
|`\$`|<span data-ttu-id="e730f-275">Trova la corrispondenza di un simbolo del dollaro.</span><span class="sxs-lookup"><span data-stu-id="e730f-275">Match a dollar sign.</span></span>|
|`(?<=[0-9A-Z])`|<span data-ttu-id="e730f-276">Esegue il lookahead del simbolo del dollaro finale per verificare che il carattere precedente sia alfanumerico.</span><span class="sxs-lookup"><span data-stu-id="e730f-276">Look ahead of the ending dollar sign to ensure that the previous character is alphanumeric.</span></span>|
|`$`|<span data-ttu-id="e730f-277">Termina la ricerca della corrispondenza alla fine della stringa di input.</span><span class="sxs-lookup"><span data-stu-id="e730f-277">End the match at the end of the input string.</span></span>|

<span data-ttu-id="e730f-278">Nell'esempio seguente viene illustrato l'utilizzo dell'espressione regolare per trovare la corrispondenza con una matrice contenente i numeri parte possibili.</span><span class="sxs-lookup"><span data-stu-id="e730f-278">The following example illustrates the use of this regular expression to match an array containing possible part numbers.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/backtrack4.cs#11)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/backtrack4.vb#11)]

<span data-ttu-id="e730f-279">Il linguaggio delle espressioni regolari in .NET include i seguenti elementi che è possibile usare per eliminare i quantificatori annidati.</span><span class="sxs-lookup"><span data-stu-id="e730f-279">The regular expression language in .NET includes the following language elements that you can use to eliminate nested quantifiers.</span></span> <span data-ttu-id="e730f-280">Per altre informazioni, vedere [Costrutti di raggruppamento](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="e730f-280">For more information, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

|<span data-ttu-id="e730f-281">Elemento di linguaggio</span><span class="sxs-lookup"><span data-stu-id="e730f-281">Language element</span></span>|<span data-ttu-id="e730f-282">Descrizione</span><span class="sxs-lookup"><span data-stu-id="e730f-282">Description</span></span>|
|----------------------|-----------------|
|<span data-ttu-id="e730f-283">`(?=` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="e730f-283">`(?=` `subexpression` `)`</span></span>|<span data-ttu-id="e730f-284">Asserzione lookahead positiva di larghezza zero.</span><span class="sxs-lookup"><span data-stu-id="e730f-284">Zero-width positive lookahead.</span></span> <span data-ttu-id="e730f-285">Lookahead della posizione corrente per determinare se `subexpression` corrisponde alla stringa di input.</span><span class="sxs-lookup"><span data-stu-id="e730f-285">Look ahead of the current position to determine whether `subexpression` matches the input string.</span></span>|
|<span data-ttu-id="e730f-286">`(?!` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="e730f-286">`(?!` `subexpression` `)`</span></span>|<span data-ttu-id="e730f-287">Asserzione lookahead negativa di larghezza zero.</span><span class="sxs-lookup"><span data-stu-id="e730f-287">Zero-width negative lookahead.</span></span> <span data-ttu-id="e730f-288">Lookahead della posizione corrente per determinare se `subexpression` non corrisponde alla stringa di input.</span><span class="sxs-lookup"><span data-stu-id="e730f-288">Look ahead of the current position to determine whether `subexpression` does not match the input string.</span></span>|
|<span data-ttu-id="e730f-289">`(?<=` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="e730f-289">`(?<=` `subexpression` `)`</span></span>|<span data-ttu-id="e730f-290">Lookbehind positivo di larghezza zero.</span><span class="sxs-lookup"><span data-stu-id="e730f-290">Zero-width positive lookbehind.</span></span> <span data-ttu-id="e730f-291">Lookbehind della posizione corrente per determinare se `subexpression` corrisponde alla stringa di input.</span><span class="sxs-lookup"><span data-stu-id="e730f-291">Look behind the current position to determine whether `subexpression` matches the input string.</span></span>|
|<span data-ttu-id="e730f-292">`(?<!` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="e730f-292">`(?<!` `subexpression` `)`</span></span>|<span data-ttu-id="e730f-293">Lookbehind negativo di larghezza zero.</span><span class="sxs-lookup"><span data-stu-id="e730f-293">Zero-width negative lookbehind.</span></span> <span data-ttu-id="e730f-294">Lookbehind della posizione corrente per determinare se `subexpression` non corrisponde alla stringa di input.</span><span class="sxs-lookup"><span data-stu-id="e730f-294">Look behind the current position to determine whether `subexpression` does not match the input string.</span></span>|

## <a name="use-time-out-values"></a><span data-ttu-id="e730f-295">Usare valori di timeout</span><span class="sxs-lookup"><span data-stu-id="e730f-295">Use time-out values</span></span>

<span data-ttu-id="e730f-296">Se le espressioni regolari elaborano l'input che corrisponde quasi al modello dell'espressione regolare, possono spesso basarsi su un backtracking eccessivo, con un impatto notevole sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="e730f-296">If your regular expressions processes input that nearly matches the regular expression pattern, it can often rely on excessive backtracking, which impacts its performance significantly.</span></span> <span data-ttu-id="e730f-297">Oltre a considerare attentamente l'utilizzo del backtracking e a testare l'espressione regolare rispetto all'input maggiormente corrispondente, è necessario impostare sempre un valore di timeout per assicurarsi che l'impatto di un eventuale backtracking eccessivo sia contenuto.</span><span class="sxs-lookup"><span data-stu-id="e730f-297">In addition to carefully considering your use of backtracking and testing the regular expression against near-matching input, you should always set a time-out value to ensure that the impact of excessive backtracking, if it occurs, is minimized.</span></span>

<span data-ttu-id="e730f-298">L'intervallo di timeout dell'espressione regolare definisce il periodo di tempo durante il quale il motore delle espressioni regolari cercherà una singola corrispondenza prima del timeout. L'intervallo di timeout predefinito è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> , il che significa che l'espressione regolare non prevede il timeout. È possibile eseguire l'override di questo valore e definire un intervallo di timeout come segue:</span><span class="sxs-lookup"><span data-stu-id="e730f-298">The regular expression time-out interval defines the period of time that the regular expression engine will look for a single match before it times out. The default time-out interval is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, which means that the regular expression will not time out. You can override this value and define a time-out interval as follows:</span></span>

- <span data-ttu-id="e730f-299">Specificando un valore di timeout quando si crea un'istanza di un oggetto <xref:System.Text.RegularExpressions.Regex> chiamando il costruttore <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>.</span><span class="sxs-lookup"><span data-stu-id="e730f-299">By providing a time-out value when you instantiate a <xref:System.Text.RegularExpressions.Regex> object by calling the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor.</span></span>

- <span data-ttu-id="e730f-300">Chiamando un metodo statico di corrispondenza dei modelli, come <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> o <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>, che include un parametro `matchTimeout`.</span><span class="sxs-lookup"><span data-stu-id="e730f-300">By calling a static pattern matching method, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>, that includes a `matchTimeout` parameter.</span></span>

- <span data-ttu-id="e730f-301">Per le espressioni regolari compilate che vengono create chiamando il metodo <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType>, chiamando il costruttore con un parametro di tipo <xref:System.TimeSpan>.</span><span class="sxs-lookup"><span data-stu-id="e730f-301">For compiled regular expressions that are created by calling the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method, by calling the constructor that has a parameter of type <xref:System.TimeSpan>.</span></span>

<span data-ttu-id="e730f-302">Se è stato definito un intervallo di timeout e non viene trovata alcuna corrispondenza alla fine di questo intervallo, il metodo dell'espressione regolare genera un'eccezione <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>.</span><span class="sxs-lookup"><span data-stu-id="e730f-302">If you have defined a time-out interval and a match is not found at the end of that interval, the regular expression method throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="e730f-303">Nel gestore eccezioni, è possibile continuare a cercare la corrispondenza con un intervallo di timeout più lungo, abbandonare il tentativo di ricerca supponendo che non esista alcuna corrispondenza oppure abbandonare il tentativo di ricerca e registrare le informazioni sull'eccezione per un'analisi futura.</span><span class="sxs-lookup"><span data-stu-id="e730f-303">In your exception handler, you can choose to retry the match with a longer time-out interval, abandon the match attempt and assume that there is no match, or abandon the match attempt and log the exception information for future analysis.</span></span>

<span data-ttu-id="e730f-304">Nell'esempio seguente viene definito un metodo `GetWordData` che crea un'istanza di un'espressione regolare con un intervallo di timeout di 350 millisecondi per calcolare il numero di parole e il numero medio di caratteri di una parola in un documento di testo.</span><span class="sxs-lookup"><span data-stu-id="e730f-304">The following example defines a `GetWordData` method that instantiates a regular expression with a time-out interval of 350 milliseconds to calculate the number of words and average number of characters in a word in a text document.</span></span> <span data-ttu-id="e730f-305">Se l'operazione di ricerca della corrispondenza scade, l'intervallo di timeout viene aumentato di 350 millisecondi e viene nuovamente creata un'istanza dell'oggetto <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="e730f-305">If the matching operation times out, the time-out interval is increased by 350 milliseconds and the <xref:System.Text.RegularExpressions.Regex> object is re-instantiated.</span></span> <span data-ttu-id="e730f-306">Se il nuovo intervallo di timeout supera 1 secondo, il metodo genera nuovamente l'eccezione al chiamante.</span><span class="sxs-lookup"><span data-stu-id="e730f-306">If the new time-out interval exceeds 1 second, the method re-throws the exception to the caller.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/timeout1.cs#12)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/timeout1.vb#12)]

## <a name="capture-only-when-necessary"></a><span data-ttu-id="e730f-307">Eseguire l'acquisizione solo quando necessario</span><span class="sxs-lookup"><span data-stu-id="e730f-307">Capture only when necessary</span></span>

<span data-ttu-id="e730f-308">Le espressioni regolari in .NET supportano diversi costrutti di raggruppamento, che consentono di raggruppare un modello di espressione regolare in una o più sottoespressioni.</span><span class="sxs-lookup"><span data-stu-id="e730f-308">Regular expressions in .NET support a number of grouping constructs, which let you group a regular expression pattern into one or more subexpressions.</span></span> <span data-ttu-id="e730f-309">I costrutti di raggruppamento più comunemente usati nel linguaggio delle espressioni regolari di .NET sono `(` *sottoespressione* `)` , che definisce un gruppo di acquisizione numerato, e `(?<` *nome* `>` *sottoespressione* `)` , che definisce un gruppo di acquisizione denominato.</span><span class="sxs-lookup"><span data-stu-id="e730f-309">The most commonly used grouping constructs in .NET regular expression language are `(`*subexpression*`)`, which defines a numbered capturing group, and `(?<`*name*`>`*subexpression*`)`, which defines a named capturing group.</span></span> <span data-ttu-id="e730f-310">I costrutti di raggruppamento sono indispensabili per la creazione di backreference e per la definizione di una sottoespressione a cui viene applicato un quantificatore.</span><span class="sxs-lookup"><span data-stu-id="e730f-310">Grouping constructs are essential for creating backreferences and for defining a subexpression to which a quantifier is applied.</span></span>

<span data-ttu-id="e730f-311">Tuttavia, l'utilizzo di questi elementi del linguaggio ha un costo.</span><span class="sxs-lookup"><span data-stu-id="e730f-311">However, the use of these language elements has a cost.</span></span> <span data-ttu-id="e730f-312">Comportano il popolamento dell'oggetto <xref:System.Text.RegularExpressions.GroupCollection> restituito dalla proprietà <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> con le acquisizioni non denominate o denominate più recenti e se un singolo costrutto di raggruppamento ha acquisito più sottostringhe nella stringa di input comportano anche il popolamento dell'oggetto <xref:System.Text.RegularExpressions.CaptureCollection> restituito dalla proprietà <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> di un gruppo di acquisizione specifico con più oggetti <xref:System.Text.RegularExpressions.Capture>.</span><span class="sxs-lookup"><span data-stu-id="e730f-312">They cause the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property to be populated with the most recent unnamed or named captures, and if a single grouping construct has captured multiple substrings in the input string, they also populate the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property of a particular capturing group with multiple <xref:System.Text.RegularExpressions.Capture> objects.</span></span>

<span data-ttu-id="e730f-313">I costrutti di raggruppamento spesso vengono utilizzati solo in un'espressione regolare in modo tale che sia possibile applicarvi i quantificatori e che i gruppi acquisiti da queste sottoespressioni non vengano utilizzati successivamente.</span><span class="sxs-lookup"><span data-stu-id="e730f-313">Often, grouping constructs are used in a regular expression only so that quantifiers can be applied to them, and the groups captured by these subexpressions are not subsequently used.</span></span> <span data-ttu-id="e730f-314">Ad esempio, l'espressione regolare `\b(\w+[;,]?\s?)+[.?!]` è progettata per acquisire un'intera frase.</span><span class="sxs-lookup"><span data-stu-id="e730f-314">For example, the regular expression `\b(\w+[;,]?\s?)+[.?!]` is designed to capture an entire sentence.</span></span> <span data-ttu-id="e730f-315">Nella tabella seguente vengono descritti gli elementi del linguaggio di tale modello di espressione regolare e il relativo effetto sulle raccolte <xref:System.Text.RegularExpressions.Match> e <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> dell'oggetto <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e730f-315">The following table describes the language elements in this regular expression pattern and their effect on the <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collections.</span></span>

|<span data-ttu-id="e730f-316">Modello</span><span class="sxs-lookup"><span data-stu-id="e730f-316">Pattern</span></span>|<span data-ttu-id="e730f-317">Descrizione</span><span class="sxs-lookup"><span data-stu-id="e730f-317">Description</span></span>|
|-------------|-----------------|
|`\b`|<span data-ttu-id="e730f-318">Inizia la corrispondenza sul confine di parola.</span><span class="sxs-lookup"><span data-stu-id="e730f-318">Begin the match at a word boundary.</span></span>|
|`\w+`|<span data-ttu-id="e730f-319">Trova la corrispondenza di uno o più caratteri alfanumerici.</span><span class="sxs-lookup"><span data-stu-id="e730f-319">Match one or more word characters.</span></span>|
|`[;,]?`|<span data-ttu-id="e730f-320">Trova la corrispondenza di una o nessuna virgola oppure di uno o nessun punto e virgola.</span><span class="sxs-lookup"><span data-stu-id="e730f-320">Match zero or one comma or semicolon.</span></span>|
|`\s?`|<span data-ttu-id="e730f-321">Trova la corrispondenza di uno o nessuno spazio vuoto.</span><span class="sxs-lookup"><span data-stu-id="e730f-321">Match zero or one white-space character.</span></span>|
|`(\w+[;,]?\s?)+`|<span data-ttu-id="e730f-322">Trova la corrispondenza di una o più occorrenze di uno o più caratteri alfanumerici seguiti da una virgola o un punto e virgola facoltativo seguito da uno spazio vuoto facoltativo.</span><span class="sxs-lookup"><span data-stu-id="e730f-322">Match one or more occurrences of one or more word characters followed by an optional comma or semicolon followed by an optional white-space character.</span></span> <span data-ttu-id="e730f-323">Questo modello definisce il primo gruppo di acquisizione, necessario affinché la combinazione di più caratteri alfanumerici, ovvero una parola, seguiti da un simbolo di punteggiatura facoltativo venga ripetuta finché il motore delle espressioni regolari non raggiunge la fine di una frase.</span><span class="sxs-lookup"><span data-stu-id="e730f-323">This defines the first capturing group, which is necessary so that the combination of multiple word characters (that is, a word) followed by an optional punctuation symbol will be repeated until the regular expression engine reaches the end of a sentence.</span></span>|
|`[.?!]`|<span data-ttu-id="e730f-324">Trova la corrispondenza di un punto, un punto interrogativo o un punto esclamativo.</span><span class="sxs-lookup"><span data-stu-id="e730f-324">Match a period, question mark, or exclamation point.</span></span>|

<span data-ttu-id="e730f-325">Come illustrato nell'esempio seguente, quando viene trovata una corrispondenza, entrambi gli oggetti <xref:System.Text.RegularExpressions.GroupCollection> e <xref:System.Text.RegularExpressions.CaptureCollection> vengono popolati con le acquisizioni della corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="e730f-325">As the following example shows, when a match is found, both the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> objects are populated with captures from the match.</span></span> <span data-ttu-id="e730f-326">In questo caso, è presente il gruppo di acquisizione `(\w+[;,]?\s?)` in modo tale che sia possibile applicarvi il quantificatore `+` consentendo al criterio di espressione regolare di trovare la corrispondenza con ogni parola di una frase.</span><span class="sxs-lookup"><span data-stu-id="e730f-326">In this case, the capturing group `(\w+[;,]?\s?)` exists so that the `+` quantifier can be applied to it, which enables the regular expression pattern to match each word in a sentence.</span></span> <span data-ttu-id="e730f-327">In caso contrario, verrebbe trovata la corrispondenza con l'ultima parola di una frase.</span><span class="sxs-lookup"><span data-stu-id="e730f-327">Otherwise, it would match the last word in a sentence.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/group1.cs#8)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/group1.vb#8)]

<span data-ttu-id="e730f-328">Quando le sottoespressioni vengono utilizzate solo per applicarvi i quantificatori e non è necessario il testo acquisito, è consigliabile disabilitare le acquisizioni del gruppo.</span><span class="sxs-lookup"><span data-stu-id="e730f-328">When you use subexpressions only to apply quantifiers to them, and you are not interested in the captured text, you should disable group captures.</span></span> <span data-ttu-id="e730f-329">Ad esempio, l'elemento del linguaggio `(?:subexpression)` impedisce al gruppo al quale viene applicato di acquisire le sottostringhe corrispondenti.</span><span class="sxs-lookup"><span data-stu-id="e730f-329">For example, the `(?:subexpression)` language element prevents the group to which it applies from capturing matched substrings.</span></span> <span data-ttu-id="e730f-330">Nell'esempio seguente il criterio di espressione regolare dell'esempio precedente viene modificato in `\b(?:\w+[;,]?\s?)+[.?!]`.</span><span class="sxs-lookup"><span data-stu-id="e730f-330">In the following example, the regular expression pattern from the previous example is changed to `\b(?:\w+[;,]?\s?)+[.?!]`.</span></span> <span data-ttu-id="e730f-331">Come illustrato nell'output, il motore delle espressioni regolari non popolerà le raccolte <xref:System.Text.RegularExpressions.GroupCollection> e <xref:System.Text.RegularExpressions.CaptureCollection>.</span><span class="sxs-lookup"><span data-stu-id="e730f-331">As the output shows, it prevents the regular expression engine from populating the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collections.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/group2.cs#9)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/group2.vb#9)]

<span data-ttu-id="e730f-332">È possibile disabilitare le acquisizioni in uno dei modi seguenti:</span><span class="sxs-lookup"><span data-stu-id="e730f-332">You can disable captures in one of the following ways:</span></span>

- <span data-ttu-id="e730f-333">Usare l'elemento del linguaggio `(?:subexpression)`.</span><span class="sxs-lookup"><span data-stu-id="e730f-333">Use the `(?:subexpression)` language element.</span></span> <span data-ttu-id="e730f-334">Questo elemento impedisce l'acquisizione delle sottostringhe corrispondenti nel gruppo a cui viene applicato.</span><span class="sxs-lookup"><span data-stu-id="e730f-334">This element prevents the capture of matched substrings in the group to which it applies.</span></span> <span data-ttu-id="e730f-335">Non disabilita le acquisizioni delle sottostringhe in tutti i gruppi annidati.</span><span class="sxs-lookup"><span data-stu-id="e730f-335">It does not disable substring captures in any nested groups.</span></span>

- <span data-ttu-id="e730f-336">Usare l'opzione <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture>.</span><span class="sxs-lookup"><span data-stu-id="e730f-336">Use the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> option.</span></span> <span data-ttu-id="e730f-337">Disabilita tutte le acquisizioni non denominate o implicite nel modello di espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="e730f-337">It disables all unnamed or implicit captures in the regular expression pattern.</span></span> <span data-ttu-id="e730f-338">Quando si usa questa opzione, è possibile acquisire solo le sottostringhe che corrispondono ai gruppi denominati definiti con l'elemento del linguaggio `(?<name>subexpression)`.</span><span class="sxs-lookup"><span data-stu-id="e730f-338">When you use this option, only substrings that match named groups defined with the `(?<name>subexpression)` language element can be captured.</span></span> <span data-ttu-id="e730f-339">Il flag <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> può essere passato al parametro `options` del costruttore della classe <xref:System.Text.RegularExpressions.Regex> o al parametro `options` di un metodo <xref:System.Text.RegularExpressions.Regex> statico corrispondente.</span><span class="sxs-lookup"><span data-stu-id="e730f-339">The <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> flag can be passed to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> static matching method.</span></span>

- <span data-ttu-id="e730f-340">Utilizzare l'opzione `n` nell'elemento del linguaggio `(?imnsx)`.</span><span class="sxs-lookup"><span data-stu-id="e730f-340">Use the `n` option in the `(?imnsx)` language element.</span></span> <span data-ttu-id="e730f-341">Questa opzione disabilita tutte le acquisizioni non denominate o implicite dal punto nel modello di espressione regolare in corrispondenza del quale viene visualizzato l'elemento.</span><span class="sxs-lookup"><span data-stu-id="e730f-341">This option disables all unnamed or implicit captures from the point in the regular expression pattern at which the element appears.</span></span> <span data-ttu-id="e730f-342">Le acquisizioni vengono disabilitate fino alla fine del modello o finché l'opzione `(-n)` non abilita le acquisizioni non denominate o implicite.</span><span class="sxs-lookup"><span data-stu-id="e730f-342">Captures are disabled either until the end of the pattern or until the `(-n)` option enables unnamed or implicit captures.</span></span> <span data-ttu-id="e730f-343">Per altre informazioni, vedere [Miscellaneous Constructs](miscellaneous-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="e730f-343">For more information, see [Miscellaneous Constructs](miscellaneous-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="e730f-344">Utilizzare l'opzione `n` nell'elemento del linguaggio `(?imnsx:subexpression)`.</span><span class="sxs-lookup"><span data-stu-id="e730f-344">Use the `n` option in the `(?imnsx:subexpression)` language element.</span></span> <span data-ttu-id="e730f-345">Questa opzione disabilita tutte le acquisizioni non denominate o implicite in `subexpression`.</span><span class="sxs-lookup"><span data-stu-id="e730f-345">This option disables all unnamed or implicit captures in `subexpression`.</span></span> <span data-ttu-id="e730f-346">Vengono inoltre disabilitate tutte le acquisizioni dai gruppi di acquisizione annidati non denominati o impliciti.</span><span class="sxs-lookup"><span data-stu-id="e730f-346">Captures by any unnamed or implicit nested capturing groups are disabled as well.</span></span>

## <a name="related-topics"></a><span data-ttu-id="e730f-347">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="e730f-347">Related topics</span></span>

|<span data-ttu-id="e730f-348">Titolo</span><span class="sxs-lookup"><span data-stu-id="e730f-348">Title</span></span>|<span data-ttu-id="e730f-349">Descrizione</span><span class="sxs-lookup"><span data-stu-id="e730f-349">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="e730f-350">Dettagli sul comportamento delle espressioni regolari</span><span class="sxs-lookup"><span data-stu-id="e730f-350">Details of Regular Expression Behavior</span></span>](details-of-regular-expression-behavior.md)|<span data-ttu-id="e730f-351">Viene esaminata l'implementazione del motore delle espressioni regolari in .NET.</span><span class="sxs-lookup"><span data-stu-id="e730f-351">Examines the implementation of the regular expression engine in .NET.</span></span> <span data-ttu-id="e730f-352">L'argomento è incentrato sulla flessibilità delle espressioni regolari e sulla responsabilità dello sviluppatore al fine di garantire un funzionamento efficace e affidabile del motore delle espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="e730f-352">The topic focuses on the flexibility of regular expressions and explains the developer's responsibility for ensuring the efficient and robust operation of the regular expression engine.</span></span>|
|[<span data-ttu-id="e730f-353">Backtracking</span><span class="sxs-lookup"><span data-stu-id="e730f-353">Backtracking</span></span>](backtracking-in-regular-expressions.md)|<span data-ttu-id="e730f-354">Viene illustrato il backtracking e il modo in cui influisce sulle prestazioni delle espressioni regolari e vengono esaminati gli elementi del linguaggio che forniscono le alternative al backtracking.</span><span class="sxs-lookup"><span data-stu-id="e730f-354">Explains what backtracking is and how it affects regular expression performance, and examines language elements that provide alternatives to backtracking.</span></span>|
|[<span data-ttu-id="e730f-355">Linguaggio di espressioni regolari - Riferimento rapido</span><span class="sxs-lookup"><span data-stu-id="e730f-355">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)|<span data-ttu-id="e730f-356">Vengono illustrati gli elementi del linguaggio delle espressioni regolari in .NET e vengono forniti i collegamenti alla documentazione dettagliata per ogni elemento del linguaggio.</span><span class="sxs-lookup"><span data-stu-id="e730f-356">Describes the elements of the regular expression language in .NET and provides links to detailed documentation for each language element.</span></span>|
