---
title: Inizializzazione differita
description: Esplora l'inizializzazione lazy in .NET, un miglioramento delle prestazioni che indica che la creazione di un oggetto viene posticipata finché l'oggetto non viene usato per la prima volta.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
ms.openlocfilehash: 355fa326fc19e9a50a74e21ace0a6353f5c740c5
ms.sourcegitcommit: 3824ff187947572b274b9715b60c11269335c181
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/17/2020
ms.locfileid: "84904234"
---
# <a name="lazy-initialization"></a><span data-ttu-id="7bf35-103">Inizializzazione differita</span><span class="sxs-lookup"><span data-stu-id="7bf35-103">Lazy Initialization</span></span>
<span data-ttu-id="7bf35-104">L'*inizializzazione differita* di un oggetto significa che la creazione dell'oggetto viene posticipata finché l'oggetto non viene usato per la prima volta.</span><span class="sxs-lookup"><span data-stu-id="7bf35-104">*Lazy initialization* of an object means that its creation is deferred until it is first used.</span></span> <span data-ttu-id="7bf35-105">Per questo argomento, i termini *inizializzazione Lazy* e *creazione di istanze Lazy* sono sinonimi. L'inizializzazione differita viene utilizzata principalmente per migliorare le prestazioni, evitare inutili calcoli e ridurre i requisiti di memoria del programma.</span><span class="sxs-lookup"><span data-stu-id="7bf35-105">(For this topic, the terms *lazy initialization* and *lazy instantiation* are synonymous.) Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements.</span></span> <span data-ttu-id="7bf35-106">Ecco gli scenari più comuni:</span><span class="sxs-lookup"><span data-stu-id="7bf35-106">These are the most common scenarios:</span></span>  
  
- <span data-ttu-id="7bf35-107">La creazione di un oggetto è dispendiosa e il programma potrebbe non usarlo.</span><span class="sxs-lookup"><span data-stu-id="7bf35-107">When you have an object that is expensive to create, and the program might not use it.</span></span> <span data-ttu-id="7bf35-108">Si supponga, ad esempio, di avere un oggetto `Customer` in memoria che include una proprietà `Orders` contenente una matrice di grandi dimensioni di oggetti `Order`, per la cui inizializzazione è necessaria una connessione di database.</span><span class="sxs-lookup"><span data-stu-id="7bf35-108">For example, assume that you have in memory a `Customer` object that has an `Orders` property that contains a large array of `Order` objects that, to be initialized, requires a database connection.</span></span> <span data-ttu-id="7bf35-109">Se l'utente non chiede mai di visualizzare gli ordini o di usare i dati in un calcolo, non vi è motivo di usare la memoria di sistema o cicli di calcolo per creare l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="7bf35-109">If the user never asks to display the Orders or use the data in a computation, then there is no reason to use system memory or computing cycles to create it.</span></span> <span data-ttu-id="7bf35-110">Usando `Lazy<Orders>` per dichiarare l'oggetto `Orders` per l'inizializzazione differita, è possibile evitare di sprecare risorse di sistema quando l'oggetto non viene usato.</span><span class="sxs-lookup"><span data-stu-id="7bf35-110">By using `Lazy<Orders>` to declare the `Orders` object for lazy initialization, you can avoid wasting system resources when the object is not used.</span></span>  
  
- <span data-ttu-id="7bf35-111">La creazione di un oggetto è dispendiosa e si vuole posticiparla fino al completamento di altre operazioni dispendiose.</span><span class="sxs-lookup"><span data-stu-id="7bf35-111">When you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.</span></span> <span data-ttu-id="7bf35-112">Si supponga, ad esempio, che il programma carichi diverse istanze dell'oggetto all'avvio, ma che solo alcune siano necessarie immediatamente.</span><span class="sxs-lookup"><span data-stu-id="7bf35-112">For example, assume that your program loads several object instances when it starts, but only some of them are required immediately.</span></span> <span data-ttu-id="7bf35-113">È possibile migliorare le prestazioni di avvio del programma posticipando l'inizializzazione degli oggetti non necessari finché non vengono creati quelli necessari.</span><span class="sxs-lookup"><span data-stu-id="7bf35-113">You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.</span></span>  
  
 <span data-ttu-id="7bf35-114">Benché sia possibile scrivere codice personalizzato per eseguire l'inizializzazione differita, è consigliabile usare <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="7bf35-114">Although you can write your own code to perform lazy initialization, we recommend that you use <xref:System.Lazy%601> instead.</span></span> <span data-ttu-id="7bf35-115"><xref:System.Lazy%601> e i tipi correlati supportano anche la thread safety e forniscono criteri uniformi di propagazione delle eccezioni.</span><span class="sxs-lookup"><span data-stu-id="7bf35-115"><xref:System.Lazy%601> and its related types also support thread-safety and provide a consistent exception propagation policy.</span></span>  
  
 <span data-ttu-id="7bf35-116">La tabella seguente elenca i tipi forniti da .NET Framework versione 4 per consentire l'inizializzazione differita in diversi scenari.</span><span class="sxs-lookup"><span data-stu-id="7bf35-116">The following table lists the types that the .NET Framework version 4 provides to enable lazy initialization in different scenarios.</span></span>  
  
|<span data-ttu-id="7bf35-117">Type</span><span class="sxs-lookup"><span data-stu-id="7bf35-117">Type</span></span>|<span data-ttu-id="7bf35-118">Descrizione</span><span class="sxs-lookup"><span data-stu-id="7bf35-118">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601>|<span data-ttu-id="7bf35-119">Classe wrapper che fornisce la semantica di inizializzazione differita per qualsiasi libreria di classi o tipo definito dall'utente.</span><span class="sxs-lookup"><span data-stu-id="7bf35-119">A wrapper class that provides lazy initialization semantics for any class library or user-defined type.</span></span>|  
|<xref:System.Threading.ThreadLocal%601>|<span data-ttu-id="7bf35-120">È simile a <xref:System.Lazy%601>, con la differenza che fornisce la semantica di inizializzazione differita in base a dati locali del thread.</span><span class="sxs-lookup"><span data-stu-id="7bf35-120">Resembles <xref:System.Lazy%601> except that it provides lazy initialization semantics on a thread-local basis.</span></span> <span data-ttu-id="7bf35-121">Ogni thread ha accesso al proprio valore univoco.</span><span class="sxs-lookup"><span data-stu-id="7bf35-121">Every thread has access to its own unique value.</span></span>|  
|<xref:System.Threading.LazyInitializer>|<span data-ttu-id="7bf35-122">Fornisce metodi `static` (`Shared` in Visual Basic) avanzati per l'inizializzazione differita di oggetti senza l'overhead di una classe.</span><span class="sxs-lookup"><span data-stu-id="7bf35-122">Provides advanced `static` (`Shared` in Visual Basic) methods for lazy initialization of objects without the overhead of a class.</span></span>|  
  
## <a name="basic-lazy-initialization"></a><span data-ttu-id="7bf35-123">Inizializzazione differita di base</span><span class="sxs-lookup"><span data-stu-id="7bf35-123">Basic Lazy Initialization</span></span>  
 <span data-ttu-id="7bf35-124">Per definire un tipo a inizializzazione differita, ad esempio `MyType`, usare `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), come mostrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="7bf35-124">To define a lazy-initialized type, for example, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), as shown in the following example.</span></span> <span data-ttu-id="7bf35-125">Se non viene passato alcun delegato nel costruttore <xref:System.Lazy%601>, il tipo con wrapping viene creato usando <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> in occasione del primo accesso alla proprietà del valore.</span><span class="sxs-lookup"><span data-stu-id="7bf35-125">If no delegate is passed in the <xref:System.Lazy%601> constructor, the wrapped type is created by using <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> when the value property is first accessed.</span></span> <span data-ttu-id="7bf35-126">Se il tipo non dispone di un costruttore senza parametri, viene generata un'eccezione in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="7bf35-126">If the type does not have a parameterless constructor, a run-time exception is thrown.</span></span>  
  
 <span data-ttu-id="7bf35-127">Nell'esempio seguente si supponga che `Orders` sia una classe che contiene una matrice di oggetti `Order` recuperati da un database.</span><span class="sxs-lookup"><span data-stu-id="7bf35-127">In the following example, assume that `Orders` is a class that contains an array of `Order` objects retrieved from a database.</span></span> <span data-ttu-id="7bf35-128">Un oggetto `Customer` contiene un'istanza di `Orders`, ma a seconda delle azioni dell'utente, i dati dell'oggetto `Orders` potrebbero non essere necessari.</span><span class="sxs-lookup"><span data-stu-id="7bf35-128">A `Customer` object contains an instance of `Orders`, but depending on user actions, the data from the `Orders` object might not be required.</span></span>  
  
 [!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)]
 [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]  
  
 <span data-ttu-id="7bf35-129">È anche possibile passare un delegato nel costruttore <xref:System.Lazy%601>, che richiama un overload del costruttore specifico nel tipo con wrapping in fase di creazione, ed eseguire tutti gli altri passaggi di inizializzazione necessari, come mostrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="7bf35-129">You can also pass a delegate in the <xref:System.Lazy%601> constructor that invokes a specific constructor overload on the wrapped type at creation time, and perform any other initialization steps that are required, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)]
 [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]  
  
 <span data-ttu-id="7bf35-130">Una volta creato l'oggetto Lazy, non viene creata alcuna istanza di `Orders` fino al momento del primo accesso alla proprietà <xref:System.Lazy%601.Value%2A> della variabile Lazy.</span><span class="sxs-lookup"><span data-stu-id="7bf35-130">After the Lazy object is created, no instance of `Orders` is created until the <xref:System.Lazy%601.Value%2A> property of the Lazy variable is accessed for the first time.</span></span> <span data-ttu-id="7bf35-131">Al primo accesso, il tipo con wrapping viene creato e restituito e quindi archiviato per tutti gli accessi futuri.</span><span class="sxs-lookup"><span data-stu-id="7bf35-131">On first access, the wrapped type is created and returned, and stored for any future access.</span></span>  
  
 [!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)]
 [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]  
  
 <span data-ttu-id="7bf35-132">Un oggetto <xref:System.Lazy%601> restituisce sempre lo stesso oggetto o valore con cui è stato inizializzato.</span><span class="sxs-lookup"><span data-stu-id="7bf35-132">A <xref:System.Lazy%601> object always returns the same object or value that it was initialized with.</span></span> <span data-ttu-id="7bf35-133">Di conseguenza, la proprietà <xref:System.Lazy%601.Value%2A> è di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="7bf35-133">Therefore, the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="7bf35-134">Se in <xref:System.Lazy%601.Value%2A> è archiviato un tipo riferimento, non è possibile assegnarvi un nuovo oggetto.</span><span class="sxs-lookup"><span data-stu-id="7bf35-134">If <xref:System.Lazy%601.Value%2A> stores a reference type, you cannot assign a new object to it.</span></span> <span data-ttu-id="7bf35-135">È tuttavia possibile modificare il valore delle proprietà e dei campi pubblici impostabili. Se <xref:System.Lazy%601.Value%2A> Archivia un tipo di valore, non è possibile modificarne il valore.</span><span class="sxs-lookup"><span data-stu-id="7bf35-135">(However, you can change the value of its settable public fields and properties.) If <xref:System.Lazy%601.Value%2A> stores a value type, you cannot modify its value.</span></span> <span data-ttu-id="7bf35-136">È tuttavia possibile creare una nuova variabile richiamando di nuovo il costruttore della variabile con nuovi argomenti.</span><span class="sxs-lookup"><span data-stu-id="7bf35-136">Nevertheless, you can create a new variable by invoking the variable constructor again by using new arguments.</span></span>  
  
 [!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)]
 [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]  
  
 <span data-ttu-id="7bf35-137">La nuova istanza Lazy, come la precedente, non crea un'istanza di `Orders` fino al momento del primo accesso alla proprietà <xref:System.Lazy%601.Value%2A> correlata.</span><span class="sxs-lookup"><span data-stu-id="7bf35-137">The new lazy instance, like the earlier one, does not instantiate `Orders` until its <xref:System.Lazy%601.Value%2A> property is first accessed.</span></span>  
  
### <a name="thread-safe-initialization"></a><span data-ttu-id="7bf35-138">Inizializzazione thread-safe</span><span class="sxs-lookup"><span data-stu-id="7bf35-138">Thread-Safe Initialization</span></span>  
 <span data-ttu-id="7bf35-139">Per impostazione predefinita, gli oggetti <xref:System.Lazy%601> sono thread-safe.</span><span class="sxs-lookup"><span data-stu-id="7bf35-139">By default, <xref:System.Lazy%601> objects are thread-safe.</span></span> <span data-ttu-id="7bf35-140">Di conseguenza, se il costruttore non specifica il tipo di thread safety, gli oggetti <xref:System.Lazy%601> creati sono thread-safe.</span><span class="sxs-lookup"><span data-stu-id="7bf35-140">That is, if the constructor does not specify the kind of thread safety, the <xref:System.Lazy%601> objects it creates are thread-safe.</span></span> <span data-ttu-id="7bf35-141">Negli scenari di multithreading il primo thread che accede alla proprietà <xref:System.Lazy%601.Value%2A> di un oggetto <xref:System.Lazy%601> thread-safe lo inizializza per tutti gli accessi successivi in tutti i thread e tutti i thread condividono gli stessi dati.</span><span class="sxs-lookup"><span data-stu-id="7bf35-141">In multi-threaded scenarios, the first thread to access the <xref:System.Lazy%601.Value%2A> property of a thread-safe <xref:System.Lazy%601> object initializes it for all subsequent accesses on all threads, and all threads share the same data.</span></span> <span data-ttu-id="7bf35-142">Di conseguenza, non importa quale thread inizializza l'oggetto e le race condition sono valide.</span><span class="sxs-lookup"><span data-stu-id="7bf35-142">Therefore, it does not matter which thread initializes the object, and race conditions are benign.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="7bf35-143">È possibile estendere questa coerenza alle condizioni di errore usando la memorizzazione nella cache delle eccezioni.</span><span class="sxs-lookup"><span data-stu-id="7bf35-143">You can extend this consistency to error conditions by using exception caching.</span></span> <span data-ttu-id="7bf35-144">Per altre informazioni, vedere la sezione [Eccezioni negli oggetti Lazy](lazy-initialization.md#ExceptionsInLazyObjects) di seguito.</span><span class="sxs-lookup"><span data-stu-id="7bf35-144">For more information, see the next section, [Exceptions in Lazy Objects](lazy-initialization.md#ExceptionsInLazyObjects).</span></span>  
  
 <span data-ttu-id="7bf35-145">L'esempio seguente mostra che la stessa istanza `Lazy<int>` ha lo stesso valore per tre thread separati.</span><span class="sxs-lookup"><span data-stu-id="7bf35-145">The following example shows that the same `Lazy<int>` instance has the same value for three separate threads.</span></span>  
  
 [!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)]
 [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]  
  
 <span data-ttu-id="7bf35-146">Se sono necessari dati separati in ogni thread, usare il tipo <xref:System.Threading.ThreadLocal%601>, descritto più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="7bf35-146">If you require separate data on each thread, use the <xref:System.Threading.ThreadLocal%601> type, as described later in this topic.</span></span>  
  
 <span data-ttu-id="7bf35-147">Alcuni costruttori <xref:System.Lazy%601> includono un parametro booleano chiamato `isThreadSafe`, che viene usato per specificare se si intende accedere alla proprietà <xref:System.Lazy%601.Value%2A> da più thread.</span><span class="sxs-lookup"><span data-stu-id="7bf35-147">Some <xref:System.Lazy%601> constructors have a Boolean parameter named `isThreadSafe` that is used to specify whether the <xref:System.Lazy%601.Value%2A> property will be accessed from multiple threads.</span></span> <span data-ttu-id="7bf35-148">Se si intende accedere alla proprietà da un solo thread, passare `false` per ottenere un vantaggio moderato in termini di prestazioni.</span><span class="sxs-lookup"><span data-stu-id="7bf35-148">If you intend to access the property from just one thread, pass in `false` to obtain a modest performance benefit.</span></span> <span data-ttu-id="7bf35-149">Se si intende accedere alla proprietà da più thread, passare `true` per indicare all'istanza <xref:System.Lazy%601> di gestire correttamente le race condition in cui un thread genera un'eccezione in fase di inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="7bf35-149">If you intend to access the property from multiple threads, pass in `true` to instruct the <xref:System.Lazy%601> instance to correctly handle race conditions in which one thread throws an exception at initialization time.</span></span>  
  
 <span data-ttu-id="7bf35-150">Alcuni costruttori <xref:System.Lazy%601> includono un parametro <xref:System.Threading.LazyThreadSafetyMode> chiamato `mode`.</span><span class="sxs-lookup"><span data-stu-id="7bf35-150">Some <xref:System.Lazy%601> constructors have a <xref:System.Threading.LazyThreadSafetyMode> parameter named `mode`.</span></span> <span data-ttu-id="7bf35-151">Questi costruttori forniscono una modalità di thread safety aggiuntiva.</span><span class="sxs-lookup"><span data-stu-id="7bf35-151">These constructors provide an additional thread safety mode.</span></span> <span data-ttu-id="7bf35-152">La tabella seguente mostra in che modo i parametri del costruttore che specificano la thread safety influiscono sulla thread safety di un oggetto <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="7bf35-152">The following table shows how the thread safety of a <xref:System.Lazy%601> object is affected by constructor parameters that specify thread safety.</span></span> <span data-ttu-id="7bf35-153">Ogni costruttore include al massimo uno di questi parametri.</span><span class="sxs-lookup"><span data-stu-id="7bf35-153">Each constructor has at most one such parameter.</span></span>  
  
|<span data-ttu-id="7bf35-154">Thread safety dell'oggetto</span><span class="sxs-lookup"><span data-stu-id="7bf35-154">Thread safety of the object</span></span>|<span data-ttu-id="7bf35-155">`LazyThreadSafetyMode``mode`parametro di</span><span class="sxs-lookup"><span data-stu-id="7bf35-155">`LazyThreadSafetyMode` `mode` parameter</span></span>|<span data-ttu-id="7bf35-156">Parametro `isThreadSafe` booleano</span><span class="sxs-lookup"><span data-stu-id="7bf35-156">Boolean `isThreadSafe` parameter</span></span>|<span data-ttu-id="7bf35-157">Nessun parametro di thread safety</span><span class="sxs-lookup"><span data-stu-id="7bf35-157">No thread safety parameters</span></span>|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="7bf35-158">Completamente thread-safe. Un solo thread per volta tenta di inizializzare il valore.</span><span class="sxs-lookup"><span data-stu-id="7bf35-158">Fully thread-safe; only one thread at a time tries to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|<span data-ttu-id="7bf35-159">Sì.</span><span class="sxs-lookup"><span data-stu-id="7bf35-159">Yes.</span></span>|  
|<span data-ttu-id="7bf35-160">Non thread-safe.</span><span class="sxs-lookup"><span data-stu-id="7bf35-160">Not thread-safe.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|<span data-ttu-id="7bf35-161">Non applicabile.</span><span class="sxs-lookup"><span data-stu-id="7bf35-161">Not applicable.</span></span>|  
|<span data-ttu-id="7bf35-162">Completamente thread-safe. I thread competono per inizializzare il valore.</span><span class="sxs-lookup"><span data-stu-id="7bf35-162">Fully thread-safe; threads race to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|<span data-ttu-id="7bf35-163">Non applicabile.</span><span class="sxs-lookup"><span data-stu-id="7bf35-163">Not applicable.</span></span>|<span data-ttu-id="7bf35-164">Non applicabile.</span><span class="sxs-lookup"><span data-stu-id="7bf35-164">Not applicable.</span></span>|  
  
 <span data-ttu-id="7bf35-165">Come mostrato nella tabella, l'immissione di <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> per il parametro `mode` equivale all'immissione di `true` per il parametro `isThreadSafe`, mentre l'immissione di <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> equivale all'immissione di `false`.</span><span class="sxs-lookup"><span data-stu-id="7bf35-165">As the table shows, specifying <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> for the `mode` parameter is the same as specifying `true` for the `isThreadSafe` parameter, and specifying <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> is the same as specifying `false`.</span></span>  
  
 <span data-ttu-id="7bf35-166">Se si specifica <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, si consente a più thread di tentare di inizializzare l'istanza <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="7bf35-166">Specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> allows multiple threads to attempt to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="7bf35-167">Solo un thread può riuscire, mentre tutti gli altri thread ricevono il valore inizializzato da quello che ha avuto esito positivo.</span><span class="sxs-lookup"><span data-stu-id="7bf35-167">Only one thread can win this race, and all the other threads receive the value that was initialized by the successful thread.</span></span> <span data-ttu-id="7bf35-168">Se durante l'inizializzazione viene generata un'eccezione in un thread, questo thread non riceve il valore impostato dal thread che è riuscito a eseguire l'inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="7bf35-168">If an exception is thrown on a thread during initialization, that thread does not receive the value set by the successful thread.</span></span> <span data-ttu-id="7bf35-169">Poiché le eccezioni non sono memorizzate nella cache, un tentativo successivo di accesso alla proprietà <xref:System.Lazy%601.Value%2A> può restituire un'inizializzazione riuscita.</span><span class="sxs-lookup"><span data-stu-id="7bf35-169">Exceptions are not cached, so a subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property can result in successful initialization.</span></span> <span data-ttu-id="7bf35-170">Questo comportamento è diverso dal modo in cui vengono gestite le eccezioni in altre modalità, descritto nella sezione seguente.</span><span class="sxs-lookup"><span data-stu-id="7bf35-170">This differs from the way exceptions are treated in other modes, which is described in the following section.</span></span> <span data-ttu-id="7bf35-171">Per altre informazioni, vedere l'enumerazione <xref:System.Threading.LazyThreadSafetyMode>.</span><span class="sxs-lookup"><span data-stu-id="7bf35-171">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
<a name="ExceptionsInLazyObjects"></a>
## <a name="exceptions-in-lazy-objects"></a><span data-ttu-id="7bf35-172">Eccezioni negli oggetti Lazy</span><span class="sxs-lookup"><span data-stu-id="7bf35-172">Exceptions in Lazy Objects</span></span>  
 <span data-ttu-id="7bf35-173">Come già indicato, un oggetto <xref:System.Lazy%601> restituisce sempre lo stesso oggetto o valore con cui è stato inizializzato e di conseguenza la proprietà <xref:System.Lazy%601.Value%2A> è di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="7bf35-173">As stated earlier, a <xref:System.Lazy%601> object always returns the same object or value that it was initialized with, and therefore the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="7bf35-174">Se si abilita la memorizzazione nella cache delle eccezioni, questa natura non modificabile si estende al comportamento delle eccezioni.</span><span class="sxs-lookup"><span data-stu-id="7bf35-174">If you enable exception caching, this immutability also extends to exception behavior.</span></span> <span data-ttu-id="7bf35-175">Se per un oggetto con inizializzazione lazy è abilitata la memorizzazione nella cache delle eccezioni e viene generata un'eccezione dal relativo metodo di inizializzazione quando <xref:System.Lazy%601.Value%2A> si accede prima alla proprietà, viene generata la stessa eccezione a ogni tentativo successivo di accesso alla <xref:System.Lazy%601.Value%2A> Proprietà.</span><span class="sxs-lookup"><span data-stu-id="7bf35-175">If a lazy-initialized object has exception caching enabled and throws an exception from its initialization method when the <xref:System.Lazy%601.Value%2A> property is first accessed, that same exception is thrown on every subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property.</span></span> <span data-ttu-id="7bf35-176">In altre parole, il costruttore del tipo con wrapping non viene mai richiamato, anche in scenari di multithreading.</span><span class="sxs-lookup"><span data-stu-id="7bf35-176">In other words, the constructor of the wrapped type is never re-invoked, even in multithreaded scenarios.</span></span> <span data-ttu-id="7bf35-177">Di conseguenza, l'oggetto <xref:System.Lazy%601> non può generare un'eccezione durante un accesso e restituire un valore all'accesso successivo.</span><span class="sxs-lookup"><span data-stu-id="7bf35-177">Therefore, the <xref:System.Lazy%601> object cannot throw an exception on one access and return a value on a subsequent access.</span></span>  
  
 <span data-ttu-id="7bf35-178">La memorizzazione nella cache delle eccezioni viene abilitata quando si usa qualsiasi costruttore <xref:System.Lazy%601?displayProperty=nameWithType> che accetta un metodo di inizializzazione (parametro `valueFactory`). Ad esempio, viene abilitata quando si usa il costruttore `Lazy(T)(Func(T))`.</span><span class="sxs-lookup"><span data-stu-id="7bf35-178">Exception caching is enabled when you use any <xref:System.Lazy%601?displayProperty=nameWithType> constructor that takes an initialization method (`valueFactory` parameter); for example, it is enabled when you use the `Lazy(T)(Func(T))`constructor.</span></span> <span data-ttu-id="7bf35-179">Se il costruttore accetta anche un valore <xref:System.Threading.LazyThreadSafetyMode> (parametro `mode`), specificare <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> o <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7bf35-179">If the constructor also takes a <xref:System.Threading.LazyThreadSafetyMode> value (`mode` parameter), specify <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> or <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7bf35-180">Se si specifica un metodo di inizializzazione, la memorizzazione nella cache delle eccezioni viene abilitata per queste due modalità.</span><span class="sxs-lookup"><span data-stu-id="7bf35-180">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="7bf35-181">Il metodo di inizializzazione può essere molto semplice.</span><span class="sxs-lookup"><span data-stu-id="7bf35-181">The initialization method can be very simple.</span></span> <span data-ttu-id="7bf35-182">Ad esempio, potrebbe chiamare il costruttore senza parametri per `T` : `new Lazy<Contents>(() => new Contents(), mode)` in C# o `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="7bf35-182">For example, it might call the parameterless constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="7bf35-183">Se si usa un costruttore <xref:System.Lazy%601?displayProperty=nameWithType> che non specifica un metodo di inizializzazione, le eccezioni generate dal costruttore senza parametri per `T` non vengono memorizzate nella cache.</span><span class="sxs-lookup"><span data-stu-id="7bf35-183">If you use a <xref:System.Lazy%601?displayProperty=nameWithType> constructor that does not specify an initialization method, exceptions that are thrown by the parameterless constructor for `T` are not cached.</span></span> <span data-ttu-id="7bf35-184">Per altre informazioni, vedere l'enumerazione <xref:System.Threading.LazyThreadSafetyMode>.</span><span class="sxs-lookup"><span data-stu-id="7bf35-184">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="7bf35-185">Se si crea un oggetto <xref:System.Lazy%601> con il parametro del costruttore `isThreadSafe` impostato su `false` o il parametro del costruttore `mode` impostato su <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, è necessario accedere all'oggetto <xref:System.Lazy%601> da un solo thread o fornire la sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="7bf35-185">If you create a <xref:System.Lazy%601> object with the `isThreadSafe` constructor parameter set to `false` or the `mode` constructor parameter set to <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, you must access the <xref:System.Lazy%601> object from a single thread or provide your own synchronization.</span></span> <span data-ttu-id="7bf35-186">Questo vale per tutti gli aspetti dell'oggetto, anche per la memorizzazione nella cache delle eccezioni.</span><span class="sxs-lookup"><span data-stu-id="7bf35-186">This applies to all aspects of the object, including exception caching.</span></span>  
  
 <span data-ttu-id="7bf35-187">Come indicato nella sezione precedente, gli oggetti <xref:System.Lazy%601> creati specificando <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> gestiscono le eccezioni in modo diverso.</span><span class="sxs-lookup"><span data-stu-id="7bf35-187">As noted in the previous section, <xref:System.Lazy%601> objects created by specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> treat exceptions differently.</span></span> <span data-ttu-id="7bf35-188">Con <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, più thread possono competere per inizializzare l'istanza <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="7bf35-188">With <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, multiple threads can compete to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="7bf35-189">In questo caso, le eccezioni non vengono memorizzate nella cache e i tentativi di accesso alla proprietà <xref:System.Lazy%601.Value%2A> possono continuare finché l'inizializzazione non riesce.</span><span class="sxs-lookup"><span data-stu-id="7bf35-189">In this case, exceptions are not cached, and attempts to access the <xref:System.Lazy%601.Value%2A> property can continue until initialization is successful.</span></span>  
  
 <span data-ttu-id="7bf35-190">La tabella seguente offre un riepilogo del modo in cui i costruttori <xref:System.Lazy%601> controllano la memorizzazione nella cache delle eccezioni.</span><span class="sxs-lookup"><span data-stu-id="7bf35-190">The following table summarizes the way the <xref:System.Lazy%601> constructors control exception caching.</span></span>  
  
|<span data-ttu-id="7bf35-191">Costruttore</span><span class="sxs-lookup"><span data-stu-id="7bf35-191">Constructor</span></span>|<span data-ttu-id="7bf35-192">Modalità di thread safety</span><span class="sxs-lookup"><span data-stu-id="7bf35-192">Thread safety mode</span></span>|<span data-ttu-id="7bf35-193">Usa il metodo di inizializzazione</span><span class="sxs-lookup"><span data-stu-id="7bf35-193">Uses initialization method</span></span>|<span data-ttu-id="7bf35-194">Le eccezioni vengono memorizzate nella cache</span><span class="sxs-lookup"><span data-stu-id="7bf35-194">Exceptions are cached</span></span>|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|<span data-ttu-id="7bf35-195">Lazy(T)()</span><span class="sxs-lookup"><span data-stu-id="7bf35-195">Lazy(T)()</span></span>|<span data-ttu-id="7bf35-196">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="7bf35-196">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="7bf35-197">No</span><span class="sxs-lookup"><span data-stu-id="7bf35-197">No</span></span>|<span data-ttu-id="7bf35-198">No</span><span class="sxs-lookup"><span data-stu-id="7bf35-198">No</span></span>|  
|<span data-ttu-id="7bf35-199">Lazy(T)(Func(T))</span><span class="sxs-lookup"><span data-stu-id="7bf35-199">Lazy(T)(Func(T))</span></span>|<span data-ttu-id="7bf35-200">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="7bf35-200">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="7bf35-201">Sì</span><span class="sxs-lookup"><span data-stu-id="7bf35-201">Yes</span></span>|<span data-ttu-id="7bf35-202">Sì</span><span class="sxs-lookup"><span data-stu-id="7bf35-202">Yes</span></span>|  
|<span data-ttu-id="7bf35-203">Lazy(T)(Boolean)</span><span class="sxs-lookup"><span data-stu-id="7bf35-203">Lazy(T)(Boolean)</span></span>|<span data-ttu-id="7bf35-204">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) o `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="7bf35-204">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="7bf35-205">No</span><span class="sxs-lookup"><span data-stu-id="7bf35-205">No</span></span>|<span data-ttu-id="7bf35-206">No</span><span class="sxs-lookup"><span data-stu-id="7bf35-206">No</span></span>|  
|<span data-ttu-id="7bf35-207">Lazy(T)(Func(T), Boolean)</span><span class="sxs-lookup"><span data-stu-id="7bf35-207">Lazy(T)(Func(T), Boolean)</span></span>|<span data-ttu-id="7bf35-208">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) o `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="7bf35-208">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="7bf35-209">Sì</span><span class="sxs-lookup"><span data-stu-id="7bf35-209">Yes</span></span>|<span data-ttu-id="7bf35-210">Sì</span><span class="sxs-lookup"><span data-stu-id="7bf35-210">Yes</span></span>|  
|<span data-ttu-id="7bf35-211">Lazy(T)(LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="7bf35-211">Lazy(T)(LazyThreadSafetyMode)</span></span>|<span data-ttu-id="7bf35-212">Specificata dall'utente</span><span class="sxs-lookup"><span data-stu-id="7bf35-212">User-specified</span></span>|<span data-ttu-id="7bf35-213">No</span><span class="sxs-lookup"><span data-stu-id="7bf35-213">No</span></span>|<span data-ttu-id="7bf35-214">No</span><span class="sxs-lookup"><span data-stu-id="7bf35-214">No</span></span>|  
|<span data-ttu-id="7bf35-215">Lazy(T)(Func(T), LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="7bf35-215">Lazy(T)(Func(T), LazyThreadSafetyMode)</span></span>|<span data-ttu-id="7bf35-216">Specificata dall'utente</span><span class="sxs-lookup"><span data-stu-id="7bf35-216">User-specified</span></span>|<span data-ttu-id="7bf35-217">Sì</span><span class="sxs-lookup"><span data-stu-id="7bf35-217">Yes</span></span>|<span data-ttu-id="7bf35-218">No se l'utente specifica <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; in caso contrario, sì.</span><span class="sxs-lookup"><span data-stu-id="7bf35-218">No if user specifies <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; otherwise, yes.</span></span>|  
  
## <a name="implementing-a-lazy-initialized-property"></a><span data-ttu-id="7bf35-219">Implementazione di una proprietà a inizializzazione differita</span><span class="sxs-lookup"><span data-stu-id="7bf35-219">Implementing a Lazy-Initialized Property</span></span>  
 <span data-ttu-id="7bf35-220">Per implementare una proprietà pubblica usando l'inizializzazione differita, definire il campo sottostante della proprietà come <xref:System.Lazy%601> e restituire la proprietà <xref:System.Lazy%601.Value%2A> dalla funzione di accesso `get` della proprietà.</span><span class="sxs-lookup"><span data-stu-id="7bf35-220">To implement a public property by using lazy initialization, define the backing field of the property as a <xref:System.Lazy%601>, and return the <xref:System.Lazy%601.Value%2A> property from the `get` accessor of the property.</span></span>  
  
 [!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)]
 [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]  
  
 <span data-ttu-id="7bf35-221">Poiché la proprietà <xref:System.Lazy%601.Value%2A> è di sola lettura, la proprietà che la espone non ha funzioni di accesso `set`.</span><span class="sxs-lookup"><span data-stu-id="7bf35-221">The <xref:System.Lazy%601.Value%2A> property is read-only; therefore, the property that exposes it has no `set` accessor.</span></span> <span data-ttu-id="7bf35-222">Se è necessaria una proprietà di lettura/scrittura con un oggetto <xref:System.Lazy%601> sottostante, la funzione di accesso `set` deve creare un nuovo oggetto <xref:System.Lazy%601> e assegnarlo all'archivio sottostante.</span><span class="sxs-lookup"><span data-stu-id="7bf35-222">If you require a read/write property backed by a <xref:System.Lazy%601> object, the `set` accessor must create a new <xref:System.Lazy%601> object and assign it to the backing store.</span></span> <span data-ttu-id="7bf35-223">La funzione di accesso `set` deve creare un'espressione lambda che restituisca il nuovo valore di proprietà passato alla funzione di accesso `set` e passare l'espressione lambda al costruttore per il nuovo oggetto <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="7bf35-223">The `set` accessor must create a lambda expression that returns the new property value that was passed to the `set` accessor, and pass that lambda expression to the constructor for the new <xref:System.Lazy%601> object.</span></span> <span data-ttu-id="7bf35-224">L'accesso successivo della proprietà <xref:System.Lazy%601.Value%2A> provoca l'inizializzazione del nuovo oggetto <xref:System.Lazy%601> e da questo momento in poi la proprietà <xref:System.Lazy%601.Value%2A> correlata restituirà il nuovo valore assegnato alla proprietà.</span><span class="sxs-lookup"><span data-stu-id="7bf35-224">The next access of the <xref:System.Lazy%601.Value%2A> property will cause initialization of the new <xref:System.Lazy%601>, and its <xref:System.Lazy%601.Value%2A> property will thereafter return the new value that was assigned to the property.</span></span> <span data-ttu-id="7bf35-225">Il motivo di questo comportamento complesso è preservare le protezioni multithreading integrate in <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="7bf35-225">The reason for this convoluted arrangement is to preserve the multithreading protections built into <xref:System.Lazy%601>.</span></span> <span data-ttu-id="7bf35-226">In caso contrario, le funzioni di accesso della proprietà dovrebbero memorizzare nella cache il primo valore restituito dalla proprietà <xref:System.Lazy%601.Value%2A> e modificare solo il valore memorizzato nella cache e sarebbe necessario scrivere codice thread-safe personalizzato a questo scopo.</span><span class="sxs-lookup"><span data-stu-id="7bf35-226">Otherwise, the property accessors would have to cache the first value returned by the <xref:System.Lazy%601.Value%2A> property and only modify the cached value, and you would have to write your own thread-safe code to do that.</span></span> <span data-ttu-id="7bf35-227">A causa delle inizializzazioni aggiuntive necessarie per una proprietà di lettura/scrittura con un oggetto <xref:System.Lazy%601> sottostante, le prestazioni potrebbero non essere accettabili.</span><span class="sxs-lookup"><span data-stu-id="7bf35-227">Because of the additional initializations required by a read/write property backed by a <xref:System.Lazy%601> object, the performance might not be acceptable.</span></span> <span data-ttu-id="7bf35-228">Inoltre, a seconda dello scenario specifico, potrebbe essere necessario un ulteriore coordinamento per evitare race condition tra setter e getter.</span><span class="sxs-lookup"><span data-stu-id="7bf35-228">Furthermore, depending on the specific scenario, additional coordination might be required to avoid race conditions between setters and getters.</span></span>  
  
## <a name="thread-local-lazy-initialization"></a><span data-ttu-id="7bf35-229">Inizializzazione differita con dati locali del thread</span><span class="sxs-lookup"><span data-stu-id="7bf35-229">Thread-Local Lazy Initialization</span></span>  
 <span data-ttu-id="7bf35-230">In alcuni scenari di multithreading potrebbe essere necessario fornire a ogni thread dati privati propri.</span><span class="sxs-lookup"><span data-stu-id="7bf35-230">In some multithreaded scenarios, you might want to give each thread its own private data.</span></span> <span data-ttu-id="7bf35-231">Questi dati vengono chiamati *dati locali del thread*.</span><span class="sxs-lookup"><span data-stu-id="7bf35-231">Such data is called *thread-local data*.</span></span> <span data-ttu-id="7bf35-232">In .NET Framework 3.5 e versioni precedenti è possibile applicare l'attributo `ThreadStatic` a una variabile statica per renderla una variabile di thread locale.</span><span class="sxs-lookup"><span data-stu-id="7bf35-232">In the .NET Framework version 3.5 and earlier, you could apply the `ThreadStatic` attribute to a static variable to make it thread-local.</span></span> <span data-ttu-id="7bf35-233">Tuttavia, l'uso dell'attributo `ThreadStatic` può provocare errori difficili da rilevare.</span><span class="sxs-lookup"><span data-stu-id="7bf35-233">However, using the `ThreadStatic` attribute can lead to subtle errors.</span></span> <span data-ttu-id="7bf35-234">Ad esempio, anche istruzioni di inizializzazione di base possono far sì che la variabile venga inizializzata solo nel primo thread che vi accede, come mostrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="7bf35-234">For example, even basic initialization statements will cause the variable to be initialized only on the first thread that accesses it, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)]
 [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]  
  
 <span data-ttu-id="7bf35-235">In tutti gli altri thread la variabile verrà inizializzata usando il valore predefinito (zero).</span><span class="sxs-lookup"><span data-stu-id="7bf35-235">On all other threads, the variable will be initialized by using its default value (zero).</span></span> <span data-ttu-id="7bf35-236">Come alternativa, in .NET Framework 4 è possibile usare il tipo <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> per creare una variabile di thread locale basata su istanza che deve essere inizializzata in tutti i thread dal delegato <xref:System.Action%601> specificato personalmente.</span><span class="sxs-lookup"><span data-stu-id="7bf35-236">As an alternative in the .NET Framework version 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> type to create an instance-based, thread-local variable that is initialized on all threads by the <xref:System.Action%601> delegate that you provide.</span></span> <span data-ttu-id="7bf35-237">Nell'esempio seguente tutti i thread che accedono a `counter` visualizzeranno il valore iniziale come 1.</span><span class="sxs-lookup"><span data-stu-id="7bf35-237">In the following example, all threads that access `counter` will see its starting value as 1.</span></span>  
  
 [!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)]
 [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]  
  
 <span data-ttu-id="7bf35-238"><xref:System.Threading.ThreadLocal%601> esegue il wrapping del proprio oggetto quasi allo stesso modo di <xref:System.Lazy%601>, con queste importanti differenze:</span><span class="sxs-lookup"><span data-stu-id="7bf35-238"><xref:System.Threading.ThreadLocal%601> wraps its object in much the same way as <xref:System.Lazy%601>, with these essential differences:</span></span>  
  
- <span data-ttu-id="7bf35-239">Ogni thread inizializza la variabile di thread locale usando i propri dati privati, che non sono accessibili da altri thread.</span><span class="sxs-lookup"><span data-stu-id="7bf35-239">Each thread initializes the thread-local variable by using its own private data that is not accessible from other threads.</span></span>  
  
- <span data-ttu-id="7bf35-240">La proprietà <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> è di lettura/scrittura e può essere modificata tutte le volte che è necessario.</span><span class="sxs-lookup"><span data-stu-id="7bf35-240">The <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> property is read-write, and can be modified any number of times.</span></span> <span data-ttu-id="7bf35-241">Questo può influire sulla propagazione delle eccezioni. Ad esempio, un'operazione `get` può generare un'eccezione, ma la successiva può inizializzare correttamente il valore.</span><span class="sxs-lookup"><span data-stu-id="7bf35-241">This can affect exception propagation, for example, one `get` operation can raise an exception but the next one can successfully initialize the value.</span></span>  
  
- <span data-ttu-id="7bf35-242">Se non si specifica alcun delegato di inizializzazione, <xref:System.Threading.ThreadLocal%601> inizializza il tipo con wrapping usando il valore predefinito del tipo.</span><span class="sxs-lookup"><span data-stu-id="7bf35-242">If no initialization delegate is provided, <xref:System.Threading.ThreadLocal%601> will initialize its wrapped type by using the default value of the type.</span></span> <span data-ttu-id="7bf35-243">In questo senso, <xref:System.Threading.ThreadLocal%601> è coerente con l'attributo <xref:System.ThreadStaticAttribute>.</span><span class="sxs-lookup"><span data-stu-id="7bf35-243">In this regard, <xref:System.Threading.ThreadLocal%601> is consistent with the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
 <span data-ttu-id="7bf35-244">L'esempio seguente mostra che ogni thread che accede all'istanza `ThreadLocal<int>` ottiene una copia univoca dei dati.</span><span class="sxs-lookup"><span data-stu-id="7bf35-244">The following example demonstrates that every thread that accesses the `ThreadLocal<int>` instance gets its own unique copy of the data.</span></span>  
  
 [!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)]
 [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a><span data-ttu-id="7bf35-245">Variabili di thread locali in Parallel.For e ForEach</span><span class="sxs-lookup"><span data-stu-id="7bf35-245">Thread-Local Variables in Parallel.For and ForEach</span></span>  
 <span data-ttu-id="7bf35-246">Quando si usa il metodo <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> o <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> per eseguire l'iterazione delle origini dati in parallelo, è possibile usare gli overload che includono supporto integrato per dati locali del thread.</span><span class="sxs-lookup"><span data-stu-id="7bf35-246">When you use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to iterate over data sources in parallel, you can use the overloads that have built-in support for thread-local data.</span></span> <span data-ttu-id="7bf35-247">In questi metodi la natura locale dei dati del thread viene ottenuta usando delegati locali per accedere ai dati, crearli e pulirli.</span><span class="sxs-lookup"><span data-stu-id="7bf35-247">In these methods, the thread-locality is achieved by using local delegates to create, access, and clean up the data.</span></span> <span data-ttu-id="7bf35-248">Per altre informazioni, vedere [Procedura: Scrivere un ciclo Parallel.For con variabili di thread locali](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) e [Procedura: Scrivere un ciclo Parallel.ForEach con variabili partition-local](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="7bf35-248">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a><span data-ttu-id="7bf35-249">Uso dell'inizializzazione differita per scenari con sovraccarico ridotto</span><span class="sxs-lookup"><span data-stu-id="7bf35-249">Using Lazy Initialization for Low-Overhead Scenarios</span></span>  
 <span data-ttu-id="7bf35-250">Negli scenari in cui è necessario inizializzare in modo differito un numero elevato di oggetti, si potrebbe stabilire che il wrapping di ogni oggetto in un oggetto <xref:System.Lazy%601> richiede una quantità eccessiva di memoria o di risorse di calcolo.</span><span class="sxs-lookup"><span data-stu-id="7bf35-250">In scenarios where you have to lazy-initialize a large number of objects, you might decide that wrapping each object in a <xref:System.Lazy%601> requires too much memory or too many computing resources.</span></span> <span data-ttu-id="7bf35-251">In un altro caso, potrebbe essere necessario soddisfare requisiti rigorosi relativamente all'esposizione dell'inizializzazione differita.</span><span class="sxs-lookup"><span data-stu-id="7bf35-251">Or, you might have stringent requirements about how lazy initialization is exposed.</span></span> <span data-ttu-id="7bf35-252">In questi casi, è possibile usare i metodi `static` (`Shared` in Visual Basic) della classe <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> per inizializzare in modo differito ogni oggetto senza eseguirne il wrapping in un'istanza di <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="7bf35-252">In such cases, you can use the `static` (`Shared` in Visual Basic) methods of the <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> class to lazy-initialize each object without wrapping it in an instance of <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="7bf35-253">Invece di eseguire il wrapping di un intero oggetto `Orders` in un oggetto <xref:System.Lazy%601>, nell'esempio seguente si supponga di aver inizializzato in modo differito singoli oggetti `Order` solo quando sono necessari.</span><span class="sxs-lookup"><span data-stu-id="7bf35-253">In the following example, assume that, instead of wrapping an entire `Orders` object in one <xref:System.Lazy%601> object, you have lazy-initialized individual `Order` objects only if they are required.</span></span>  
  
 [!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)]
 [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]  
  
 <span data-ttu-id="7bf35-254">In questo esempio notare che la procedura di inizializzazione viene richiamata a ogni iterazione del ciclo.</span><span class="sxs-lookup"><span data-stu-id="7bf35-254">In this example, notice that the initialization procedure is invoked on every iteration of the loop.</span></span> <span data-ttu-id="7bf35-255">In scenari di multithreading, il primo thread che richiama la procedura di inizializzazione è quello i cui valori vengono visualizzati da tutti i thread.</span><span class="sxs-lookup"><span data-stu-id="7bf35-255">In multi-threaded scenarios, the first thread to invoke the initialization procedure is the one whose value is seen by all threads.</span></span> <span data-ttu-id="7bf35-256">Anche i thread successivi richiamano la procedura di inizializzazione, ma i loro risultati non vengono usati.</span><span class="sxs-lookup"><span data-stu-id="7bf35-256">Later threads also invoke the initialization procedure, but their results are not used.</span></span> <span data-ttu-id="7bf35-257">Se questo tipo di possibile race condition non è accettabile, usare l'overload di <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType>, che accetta un argomento booleano e un oggetto di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="7bf35-257">If this kind of potential race condition is not acceptable, use the overload of <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> that takes a Boolean argument and a synchronization object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7bf35-258">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="7bf35-258">See also</span></span>

- [<span data-ttu-id="7bf35-259">Nozioni fondamentali sul threading gestito</span><span class="sxs-lookup"><span data-stu-id="7bf35-259">Managed Threading Basics</span></span>](../../standard/threading/managed-threading-basics.md)
- [<span data-ttu-id="7bf35-260">Thread e Threading</span><span class="sxs-lookup"><span data-stu-id="7bf35-260">Threads and Threading</span></span>](../../standard/threading/threads-and-threading.md)
- [<span data-ttu-id="7bf35-261">Task Parallel Library (TPL)</span><span class="sxs-lookup"><span data-stu-id="7bf35-261">Task Parallel Library (TPL)</span></span>](../../standard/parallel-programming/task-parallel-library-tpl.md)
- [<span data-ttu-id="7bf35-262">Procedura: eseguire l'inizializzazione lenta di oggetti</span><span class="sxs-lookup"><span data-stu-id="7bf35-262">How to: Perform Lazy Initialization of Objects</span></span>](how-to-perform-lazy-initialization-of-objects.md)
