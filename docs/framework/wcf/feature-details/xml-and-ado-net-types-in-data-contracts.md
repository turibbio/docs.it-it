---
title: Tipi XML e ADO.NET nei contratti dati
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: c2ce8461-3c15-4c41-8c81-1cb78f5b59a6
ms.openlocfilehash: 975d4f4f37bbbd895cab4e87686f15017e90f382
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/09/2020
ms.locfileid: "84600075"
---
# <a name="xml-and-adonet-types-in-data-contracts"></a><span data-ttu-id="ce969-102">Tipi XML e ADO.NET nei contratti dati</span><span class="sxs-lookup"><span data-stu-id="ce969-102">XML and ADO.NET Types in Data Contracts</span></span>
<span data-ttu-id="ce969-103">Il modello di contratto dati Windows Communication Foundation (WCF) supporta determinati tipi che rappresentano direttamente il codice XML.</span><span class="sxs-lookup"><span data-stu-id="ce969-103">The Windows Communication Foundation (WCF) data contract model supports certain types that represent XML directly.</span></span> <span data-ttu-id="ce969-104">Quando questi tipi vengono serializzati in XML, il serializzatore scrive il contenuto XML di questi tipi senza ulteriore elaborazione.</span><span class="sxs-lookup"><span data-stu-id="ce969-104">When these types are serialized to XML, the serializer writes out the XML contents of these types without any further processing.</span></span> <span data-ttu-id="ce969-105">I tipi supportati sono <xref:System.Xml.XmlElement>, matrici di <xref:System.Xml.XmlNode> (ma non il tipo `XmlNode` stesso) e tipi che implementano <xref:System.Xml.Serialization.IXmlSerializable>.</span><span class="sxs-lookup"><span data-stu-id="ce969-105">Supported types are <xref:System.Xml.XmlElement>, arrays of <xref:System.Xml.XmlNode> (but not the `XmlNode` type itself), as well as types that implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span> <span data-ttu-id="ce969-106">I tipi <xref:System.Data.DataSet> e <xref:System.Data.DataTable>, nonché i dataset tipizzati, vengono comunemente usati nella programmazione dei database.</span><span class="sxs-lookup"><span data-stu-id="ce969-106">The <xref:System.Data.DataSet> and <xref:System.Data.DataTable> type, as well as typed datasets, are commonly used in database programming.</span></span> <span data-ttu-id="ce969-107">Questi tipi implementano l'interfaccia `IXmlSerializable` e sono pertanto serializzabili nel modello del contratto dati.</span><span class="sxs-lookup"><span data-stu-id="ce969-107">These types implement the `IXmlSerializable` interface and are therefore serializable in the data contract model.</span></span> <span data-ttu-id="ce969-108">Alcune considerazioni speciali per questi tipi sono elencate alla fine di questo argomento.</span><span class="sxs-lookup"><span data-stu-id="ce969-108">Some special considerations for these types are listed at the end of this topic.</span></span>  
  
## <a name="xml-types"></a><span data-ttu-id="ce969-109">Tipi XML</span><span class="sxs-lookup"><span data-stu-id="ce969-109">XML Types</span></span>  
  
### <a name="xml-element"></a><span data-ttu-id="ce969-110">Elemento XML</span><span class="sxs-lookup"><span data-stu-id="ce969-110">Xml Element</span></span>  
 <span data-ttu-id="ce969-111">Il tipo `XmlElement` viene serializzato usando il contenuto XML.</span><span class="sxs-lookup"><span data-stu-id="ce969-111">The `XmlElement` type is serialized using its XML contents.</span></span> <span data-ttu-id="ce969-112">Si usi ad esempio il tipo seguente.</span><span class="sxs-lookup"><span data-stu-id="ce969-112">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#4)]
 [!code-vb[DataContractAttribute#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#4)]  
  
 <span data-ttu-id="ce969-113">Questo tipo viene serializzato in XML come segue:</span><span class="sxs-lookup"><span data-stu-id="ce969-113">This is serialized to XML as follows:</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
    <myDataMember>  
        <myElement xmlns="" myAttribute="myValue">  
            myContents  
        </myElement>  
    </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="ce969-114">Si noti che è ancora presente un elemento `<myDataMember>` membro dati del wrapper.</span><span class="sxs-lookup"><span data-stu-id="ce969-114">Notice that a wrapper data member element `<myDataMember>` is still present.</span></span> <span data-ttu-id="ce969-115">Non è possibile rimuovere questo elemento dal modello del contratto dati.</span><span class="sxs-lookup"><span data-stu-id="ce969-115">There is no way of removing this element in the data contract model.</span></span> <span data-ttu-id="ce969-116">I serializzatori che gestiscono questo modello (<xref:System.Runtime.Serialization.DataContractSerializer> e <xref:System.Runtime.Serialization.NetDataContractSerializer>) possono generare attributi speciali in questo elemento wrapper.</span><span class="sxs-lookup"><span data-stu-id="ce969-116">The serializers that handle this model (the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>) may emit special attributes into this wrapper element.</span></span> <span data-ttu-id="ce969-117">Tali attributi includono l'attributo "nil" standard dell'istanza di XML Schema (consentendo a `XmlElement` di essere `null`) e l'attributo "type" (consentendo l'uso di `XmlElement` in modo polimorfico).</span><span class="sxs-lookup"><span data-stu-id="ce969-117">These attributes include the standard XML Schema Instance "nil" attribute (allowing the `XmlElement` to be `null`) and the "type" attribute (allowing `XmlElement` to be used polymorphically).</span></span> <span data-ttu-id="ce969-118">Inoltre, gli attributi XML seguenti sono specifici di WCF: "ID", "ref", "Type" e "assembly".</span><span class="sxs-lookup"><span data-stu-id="ce969-118">Also, the following XML attributes are specific to WCF: "Id", "Ref", "Type" and "Assembly".</span></span> <span data-ttu-id="ce969-119">Questi attributi possono essere generati per supportare l'uso di `XmlElement` con la modalità di mantenimento dell'oggetto grafico abilitata o con <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="ce969-119">These attributes may be emitted to support using the `XmlElement` with the object graph preservation mode enabled, or with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="ce969-120">Per ulteriori informazioni sulla modalità di conservazione dell'oggetto grafico, vedere [serializzazione e deserializzazione](serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="ce969-120">(For more information about the object graph preservation mode, see [Serialization and Deserialization](serialization-and-deserialization.md).)</span></span>  
  
 <span data-ttu-id="ce969-121">Le matrici o raccolte di `XmlElement` sono consentite e sono gestite come qualsiasi altra matrice o raccolta.</span><span class="sxs-lookup"><span data-stu-id="ce969-121">Arrays or collections of `XmlElement` are allowed and are handled as any other array or collection.</span></span> <span data-ttu-id="ce969-122">Ovvero, è presente un elemento wrapper per l'intera raccolta e un elemento wrapper separato (simile a `<myDataMember>` della matrice.</span><span class="sxs-lookup"><span data-stu-id="ce969-122">That is, there is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each `XmlElement` in the array.</span></span>  
  
 <span data-ttu-id="ce969-123">Durante la deserializzazione, viene creato un `XmlElement` dal deserializzatore per il file XML in ingresso.</span><span class="sxs-lookup"><span data-stu-id="ce969-123">On deserialization, an `XmlElement` is created by the deserializer from the incoming XML.</span></span> <span data-ttu-id="ce969-124">Dal deserializzatore viene fornito un elemento <xref:System.Xml.XmlDocument> padre valido.</span><span class="sxs-lookup"><span data-stu-id="ce969-124">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span>  
  
 <span data-ttu-id="ce969-125">Verificare che il frammento XML che viene deserializzato in un `XmlElement` definisca tutti i prefissi usati e non si basi su definizioni di prefissi degli elementi predecessori.</span><span class="sxs-lookup"><span data-stu-id="ce969-125">Make sure that the XML fragment that is deserialized to an `XmlElement` defines all prefixes that it uses and does not rely on any prefix definitions from ancestor elements.</span></span> <span data-ttu-id="ce969-126">Questo aspetto è importante solo quando si adopera `DataContractSerializer` per usare il file XML da un'origine diversa (non `DataContractSerializer`).</span><span class="sxs-lookup"><span data-stu-id="ce969-126">This is a concern only when using the `DataContractSerializer` to access XML from a different (non-`DataContractSerializer`) source.</span></span>  
  
 <span data-ttu-id="ce969-127">Se utilizzato con `DataContractSerializer` , `XmlElement` può essere assegnato in modo polimorfico, ma solo a un membro dati di tipo <xref:System.Object> .</span><span class="sxs-lookup"><span data-stu-id="ce969-127">When used with the `DataContractSerializer`, the `XmlElement` may be assigned polymorphically, but only to a data member of type <xref:System.Object>.</span></span> <span data-ttu-id="ce969-128">Sebbene implementi <xref:System.Collections.IEnumerable>, `XmlElement` non può essere usato come tipo di raccolta e non può essere assegnato a un membro dati <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="ce969-128">Even though it implements <xref:System.Collections.IEnumerable>, an `XmlElement` cannot be used as a collection type and cannot be assigned to an <xref:System.Collections.IEnumerable> data member.</span></span> <span data-ttu-id="ce969-129">Come per tutte le assegnazioni polimorfiche, `DataContractSerializer` genera il nome del contratto dati nel codice XML risultante, in questo caso è "XmlElement" nello http://schemas.datacontract.org/2004/07/System.Xml spazio dei nomi "".</span><span class="sxs-lookup"><span data-stu-id="ce969-129">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "XmlElement" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span>  
  
 <span data-ttu-id="ce969-130">Con `NetDataContractSerializer`, è supportata qualsiasi assegnazione polimorfica valida di `XmlElement` (`Object` o `IEnumerable`).</span><span class="sxs-lookup"><span data-stu-id="ce969-130">With the `NetDataContractSerializer`, any valid polymorphic assignment of `XmlElement` (to `Object` or `IEnumerable`) is supported.</span></span>  
  
 <span data-ttu-id="ce969-131">Non tentare di usare uno dei serializzatori con i tipi derivati da `XmlElement`, indipendentemente dal fatto che siano stati assegnati in modo polimorfico o meno.</span><span class="sxs-lookup"><span data-stu-id="ce969-131">Do not attempt to use either of the serializers with types derived from `XmlElement`, whether they are assigned polymorphically or not.</span></span>  
  
### <a name="array-of-xmlnode"></a><span data-ttu-id="ce969-132">Matrice di XmlNode</span><span class="sxs-lookup"><span data-stu-id="ce969-132">Array of XmlNode</span></span>  
 <span data-ttu-id="ce969-133">L'uso di matrici di <xref:System.Xml.XmlNode> è molto simile all'uso di `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="ce969-133">Using arrays of <xref:System.Xml.XmlNode> is very similar to using `XmlElement`.</span></span> <span data-ttu-id="ce969-134">Tuttavia, la scelta di usare matrici di `XmlNode` garantisce una maggiore flessibilità rispetto all'uso di `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="ce969-134">Using arrays of `XmlNode` gives you more flexibility than using `XmlElement`.</span></span> <span data-ttu-id="ce969-135">È possibile scrivere più elementi nell'elemento wrapper del membro dati</span><span class="sxs-lookup"><span data-stu-id="ce969-135">You can write multiple elements inside the data member wrapping element.</span></span> <span data-ttu-id="ce969-136">E’ possibile inserire al suo interno un contenuto diverso dagli elementi, ad esempio commenti XML.</span><span class="sxs-lookup"><span data-stu-id="ce969-136">You can also inject content other than elements inside of the data member wrapping element, such as XML comments.</span></span> <span data-ttu-id="ce969-137">Infine, è inoltre possibile inserire attributi nell'elemento wrapper del membro dati.</span><span class="sxs-lookup"><span data-stu-id="ce969-137">Finally, you can put attributes into the wrapping data member element.</span></span> <span data-ttu-id="ce969-138">Tutte queste operazioni possono essere realizzate popolando la matrice di `XmlNode` con classi derivate specifiche di `XmlNode`, ad esempio <xref:System.Xml.XmlAttribute>, `XmlElement` o <xref:System.Xml.XmlComment>.</span><span class="sxs-lookup"><span data-stu-id="ce969-138">All this can be achieved by populating the array of `XmlNode` with specific derived classes of `XmlNode` such as <xref:System.Xml.XmlAttribute>, `XmlElement` or <xref:System.Xml.XmlComment>.</span></span> <span data-ttu-id="ce969-139">Si usi ad esempio il tipo seguente.</span><span class="sxs-lookup"><span data-stu-id="ce969-139">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#5)]
 [!code-vb[DataContractAttribute#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#5)]  
  
 <span data-ttu-id="ce969-140">Quando viene serializzato, l'XML risultante è simile al codice seguente.</span><span class="sxs-lookup"><span data-stu-id="ce969-140">When serialized, the resulting XML is similar to the following code.</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
  <myDataMember myAttribute="myValue">  
     <!--myComment-->  
     <myElement xmlns="" myAttribute="myValue">  
 myContents  
     </myElement>  
     <myElement xmlns="" myAttribute="myValue">  
       myContents  
     </myElement>  
  </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="ce969-141">Si noti che l'elemento wrapper del membro dati `<myDataMember>` contiene un attributo, un commento e due elementi.</span><span class="sxs-lookup"><span data-stu-id="ce969-141">Note that the data member wrapper element `<myDataMember>` contains an attribute, a comment, and two elements.</span></span> <span data-ttu-id="ce969-142">Sono le quattro istanze di `XmlNode` serializzate.</span><span class="sxs-lookup"><span data-stu-id="ce969-142">These are the four `XmlNode` instances that were serialized.</span></span>  
  
 <span data-ttu-id="ce969-143">Non è possibile serializzare una matrice di `XmlNode` che causa un XML non valido.</span><span class="sxs-lookup"><span data-stu-id="ce969-143">An array of `XmlNode` that results in invalid XML cannot be serialized.</span></span> <span data-ttu-id="ce969-144">Ad esempio, una matrice di due istanze di `XmlNode` di cui la prima è un `XmlElement` e la seconda è un <xref:System.Xml.XmlAttribute> non è valida poiché questa sequenza non corrisponde ad alcuna istanza XML valida (non è possibile allegare un attributo).</span><span class="sxs-lookup"><span data-stu-id="ce969-144">For example, an array of two `XmlNode` instances where the first one is an `XmlElement` and the second one is an <xref:System.Xml.XmlAttribute> is invalid, because this sequence does not correspond to any valid XML instance (there is no place to attach the attribute to).</span></span>  
  
 <span data-ttu-id="ce969-145">Durante la deserializzazione di una matrice di `XmlNode`, i nodi vengono creati e popolati con informazioni derivate dal file XML in ingresso.</span><span class="sxs-lookup"><span data-stu-id="ce969-145">On deserialization of an array of `XmlNode`, nodes are created and populated with information from the incoming XML.</span></span> <span data-ttu-id="ce969-146">Dal deserializzatore viene fornito un elemento <xref:System.Xml.XmlDocument> padre valido.</span><span class="sxs-lookup"><span data-stu-id="ce969-146">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span> <span data-ttu-id="ce969-147">Tutti i nodi vengono deserializzati, inclusi tutti gli attributi sull'elemento del membro dati wrapper, esclusi gli attributi posizionati dai serializzatori WCF (ad esempio, gli attributi utilizzati per indicare l'assegnazione polimorfica).</span><span class="sxs-lookup"><span data-stu-id="ce969-147">All nodes are deserialized, including any attributes on the wrapper data member element, but excluding the attributes placed there by the WCF serializers (such as the attributes used to indicate polymorphic assignment).</span></span> <span data-ttu-id="ce969-148">La necessità di definire tutti i prefissi degli spazi dei nomi nel frammento XML si applica alla deserializzazione delle matrici di `XmlNode` e alla deserializzazione di `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="ce969-148">The caveat about defining all namespace prefixes in the XML fragment applies to the deserialization of arrays of `XmlNode` just like it does to deserializing `XmlElement`.</span></span>  
  
 <span data-ttu-id="ce969-149">Se si usano serializzatori per i quali è attivato il mantenimento dell'oggetto grafico, l'uguaglianza degli oggetti viene mantenuta solo a livello delle matrici di `XmlNode` e non per le singole istanze di `XmlNode`.</span><span class="sxs-lookup"><span data-stu-id="ce969-149">When using the serializers with object graph preservation turned on, object equality is only preserved on the level of `XmlNode` arrays, not individual `XmlNode` instances.</span></span>  
  
 <span data-ttu-id="ce969-150">Non tentare di serializzare una matrice di `XmlNode` se uno o più nodi è impostato su `null`.</span><span class="sxs-lookup"><span data-stu-id="ce969-150">Do not attempt to serialize an array of `XmlNode` where one or more of the nodes is set to `null`.</span></span> <span data-ttu-id="ce969-151">L'intero membro matrice può essere `null`, ma non i singoli `XmlNode` contenuti nella matrice.</span><span class="sxs-lookup"><span data-stu-id="ce969-151">It is permitted for the entire array member to be `null`, but not for any individual `XmlNode` contained in the array.</span></span> <span data-ttu-id="ce969-152">Se l'intero membro matrice è Null, l'elemento wrapper del membro dati contiene un attributo speciale che indica che è Null.</span><span class="sxs-lookup"><span data-stu-id="ce969-152">If the entire array member is null, the wrapper data member element contains a special attribute that indicates that it is null.</span></span> <span data-ttu-id="ce969-153">Durante la deserializzazione, anche l'intero membro matrice diviene Null.</span><span class="sxs-lookup"><span data-stu-id="ce969-153">On deserialization, the entire array member also becomes null.</span></span>  
  
 <span data-ttu-id="ce969-154">Solo le matrici normali di `XmlNode` vengono trattate in modo speciale dal serializzatore.</span><span class="sxs-lookup"><span data-stu-id="ce969-154">Only regular arrays of `XmlNode` are treated specially by the serializer.</span></span> <span data-ttu-id="ce969-155">I membri dati dichiarati come altri tipi di raccolta contenenti `XmlNode` o i membri dati dichiarati come matrici di tipi derivati da `XmlNode` non vengono trattati in modo speciale.</span><span class="sxs-lookup"><span data-stu-id="ce969-155">Data members declared as other collection types that contain `XmlNode`, or data members declared as arrays of types derived from `XmlNode`, are not treated specially.</span></span> <span data-ttu-id="ce969-156">Pertanto, in genere non sono serializzabili a meno che soddisfino anche uno degli altri criteri di serializzazione.</span><span class="sxs-lookup"><span data-stu-id="ce969-156">Thus, they are normally not serializable unless they also meet one of the other criteria for serializing.</span></span>  
  
 <span data-ttu-id="ce969-157">Sono consentite matrici o raccolte di matrici di `XmlNode`.</span><span class="sxs-lookup"><span data-stu-id="ce969-157">Arrays or collections of arrays of `XmlNode` are allowed.</span></span> <span data-ttu-id="ce969-158">E’ presente un elemento wrapper per l'intera raccolta e un elemento wrapper separato (simile a  nell'esempio precedente) per ogni matrice di  nella matrice esterna o nella raccolta.</span><span class="sxs-lookup"><span data-stu-id="ce969-158">There is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each array of `XmlNode` in the outer array or collection.</span></span>  
  
 <span data-ttu-id="ce969-159">Se si popola un membro dati di tipo <xref:System.Array> di `Object` o `Array` di `IEnumerable` con le istanze di `XmlNode`, il membro dati non viene trattato come una `Array` di istanze di `XmlNode`.</span><span class="sxs-lookup"><span data-stu-id="ce969-159">Populating a data member of type <xref:System.Array> of `Object` or `Array` of `IEnumerable` with `XmlNode` instances does not result in the data member being treated as an `Array` of `XmlNode` instances.</span></span> <span data-ttu-id="ce969-160">Ogni membro della matrice viene serializzato separatamente.</span><span class="sxs-lookup"><span data-stu-id="ce969-160">Each array member is serialized separately.</span></span>  
  
 <span data-ttu-id="ce969-161">Se si usano con `DataContractSerializer`, le matrici di `XmlNode` possono essere assegnate in modo polimorfico, ma solo a un membro dati di tipo `Object`.</span><span class="sxs-lookup"><span data-stu-id="ce969-161">When used with the `DataContractSerializer`, arrays of `XmlNode` can be assigned polymorphically, but only to a data member of type `Object`.</span></span> <span data-ttu-id="ce969-162">Sebbene implementi `IEnumerable`, una matrice di `XmlNode` non può essere usata come tipo di raccolta e non può essere assegnata a un membro dati `IEnumerable`.</span><span class="sxs-lookup"><span data-stu-id="ce969-162">Even though it implements `IEnumerable`, an array of `XmlNode` cannot be used as a collection type and be assigned to an `IEnumerable` data member.</span></span> <span data-ttu-id="ce969-163">Come per tutte le assegnazioni polimorfiche, `DataContractSerializer` genera il nome del contratto dati nel codice XML risultante, in questo caso è "ArrayOfXmlNode" nello http://schemas.datacontract.org/2004/07/System.Xml spazio dei nomi "".</span><span class="sxs-lookup"><span data-stu-id="ce969-163">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "ArrayOfXmlNode" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span> <span data-ttu-id="ce969-164">Se utilizzata con `NetDataContractSerializer` , qualsiasi assegnazione valida di una `XmlNode` matrice è supportata.</span><span class="sxs-lookup"><span data-stu-id="ce969-164">When used with the `NetDataContractSerializer`, any valid assignment of an `XmlNode` array is supported.</span></span>  
  
### <a name="schema-considerations"></a><span data-ttu-id="ce969-165">Considerazioni sugli schemi</span><span class="sxs-lookup"><span data-stu-id="ce969-165">Schema Considerations</span></span>  
 <span data-ttu-id="ce969-166">Per informazioni dettagliate sul mapping dello schema dei tipi XML, vedere [riferimento allo schema del contratto dati](data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="ce969-166">For details about the schema mapping of XML types, see [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span> <span data-ttu-id="ce969-167">Questa sezione fornisce un riepilogo dei punti importanti.</span><span class="sxs-lookup"><span data-stu-id="ce969-167">This section provides a summary of the important points.</span></span>  
  
 <span data-ttu-id="ce969-168">Un membro dati di tipo `XmlElement` viene mappato a un elemento definito usando il tipo anonimo seguente.</span><span class="sxs-lookup"><span data-stu-id="ce969-168">A data member of type `XmlElement` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType>  
   <xsd:sequence>  
      <xsd:any minOccurs="0" processContents="lax" />  
   </xsd:sequence>  
</xsd:complexType>  
```  
  
 <span data-ttu-id="ce969-169">Un membro dati di tipo matrice di `XmlNode` viene mappato a un elemento definito usando il tipo anonimo seguente.</span><span class="sxs-lookup"><span data-stu-id="ce969-169">A data member of type Array of `XmlNode` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType mixed="true">  
   <xsd:sequence>  
      <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax" />  
   </xsd:sequence>  
   <xsd:anyAttribute/>  
</xsd:complexType>  
```  
  
## <a name="types-implementing-the-ixmlserializable-interface"></a><span data-ttu-id="ce969-170">Tipi che implementano l'interfaccia IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="ce969-170">Types Implementing the IXmlSerializable Interface</span></span>  
 <span data-ttu-id="ce969-171">I tipi che implementano l'interfaccia `IXmlSerializable` sono completamente supportati da `DataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="ce969-171">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="ce969-172">L'attributo <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> deve essere applicato sempre a questi tipi per controllarne lo schema.</span><span class="sxs-lookup"><span data-stu-id="ce969-172">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>  
  
 <span data-ttu-id="ce969-173">Esistono tre varietà di tipi che implementano `IXmlSerializable`: i tipi che rappresentano contenuto arbitrario, i tipi che rappresentano un singolo elemento e i tipi <xref:System.Data.DataSet> legacy.</span><span class="sxs-lookup"><span data-stu-id="ce969-173">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>  
  
- <span data-ttu-id="ce969-174">I tipi di contenuto usano un metodo del provider dello schema specificato dall'attributo `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="ce969-174">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="ce969-175">Il metodo non restituisce `null` e la proprietà <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> dell'attributo mantiene il valore predefinito `false`.</span><span class="sxs-lookup"><span data-stu-id="ce969-175">The method does not return `null`, and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="ce969-176">Si tratta dell'utilizzo più comune di tipi `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="ce969-176">This is the most common usage of `IXmlSerializable` types.</span></span>  
  
- <span data-ttu-id="ce969-177">I tipi di elemento vengono usati quando un tipo `IXmlSerializable` deve controllare il nome del relativo elemento radice.</span><span class="sxs-lookup"><span data-stu-id="ce969-177">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="ce969-178">Per contrassegnare un tipo come tipo di elemento, impostare la proprietà <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> dell'attributo <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> su `true` o fare in modo che il metodo del provider dello schema restituisca Null.</span><span class="sxs-lookup"><span data-stu-id="ce969-178">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return null from the schema provider method.</span></span> <span data-ttu-id="ce969-179">Il metodo del provider dello schema è facoltativo per i tipi di elemento; è infatti possibile specificare Null anziché il nome del metodo in `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="ce969-179">Having a schema provider method is optional for element types – you may specify null instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="ce969-180">Tuttavia, se `IsAny` è `true` ed è specificato un metodo del provider dello schema, il metodo deve restituire Null.</span><span class="sxs-lookup"><span data-stu-id="ce969-180">However, if `IsAny` is `true` and a schema provider method is specified, the method must return null.</span></span>  
  
- <span data-ttu-id="ce969-181">I tipi <xref:System.Data.DataSet> legacy sono tipi `IXmlSerializable` non contrassegnati con l'attributo `XmlSchemaProviderAttribute`,</span><span class="sxs-lookup"><span data-stu-id="ce969-181">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="ce969-182">che si basano sul metodo <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> per la generazione dello schema.</span><span class="sxs-lookup"><span data-stu-id="ce969-182">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="ce969-183">Questo modello è usato per il tipo `DataSet` e le relative classi derivate del dataset tipizzato nelle versioni precedenti di .NET Framework, ma ora è obsoleto ed è supportato solo per elementi legacy.</span><span class="sxs-lookup"><span data-stu-id="ce969-183">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="ce969-184">Non è consigliabile basarsi su questo modello, bensì applicare sempre `XmlSchemaProviderAttribute` ai tipi `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="ce969-184">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>  
  
### <a name="ixmlserializable-content-types"></a><span data-ttu-id="ce969-185">Tipi di contenuto IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="ce969-185">IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="ce969-186">Quando si serializza un membro dati di un tipo che implementa `IXmlSerializable` e il tipo di contenuto rispecchia la definizione precedente, il serializzatore scrive l'elemento wrapper per il membro dati e passa il controllo al metodo <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A>.</span><span class="sxs-lookup"><span data-stu-id="ce969-186">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="ce969-187">L'implementazione <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> può scrivere qualsiasi elemento XML e può anche aggiungere attributi all'elemento wrapper.</span><span class="sxs-lookup"><span data-stu-id="ce969-187">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, including adding attributes to the wrapper element.</span></span> <span data-ttu-id="ce969-188">Quando l'operazione `WriteXml` è stata completata, il serializzatore chiude l'elemento.</span><span class="sxs-lookup"><span data-stu-id="ce969-188">After `WriteXml` is done, the serializer closes the element.</span></span>  
  
 <span data-ttu-id="ce969-189">Quando si deserializza un membro dati di un tipo che implementa `IXmlSerializable` e il tipo di contenuto rispecchia la definizione precedente, il deserializzatore posiziona il lettore XML sull'elemento wrapper per il membro dati e passa il controllo al metodo <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A>.</span><span class="sxs-lookup"><span data-stu-id="ce969-189">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="ce969-190">Il metodo deve leggere l'elemento intero, inclusi i tag di inizio e fine.</span><span class="sxs-lookup"><span data-stu-id="ce969-190">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="ce969-191">Verificare che il codice `ReadXml` gestisca l'eventualità che l'elemento sia vuoto.</span><span class="sxs-lookup"><span data-stu-id="ce969-191">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="ce969-192">Inoltre, l'implementazione `ReadXml` non deve basarsi sull'uso di un nome specifico per l'elemento wrapper,</span><span class="sxs-lookup"><span data-stu-id="ce969-192">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="ce969-193">poiché il nome viene scelto dal serializzatore e quindi può variare.</span><span class="sxs-lookup"><span data-stu-id="ce969-193">The name is chosen by the serializer can vary.</span></span>  
  
 <span data-ttu-id="ce969-194">È consentito assegnare tipi di contenuto `IXmlSerializable` in modo polimorfico, ad esempio, ai membri dati di tipo <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="ce969-194">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="ce969-195">È inoltre consentito che le istanze del tipo siano Null.</span><span class="sxs-lookup"><span data-stu-id="ce969-195">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="ce969-196">Infine, è possibile usare tipi `IXmlSerializable` con il mantenimento dell'oggetto grafico abilitato e con <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="ce969-196">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="ce969-197">Per tutte queste funzionalità è necessario che il serializzatore WCF alleghi determinati attributi nell'elemento wrapper ("nil" e "Type" nello spazio dei nomi dell'istanza di XML Schema e "ID", "ref", "Type" e "assembly" in uno spazio dei nomi specifico di WCF).</span><span class="sxs-lookup"><span data-stu-id="ce969-197">All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</span></span>  
  
#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="ce969-198">Attributi da ignorare quando si implementa ReadXml</span><span class="sxs-lookup"><span data-stu-id="ce969-198">Attributes to Ignore when Implementing ReadXml</span></span>  
 <span data-ttu-id="ce969-199">Prima di passare il controllo al codice `ReadXml`, il deserializzatore esamina l'elemento XML, rileva questi attributi XML speciali e interviene su di essi.</span><span class="sxs-lookup"><span data-stu-id="ce969-199">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="ce969-200">Ad esempio, se "nil" è `true`, un valore Null viene deserializzato e `ReadXml` non viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="ce969-200">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="ce969-201">Se viene rilevato il polimorfismo, il contenuto dell'elemento viene deserializzato come se si trattasse di un tipo diverso.</span><span class="sxs-lookup"><span data-stu-id="ce969-201">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="ce969-202">L'implementazione di `ReadXml` del tipo assegnato in modo polimorfico viene chiamata.</span><span class="sxs-lookup"><span data-stu-id="ce969-202">The polymorphically assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="ce969-203">In ogni caso, un'implementazione `ReadXml` deve ignorare questi attributi speciali poiché vengono gestiti dal deserializzatore.</span><span class="sxs-lookup"><span data-stu-id="ce969-203">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>  
  
### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="ce969-204">Considerazioni sullo schema per i tipi di contenuto IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="ce969-204">Schema Considerations for IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="ce969-205">Se si esporta lo schema per un tipo di contenuto `IXmlSerializable`, viene chiamato il metodo del provider dello schema.</span><span class="sxs-lookup"><span data-stu-id="ce969-205">When exporting schema an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="ce969-206">Al metodo del provider dello schema viene passata una classe <xref:System.Xml.Schema.XmlSchemaSet>.</span><span class="sxs-lookup"><span data-stu-id="ce969-206">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="ce969-207">Il metodo può aggiungere qualsiasi schema valido al set di schemi.</span><span class="sxs-lookup"><span data-stu-id="ce969-207">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="ce969-208">Il set di schemi contiene lo schema già conosciuto al momento dell'esportazione dello schema.</span><span class="sxs-lookup"><span data-stu-id="ce969-208">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="ce969-209">Quando il metodo del provider dello schema deve aggiungere un elemento al set di schemi, deve determinare se esiste una classe <xref:System.Xml.Schema.XmlSchema> con lo spazio dei nomi appropriato nel set.</span><span class="sxs-lookup"><span data-stu-id="ce969-209">When the schema provider method must add an item to the schema set, it must determine if an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="ce969-210">In tal caso, il metodo del provider dello schema deve aggiungere il nuovo elemento alla classe `XmlSchema` esistente.</span><span class="sxs-lookup"><span data-stu-id="ce969-210">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="ce969-211">In caso contrario, deve creare una nuova istanza di `XmlSchema`.</span><span class="sxs-lookup"><span data-stu-id="ce969-211">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="ce969-212">Questo è importante se vengono usate matrici di tipi `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="ce969-212">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="ce969-213">Ad esempio, se un tipo `IXmlSerializable` viene esportato come tipo "A" nello spazio dei nomi "B", è possibile che quando il metodo del provider dello schema viene chiamato il set di schemi contenga già lo schema per "B" che contiene il tipo "ArrayOfA".</span><span class="sxs-lookup"><span data-stu-id="ce969-213">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>  
  
 <span data-ttu-id="ce969-214">Oltre ad aggiungere i tipi nella classe <xref:System.Xml.Schema.XmlSchemaSet>, il metodo del provider dello schema per i tipi di contenuto deve restituire un valore diverso da Null.</span><span class="sxs-lookup"><span data-stu-id="ce969-214">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="ce969-215">Può restituire un oggetto <xref:System.Xml.XmlQualifiedName> che specifica il nome del tipo di schema da usare per il tipo `IXmlSerializable` specificato.</span><span class="sxs-lookup"><span data-stu-id="ce969-215">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="ce969-216">Questo nome completo serve anche come nome e spazio dei nomi del contratto dati per il tipo.</span><span class="sxs-lookup"><span data-stu-id="ce969-216">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="ce969-217">È consentito restituire un tipo che non esiste nel set di schemi quando il metodo del provider di schema viene restituito.</span><span class="sxs-lookup"><span data-stu-id="ce969-217">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="ce969-218">Tuttavia, in genere al momento dell'esportazione di tutti i tipi correlati (il metodo <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> viene chiamato per tutti i tipi attinenti su <xref:System.Runtime.Serialization.XsdDataContractExporter> e si accede alla proprietà <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A>) il tipo esiste già nel set di schemi.</span><span class="sxs-lookup"><span data-stu-id="ce969-218">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="ce969-219">L'accesso alla proprietà `Schemas` prima che tutte le chiamate `Export` attinenti siano state effettuate può generare un'eccezione <xref:System.Xml.Schema.XmlSchemaException>.</span><span class="sxs-lookup"><span data-stu-id="ce969-219">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> <span data-ttu-id="ce969-220">Per ulteriori informazioni sul processo di esportazione, vedere [esportazione di schemi dalle classi](exporting-schemas-from-classes.md).</span><span class="sxs-lookup"><span data-stu-id="ce969-220">For more information about the export process, see [Exporting Schemas from Classes](exporting-schemas-from-classes.md).</span></span>  
  
 <span data-ttu-id="ce969-221">Il metodo del provider dello schema può restituire anche l'oggetto <xref:System.Xml.Schema.XmlSchemaType> da usare.</span><span class="sxs-lookup"><span data-stu-id="ce969-221">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="ce969-222">Il tipo può o meno essere anonimo.</span><span class="sxs-lookup"><span data-stu-id="ce969-222">The type may or may not be anonymous.</span></span> <span data-ttu-id="ce969-223">Se è anonimo, lo schema per il tipo `IXmlSerializable` viene esportato come tipo anonimo ogni volta che il tipo `IXmlSerializable` viene usato come membro dati.</span><span class="sxs-lookup"><span data-stu-id="ce969-223">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="ce969-224">Il tipo `IXmlSerializable` ha ancora un nome e uno spazio dei nomi del contratto dati</span><span class="sxs-lookup"><span data-stu-id="ce969-224">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="ce969-225">Questa operazione viene determinata come descritto nei [nomi dei contratti dati](data-contract-names.md) , ad eccezione del fatto che l' <xref:System.Runtime.Serialization.DataContractAttribute> attributo non può essere utilizzato per personalizzare il nome. Se non è anonimo, deve essere uno dei tipi in `XmlSchemaSet` .</span><span class="sxs-lookup"><span data-stu-id="ce969-225">(This is determined as described in [Data Contract Names](data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="ce969-226">Questo caso è equivalente alla restituzione del `XmlQualifiedName` del tipo.</span><span class="sxs-lookup"><span data-stu-id="ce969-226">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>  
  
 <span data-ttu-id="ce969-227">Inoltre, viene esportata una dichiarazione di elemento globale per il tipo.</span><span class="sxs-lookup"><span data-stu-id="ce969-227">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="ce969-228">Se al tipo non è applicato l'attributo <xref:System.Xml.Serialization.XmlRootAttribute>, l'elemento ha lo stesso nome e spazio dei nomi del contratto dati e la proprietà "nillable" sarà True.</span><span class="sxs-lookup"><span data-stu-id="ce969-228">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is true.</span></span> <span data-ttu-id="ce969-229">L'unica eccezione è lo spazio dei nomi dello schema (" http://www.w3.org/2001/XMLSchema "): se il contratto dati del tipo si trova in questo spazio dei nomi, l'elemento globale corrispondente si trova nello spazio dei nomi vuoto perché non è consentito aggiungere nuovi elementi allo spazio dei nomi dello schema.</span><span class="sxs-lookup"><span data-stu-id="ce969-229">The only exception to this is the schema namespace ("http://www.w3.org/2001/XMLSchema") – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="ce969-230">Se al tipo è applicato l'attributo `XmlRootAttribute`, la dichiarazione di elemento globale viene esportata usando le proprietà <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> e <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A>.</span><span class="sxs-lookup"><span data-stu-id="ce969-230">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="ce969-231">L'impostazione predefinita quando è applicato l'attributo `XmlRootAttribute` è costituita dal nome del contratto dati, da un spazio dei nomi vuoto e da un valore "nillable" impostato su True.</span><span class="sxs-lookup"><span data-stu-id="ce969-231">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being true.</span></span>  
  
 <span data-ttu-id="ce969-232">Le stesse regole della dichiarazione di elemento globale si applicano ai tipi di dataset legacy.</span><span class="sxs-lookup"><span data-stu-id="ce969-232">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="ce969-233">Si noti che `XmlRootAttribute` non può eseguire l'override delle dichiarazioni di elemento globale aggiunte tramite codice personalizzato o aggiunte a `XmlSchemaSet` usando il metodo del provider dello schema o tramite `GetSchema` per i tipi di dataset legacy.</span><span class="sxs-lookup"><span data-stu-id="ce969-233">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>  
  
### <a name="ixmlserializable-element-types"></a><span data-ttu-id="ce969-234">Tipi di elemento IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="ce969-234">IXmlSerializable Element Types</span></span>  
 <span data-ttu-id="ce969-235">I tipi di elemento `IXmlSerializable` hanno la proprietà `IsAny` impostata su `true` o il relativo metodo del provider dello schema restituisce `null`.</span><span class="sxs-lookup"><span data-stu-id="ce969-235">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>  
  
 <span data-ttu-id="ce969-236">La serializzazione e deserializzazione di un tipo di elemento è molto simile alla serializzazione e deserializzazione di un tipo di contenuto.</span><span class="sxs-lookup"><span data-stu-id="ce969-236">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="ce969-237">Esistono tuttavia alcune importanti differenze:</span><span class="sxs-lookup"><span data-stu-id="ce969-237">However, there are some important differences:</span></span>  
  
- <span data-ttu-id="ce969-238">Si presuppone che l'implementazione `WriteXml` scriva un solo elemento (che può ovviamente contenere più elementi figlio).</span><span class="sxs-lookup"><span data-stu-id="ce969-238">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="ce969-239">Non deve scrivere attributi all'esterno di questo singolo elemento, più elementi di pari livello o contenuto misto.</span><span class="sxs-lookup"><span data-stu-id="ce969-239">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="ce969-240">L'elemento può essere vuoto.</span><span class="sxs-lookup"><span data-stu-id="ce969-240">The element may be empty.</span></span>  
  
- <span data-ttu-id="ce969-241">L'implementazione `ReadXml` non deve leggere l'elemento wrapper,</span><span class="sxs-lookup"><span data-stu-id="ce969-241">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="ce969-242">bensì deve leggere l'unico elemento prodotto da `WriteXml`.</span><span class="sxs-lookup"><span data-stu-id="ce969-242">It is expected to read the one element that `WriteXml` produces.</span></span>  
  
- <span data-ttu-id="ce969-243">Quando si serializza regolarmente un tipo di elemento (ad esempio, come un membro dati in un contratto dati), il serializzatore restituisce un elemento wrapper prima di chiamare `WriteXml`, come per i tipi di contenuto.</span><span class="sxs-lookup"><span data-stu-id="ce969-243">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="ce969-244">Tuttavia, quando si serializza un tipo di elemento al primo livello, il serializzatore in genere non restituisce un elemento wrapper per l'elemento scritto da `WriteXml`, a meno che un nome e uno spazio dei nomi principali vengano specificati in modo esplicito durante la creazione del serializzatore nei costruttori `DataContractSerializer` o `NetDataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="ce969-244">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace were explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="ce969-245">Per ulteriori informazioni, vedere [serializzazione e deserializzazione](serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="ce969-245">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>  
  
- <span data-ttu-id="ce969-246">Quando si serializza un tipo di elemento al primo livello senza specificare il nome e lo spazio dei nomi principali in fase di creazione, i metodi <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> e <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essenzialmente non eseguono alcuna operazione e il metodo <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> chiama `WriteXml`.</span><span class="sxs-lookup"><span data-stu-id="ce969-246">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially does nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="ce969-247">In questo caso, l'oggetto serializzato non può essere Null e non può essere assegnato in modo polimorfico.</span><span class="sxs-lookup"><span data-stu-id="ce969-247">In this mode, the object being serialized cannot be null and cannot be polymorphically assigned.</span></span> <span data-ttu-id="ce969-248">Inoltre, il mantenimento dell'oggetto grafico non può essere abilitato e `NetDataContractSerializer` non può essere usato.</span><span class="sxs-lookup"><span data-stu-id="ce969-248">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>  
  
- <span data-ttu-id="ce969-249">Quando si deserializza un tipo di elemento al primo livello senza specificare il nome e lo spazio dei nomi radice in fase di costruzione, il metodo <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> restituisce `true` se riesce a trovare l'inizio di qualsiasi elemento.</span><span class="sxs-lookup"><span data-stu-id="ce969-249">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="ce969-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> con il parametro `verifyObjectName` impostato su `true` si comporta allo stesso modo di `IsStartObject` prima di leggere effettivamente l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="ce969-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="ce969-251">`ReadObject` passa quindi il controllo al metodo `ReadXml`.</span><span class="sxs-lookup"><span data-stu-id="ce969-251">`ReadObject` then passes control to `ReadXml` method.</span></span>  
  
 <span data-ttu-id="ce969-252">Lo schema esportato per i tipi di elemento è lo stesso del tipo `XmlElement`, come illustrato in una sezione precedente, con l'eccezione che il metodo del provider dello schema può aggiungere qualsiasi altro schema a <xref:System.Xml.Schema.XmlSchemaSet> come con i tipi di contenuto.</span><span class="sxs-lookup"><span data-stu-id="ce969-252">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="ce969-253">L'uso dell'attributo `XmlRootAttribute` con i tipi di elemento non è consentito e le dichiarazioni di elemento globale non vengono mai generate per questi tipi.</span><span class="sxs-lookup"><span data-stu-id="ce969-253">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>  
  
### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="ce969-254">Differenze rispetto a XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="ce969-254">Differences from the XmlSerializer</span></span>  
 <span data-ttu-id="ce969-255">L'interfaccia `IXmlSerializable` e gli attributi `XmlSchemaProviderAttribute` e `XmlRootAttribute` vengono riconosciuti anche da <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="ce969-255">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="ce969-256">Tuttavia, esistono alcune differenze nel modo in cui questi elementi vengono gestiti nel modello del contratto dati.</span><span class="sxs-lookup"><span data-stu-id="ce969-256">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="ce969-257">Le differenze più importanti sono riepilogate di seguito:</span><span class="sxs-lookup"><span data-stu-id="ce969-257">The important differences are summarized in the following:</span></span>  
  
- <span data-ttu-id="ce969-258">Il metodo del provider dello schema deve essere pubblico per poter essere usato in `XmlSerializer`, ma non deve essere pubblico per poter essere usato nel modello del contratto dati.</span><span class="sxs-lookup"><span data-stu-id="ce969-258">The schema provider method must be public to be usable in the `XmlSerializer`, but does not have to be public to be usable in the data contract model.</span></span>  
  
- <span data-ttu-id="ce969-259">Il metodo del provider dello schema viene chiamato quando `IsAny` è True nel modello del contratto dati, ma non con `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="ce969-259">The schema provider method is called when `IsAny` is true in the data contract model but not with the `XmlSerializer`.</span></span>  
  
- <span data-ttu-id="ce969-260">Quando l'attributo `XmlRootAttribute` non è presente per contenuto o i tipi di dataset legacy, `XmlSerializer` esporta una dichiarazione di elemento globale nello spazio dei nomi vuoto.</span><span class="sxs-lookup"><span data-stu-id="ce969-260">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="ce969-261">Nel modello del contratto dati, lo spazio dei nomi usato è in genere lo spazio dei nomi del contratto dati, come descritto in precedenza.</span><span class="sxs-lookup"><span data-stu-id="ce969-261">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>  
  
 <span data-ttu-id="ce969-262">Tenere presenti queste differenze durante la creazione di tipi che vengono usati con entrambe le tecnologie di serializzazione.</span><span class="sxs-lookup"><span data-stu-id="ce969-262">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>  
  
### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="ce969-263">Importazione dello schema IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="ce969-263">Importing IXmlSerializable Schema</span></span>  
 <span data-ttu-id="ce969-264">Quando si importa uno schema generato dai tipi `IXmlSerializable`, si verificano alcuni possibili scenari:</span><span class="sxs-lookup"><span data-stu-id="ce969-264">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>  
  
- <span data-ttu-id="ce969-265">Lo schema generato può essere uno schema del contratto dati valido come descritto in [riferimento allo schema del contratto dati](data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="ce969-265">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span> <span data-ttu-id="ce969-266">In questo caso, lo schema può essere importato normalmente e vengono generati tipi del contratto dati normali.</span><span class="sxs-lookup"><span data-stu-id="ce969-266">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>  
  
- <span data-ttu-id="ce969-267">Lo schema generato può non essere uno schema valido del contratto dati.</span><span class="sxs-lookup"><span data-stu-id="ce969-267">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="ce969-268">Ad esempio, il metodo del provider dello schema può generare lo schema coinvolgendo gli attributi XML che non sono supportati nel modello del contratto dati.</span><span class="sxs-lookup"><span data-stu-id="ce969-268">For example, your schema provider method may generate schema that involves XML attributes which are not supported in the data contract model.</span></span> <span data-ttu-id="ce969-269">In questo caso, è possibile importare lo schema come tipi `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="ce969-269">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="ce969-270">Questa modalità di importazione non è attiva per impostazione predefinita, ma può essere abilitata facilmente, ad esempio con l' `/importXmlTypes` opzione della riga di comando per lo [strumento ServiceModel Metadata Utility Tool (Svcutil. exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span><span class="sxs-lookup"><span data-stu-id="ce969-270">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="ce969-271">Questa operazione è descritta in dettaglio nello [schema di importazione per generare le classi](importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="ce969-271">This is described in detail in the [Importing Schema to Generate Classes](importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="ce969-272">Si noti che è necessario interagire direttamente con XML per le istanze del tipo.</span><span class="sxs-lookup"><span data-stu-id="ce969-272">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="ce969-273">Si può anche scegliere di usare una tecnologia di serializzazione diversa che supporti una gamma più ampia di schemi (vedere l'argomento relativo all'uso di `XmlSerializer`).</span><span class="sxs-lookup"><span data-stu-id="ce969-273">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>  
  
- <span data-ttu-id="ce969-274">Può essere necessario riusare i tipi `IXmlSerializable` esistenti nel proxy anziché generare tipi nuovi.</span><span class="sxs-lookup"><span data-stu-id="ce969-274">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="ce969-275">In questo caso, è possibile usare la funzionalità dei tipi a cui è stato fatto riferimento descritta nell'argomento relativo all'importazione dello schema per generare i tipi per indicare il tipo da riusare.</span><span class="sxs-lookup"><span data-stu-id="ce969-275">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="ce969-276">Questa procedura corrisponde all'uso dell'opzione `/reference` in svcutil.exe, che specifica l'assembly contenente i tipi da riutilizzare.</span><span class="sxs-lookup"><span data-stu-id="ce969-276">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>  
  
## <a name="representing-arbitrary-xml-in-data-contracts"></a><span data-ttu-id="ce969-277">Rappresentazione di contenuto XML arbitrario nei contratti dati</span><span class="sxs-lookup"><span data-stu-id="ce969-277">Representing Arbitrary XML in Data Contracts</span></span>  
 <span data-ttu-id="ce969-278">`XmlElement`, la matrice di `XmlNode` e i tipi `IXmlSerializable` consentono di inserire contenuto XML arbitrario nel modello del contratto dati.</span><span class="sxs-lookup"><span data-stu-id="ce969-278">The `XmlElement`, Array of `XmlNode` and `IXmlSerializable` types allow you to inject arbitrary XML into the data contract model.</span></span> <span data-ttu-id="ce969-279">`DataContractSerializer` e `NetDataContractSerializer` passano questo contenuto XML al writer XML in uso, senza interferire nel processo.</span><span class="sxs-lookup"><span data-stu-id="ce969-279">The `DataContractSerializer` and `NetDataContractSerializer` pass this XML content on to the XML writer in use, without interfering in the process.</span></span> <span data-ttu-id="ce969-280">Tuttavia, i writer XML possono applicare alcune restrizioni sul contenuto XML che scrivono.</span><span class="sxs-lookup"><span data-stu-id="ce969-280">However, the XML writers may enforce certain restrictions on the XML that they write.</span></span> <span data-ttu-id="ce969-281">Di seguito sono riportati alcuni esempi importanti:</span><span class="sxs-lookup"><span data-stu-id="ce969-281">Specifically, here are some important examples:</span></span>  
  
- <span data-ttu-id="ce969-282">I writer XML in genere non consentono una dichiarazione del documento XML (ad esempio, \<?xml version=’1.0’ ?> ) durante la scrittura di un altro documento.</span><span class="sxs-lookup"><span data-stu-id="ce969-282">The XML writers do not typically allow an XML document declaration (for example, \<?xml version=’1.0’ ?>) in the middle of writing another document.</span></span> <span data-ttu-id="ce969-283">Non è possibile serializzare un documento XML completo come un elemento `Array` del membro dati `XmlNode`.</span><span class="sxs-lookup"><span data-stu-id="ce969-283">You cannot take a full XML document and serialize it as an `Array` of `XmlNode` data member.</span></span> <span data-ttu-id="ce969-284">Per questo scopo, è necessario rimuovere la dichiarazione del documento o usare uno schema di codifica personalizzato per rappresentarlo.</span><span class="sxs-lookup"><span data-stu-id="ce969-284">To do this, you have to either strip out the document declaration or use your own encoding scheme to represent it.</span></span>  
  
- <span data-ttu-id="ce969-285">Tutti i writer XML forniti con WCF rifiutano le istruzioni di elaborazione XML ( \<? … ?> ) e le definizioni \<! … > del tipo di documento () perché non sono consentiti nei messaggi SOAP.</span><span class="sxs-lookup"><span data-stu-id="ce969-285">All of the XML writers supplied with WCF reject XML processing instructions (\<? … ?>) and document type definitions (\<! … >), because they are not allowed in SOAP messages.</span></span> <span data-ttu-id="ce969-286">Anche in questo caso è possibile usare un meccanismo di codifica personalizzato per evitare questa restrizione.</span><span class="sxs-lookup"><span data-stu-id="ce969-286">Again, you can use your own encoding mechanism to get around this restriction.</span></span> <span data-ttu-id="ce969-287">Se è necessario includere questi elementi nel contenuto XML risultante, è possibile scrivere un codificatore personalizzato che usi i writer XML che li supportano.</span><span class="sxs-lookup"><span data-stu-id="ce969-287">If you must include these in your resultant XML, you can write a custom encoder that uses XML writers that support them.</span></span>  
  
- <span data-ttu-id="ce969-288">Quando si implementa `WriteXml`, evitare di chiamare il metodo <xref:System.Xml.XmlWriter.WriteRaw%2A> sul writer XML.</span><span class="sxs-lookup"><span data-stu-id="ce969-288">When implementing `WriteXml`, avoid calling <xref:System.Xml.XmlWriter.WriteRaw%2A> method on the XML writer.</span></span> <span data-ttu-id="ce969-289">WCF utilizza una varietà di codifiche XML (incluso Binary), è molto difficile o Impossibile utilizzare `WriteRaw` in modo tale che il risultato sia utilizzabile in qualsiasi codifica.</span><span class="sxs-lookup"><span data-stu-id="ce969-289">WCF uses a variety of XML encodings (including binary), it is very difficult or impossible to use `WriteRaw` such that the result is usable in any encoding.</span></span>  
  
- <span data-ttu-id="ce969-290">Quando `WriteXml` si implementa, evitare di utilizzare i <xref:System.Xml.XmlWriter.WriteEntityRef%2A> metodi e non <xref:System.Xml.XmlWriter.WriteNmToken%2A> supportati nei writer XML forniti con WCF.</span><span class="sxs-lookup"><span data-stu-id="ce969-290">When implementing `WriteXml`, avoid using the <xref:System.Xml.XmlWriter.WriteEntityRef%2A> and <xref:System.Xml.XmlWriter.WriteNmToken%2A> methods that are unsupported on the XML writers supplied with WCF.</span></span>  
  
## <a name="using-dataset-typed-dataset-and-datatable"></a><span data-ttu-id="ce969-291">Uso di dataset, dataset tipizzati e DataTable</span><span class="sxs-lookup"><span data-stu-id="ce969-291">Using DataSet, Typed DataSet and DataTable</span></span>  
 <span data-ttu-id="ce969-292">L'uso di questi tipi è supportato pienamente nel modello del contratto dati.</span><span class="sxs-lookup"><span data-stu-id="ce969-292">Using these types is fully supported in the data contract model.</span></span> <span data-ttu-id="ce969-293">Quando si usano questi tipi, è opportuno considerare i punti seguenti:</span><span class="sxs-lookup"><span data-stu-id="ce969-293">When using these types, consider the following points:</span></span>  
  
- <span data-ttu-id="ce969-294">Lo schema per questi tipi (in particolare <xref:System.Data.DataSet> e le relative classi derivate tipizzate) potrebbe non essere interoperativo con alcune piattaforme non WCF oppure può comportare una scarsa usabilità quando viene usato con queste piattaforme.</span><span class="sxs-lookup"><span data-stu-id="ce969-294">The schema for these types (especially <xref:System.Data.DataSet> and its typed derived classes) may not be interoperable with some non-WCF platforms, or may result in poor usability when used with these platforms.</span></span> <span data-ttu-id="ce969-295">Inoltre, l'uso del tipo `DataSet` può avere implicazioni sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="ce969-295">Additionally, using the `DataSet` type may have performance implications.</span></span> <span data-ttu-id="ce969-296">Può infine rendere più difficile il controllo della versione dell'applicazione in futuro.</span><span class="sxs-lookup"><span data-stu-id="ce969-296">Finally, it may make it more difficult for you to version your application in the future.</span></span> <span data-ttu-id="ce969-297">È consigliabile usare tipi di contratto dati definiti in modo esplicito al posto dei tipi `DataSet` nei contratti.</span><span class="sxs-lookup"><span data-stu-id="ce969-297">Consider using explicitly defined data contract types instead of `DataSet` types in your contracts.</span></span>  
  
- <span data-ttu-id="ce969-298">Quando si importa lo schema `DataSet` o `DataTable`, è importante fare riferimento a questi tipi.</span><span class="sxs-lookup"><span data-stu-id="ce969-298">When importing `DataSet` or `DataTable` schema, it is important to reference these types.</span></span> <span data-ttu-id="ce969-299">Con lo strumento da riga di comando svcutil. exe, questa operazione può essere eseguita passando il nome dell'assembly System. Data. dll all' `/reference` opzione.</span><span class="sxs-lookup"><span data-stu-id="ce969-299">With the Svcutil.exe command-line tool, this can be accomplished by passing the System.Data.dll assembly name to the `/reference` switch.</span></span> <span data-ttu-id="ce969-300">Se si importa lo schema del dataset tipizzato, è necessario fare riferimento al tipo del dataset tipizzato.</span><span class="sxs-lookup"><span data-stu-id="ce969-300">If importing typed dataset schema, you must reference the typed dataset’s type.</span></span> <span data-ttu-id="ce969-301">Con Svcutil. exe, passare il percorso dell'assembly del set di dati tipizzato all' `/reference` opzione.</span><span class="sxs-lookup"><span data-stu-id="ce969-301">With Svcutil.exe, pass the location of the typed dataset’s assembly to the `/reference` switch.</span></span> <span data-ttu-id="ce969-302">Per ulteriori informazioni sui tipi di riferimento, vedere lo [schema di importazione per generare classi](importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="ce969-302">For more information about referencing types, see the [Importing Schema to Generate Classes](importing-schema-to-generate-classes.md).</span></span>  
  
 <span data-ttu-id="ce969-303">Il supporto per i dataset tipizzati nel modello del contratto dati è limitato.</span><span class="sxs-lookup"><span data-stu-id="ce969-303">Support for typed DataSets in the data contract model is limited.</span></span> <span data-ttu-id="ce969-304">I dataset tipizzati possono essere serializzati e deserializzati e possono esportare il proprio schema.</span><span class="sxs-lookup"><span data-stu-id="ce969-304">Typed DataSets can be serialized and deserialized and can export their schema.</span></span> <span data-ttu-id="ce969-305">Tuttavia, l’importazione dello schema del contratto dati non è in grado di generare nuovi tipi di dataset tipizzati dallo schema, in quanto può solo riusare quelli esistenti.</span><span class="sxs-lookup"><span data-stu-id="ce969-305">However, the Data Contract schema import is unable to generate new typed DataSet types from the schema, as it can only reuse existing ones.</span></span> <span data-ttu-id="ce969-306">E’ possibile far riferimento a un dataset tipizzato esistente usando l’opzione `/r` in Svcutil.exe.</span><span class="sxs-lookup"><span data-stu-id="ce969-306">You can point to an existing typed DataSet by using the `/r` switch on Svcutil.exe.</span></span> <span data-ttu-id="ce969-307">Se si tenta di usare Svcutil.exe senza l’opzione `/r` in un servizio che usa un dataset tipizzato, viene automaticamente selezionato un serializzatore alternativo (XmlSerializer).</span><span class="sxs-lookup"><span data-stu-id="ce969-307">If you attempt to use a Svcutil.exe without the `/r` switch on a service that uses a typed dataset, an alternative serializer (XmlSerializer) is automatically selected.</span></span> <span data-ttu-id="ce969-308">Se è necessario usare il DataContractSerializer e generare dataset dallo schema, è possibile usare la seguente procedura: generare i tipi di dataset tipizzati (usando lo strumento Xsd.exe con l’opzione `/d` nel servizio), compilare i tipi, quindi farvi riferimento usando l’opzione `/r` in Svcutil.exe.</span><span class="sxs-lookup"><span data-stu-id="ce969-308">If you must use the DataContractSerializer and must generate DataSets from schema, you can use the following procedure: generate the typed DataSet types (by using the Xsd.exe tool with the `/d` switch on the service), compile the types, and then point to them using the `/r` switch on Svcutil.exe.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ce969-309">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="ce969-309">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.Serialization.IXmlSerializable>
- [<span data-ttu-id="ce969-310">Using Data Contracts</span><span class="sxs-lookup"><span data-stu-id="ce969-310">Using Data Contracts</span></span>](using-data-contracts.md)
- [<span data-ttu-id="ce969-311">Types Supported by the Data Contract Serializer</span><span class="sxs-lookup"><span data-stu-id="ce969-311">Types Supported by the Data Contract Serializer</span></span>](types-supported-by-the-data-contract-serializer.md)
