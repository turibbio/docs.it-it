---
title: Panoramica dell'architettura di trasferimento dei dati
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- data transfer [WCF], architectural overview
ms.assetid: 343c2ca2-af53-4936-a28c-c186b3524ee9
ms.openlocfilehash: f34bf82ec44140827c5d8da59911afe10ab7a853
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/09/2020
ms.locfileid: "84576473"
---
# <a name="data-transfer-architectural-overview"></a><span data-ttu-id="6c8a6-102">Panoramica dell'architettura di trasferimento dei dati</span><span class="sxs-lookup"><span data-stu-id="6c8a6-102">Data Transfer Architectural Overview</span></span>
<span data-ttu-id="6c8a6-103">Windows Communication Foundation (WCF) può essere considerato come un'infrastruttura di messaggistica.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-103">Windows Communication Foundation (WCF) can be thought of as a messaging infrastructure.</span></span> <span data-ttu-id="6c8a6-104">Può ricevere messaggi, elaborarli e inviarli a codice utente per ulteriori azioni, oppure può costruire messaggi dai dati forniti dal codice utente e recapitarli a una destinazione.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-104">It can receive messages, process them, and dispatch them to user code for further action, or it can construct messages from data given by user code and deliver them to a destination.</span></span> <span data-ttu-id="6c8a6-105">In questo argomento, rivolto agli sviluppatori avanzati, viene illustrata l'architettura per la gestione dei messaggi e dei dati in essi contenuti.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-105">This topic, which is intended for advanced developers, describes the architecture for handling messages and the contained data.</span></span> <span data-ttu-id="6c8a6-106">Per informazioni più semplici e orientate alle attività su come inviare e ricevere dati, vedere [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="6c8a6-106">For a simpler, task-oriented view of how to send and receive data, see [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="6c8a6-107">In questo argomento vengono illustrati i dettagli di implementazione WCF che non sono visibili esaminando il modello a oggetti WCF.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-107">This topic discusses WCF implementation details that are not visible by examining the WCF object model.</span></span> <span data-ttu-id="6c8a6-108">In merito ai dettagli di implementazione documentati, è opportuno precisare due cose.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-108">Two words of caution are in order with regard to documented implementation details.</span></span> <span data-ttu-id="6c8a6-109">In primo luogo, le descrizioni sono semplificate. L'implementazione effettiva potrebbe essere più complessa a causa delle ottimizzazioni o di altre ragioni.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-109">First, the descriptions are simplified; actual implementation may be more complex due to optimizations or other reasons.</span></span> <span data-ttu-id="6c8a6-110">In secondo luogo, non fare mai affidamento su dettagli specifici di implementazione, nemmeno su quelli documentati, poiché possono cambiare senza preavviso da una versione all'altra o anche in una Service Release.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-110">Second, you should never rely on specific implementation details, even documented ones, because these may change without notice from version to version or even in a servicing release.</span></span>  
  
## <a name="basic-architecture"></a><span data-ttu-id="6c8a6-111">Architettura di base</span><span class="sxs-lookup"><span data-stu-id="6c8a6-111">Basic Architecture</span></span>  
 <span data-ttu-id="6c8a6-112">Alla base delle funzionalità di gestione dei messaggi WCF è la <xref:System.ServiceModel.Channels.Message> classe, descritta in dettaglio in [utilizzo della classe Message](using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="6c8a6-112">At the core of WCF message-handling capabilities is the <xref:System.ServiceModel.Channels.Message> class, which is described in detail in [Using the Message Class](using-the-message-class.md).</span></span> <span data-ttu-id="6c8a6-113">I componenti della fase di esecuzione di WCF possono essere divisi in due parti principali: lo stack dei canali e il Framework del servizio, con la <xref:System.ServiceModel.Channels.Message> classe che è il punto di connessione.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-113">The run-time components of WCF can be divided into two major parts: the channel stack and the service framework, with the <xref:System.ServiceModel.Channels.Message> class being the connection point.</span></span>  
  
 <span data-ttu-id="6c8a6-114">Lo stack dei canali è responsabile della conversione tra un'istanza <xref:System.ServiceModel.Channels.Message> valida e una qualche azione che corrisponde all'invio o alla ricezione di dati del messaggio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-114">The channel stack is responsible for converting between a valid <xref:System.ServiceModel.Channels.Message> instance and some action that corresponds to the sending or receiving of message data.</span></span> <span data-ttu-id="6c8a6-115">Sul lato di invio, lo stack dei canali prende un'istanza <xref:System.ServiceModel.Channels.Message> valida e, dopo averla elaborata, esegue un'azione che corrisponde in modo logico all'invio del messaggio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-115">On the sending side, the channel stack takes a valid <xref:System.ServiceModel.Channels.Message> instance and, after some processing, performs some action that logically corresponds to sending the message.</span></span> <span data-ttu-id="6c8a6-116">L'azione potrebbe essere l'invio di pacchetti TCP o HTTP, la messa in coda del messaggio nel sistema di Accodamento messaggi, la scrittura del messaggio in un database, il suo salvataggio in una condivisione file o una qualsiasi altra azione, a seconda dell'implementazione.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-116">The action may be sending TCP or HTTP packets, queuing the message in Message Queuing, writing the message to a database, saving it to a file share, or any other action, depending on the implementation.</span></span> <span data-ttu-id="6c8a6-117">L'azione più comune è l'invio del messaggio su un protocollo di rete.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-117">The most common action is sending the message over a network protocol.</span></span> <span data-ttu-id="6c8a6-118">Sul lato di ricezione, accade il contrario, ovvero viene rilevata un'azione (che può essere l'arrivo di pacchetti TCP o HTTP o qualsiasi altra azione) e, dopo l'elaborazione, lo stack dei canali converte questa azione in un'istanza <xref:System.ServiceModel.Channels.Message> valida.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-118">On the receive side, the opposite happens—an action is detected (which may be TCP or HTTP packets arriving or any other action), and, after processing, the channel stack converts this action into a valid <xref:System.ServiceModel.Channels.Message> instance.</span></span>  
  
 <span data-ttu-id="6c8a6-119">È possibile utilizzare WCF utilizzando direttamente la <xref:System.ServiceModel.Channels.Message> classe e lo stack dei canali.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-119">You can use WCF by using the <xref:System.ServiceModel.Channels.Message> class and the channel stack directly.</span></span> <span data-ttu-id="6c8a6-120">Questa procedura è tuttavia difficile e lunga.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-120">However, doing so is difficult and time-consuming.</span></span> <span data-ttu-id="6c8a6-121">Inoltre, l' <xref:System.ServiceModel.Channels.Message> oggetto non fornisce supporto per i metadati, pertanto non è possibile generare client WCF fortemente tipizzati se si utilizza WCF in questo modo.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-121">Additionally, the <xref:System.ServiceModel.Channels.Message> object provides no metadata support, so you cannot generate strongly typed WCF clients if you use WCF in this manner.</span></span>  
  
 <span data-ttu-id="6c8a6-122">WCF include pertanto un Framework del servizio che fornisce un modello di programmazione di facile utilizzo che è possibile utilizzare per costruire e ricevere `Message` oggetti.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-122">Therefore, WCF includes a service framework that provides an easy-to-use programming model that you can use to construct and receive `Message` objects.</span></span> <span data-ttu-id="6c8a6-123">Il Framework del servizio esegue il mapping dei servizi ai tipi di .NET Framework tramite la nozione di contratti di servizio e invia messaggi a operazioni utente che sono semplicemente .NET Framework metodi contrassegnati con l' <xref:System.ServiceModel.OperationContractAttribute> attributo. per altre informazioni, vedere [progettazione di contratti di servizio](../designing-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="6c8a6-123">The service framework maps services to .NET Framework types through the notion of service contracts, and dispatches messages to user operations that are simply .NET Framework methods marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute (for more details, see [Designing Service Contracts](../designing-service-contracts.md)).</span></span> <span data-ttu-id="6c8a6-124">Tali metodi possono avere parametri e valori restituiti.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-124">These methods may have parameters and return values.</span></span> <span data-ttu-id="6c8a6-125">Sul lato del servizio, il framework del servizio converte le istanze <xref:System.ServiceModel.Channels.Message> in ingresso in parametri e i valori restituiti in istanze <xref:System.ServiceModel.Channels.Message> in uscita.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-125">On the service side, the service framework converts incoming <xref:System.ServiceModel.Channels.Message> instances into parameters and converts return values into outgoing <xref:System.ServiceModel.Channels.Message> instances.</span></span> <span data-ttu-id="6c8a6-126">Nel lato client, avviene il contrario.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-126">On the client side, it does the opposite.</span></span> <span data-ttu-id="6c8a6-127">Si consideri ad esempio l'operazione `FindAirfare` seguente.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-127">For example, consider the `FindAirfare` operation below.</span></span>  
  
 [!code-csharp[c_DataArchitecture#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#1)]
 [!code-vb[c_DataArchitecture#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#1)]  
  
 <span data-ttu-id="6c8a6-128">Si supponga che `FindAirfare` venga chiamato nel client.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-128">Suppose `FindAirfare` is called on the client.</span></span> <span data-ttu-id="6c8a6-129">Il framework del servizio nel client converte i parametri `FromCity` e `ToCity` in un'istanza <xref:System.ServiceModel.Channels.Message> in uscita e la passa allo stack dei canali perché venga inviata.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-129">The service framework on the client converts the `FromCity` and `ToCity` parameters into an outgoing <xref:System.ServiceModel.Channels.Message> instance and passes it to the channel stack to be sent.</span></span>  
  
 <span data-ttu-id="6c8a6-130">Nel lato del servizio, quando un'istanza <xref:System.ServiceModel.Channels.Message> arriva dallo stack dei canali, il framework del servizio estrae i dati pertinenti dal messaggio per popolare i parametri `FromCity` e `ToCity` , quindi chiama il metodo `FindAirfare` nel lato servizio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-130">On the service side, when a <xref:System.ServiceModel.Channels.Message> instance arrives from the channel stack, the service framework extracts the relevant data from the message to populate the `FromCity` and `ToCity` parameters and then calls the service-side `FindAirfare` method.</span></span> <span data-ttu-id="6c8a6-131">Quando il metodo restituisce il risultato, il framework del servizio prende il valore integer restituito e il parametro di output `IsDirectFlight` e crea un'istanza dell'oggetto <xref:System.ServiceModel.Channels.Message> che contiene queste informazioni.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-131">When the method returns, the service framework takes the returned integer value and the `IsDirectFlight` output parameter and creates a <xref:System.ServiceModel.Channels.Message> object instance that contains this information.</span></span> <span data-ttu-id="6c8a6-132">Passa quindi l'istanza `Message` allo stack dei canali affinché venga inviata di nuovo al client.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-132">It then passes the `Message` instance to the channel stack to be sent back to the client.</span></span>  
  
 <span data-ttu-id="6c8a6-133">Sul lato client, dallo stack dei canali emerge un'istanza <xref:System.ServiceModel.Channels.Message> che contiene il messaggio di risposta.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-133">On the client side, a <xref:System.ServiceModel.Channels.Message> instance that contains the response message emerges from the channel stack.</span></span> <span data-ttu-id="6c8a6-134">Il framework del servizio estrae il valore restituito e il valore `IsDirectFlight` e li restituisce al chiamante del client.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-134">The service framework extracts the return value and the `IsDirectFlight` value and returns these to the caller of the client.</span></span>  
  
## <a name="message-class"></a><span data-ttu-id="6c8a6-135">Classe di messaggi</span><span class="sxs-lookup"><span data-stu-id="6c8a6-135">Message Class</span></span>  
 <span data-ttu-id="6c8a6-136">La classe <xref:System.ServiceModel.Channels.Message> è intesa per essere una rappresentazione astratta di un messaggio, ma la sua progettazione è fortemente legata al messaggio SOAP.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-136">The <xref:System.ServiceModel.Channels.Message> class is intended to be an abstract representation of a message, but its design is strongly tied to the SOAP message.</span></span> <span data-ttu-id="6c8a6-137">Un <xref:System.ServiceModel.Channels.Message> contiene tre informazioni principali: il corpo, le intestazioni e le proprietà del messaggio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-137">A <xref:System.ServiceModel.Channels.Message> contains three major pieces of information: a message body, message headers, and message properties.</span></span>  
  
## <a name="message-body"></a><span data-ttu-id="6c8a6-138">Corpo del messaggio</span><span class="sxs-lookup"><span data-stu-id="6c8a6-138">Message Body</span></span>  
 <span data-ttu-id="6c8a6-139">Il corpo del messaggio ha lo scopo di rappresentare il payload effettivo dei dati del messaggio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-139">The message body is intended to represent the actual data payload of the message.</span></span> <span data-ttu-id="6c8a6-140">Il corpo del messaggio è sempre rappresentato come un Infoset XML.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-140">The message body is always represented as an XML Infoset.</span></span> <span data-ttu-id="6c8a6-141">Ciò non significa che tutti i messaggi creati o ricevuti in WCF siano in formato XML.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-141">This does not mean that all messages created or received in WCF must be in XML format.</span></span> <span data-ttu-id="6c8a6-142">È lo stack dei canali a decidere come interpretare il corpo del messaggio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-142">It is up to the channel stack to decide how to interpret the message body.</span></span> <span data-ttu-id="6c8a6-143">Può emetterlo come XML, convertirlo in un altro formato o anche ometterlo completamente.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-143">It may emit it as XML, convert it to some other format, or even omit it entirely.</span></span> <span data-ttu-id="6c8a6-144">Naturalmente, con la maggior parte delle associazioni fornite da WCF, il corpo del messaggio è rappresentato come contenuto XML nella sezione del corpo di una SOAP envelope.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-144">Of course, with most of the bindings WCF supplies, the message body is represented as XML content in the body section of a SOAP envelope.</span></span>  
  
 <span data-ttu-id="6c8a6-145">È importante comprendere che la classe `Message` non contiene necessariamente un buffer con dati XML che rappresentano il corpo.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-145">It is important to realize that the `Message` class does not necessarily contain a buffer with XML data representing the body.</span></span> <span data-ttu-id="6c8a6-146">Logicamente, `Message` contiene un Infoset XML, che può essere creato dinamicamente e può non essere mai fisicamente presente in memoria.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-146">Logically, `Message` contains an XML Infoset, but this Infoset may be dynamically constructed and may never physically exist in memory.</span></span>  
  
### <a name="putting-data-into-the-message-body"></a><span data-ttu-id="6c8a6-147">Inserimento di dati nel corpo del messaggio</span><span class="sxs-lookup"><span data-stu-id="6c8a6-147">Putting Data into the Message Body</span></span>  
 <span data-ttu-id="6c8a6-148">Non esiste un meccanismo uniforme per inserire dati in un corpo del messaggio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-148">There is no uniform mechanism to put data into a message body.</span></span> <span data-ttu-id="6c8a6-149">La classe <xref:System.ServiceModel.Channels.Message> ha un metodo astratto, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, che prende un <xref:System.Xml.XmlDictionaryWriter>.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-149">The <xref:System.ServiceModel.Channels.Message> class has an abstract method, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, which takes an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="6c8a6-150">Ogni sottoclasse della classe <xref:System.ServiceModel.Channels.Message> è responsabile dell'esecuzione dell'override di questo metodo e della scrittura del suo contenuto.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-150">Each subclass of the <xref:System.ServiceModel.Channels.Message> class is responsible for overriding this method and writing out its own contents.</span></span> <span data-ttu-id="6c8a6-151">Il corpo del messaggio contiene logicamente l'Infoset XML prodotto da `OnWriteBodyContent` .</span><span class="sxs-lookup"><span data-stu-id="6c8a6-151">The message body logically contains the XML Infoset that `OnWriteBodyContent` produces.</span></span> <span data-ttu-id="6c8a6-152">Si consideri ad esempio la sottoclasse seguente `Message` .</span><span class="sxs-lookup"><span data-stu-id="6c8a6-152">For example, consider the following `Message` subclass.</span></span>  
  
 [!code-csharp[c_DataArchitecture#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#2)]
 [!code-vb[c_DataArchitecture#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#2)]  
  
 <span data-ttu-id="6c8a6-153">Fisicamente, un'istanza `AirfareRequestMessage` contiene solo due stringhe ("fromCity" e "toCity").</span><span class="sxs-lookup"><span data-stu-id="6c8a6-153">Physically, an `AirfareRequestMessage` instance contains only two strings ("fromCity" and "toCity").</span></span> <span data-ttu-id="6c8a6-154">Tuttavia, il messaggio contiene logicamente l'infoset XML seguente:</span><span class="sxs-lookup"><span data-stu-id="6c8a6-154">However, logically the message contains the following XML infoset:</span></span>  
  
```xml  
<airfareRequest>  
    <from>Tokyo</from>  
    <to>London</to>  
</airfareRequest>  
```  
  
 <span data-ttu-id="6c8a6-155">In genere questo non è il metodo utilizzato per creare messaggi, perché è possibile utilizzare il framework del servizio per creare un messaggio come il precedente dai parametri del contratto dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-155">Of course, you would normally not create messages in this manner, because you can use the service framework to create a message like the preceding one from operation contract parameters.</span></span> <span data-ttu-id="6c8a6-156">La classe <xref:System.ServiceModel.Channels.Message> , inoltre, ha metodi `CreateMessage` statici che è possibile utilizzare per creare messaggi con tipi di contenuto comuni: un messaggio vuoto, un messaggio che contiene un oggetto serializzato in XML con <xref:System.Runtime.Serialization.DataContractSerializer>, un messaggio che contiene un errore SOAP, un messaggio che contiene XML rappresentato da un <xref:System.Xml.XmlReader>e così via.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-156">Additionally, the <xref:System.ServiceModel.Channels.Message> class has static `CreateMessage` methods that you can use to create messages with common types of content: an empty message, a message that contains an object serialized to XML with the <xref:System.Runtime.Serialization.DataContractSerializer>, a message that contains a SOAP fault, a message that contains XML represented by an <xref:System.Xml.XmlReader>, and so on.</span></span>  
  
### <a name="getting-data-from-a-message-body"></a><span data-ttu-id="6c8a6-157">Ottenimento di dati da un corpo del messaggio</span><span class="sxs-lookup"><span data-stu-id="6c8a6-157">Getting Data from a Message Body</span></span>  
 <span data-ttu-id="6c8a6-158">Esistono due modalità principali per estrarre i dati archiviati in un corpo del messaggio:</span><span class="sxs-lookup"><span data-stu-id="6c8a6-158">You can extract the data stored in a message body in two main ways:</span></span>  
  
- <span data-ttu-id="6c8a6-159">È possibile ottenere l'intero corpo del messaggio chiamando il metodo <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> e passando contemporaneamente un writer XML.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-159">You can get the entire message body at one time by calling the <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method and passing in an XML writer.</span></span> <span data-ttu-id="6c8a6-160">L'intero corpo del messaggio viene scritto in questo writer.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-160">The complete message body is written out to this writer.</span></span> <span data-ttu-id="6c8a6-161">L'ottenimento contemporaneo dell'intero corpo del messaggio viene detto anche *scrittura di un messaggio*.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-161">Getting the entire message body at one time is also called *writing a message*.</span></span> <span data-ttu-id="6c8a6-162">La scrittura viene eseguita principalmente dallo stack dei canali all'invio dei messaggi. Parte dello stack dei canali di solito otterrà l'accesso all'intero corpo del messaggio, lo codificherà e l'invierà.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-162">Writing is done primarily by the channel stack when sending messages—some part of the channel stack will usually get access to the entire message body, encode it, and send it.</span></span>  
  
- <span data-ttu-id="6c8a6-163">Un'altra modalità per estrarre informazioni dal corpo del messaggio consiste nel chiamare <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> e ottenere un lettore XML.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-163">Another way to get information out of the message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> and get an XML reader.</span></span> <span data-ttu-id="6c8a6-164">Se necessario, sarà quindi possibile accedere al corpo del messaggio in sequenza, chiamando i metodi nel lettore.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-164">The message body can then be accessed sequentially as needed by calling methods on the reader.</span></span> <span data-ttu-id="6c8a6-165">L'ottenimento del corpo del messaggio un pezzo alla volta viene detto anche *lettura di un messaggio*.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-165">Getting the message body piece-by-piece is also called *reading a message*.</span></span> <span data-ttu-id="6c8a6-166">La lettura del messaggio è utilizzata principalmente dal framework del servizio alla ricezione dei messaggi.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-166">Reading the message is primarily used by the service framework when receiving messages.</span></span> <span data-ttu-id="6c8a6-167">Quando, ad esempio, è utilizzato <xref:System.Runtime.Serialization.DataContractSerializer> , il framework del servizio otterrà un lettore XML sul corpo e lo passerà al motore di deserializzazione che avvierà la lettura del messaggio, elemento per elemento, e costruirà l'oggetto grafico corrispondente.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-167">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> is in use, the service framework will get an XML reader over the body and pass it to the deserialization engine, which will then start reading the message element-by-element and constructing the corresponding object graph.</span></span>  
  
 <span data-ttu-id="6c8a6-168">Un corpo del messaggio può essere recuperato solo una volta.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-168">A message body can be retrieved only once.</span></span> <span data-ttu-id="6c8a6-169">Ciò consente di lavorare con flussi di tipo forward-only.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-169">This makes it possible to work with forward-only streams.</span></span> <span data-ttu-id="6c8a6-170">È ad esempio possibile scrivere un override <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> che legge da un <xref:System.IO.FileStream> e restituisce i risultati come Infoset XML.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-170">For example, you can write an <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> override that reads from a <xref:System.IO.FileStream> and returns the results as an XML Infoset.</span></span> <span data-ttu-id="6c8a6-171">Non sarà mai necessario eseguire il "Rewind" all'inizio del file.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-171">You will never need to "rewind" to the beginning of the file.</span></span>  
  
 <span data-ttu-id="6c8a6-172">I metodi `WriteBodyContents` e `GetReaderAtBodyContents` controllano semplicemente che il corpo del messaggio non sia mai stato recuperato, quindi chiamano rispettivamente `OnWriteBodyContents` o `OnGetReaderAtBodyContents`.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-172">The `WriteBodyContents` and `GetReaderAtBodyContents` methods simply check that the message body has never been retrieved before, and then call `OnWriteBodyContents` or `OnGetReaderAtBodyContents`, respectively.</span></span>  
  
## <a name="message-usage-in-wcf"></a><span data-ttu-id="6c8a6-173">Utilizzo di messaggi in WCF</span><span class="sxs-lookup"><span data-stu-id="6c8a6-173">Message Usage in WCF</span></span>  
 <span data-ttu-id="6c8a6-174">La maggior parte dei messaggi può essere classificata come *in uscita* (quelli che vengono creati dal framework del servizio per essere inviati dallo stack dei canali) o *in ingresso* (quelli che arrivano dallo stack dei canali e sono interpretati dal framework del servizio).</span><span class="sxs-lookup"><span data-stu-id="6c8a6-174">Most messages can be classified as either *outgoing* (those that are created by the service framework to be sent by the channel stack) or *incoming* (those that arrive from the channel stack and are interpreted by the service framework).</span></span> <span data-ttu-id="6c8a6-175">Lo stack di canali può inoltre operare in modalità di memorizzazione nel buffer o in modalità flusso.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-175">Furthermore, the channel stack can operate in either buffered or streaming mode.</span></span> <span data-ttu-id="6c8a6-176">Il framework del servizio può anche esporre un modello di programmazione con o senza invio nel flusso.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-176">The service framework may also expose a streamed or nonstreamed programming model.</span></span> <span data-ttu-id="6c8a6-177">Ciò porta ai casi elencati nella tabella seguente assieme ai dettagli semplificati della loro implementazione.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-177">This leads to the cases listed in the following table, along with simplified details of their implementation.</span></span>  
  
|<span data-ttu-id="6c8a6-178">Tipo di messaggio</span><span class="sxs-lookup"><span data-stu-id="6c8a6-178">Message type</span></span>|<span data-ttu-id="6c8a6-179">Dati del corpo nel messaggio</span><span class="sxs-lookup"><span data-stu-id="6c8a6-179">Body data in message</span></span>|<span data-ttu-id="6c8a6-180">Implementazione della scrittura (OnWriteBodyContents)</span><span class="sxs-lookup"><span data-stu-id="6c8a6-180">Write (OnWriteBodyContents) implementation</span></span>|<span data-ttu-id="6c8a6-181">Implementazione della lettura (OnGetReaderAtBodyContents)</span><span class="sxs-lookup"><span data-stu-id="6c8a6-181">Read (OnGetReaderAtBodyContents) Implementation</span></span>|  
|------------------|--------------------------|--------------------------------------------------|-------------------------------------------------------|  
|<span data-ttu-id="6c8a6-182">In uscita, creato da un modello di programmazione senza invio nel flusso</span><span class="sxs-lookup"><span data-stu-id="6c8a6-182">Outgoing, created from nonstreamed programming model</span></span>|<span data-ttu-id="6c8a6-183">I dati necessario per scrivere il messaggio (ad esempio, un oggetto e l'istanza <xref:System.Runtime.Serialization.DataContractSerializer> necessaria per serializzarlo)\*</span><span class="sxs-lookup"><span data-stu-id="6c8a6-183">The data needed to write the message (for example, an object and the <xref:System.Runtime.Serialization.DataContractSerializer> instance needed to serialize it)\*</span></span>|<span data-ttu-id="6c8a6-184">Logica personalizzata per scrivere il messaggio sulla base dei dati archiviati (ad esempio, chiamare `WriteObject` su `DataContractSerializer` se questo è il serializzatore utilizzato)\*</span><span class="sxs-lookup"><span data-stu-id="6c8a6-184">Custom logic to write out the message based on the stored data (for example, call `WriteObject` on the `DataContractSerializer` if that is the serializer in use)\*</span></span>|<span data-ttu-id="6c8a6-185">Chiamare `OnWriteBodyContents`, memorizzare nel buffer i risultati, restituire un lettore XML sul buffer</span><span class="sxs-lookup"><span data-stu-id="6c8a6-185">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="6c8a6-186">In uscita, creato dal modello di programmazione con invio nel flusso</span><span class="sxs-lookup"><span data-stu-id="6c8a6-186">Outgoing, created from streamed programming model</span></span>|<span data-ttu-id="6c8a6-187">`Stream` con i dati da scrivere\*</span><span class="sxs-lookup"><span data-stu-id="6c8a6-187">The `Stream` with the data to be written\*</span></span>|<span data-ttu-id="6c8a6-188">Scrivere i dati dal flusso archiviato utilizzando il meccanismo <xref:System.Xml.IStreamProvider> \*</span><span class="sxs-lookup"><span data-stu-id="6c8a6-188">Write out data from the stored stream using the <xref:System.Xml.IStreamProvider> mechanism\*</span></span>|<span data-ttu-id="6c8a6-189">Chiamare `OnWriteBodyContents`, memorizzare nel buffer i risultati, restituire un lettore XML sul buffer</span><span class="sxs-lookup"><span data-stu-id="6c8a6-189">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="6c8a6-190">In ingresso dallo stack dei canali del flusso</span><span class="sxs-lookup"><span data-stu-id="6c8a6-190">Incoming from streaming channel stack</span></span>|<span data-ttu-id="6c8a6-191">Un oggetto `Stream` che rappresenta i dati che entrano sulla rete con un <xref:System.Xml.XmlReader> su di esso</span><span class="sxs-lookup"><span data-stu-id="6c8a6-191">A `Stream` object that represents the data coming in over the network with an <xref:System.Xml.XmlReader> over it</span></span>|<span data-ttu-id="6c8a6-192">Scrivere il contenuto dal `XmlReader` archiviato utilizzando `WriteNode`</span><span class="sxs-lookup"><span data-stu-id="6c8a6-192">Write out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="6c8a6-193">Restituisce il `XmlReader`archiviato</span><span class="sxs-lookup"><span data-stu-id="6c8a6-193">Returns the stored `XmlReader`</span></span>|  
|<span data-ttu-id="6c8a6-194">In ingresso dallo stack dei canali senza utilizzo del flusso</span><span class="sxs-lookup"><span data-stu-id="6c8a6-194">Incoming from nonstreaming channel stack</span></span>|<span data-ttu-id="6c8a6-195">Un buffer che contiene dati del corpo con un `XmlReader` su di esso</span><span class="sxs-lookup"><span data-stu-id="6c8a6-195">A buffer that contains body data with an `XmlReader` over it</span></span>|<span data-ttu-id="6c8a6-196">Scrive il contenuto dal `XmlReader` archiviato utilizzando `WriteNode`</span><span class="sxs-lookup"><span data-stu-id="6c8a6-196">Writes out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="6c8a6-197">Restituisce il lang archiviato</span><span class="sxs-lookup"><span data-stu-id="6c8a6-197">Returns the stored lang</span></span>|  
  
 <span data-ttu-id="6c8a6-198">\*Questi elementi non sono implementati direttamente nelle `Message` sottoclassi, ma nelle sottoclassi della <xref:System.ServiceModel.Channels.BodyWriter> classe.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-198">\* These items are not implemented directly in `Message` subclasses, but in subclasses of the <xref:System.ServiceModel.Channels.BodyWriter> class.</span></span> <span data-ttu-id="6c8a6-199">Per altre informazioni su <xref:System.ServiceModel.Channels.BodyWriter>, vedere [Using the Message Class](using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="6c8a6-199">For more information about the <xref:System.ServiceModel.Channels.BodyWriter>, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
## <a name="message-headers"></a><span data-ttu-id="6c8a6-200">Intestazioni del messaggio</span><span class="sxs-lookup"><span data-stu-id="6c8a6-200">Message Headers</span></span>  
 <span data-ttu-id="6c8a6-201">Un messaggio può contenere intestazioni.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-201">A message may contain headers.</span></span> <span data-ttu-id="6c8a6-202">Un'intestazione è costituita in modo logico da un Infoset XML a cui sono associati un nome, uno spazio dei nomi e alcune altre proprietà.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-202">A header logically consists of an XML Infoset that is associated with a name, a namespace, and a few other properties.</span></span> <span data-ttu-id="6c8a6-203">Alle intestazioni messaggio si accede utilizzando la proprietà `Headers` su <xref:System.ServiceModel.Channels.Message>.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-203">Message headers are accessed using the `Headers` property on <xref:System.ServiceModel.Channels.Message>.</span></span> <span data-ttu-id="6c8a6-204">Ogni intestazione è rappresentata da una classe <xref:System.ServiceModel.Channels.MessageHeader> .</span><span class="sxs-lookup"><span data-stu-id="6c8a6-204">Each header is represented by a <xref:System.ServiceModel.Channels.MessageHeader> class.</span></span> <span data-ttu-id="6c8a6-205">Le intestazioni messaggio in genere vengono mappate su intestazioni messaggio SOAP quando si utilizza uno stack dei canali configurato per lavorare con messaggi SOAP.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-205">Normally, message headers are mapped to SOAP message headers when using a channel stack configured to work with SOAP messages.</span></span>  
  
 <span data-ttu-id="6c8a6-206">L'inserimento e l'estrazione di informazioni in e da un'intestazione messaggio sono simili all'utilizzo del corpo del messaggio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-206">Putting information into a message header and extracting information from it is similar to using the message body.</span></span> <span data-ttu-id="6c8a6-207">Il processo è leggermente semplificato perché il flusso non è supportato.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-207">The process is somewhat simplified because streaming is not supported.</span></span> <span data-ttu-id="6c8a6-208">È possibile accedere al contenuto della stessa intestazione più di una volta e accedere alle intestazioni in ordine arbitrario, forzando le intestazioni a essere sempre memorizzate nel buffer.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-208">It is possible to access the contents of the same header more than once, and headers can be accessed in arbitrary order, forcing headers to always be buffered.</span></span> <span data-ttu-id="6c8a6-209">Non è disponibile alcun meccanismo generico per ottenere un lettore XML su un'intestazione, ma esiste una `MessageHeader` sottoclasse interna a WCF che rappresenta un'intestazione leggibile con tale funzionalità.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-209">There is no general-purpose mechanism available to get an XML reader over a header, but there is a `MessageHeader` subclass internal to WCF that represents a readable header with such a capability.</span></span> <span data-ttu-id="6c8a6-210">Questo tipo di `MessageHeader` viene creato dallo stack dei canali all'arrivo di un messaggio con intestazioni dell'applicazione personalizzate.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-210">This type of `MessageHeader` is created by the channel stack when a message with custom application headers comes in.</span></span> <span data-ttu-id="6c8a6-211">Ciò consente al framework del servizio di utilizzare un motore di deserializzazione, ad esempio <xref:System.Runtime.Serialization.DataContractSerializer>, per interpretare queste intestazioni.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-211">This enables the service framework to use a deserialization engine, such as the <xref:System.Runtime.Serialization.DataContractSerializer>, to interpret these headers.</span></span>  
  
 <span data-ttu-id="6c8a6-212">Per ulteriori informazioni, vedere [utilizzo della classe Message](using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="6c8a6-212">For more information, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
## <a name="message-properties"></a><span data-ttu-id="6c8a6-213">Proprietà del messaggio</span><span class="sxs-lookup"><span data-stu-id="6c8a6-213">Message Properties</span></span>  
 <span data-ttu-id="6c8a6-214">Un messaggio può contenere proprietà.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-214">A message may contain properties.</span></span> <span data-ttu-id="6c8a6-215">Una *Proprietà* è qualsiasi .NET Framework oggetto associato a un nome di stringa.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-215">A *property* is any .NET Framework object that is associated with a string name.</span></span> <span data-ttu-id="6c8a6-216">Alle proprietà si accede tramite la proprietà `Properties` su `Message`.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-216">Properties are accessed through the `Properties` property on `Message`.</span></span>  
  
 <span data-ttu-id="6c8a6-217">Contrariamente al corpo del messaggio e alle intestazioni messaggio (che in genere eseguono il mapping rispettivamente al corpo SOAP e alle intestazioni SOAP), le proprietà normalmente non vengono inviate o ricevute insieme ai messaggi.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-217">Unlike the message body and message headers (which normally map to the SOAP body and SOAP headers, respectively), message properties are normally not sent or received along with the messages.</span></span> <span data-ttu-id="6c8a6-218">La funzione principale delle proprietà del messaggio è quella di fungere da meccanismo di comunicazione per passare dati sul messaggio tra i vari canali nello stack dei canali e tra lo stack dei canali e il modello di servizio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-218">Message properties exist primarily as a communication mechanism to pass data about the message between the various channels in the channel stack, and between the channel stack and the service model.</span></span>  
  
 <span data-ttu-id="6c8a6-219">Ad esempio, il canale di trasporto HTTP incluso come parte di WCF è in grado di produrre vari codici di stato HTTP, ad esempio "404 (non trovato)" e "500 (errore interno del server)", quando invia risposte ai client.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-219">For example, the HTTP transport channel included as part of WCF is capable of producing various HTTP status codes, such as "404 (Not Found)" and "500 (Internal Server Error)," when it sends replies to clients.</span></span> <span data-ttu-id="6c8a6-220">Prima di inviare un messaggio di risposta, verifica se la `Properties` `Message` proprietà di contiene una proprietà denominata "HttpResponse" che contiene un oggetto di tipo <xref:System.ServiceModel.Channels.HttpResponseMessageProperty> .</span><span class="sxs-lookup"><span data-stu-id="6c8a6-220">Before sending a reply message, it checks to see whether the `Properties` of the `Message` contain a property called "httpResponse" that contains an object of type <xref:System.ServiceModel.Channels.HttpResponseMessageProperty>.</span></span> <span data-ttu-id="6c8a6-221">Se tale proprietà risulta presente, esaminerà la proprietà <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> e utilizzerà quel codice di stato.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-221">If such a property is found, it will look at the <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> property and use that status code.</span></span> <span data-ttu-id="6c8a6-222">Se non la trova, viene utilizzato il codice predefinito "200 (OK)".</span><span class="sxs-lookup"><span data-stu-id="6c8a6-222">If it is not found, the default "200 (OK)" code is used.</span></span>  
  
 <span data-ttu-id="6c8a6-223">Per ulteriori informazioni, vedere [utilizzo della classe Message](using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="6c8a6-223">For more information, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
### <a name="the-message-as-a-whole"></a><span data-ttu-id="6c8a6-224">Il messaggio nel suo insieme</span><span class="sxs-lookup"><span data-stu-id="6c8a6-224">The Message as a Whole</span></span>  
 <span data-ttu-id="6c8a6-225">Finora, sono stati illustrati i metodi per accedere separatamente alle varie parti del messaggio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-225">So far, we have discussed methods for accessing the various parts of the message in isolation.</span></span> <span data-ttu-id="6c8a6-226">La classe <xref:System.ServiceModel.Channels.Message> fornisce tuttavia anche dei metodi per lavorare su tutto il messaggio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-226">However, the <xref:System.ServiceModel.Channels.Message> class also provides methods to work with the entire message as a whole.</span></span> <span data-ttu-id="6c8a6-227">Il metodo `WriteMessage` , ad esempio, scrive l'intero messaggio in un writer XML.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-227">For example, the `WriteMessage` method writes out the entire message to an XML writer.</span></span>  
  
 <span data-ttu-id="6c8a6-228">Affinché ciò sia possibile, è necessario definire un mapping tra l'intera istanza `Message` e un Infoset XML.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-228">For this to be possible, a mapping must be defined between the entire `Message` instance and an XML Infoset.</span></span> <span data-ttu-id="6c8a6-229">Tale mapping, infatti, esiste: WCF utilizza lo standard SOAP per definire questo mapping.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-229">Such a mapping, in fact, exists: WCF uses the SOAP standard to define this mapping.</span></span> <span data-ttu-id="6c8a6-230">Quando un'istanza `Message` viene scritta come Infoset XML, l'Infoset risultante è la SOAP envelope valida che contiene il messaggio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-230">When a `Message` instance is written out as an XML Infoset, the resulting Infoset is the valid SOAP envelope that contains the message.</span></span> <span data-ttu-id="6c8a6-231">Pertanto, `WriteMessage` eseguirebbe in genere i passaggi seguenti:</span><span class="sxs-lookup"><span data-stu-id="6c8a6-231">Thus, `WriteMessage` would normally perform the following steps:</span></span>  
  
1. <span data-ttu-id="6c8a6-232">Scrivere il tag di apertura dell'elemento SOAP envelope.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-232">Write the SOAP envelope element opening tag.</span></span>  
  
2. <span data-ttu-id="6c8a6-233">Scrivere il tag di apertura dell'elemento intestazione SOAP, scrivere tutte le intestazioni e chiudere l'elemento intestazione.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-233">Write the SOAP header element opening tag, write out all of the headers, and close the header element.</span></span>  
  
3. <span data-ttu-id="6c8a6-234">Scrivere il tag di apertura dell'elemento corpo SOAP.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-234">Write the SOAP body element opening tag.</span></span>  
  
4. <span data-ttu-id="6c8a6-235">Chiamare `WriteBodyContents` o un metodo equivalente per scrivere il corpo.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-235">Call `WriteBodyContents` or an equivalent method to write out the body.</span></span>  
  
5. <span data-ttu-id="6c8a6-236">Chiudere gli elementi corpo ed envelope.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-236">Close the body and envelope elements.</span></span>  
  
 <span data-ttu-id="6c8a6-237">I passaggi precedenti sono strettamente legati allo standard SOAP.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-237">The preceding steps are closely tied to the SOAP standard.</span></span> <span data-ttu-id="6c8a6-238">Una complicazione deriva dal fatto che esistono più versioni di SOAP. È ad esempio impossibile scrivere correttamente l'elemento SOAP envelope senza sapere qual è la versione SOAP utilizzata.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-238">This is complicated by the fact that multiple versions of SOAP exist, for example, it is impossible to write out the SOAP envelope element correctly without knowing the SOAP version in use.</span></span> <span data-ttu-id="6c8a6-239">In alcuni casi, inoltre, potrebbe essere auspicabile disattivare completamente questo mapping complesso specifico di SOAP.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-239">Also, in some cases, it may be desirable to turn off this complex SOAP-specific mapping completely.</span></span>  
  
 <span data-ttu-id="6c8a6-240">A tale scopo, in `Version` viene fornita una proprietà `Message`.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-240">For these purposes, a `Version` property is provided on `Message`.</span></span> <span data-ttu-id="6c8a6-241">Può essere impostata sulla versione SOAP da utilizzare quando si scrive il messaggio, oppure su `None` per impedire qualsiasi mapping specifico di SOAP.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-241">It can be set to the SOAP version to use when writing out the message, or it can be set to `None` to prevent any SOAP-specific mappings.</span></span> <span data-ttu-id="6c8a6-242">Se la proprietà `Version` è impostata su `None`, i metodi che lavorano con il messaggio intero operano come se il messaggio fosse costituito unicamente dal suo corpo. `WriteMessage` , ad esempio, chiamerebbe semplicemente `WriteBodyContents` invece di eseguire i diversi passaggi elencati sopra.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-242">If the `Version` property is set to `None`, methods that work with the entire message act as if the message consisted of its body only, for example, `WriteMessage` would simply call `WriteBodyContents` instead of performing the multiple steps listed above.</span></span> <span data-ttu-id="6c8a6-243">È previsto che, sui messaggi in arrivo, `Version` verrà automaticamente rilevata e impostata correttamente.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-243">It is expected that on incoming messages, `Version` will be auto-detected and set correctly.</span></span>  
  
## <a name="the-channel-stack"></a><span data-ttu-id="6c8a6-244">Stack dei canali</span><span class="sxs-lookup"><span data-stu-id="6c8a6-244">The Channel Stack</span></span>  
  
### <a name="channels"></a><span data-ttu-id="6c8a6-245">Canali</span><span class="sxs-lookup"><span data-stu-id="6c8a6-245">Channels</span></span>  
 <span data-ttu-id="6c8a6-246">Come già indicato, lo stack dei canali è responsabile della conversione di istanze <xref:System.ServiceModel.Channels.Message> in uscita in un'azione (ad esempio l'invio di pacchetti sulla rete) o della conversione di un'azione (ad esempio la ricezione di pacchetti di rete) in istanze `Message` in ingresso.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-246">As stated before, the channel stack is responsible for converting outgoing <xref:System.ServiceModel.Channels.Message> instances into some action (such as sending packets over the network), or converting some action (such as receiving network packets) into incoming `Message` instances.</span></span>  
  
 <span data-ttu-id="6c8a6-247">Lo stack dei canali è composto da uno o più canali ordinati in una sequenza.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-247">The channel stack is composed of one or more channels ordered in a sequence.</span></span> <span data-ttu-id="6c8a6-248">Un'istanza `Message` in uscita viene passata al primo canale nello stack (chiamato anche *canale superiore*) che lo passa al canale successivo lungo lo stack e così via.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-248">An outgoing `Message` instance is passed to the first channel in the stack (also called the *topmost channel*), which passes it to the next channel down in stack, and so on.</span></span> <span data-ttu-id="6c8a6-249">Il messaggio termina nell'ultimo canale, chiamato *canale di trasporto*.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-249">The message terminates in the last channel, which is called the *transport channel*.</span></span> <span data-ttu-id="6c8a6-250">I messaggi in arrivo hanno origine nel canale di trasporto e vengono passati di canale in canale lungo lo stack.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-250">Incoming messages originate in the transport channel and are passed from channel to channel up the stack.</span></span> <span data-ttu-id="6c8a6-251">Dal canale principale, il messaggio viene in genere passato nel framework del servizio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-251">From the topmost channel, the message is usually passed into the service framework.</span></span> <span data-ttu-id="6c8a6-252">Anche se questo è il modello abituale per i messaggi dell'applicazione, alcuni canali potrebbero funzionare in modo leggermente diverso. Potrebbero, ad esempio, inviare i messaggi della propria infrastruttura senza che venga loro passato un messaggio da un canale superiore.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-252">While this is the usual pattern for application messages, some channels may work slightly differently, for example, they may send their own infrastructure messages without being passed a message from a channel above.</span></span>  
  
 <span data-ttu-id="6c8a6-253">I canali possono operare sul messaggio in vari modi, mentre transita nello stack.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-253">Channels may operate on the message in various ways as it passes through the stack.</span></span> <span data-ttu-id="6c8a6-254">L'operazione più comune consiste nell'aggiungere un'intestazione a un messaggio in uscita e nel leggere le intestazioni in un messaggio in arrivo.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-254">The most common operation is adding a header to an outgoing message and reading headers on an incoming message.</span></span> <span data-ttu-id="6c8a6-255">Un canale può, ad esempio, calcolare la firma digitale di un messaggio e aggiungerla come intestazione.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-255">For example, a channel may compute the digital signature of a message and add it as a header.</span></span> <span data-ttu-id="6c8a6-256">Un canale può anche controllare tale intestazione di firma digitale sui messaggi in arrivo e impedire che quelli senza una firma valida risalgano lo stack dei canali.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-256">A channel may also inspect this digital signature header on incoming messages and block messages that do not have a valid signature from making their way up the channel stack.</span></span> <span data-ttu-id="6c8a6-257">I canali, inoltre, spesso impostano o controllano le proprietà dei messaggi.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-257">Channels also often set or inspect message properties.</span></span> <span data-ttu-id="6c8a6-258">Il corpo del messaggio in genere non viene modificato, anche se ciò è consentito, ad esempio, il canale di sicurezza WCF può crittografare il corpo del messaggio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-258">The message body is usually not modified, although this is allowed, for example, the WCF security channel can encrypt the message body.</span></span>  
  
### <a name="transport-channels-and-message-encoders"></a><span data-ttu-id="6c8a6-259">Canali di trasporto e codificatori di messaggi</span><span class="sxs-lookup"><span data-stu-id="6c8a6-259">Transport Channels and Message Encoders</span></span>  
 <span data-ttu-id="6c8a6-260">Il canale inferiore nello stack è responsabile della trasformazione effettiva in un'azione di un <xref:System.ServiceModel.Channels.Message>in uscita, modificato da altri canali.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-260">The bottommost channel in the stack is responsible for actually transforming an outgoing <xref:System.ServiceModel.Channels.Message>, as modified by other channels, into some action.</span></span> <span data-ttu-id="6c8a6-261">Sul lato ricevente, questo è il canale che converte un'azione in un `Message` che viene elaborato dagli altri canali.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-261">On the receive side, this is the channel that converts some action into a `Message` that other channels process.</span></span>  
  
 <span data-ttu-id="6c8a6-262">Come già indicato, le azioni possono essere diverse: invio o ricezione di pacchetti di rete su vari protocolli, lettura o scrittura del messaggio in un database, oppure messa in coda o rimozione del messaggio da una coda di Accodamento messaggi e così via.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-262">As stated previously, the actions may be varied: sending or receiving network packets over various protocols, reading or writing the message in a database, or queuing or dequeuing the message in a Message Queuing queue, to provide but a few examples.</span></span> <span data-ttu-id="6c8a6-263">Tutte queste azioni hanno una cosa in comune: richiedono una trasformazione tra l'istanza WCF `Message` e un gruppo effettivo di byte che possono essere inviati, ricevuti, letti, scritti, accodati o rimossi dalla coda.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-263">All these actions have one thing in common: they require a transformation between the WCF`Message` instance and an actual group of bytes that can be sent, received, read, written, queued, or dequeued.</span></span> <span data-ttu-id="6c8a6-264">Il processo di conversione di un `Message` in un gruppo di byte è detto *codifica*, mentre il processo inverso di creazione di un `Message` da un gruppo di byte è detto *decodifica*.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-264">The process of converting a `Message` into a group of bytes is called *encoding*, and the reverse process of creating a `Message` from a group of bytes is called *decoding*.</span></span>  
  
 <span data-ttu-id="6c8a6-265">La maggior parte dei canali di trasporto utilizza componenti detti *codificatori di messaggi* destinati ad eseguire la codifica e la decodifica.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-265">Most transport channels use components called *message encoders* to accomplish the encoding and decoding work.</span></span> <span data-ttu-id="6c8a6-266">Un codificatore di messaggi è una sottoclasse della classe <xref:System.ServiceModel.Channels.MessageEncoder> .</span><span class="sxs-lookup"><span data-stu-id="6c8a6-266">A message encoder is a subclass of the <xref:System.ServiceModel.Channels.MessageEncoder> class.</span></span> <span data-ttu-id="6c8a6-267">`MessageEncoder` include vari overload dei metodi `ReadMessage` e `WriteMessage` per eseguire la conversione tra `Message` e gruppi di byte.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-267">`MessageEncoder` includes various `ReadMessage` and `WriteMessage` method overloads to convert between `Message` and groups of bytes.</span></span>  
  
 <span data-ttu-id="6c8a6-268">Sul lato di invio, un canale di trasporto di memorizzazione nel buffer passa l'oggetto `Message` ricevuto da un canale sovrastante a `WriteMessage`.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-268">On the sending side, a buffering transport channel passes the `Message` object that it received from a channel above it to `WriteMessage`.</span></span> <span data-ttu-id="6c8a6-269">Di ritorno, riceve una matrice di byte che utilizzerà poi per eseguire l'azione (ad esempio assemblare questi byte come pacchetti TCP validi e inviarli alla destinazione corretta).</span><span class="sxs-lookup"><span data-stu-id="6c8a6-269">It gets back an array of bytes, which it then uses to perform its action (such as packaging these bytes as valid TCP packets and sending them to the correct destination).</span></span> <span data-ttu-id="6c8a6-270">Un canale di trasporto del flusso crea innanzitutto un `Stream` (ad esempio, sulla connessione TCP in uscita), quindi passa sia lo `Stream` che il `Message` da inviare all'overload `WriteMessage` appropriato che scrive il messaggio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-270">A streaming transport channel first creates a `Stream` (for example, over the outgoing TCP connection), and then passes both the `Stream` and the `Message` it needs to send to the appropriate `WriteMessage` overload, which writes out the message.</span></span>  
  
 <span data-ttu-id="6c8a6-271">Sul lato ricevente, un canale di trasporto di memorizzazione nel buffer estrae i byte in ingresso (ad esempio, dai pacchetti TCP in ingresso) in una matrice e chiama `ReadMessage` per ottenere un oggetto `Message` che può passare più avanti nello stack dei canali.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-271">On the receiving side, a buffering transport channel extracts incoming bytes (for example, from incoming TCP packets) into an array and calls `ReadMessage` to get a `Message` object that it can pass further up the channel stack.</span></span> <span data-ttu-id="6c8a6-272">Un canale di trasporto del flusso crea un oggetto `Stream` (ad esempio, un flusso di rete sulla connessione TCP in ingresso) e lo passa a `ReadMessage` per ottenere un oggetto `Message` .</span><span class="sxs-lookup"><span data-stu-id="6c8a6-272">A streaming transport channel creates a `Stream` object (for example, a network stream over the incoming TCP connection) and passes that to `ReadMessage` to get back a `Message` object.</span></span>  
  
 <span data-ttu-id="6c8a6-273">La separazione tra i canali di trasporto e il codificatore di messaggi non è obbligatoria. È possibile scrivere un canale di trasporto che non utilizza un codificatore di messaggi.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-273">The separation between the transport channels and the message encoder is not mandatory; it is possible to write a transport channel that does not use a message encoder.</span></span> <span data-ttu-id="6c8a6-274">Il vantaggio di questa separazione, tuttavia, è la facilità di composizione.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-274">However, the advantage of this separation is ease of composition.</span></span> <span data-ttu-id="6c8a6-275">Finché un canale di trasporto utilizza solo la base <xref:System.ServiceModel.Channels.MessageEncoder> , può funzionare con qualsiasi codificatore di messaggi WCF o di terze parti.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-275">As long as a transport channel uses only the base <xref:System.ServiceModel.Channels.MessageEncoder>, it can work with any WCF or third-party message encoder.</span></span> <span data-ttu-id="6c8a6-276">Analogamente, lo stesso codificatore può essere normalmente utilizzato in qualsiasi canale di trasporto.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-276">Likewise, the same encoder can normally be used in any transport channel.</span></span>  
  
### <a name="message-encoder-operation"></a><span data-ttu-id="6c8a6-277">Operazione del codificatore messaggi</span><span class="sxs-lookup"><span data-stu-id="6c8a6-277">Message Encoder Operation</span></span>  
 <span data-ttu-id="6c8a6-278">Per descrivere l'operazione tipica di un codificatore, è opportuno considerare i quattro casi seguenti.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-278">To describe the typical operation of an encoder, it is useful to consider the following four cases.</span></span>  
  
|<span data-ttu-id="6c8a6-279">Operazione</span><span class="sxs-lookup"><span data-stu-id="6c8a6-279">Operation</span></span>|<span data-ttu-id="6c8a6-280">Commento</span><span class="sxs-lookup"><span data-stu-id="6c8a6-280">Comment</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="6c8a6-281">Codifica, memorizzata nel buffer</span><span class="sxs-lookup"><span data-stu-id="6c8a6-281">Encoding, Buffered</span></span>|<span data-ttu-id="6c8a6-282">In modalità di memorizzazione nel buffer, il codificatore crea un buffer  di dimensioni variabili, dopo di che crea un writer XML su di esso.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-282">In buffered mode, the encoder normally creates a variable-size buffer and then creates an XML writer over it.</span></span> <span data-ttu-id="6c8a6-283">Chiama quindi <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> sul messaggio in fase di codifica, per scrivere le intestazioni e il corpo utilizzando <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, come spiegato nella sezione precedente di questo argomento su `Message` .</span><span class="sxs-lookup"><span data-stu-id="6c8a6-283">It then calls <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> on the message being encoded, which writes out the headers and then the body using <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, as explained in the preceding section about `Message` in this topic.</span></span> <span data-ttu-id="6c8a6-284">Viene infine restituito il contenuto del buffer (rappresentato come matrice di byte) che deve essere utilizzato dal canale di trasporto.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-284">The contents of the buffer (represented as an array of bytes) are then returned for the transport channel to use.</span></span>|  
|<span data-ttu-id="6c8a6-285">Codifica, trasmessa</span><span class="sxs-lookup"><span data-stu-id="6c8a6-285">Encoding, Streamed</span></span>|<span data-ttu-id="6c8a6-286">In modalità con invio nel flusso, l'operazione è simile a quanto sopra, ma più semplice.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-286">In streamed mode, the operation is similar to the above, but simpler.</span></span> <span data-ttu-id="6c8a6-287">Non è necessario alcun buffer.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-287">There is no need for a buffer.</span></span> <span data-ttu-id="6c8a6-288">In genere viene creato un writer XML sopra il flusso e viene chiamato <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> sul `Message` per scriverlo in questo writer.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-288">An XML writer is normally created over the stream and <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> is called on the `Message` to write it out to this writer.</span></span>|  
|<span data-ttu-id="6c8a6-289">Decodifica, memorizzata nel buffer</span><span class="sxs-lookup"><span data-stu-id="6c8a6-289">Decoding, Buffered</span></span>|<span data-ttu-id="6c8a6-290">In caso di decodifica in modalità di memorizzazione nel buffer, in genere viene creata una speciale sottoclasse `Message` che contiene i dati memorizzati nel buffer.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-290">When decoding in buffered mode, a special `Message` subclass that contains the buffered data is normally created.</span></span> <span data-ttu-id="6c8a6-291">Vengono lette le intestazioni messaggio e viene creato un lettore XML posizionato sul corpo del messaggio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-291">The headers of the message are read, and an XML reader positioned on the message body is created.</span></span> <span data-ttu-id="6c8a6-292">Si tratta del lettore che verrà restituito con <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-292">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
|<span data-ttu-id="6c8a6-293">Decodifica, trasmessa</span><span class="sxs-lookup"><span data-stu-id="6c8a6-293">Decoding, Streamed</span></span>|<span data-ttu-id="6c8a6-294">In caso di decodifica in modalità con invio nel flusso, in genere viene creata una speciale sottoclasse messaggio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-294">When decoding in streamed mode, a special Message subclass is normally created.</span></span> <span data-ttu-id="6c8a6-295">Il flusso viene fatto avanzare solo quel tanto che è sufficiente per leggere tutte le intestazioni e posizionarlo sul corpo del messaggio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-295">The stream is advanced just enough to read all the headers and position it on the message body.</span></span> <span data-ttu-id="6c8a6-296">Sul flusso viene quindi creato un lettore XML.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-296">An XML reader is then created over the stream.</span></span> <span data-ttu-id="6c8a6-297">Si tratta del lettore che verrà restituito con <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-297">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
  
 <span data-ttu-id="6c8a6-298">I codificatori possono eseguire anche altre funzioni.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-298">Encoders can perform other functions as well.</span></span> <span data-ttu-id="6c8a6-299">Possono, ad esempio, inserire in un pool i lettori e i writer XML.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-299">For example, the encoders can pool XML readers and writers.</span></span> <span data-ttu-id="6c8a6-300">Creare un nuovo lettore o writer XML ogni volta che è richiesto, è oneroso.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-300">It is expensive to create a new XML reader or writer every time one is needed.</span></span> <span data-ttu-id="6c8a6-301">I codificatori, pertanto, gestiscono un pool di lettori e un pool di writer di dimensioni configurabili.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-301">Therefore, encoders normally maintain a pool of readers and a pool of writers of configurable size.</span></span> <span data-ttu-id="6c8a6-302">Nelle descrizioni dell'operazione del codificatore descritta in precedenza, ogni volta che viene usata la frase "creare un lettore/writer XML", normalmente significa "prenderne uno dal pool o crearne uno se non è disponibile".</span><span class="sxs-lookup"><span data-stu-id="6c8a6-302">In the descriptions of encoder operation described previously, whenever the phrase "create an XML reader/writer" is used, it normally means "take one from the pool, or create one if one is not available."</span></span> <span data-ttu-id="6c8a6-303">Il codificatore (insieme alle sottoclassi `Message` che crea durante la decodifica) contiene la logica necessaria per restituire lettori e scrittori ai pool quando non sono più necessari, ad esempio quando `Message` viene chiuso.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-303">The encoder (and the `Message` subclasses it creates while decoding) contain logic to return readers and writers to the pools once they are no longer needed (for example, when the `Message` is closed).</span></span>  
  
 <span data-ttu-id="6c8a6-304">WCF fornisce tre codificatori di messaggi, anche se è possibile creare altri tipi personalizzati.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-304">WCF provides three message encoders, although it is possible to create additional custom types.</span></span> <span data-ttu-id="6c8a6-305">I tipi forniti sono testo, binario e MTOM (Message Transmission Optimization Mechanism).</span><span class="sxs-lookup"><span data-stu-id="6c8a6-305">The supplied types are Text, Binary, and Message Transmission Optimization Mechanism (MTOM).</span></span> <span data-ttu-id="6c8a6-306">La descrizione dettagliata è disponibile in [Choosing a Message Encoder](choosing-a-message-encoder.md).</span><span class="sxs-lookup"><span data-stu-id="6c8a6-306">These are described in detail in [Choosing a Message Encoder](choosing-a-message-encoder.md).</span></span>  
  
### <a name="the-istreamprovider-interface"></a><span data-ttu-id="6c8a6-307">Interfaccia IStreamProvider</span><span class="sxs-lookup"><span data-stu-id="6c8a6-307">The IStreamProvider Interface</span></span>  
 <span data-ttu-id="6c8a6-308">Quando si scrive in un writer XML un messaggio in uscita che contiene un corpo inviato nel flusso, <xref:System.ServiceModel.Channels.Message> utilizza una sequenza di chiamate simili alle seguenti nell'implementazione di <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> :</span><span class="sxs-lookup"><span data-stu-id="6c8a6-308">When writing an outgoing message that contains a streamed body to an XML writer, the <xref:System.ServiceModel.Channels.Message> uses a sequence of calls similar to the following in its <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> implementation:</span></span>  
  
- <span data-ttu-id="6c8a6-309">Scrivere tutte le informazioni necessarie che precedono il flusso (ad esempio, il tag di apertura XML).</span><span class="sxs-lookup"><span data-stu-id="6c8a6-309">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
- <span data-ttu-id="6c8a6-310">Scrivere il flusso.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-310">Write the stream.</span></span>  
  
- <span data-ttu-id="6c8a6-311">Scrivere tutte le informazioni dopo il flusso (ad esempio, il tag di chiusura XML).</span><span class="sxs-lookup"><span data-stu-id="6c8a6-311">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="6c8a6-312">Questa procedura funziona bene con codifiche simili alla codifica XML testuale.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-312">This works well with encodings that are similar to the textual XML encoding.</span></span> <span data-ttu-id="6c8a6-313">Esistono, tuttavia, alcune codifiche che non inseriscono informazioni InfoSet XML (ad esempio, i tag di inizio e fine di elementi XML) insieme ai dati contenuti all'interno di elementi.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-313">However, some encodings do not place XML Infoset information (for example, tags for starting and ending XML elements) together with the data contained within elements.</span></span> <span data-ttu-id="6c8a6-314">Nella codifica MTOM, ad esempio, il messaggio è suddiviso in più parti.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-314">For example, in the MTOM encoding, the message is split into multiple parts.</span></span> <span data-ttu-id="6c8a6-315">Una parte contiene l'InfoSet XML, che può contenere riferimenti ad altre parti per il contenuto effettivo degli elementi.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-315">One part contains the XML Infoset, which may contain references to other parts for actual element contents.</span></span> <span data-ttu-id="6c8a6-316">Dato che, in genere, l'InfoSet XML è di piccole dimensioni rispetto al contenuto inviato nel flusso, è consigliabile memorizzarlo nel buffer, scriverlo e quindi scrivere il contenuto in un flusso.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-316">The XML Infoset is normally small compared to the streamed contents, so it makes sense to buffer the Infoset, write it out, and then write the contents in a streamed way.</span></span> <span data-ttu-id="6c8a6-317">Ciò significa che quando viene scritto il tag dell'elemento di chiusura, il flusso non dovrebbe essere stato ancora scritto.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-317">This means that by the time the closing element tag is written, the stream should not have been written out yet.</span></span>  
  
 <span data-ttu-id="6c8a6-318">A tale fine, viene utilizzata l'interfaccia <xref:System.Xml.IStreamProvider> .</span><span class="sxs-lookup"><span data-stu-id="6c8a6-318">For this purpose, the <xref:System.Xml.IStreamProvider> interface is used.</span></span> <span data-ttu-id="6c8a6-319">L'interfaccia ha un metodo <xref:System.Xml.IStreamProvider.GetStream> che restituisce il flusso da scrivere.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-319">The interface has a <xref:System.Xml.IStreamProvider.GetStream> method that returns the stream to be written.</span></span> <span data-ttu-id="6c8a6-320">La modalità corretta per scrivere il corpo di un messaggio inviato in un flusso in <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> è la seguente:</span><span class="sxs-lookup"><span data-stu-id="6c8a6-320">The correct way to write out a streamed message body in <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> is as follows:</span></span>  
  
1. <span data-ttu-id="6c8a6-321">Scrivere tutte le informazioni necessarie che precedono il flusso (ad esempio, il tag di apertura XML).</span><span class="sxs-lookup"><span data-stu-id="6c8a6-321">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
2. <span data-ttu-id="6c8a6-322">Chiamare l'overload `WriteValue` in <xref:System.Xml.XmlDictionaryWriter> che prende un <xref:System.Xml.IStreamProvider>, con un'implementazione `IStreamProvider` che restituisce il flusso da scrivere.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-322">Call the `WriteValue` overload on the <xref:System.Xml.XmlDictionaryWriter> that takes an <xref:System.Xml.IStreamProvider>, with an `IStreamProvider` implementation that returns the stream to be written.</span></span>  
  
3. <span data-ttu-id="6c8a6-323">Scrivere tutte le informazioni dopo il flusso (ad esempio, il tag di chiusura XML).</span><span class="sxs-lookup"><span data-stu-id="6c8a6-323">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="6c8a6-324">Con questo approccio, il writer XML può scegliere quando chiamare <xref:System.Xml.IStreamProvider.GetStream> e scrivere i dati inviati nel flusso.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-324">With this approach, the XML writer has a choice of when to call <xref:System.Xml.IStreamProvider.GetStream> and write out the streamed data.</span></span> <span data-ttu-id="6c8a6-325">I writer XML binari e testuali, ad esempio, lo chiameranno immediatamente e scriveranno il contenuto inviato nel flusso tra il tag di inizio e quello di fine.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-325">For example, the textual and binary XML writers will call it immediately and write out the streamed contents in-between the start and end tags.</span></span> <span data-ttu-id="6c8a6-326">Il writer MTOM può decidere di chiamare <xref:System.Xml.IStreamProvider.GetStream> in un secondo momento, quando è pronto per scrivere la parte appropriata del messaggio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-326">The MTOM writer may decide to call <xref:System.Xml.IStreamProvider.GetStream> later, when it is ready to write the appropriate part of the message.</span></span>  
  
## <a name="representing-data-in-the-service-framework"></a><span data-ttu-id="6c8a6-327">Rappresentazione di dati in framework del servizio</span><span class="sxs-lookup"><span data-stu-id="6c8a6-327">Representing Data in the Service Framework</span></span>  
 <span data-ttu-id="6c8a6-328">Come indicato nella sezione "architettura di base" di questo argomento, il Framework del servizio è la parte di WCF che, tra le altre cose, è responsabile della conversione tra un modello di programmazione intuitivo per i dati del messaggio e le istanze effettive `Message` .</span><span class="sxs-lookup"><span data-stu-id="6c8a6-328">As stated in the "Basic Architecture" section of this topic, the service framework is the part of WCF that, among other things, is responsible for converting between a user-friendly programming model for message data and actual `Message` instances.</span></span> <span data-ttu-id="6c8a6-329">Uno scambio di messaggi viene in genere rappresentato nel Framework del servizio come metodo di .NET Framework contrassegnato con l' <xref:System.ServiceModel.OperationContractAttribute> attributo.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-329">Normally, a message exchange is represented in the service framework as a .NET Framework method marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute.</span></span> <span data-ttu-id="6c8a6-330">Il metodo può prendere alcuni parametri e restituire un valore restituito o parametri out (o entrambi).</span><span class="sxs-lookup"><span data-stu-id="6c8a6-330">The method can take in some parameters and can return a return value or out parameters (or both).</span></span> <span data-ttu-id="6c8a6-331">Sul lato servizio, i parametri di input rappresentano il messaggio in arrivo, mentre il valore restituito e i parametri out rappresentano il messaggio in uscita.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-331">On the service side, the input parameters represent the incoming message, and the return value and out parameters represent the outgoing message.</span></span> <span data-ttu-id="6c8a6-332">Sul lato client, è vero il contrario.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-332">On the client side, the reverse is true.</span></span> <span data-ttu-id="6c8a6-333">Il modello di programmazione per descrivere i messaggi tramite parametri e il valore restituito vengono illustrati dettagliatamente in [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="6c8a6-333">The programming model for describing messages using parameters and the return value is described in detail in [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span> <span data-ttu-id="6c8a6-334">Contenuto della sezione verrà fornita una breve panoramica.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-334">However, this section will provide a brief overview.</span></span>  
  
## <a name="programming-models"></a><span data-ttu-id="6c8a6-335">Modelli di programmazione</span><span class="sxs-lookup"><span data-stu-id="6c8a6-335">Programming Models</span></span>  
 <span data-ttu-id="6c8a6-336">Il Framework del servizio WCF supporta cinque diversi modelli di programmazione per la descrizione dei messaggi:</span><span class="sxs-lookup"><span data-stu-id="6c8a6-336">The WCF service framework supports five different programming models for describing messages:</span></span>  
  
### <a name="1-the-empty-message"></a><span data-ttu-id="6c8a6-337">1. Messaggio vuoto</span><span class="sxs-lookup"><span data-stu-id="6c8a6-337">1. The Empty Message</span></span>  
 <span data-ttu-id="6c8a6-338">Questo è il caso più semplice.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-338">This is the simplest case.</span></span> <span data-ttu-id="6c8a6-339">Per descrivere un messaggio in arrivo vuoto, non utilizzare parametri di input.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-339">To describe an empty incoming message, do not use any input parameters.</span></span>  
  
 [!code-csharp[C_DataArchitecture#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#3)]
 [!code-vb[C_DataArchitecture#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#3)]  
  
 <span data-ttu-id="6c8a6-340">Per descrivere un messaggio in uscita vuoto, utilizzare un valore restituito vuoto e non utilizzare nessun parametro out:</span><span class="sxs-lookup"><span data-stu-id="6c8a6-340">To describe an empty outgoing message, use a void return value and do not use any out parameters:</span></span>  
  
 [!code-csharp[C_DataArchitecture#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#4)]
 [!code-vb[C_DataArchitecture#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#4)]  
  
 <span data-ttu-id="6c8a6-341">Si noti che questa procedura è diversa da un contratto dell'operazione unidirezionale:</span><span class="sxs-lookup"><span data-stu-id="6c8a6-341">Note that this is different from a one-way operation contract:</span></span>  
  
 [!code-csharp[C_DataArchitecture#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#5)]
 [!code-vb[C_DataArchitecture#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#5)]  
  
 <span data-ttu-id="6c8a6-342">Nell'esempio `SetDesiredTemperature` , viene illustrato un modello di scambio di messaggio bidirezionale.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-342">In the `SetDesiredTemperature` example, a two-way message exchange pattern is described.</span></span> <span data-ttu-id="6c8a6-343">Dall'operazione viene restituito un messaggio, ma è vuoto.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-343">A message is returned from the operation, but it is empty.</span></span> <span data-ttu-id="6c8a6-344">L'operazione può restituire un errore.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-344">It is possible to return a fault from the operation.</span></span> <span data-ttu-id="6c8a6-345">Nell'esempio "Set Lightbulb", il modello di scambio di messaggi è unidirezionale, pertanto non c'è nessun messaggio in uscita da descrivere.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-345">In the "Set Lightbulb" example, the message exchange pattern is one-way, so there is no outgoing message to describe.</span></span> <span data-ttu-id="6c8a6-346">In questo caso, il servizio non può comunicare nessuno stato al client.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-346">The service cannot communicate any status back to the client in this case.</span></span>  
  
### <a name="2-using-the-message-class-directly"></a><span data-ttu-id="6c8a6-347">2. Utilizzo diretto della classe messaggio</span><span class="sxs-lookup"><span data-stu-id="6c8a6-347">2. Using the Message Class Directly</span></span>  
 <span data-ttu-id="6c8a6-348">È possibile utilizzare direttamente la classe <xref:System.ServiceModel.Channels.Message> (o una delle sue sottoclassi) in un contratto dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-348">It is possible to use the <xref:System.ServiceModel.Channels.Message> class (or one of its subclasses) directly in an operation contract.</span></span> <span data-ttu-id="6c8a6-349">In questo caso, il framework del servizio passa unicamente `Message` dall'operazione allo stack dei canali e viceversa, senza ulteriore elaborazione.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-349">In this case, the service framework just passes the `Message` from the operation to the channel stack and vice versa, with no further processing.</span></span>  
  
 <span data-ttu-id="6c8a6-350">L'utilizzo diretto di `Message` è consigliato principalmente in due casi.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-350">There are two main use cases for using `Message` directly.</span></span> <span data-ttu-id="6c8a6-351">È possibile utilizzarlo per scenari avanzati, quando nessuno degli altri modelli di programmazione offre flessibilità sufficiente per descrivere il messaggio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-351">You can use this for advanced scenarios, when none of the other programming models gives you enough flexibility to describe your message.</span></span> <span data-ttu-id="6c8a6-352">Si potrebbe, ad esempio, voler utilizzare file su disco per descrivere un messaggio, con le proprietà file che diventano intestazioni messaggio e il contenuto del file che diventa il corpo del messaggio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-352">For example, you might want to use files on disk to describe a message, with the file’s properties becoming message headers and the file’s contents becoming the message body.</span></span> <span data-ttu-id="6c8a6-353">A questo punto, è possibile creare un codice simile al seguente.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-353">You can then create something similar to the following.</span></span>  
  
 [!code-csharp[C_DataArchitecture#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#6)]
 [!code-vb[C_DataArchitecture#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#6)]  
  
 <span data-ttu-id="6c8a6-354">Il secondo utilizzo comune per `Message` in un contratto dell'operazione è quando un servizio non tiene conto dello specifico contenuto del messaggio e si comporta come se fosse una black box.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-354">The second common use for `Message` in an operation contract is when a service does not care about the particular message contents and acts on the message as on a black box.</span></span> <span data-ttu-id="6c8a6-355">Potrebbe, ad esempio, esservi un servizio che inoltra i messaggi a più destinatari diversi.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-355">For example, you might have a service that forwards messages to multiple other recipients.</span></span> <span data-ttu-id="6c8a6-356">Il contratto può essere scritto come segue.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-356">The contract can be written as follows.</span></span>  
  
 [!code-csharp[C_DataArchitecture#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#7)]
 [!code-vb[C_DataArchitecture#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#7)]  
  
 <span data-ttu-id="6c8a6-357">La riga Action = "\*" Disattiva in modo efficace l'invio dei messaggi e assicura che tutti i messaggi inviati al `IForwardingService` contratto siano in `ForwardMessage` funzione.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-357">The Action="\*" line effectively turns off message dispatching and ensures that all messages sent to the `IForwardingService` contract make their way to the `ForwardMessage` operation.</span></span> <span data-ttu-id="6c8a6-358">In genere, il dispatcher esaminerebbe l'intestazione "Action" del messaggio per determinare a quale operazione è destinata.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-358">(Normally, the dispatcher would examine the message’s "Action" header to determine which operation it is intended for.</span></span> <span data-ttu-id="6c8a6-359">Action = " \* " significa "tutti i valori possibili dell'intestazione Action". La combinazione di Action = " \* " e l'uso di Message come parametro è nota come "contratto universale" perché è in grado di ricevere tutti i messaggi possibili.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-359">Action="\*" means "all possible values of the Action header".) The combination of Action="\*" and using Message as a parameter is known as the "universal contract" because it is able to receive all possible messages.</span></span> <span data-ttu-id="6c8a6-360">Per poter inviare tutti i messaggi possibili, utilizzare Message come valore restituito e impostare `ReplyAction` su " \* ".</span><span class="sxs-lookup"><span data-stu-id="6c8a6-360">To be able to send all possible messages, use Message as the return value and set `ReplyAction` to "\*".</span></span> <span data-ttu-id="6c8a6-361">Ciò impedirà al framework del servizio di aggiungere la propria intestazione Action, permettendogli di controllarla utilizzando l'oggetto `Message` restituito.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-361">This will prevent the service framework from adding its own Action header, enabling you to control this header using the `Message` object you return.</span></span>  
  
### <a name="3-message-contracts"></a><span data-ttu-id="6c8a6-362">3. Contratti di messaggio</span><span class="sxs-lookup"><span data-stu-id="6c8a6-362">3. Message Contracts</span></span>  
 <span data-ttu-id="6c8a6-363">WCF fornisce un modello di programmazione dichiarativa per la descrizione dei messaggi, detti *contratti di messaggio*.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-363">WCF provides a declarative programming model for describing messages, called *message contracts*.</span></span> <span data-ttu-id="6c8a6-364">Questo modello viene descritto dettagliatamente in [Using Message Contracts](using-message-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="6c8a6-364">This model is described in detail in [Using Message Contracts](using-message-contracts.md).</span></span> <span data-ttu-id="6c8a6-365">Essenzialmente, l'intero messaggio è rappresentato da un singolo tipo di .NET Framework che utilizza attributi come <xref:System.ServiceModel.MessageBodyMemberAttribute> e <xref:System.ServiceModel.MessageHeaderAttribute> per descrivere le parti della classe del contratto di messaggio di cui eseguire il mapping alla parte del messaggio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-365">Essentially, the entire message is represented by a single .NET Framework type that uses attributes like the <xref:System.ServiceModel.MessageBodyMemberAttribute> and <xref:System.ServiceModel.MessageHeaderAttribute> to describe which parts of the message contract class should map to which part of the message.</span></span>  
  
 <span data-ttu-id="6c8a6-366">I contratti di messaggio forniscono un grande controllo sulle istanze `Message` risultanti, anche se, ovviamente, non pari a quello assicurato dall'utilizzo diretto della classe `Message` .</span><span class="sxs-lookup"><span data-stu-id="6c8a6-366">Message contracts provide a lot of control over the resulting `Message` instances (although obviously not as much control as using the `Message` class directly).</span></span> <span data-ttu-id="6c8a6-367">I corpi dei messaggi, ad esempio, spesso sono composti da più informazioni, ognuna delle quali è rappresentata da un proprio elemento XML.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-367">For example, message bodies are often composed of multiple pieces of information, each represented by its own XML element.</span></span> <span data-ttu-id="6c8a6-368">Questi elementi possono verificarsi direttamente nel corpo (modalità*bare* ) oppure possono essere *incapsulati* in un elemento XML.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-368">These elements can either occur directly in the body (*bare* mode) or can be *wrapped* in an encompassing XML element.</span></span> <span data-ttu-id="6c8a6-369">L'utilizzo del modello di programmazione di contratto di messaggio consente di decidere se utilizzare lo stile bare o quello incapsulato e controllare il nome wrapper e lo spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-369">Using the message contract programming model enables you to make the bare-versus-wrapped decision and control the name of the wrapper name and namespace.</span></span>  
  
 <span data-ttu-id="6c8a6-370">Nell'esempio di codice seguente di un contratto di messaggio vengono illustrate queste funzionalità.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-370">The following code example of a message contract demonstrates these features.</span></span>  
  
 [!code-csharp[C_DataArchitecture#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#9)]
 [!code-vb[C_DataArchitecture#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#9)]  
  
 <span data-ttu-id="6c8a6-371">Gli elementi contrassegnati per essere serializzati (con <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>o altri attributi correlati) devono essere serializzabili per partecipare a un contratto di messaggio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-371">Items marked to be serialized (with the <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, or other related attributes) must be serializable to participate in a message contract.</span></span> <span data-ttu-id="6c8a6-372">Per ulteriori informazioni, vedere la sezione "serializzazione" più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-372">For more information, see the "Serialization" section later in this topic.</span></span>  
  
### <a name="4-parameters"></a><span data-ttu-id="6c8a6-373">4. Parametri</span><span class="sxs-lookup"><span data-stu-id="6c8a6-373">4. Parameters</span></span>  
 <span data-ttu-id="6c8a6-374">Spesso, uno sviluppatore che desidera descrivere un'operazione che influenza più blocchi di dati non ha bisogno del livello di controllo fornito dai contratti di messaggio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-374">Often, a developer who wants to describe an operation that acts on multiple pieces of data does not need the degree of control that message contracts provide.</span></span> <span data-ttu-id="6c8a6-375">Quando si creano nuovi servizi, ad esempio, in genere non si desidera decidere se scegliere lo stile bare o quello incapsulato o il nome dell'elemento wrapper.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-375">For example, when creating new services, one does not usually want to make the bare-versus-wrapped decision and decide on the wrapper element name.</span></span> <span data-ttu-id="6c8a6-376">Queste decisioni spesso richiedono una profonda conoscenza dei servizi Web e di SOAP.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-376">Making these decisions often requires deep knowledge of Web services and SOAP.</span></span>  
  
 <span data-ttu-id="6c8a6-377">Il Framework del servizio WCF può scegliere automaticamente la rappresentazione SOAP migliore e più interoperativa per l'invio o la ricezione di più informazioni correlate, senza imporre queste scelte all'utente.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-377">The WCF service framework can automatically pick the best and most interoperable SOAP representation for sending or receiving multiple related pieces of information, without forcing these choices on the user.</span></span> <span data-ttu-id="6c8a6-378">A tale fine, è sufficiente descrivere queste informazioni come parametri o valori restituiti di un contratto dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-378">This is accomplished by simply describing these pieces of information as parameters or return values of an operation contract.</span></span> <span data-ttu-id="6c8a6-379">Si consideri ad esempio il contratto dell'operazione seguente:</span><span class="sxs-lookup"><span data-stu-id="6c8a6-379">For example, consider the following operation contract.</span></span>  
  
 [!code-csharp[C_DataArchitecture#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#11)]
 [!code-vb[C_DataArchitecture#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#11)]  
  
 <span data-ttu-id="6c8a6-380">Il framework del servizio decide automaticamente di inserire tutte e tre le informazioni (`customerID`, `item`e `quantity`) nel corpo del messaggio e di incapsularle in un elemento wrapper chiamato `SubmitOrderRequest`.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-380">The service framework automatically decides to put all three pieces of information (`customerID`, `item`, and `quantity`) into the message body and wrap them in a wrapper element named `SubmitOrderRequest`.</span></span>  
  
 <span data-ttu-id="6c8a6-381">L'approccio consigliato è quello di descrivere le informazioni da inviare o ricevere come un semplice elenco di parametri del contratto dell'operazione, a meno che non vi siano delle ragioni speciali per passare al contratto di messaggio più complesso o a modelli di programmazione basati su `Message`.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-381">Describing the information to be sent or received as a simple list of operation contract parameters is the recommended approach, unless special reasons exist to move to the more-complex message contract or `Message`-based programming models.</span></span>  
  
### <a name="5-stream"></a><span data-ttu-id="6c8a6-382">5. Flusso</span><span class="sxs-lookup"><span data-stu-id="6c8a6-382">5. Stream</span></span>  
 <span data-ttu-id="6c8a6-383">L'utilizzo di `Stream` o di una delle sue sottoclassi in un contratto dell'operazione o come parte unica del corpo del messaggio in un contratto di messaggio può essere considerato un modello di programmazione separato da quelli descritti sopra.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-383">Using `Stream` or one of its subclasses in an operation contract or as a sole message body part in a message contract can be considered a separate programming model from the ones described above.</span></span> <span data-ttu-id="6c8a6-384">Utilizzare `Stream` in questo modo è l'unica possibilità per garantire che il contratto sia utilizzabile in un flusso, a meno che non si scriva una sottoclasse `Message` compatibile con il flusso.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-384">Using `Stream` in this way is the only way to guarantee that your contract will be usable in a streamed fashion, short of writing your own streaming-compatible `Message` subclass.</span></span> <span data-ttu-id="6c8a6-385">Per altre informazioni, vedere [dati di grandi dimensioni e flussi](large-data-and-streaming.md).</span><span class="sxs-lookup"><span data-stu-id="6c8a6-385">For more information, see [Large Data and Streaming](large-data-and-streaming.md).</span></span>  
  
 <span data-ttu-id="6c8a6-386">Quando `Stream` o una delle sottoclassi vengono utilizzati in questo modo, il serializzatore non viene richiamato.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-386">When `Stream` or one of its subclasses is used in this way, the serializer is not invoked.</span></span> <span data-ttu-id="6c8a6-387">Per i messaggi in uscita, viene creata una sottoclasse `Message` speciale di flusso e il flusso viene scritto come descritto nella sezione sull'interfaccia <xref:System.Xml.IStreamProvider> .</span><span class="sxs-lookup"><span data-stu-id="6c8a6-387">For outgoing messages, a special streaming `Message` subclass is created and the stream is written out as described in the section on the <xref:System.Xml.IStreamProvider> interface.</span></span> <span data-ttu-id="6c8a6-388">Per i messaggi in arrivo, il framework del servizio crea una sottoclasse `Stream` sul messaggio in arrivo e la fornisce all'operazione.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-388">For incoming messages, the service framework creates a `Stream` subclass over the incoming message and provides it to the operation.</span></span>  
  
## <a name="programming-model-restrictions"></a><span data-ttu-id="6c8a6-389">Restrizioni del modello di programmazione</span><span class="sxs-lookup"><span data-stu-id="6c8a6-389">Programming Model Restrictions</span></span>  
 <span data-ttu-id="6c8a6-390">I modelli di programmazione descritti sopra non possono essere combinati arbitrariamente.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-390">The programming models described above cannot be arbitrarily combined.</span></span> <span data-ttu-id="6c8a6-391">Se, ad esempio, un'operazione accetta un tipo di contratto di messaggio, il contratto di messaggio deve essere il suo unico parametro di input.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-391">For example, if an operation accepts a message contract type, the message contract must be its only input parameter.</span></span> <span data-ttu-id="6c8a6-392">L'operazione, inoltre, deve restituire un messaggio vuoto (il tipo restituito deve essere void) o un altro contratto di messaggio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-392">Furthermore, the operation must then either return an empty message (return type of void) or another message contract.</span></span> <span data-ttu-id="6c8a6-393">Queste restrizioni del modello di programmazione vengono descritte negli argomenti per ogni modello di programmazione specifico: [Using Message Contracts](using-message-contracts.md), [Using the Message Class](using-the-message-class.md)e [Large Data and Streaming](large-data-and-streaming.md).</span><span class="sxs-lookup"><span data-stu-id="6c8a6-393">These programming model restrictions are described in the topics for each specific programming model: [Using Message Contracts](using-message-contracts.md), [Using the Message Class](using-the-message-class.md), and [Large Data and Streaming](large-data-and-streaming.md).</span></span>  
  
## <a name="message-formatters"></a><span data-ttu-id="6c8a6-394">Formattatori dei messaggi</span><span class="sxs-lookup"><span data-stu-id="6c8a6-394">Message Formatters</span></span>  
 <span data-ttu-id="6c8a6-395">I modelli di programmazione descritti sopra sono supportati inserendo nel framework del servizio componenti denominati *formattatori dei messaggi* .</span><span class="sxs-lookup"><span data-stu-id="6c8a6-395">The programming models described above are supported by plugging in components called *message formatters* into the service framework.</span></span> <span data-ttu-id="6c8a6-396">I formattatori dei messaggi sono tipi che implementano l' <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> interfaccia o, o entrambi, per l'utilizzo rispettivamente nei client e nei client WCF del servizio.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-396">Message formatters are types that implement the <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> or <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> interface, or both, for use in clients and service WCF clients, respectively.</span></span>  
  
 <span data-ttu-id="6c8a6-397">I formattatori dei messaggi normalmente sono inseriti da comportamenti.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-397">Message formatters are normally plugged in by behaviors.</span></span> <span data-ttu-id="6c8a6-398"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> , ad esempio, inserisce il formattatore dei messaggi di contratto dati.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-398">For example, the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> plugs in the data contract message formatter.</span></span> <span data-ttu-id="6c8a6-399">Questa operazione viene eseguita sul lato servizio impostando <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> sul formattatore corretto nel metodo <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> oppure sul lato client impostando <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> sul formattatore corretto nel metodo <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> .</span><span class="sxs-lookup"><span data-stu-id="6c8a6-399">This is done on the service side by setting <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> method, or on the client side by setting <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> method.</span></span>  
  
 <span data-ttu-id="6c8a6-400">Nelle tabelle seguenti sono elencati i metodi che possono essere implementati da un formattatore dei messaggi.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-400">The following tables lists the methods that a message formatter may implement.</span></span>  
  
|<span data-ttu-id="6c8a6-401">Interfaccia</span><span class="sxs-lookup"><span data-stu-id="6c8a6-401">Interface</span></span>|<span data-ttu-id="6c8a6-402">Metodo</span><span class="sxs-lookup"><span data-stu-id="6c8a6-402">Method</span></span>|<span data-ttu-id="6c8a6-403">Azione</span><span class="sxs-lookup"><span data-stu-id="6c8a6-403">Action</span></span>|  
|---------------|------------|------------|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.DeserializeRequest%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="6c8a6-404">Converte un `Message` in ingresso in parametri dell'operazione</span><span class="sxs-lookup"><span data-stu-id="6c8a6-404">Converts an incoming `Message` to operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.SerializeReply%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%2CSystem.Object%29>|<span data-ttu-id="6c8a6-405">Crea un `Message` in uscita dal valore restituito/parametri out dell'operazione</span><span class="sxs-lookup"><span data-stu-id="6c8a6-405">Creates an outgoing `Message` from operation return value/out parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.SerializeRequest%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%29>|<span data-ttu-id="6c8a6-406">Crea un `Message` in uscita dai parametri dell'operazione</span><span class="sxs-lookup"><span data-stu-id="6c8a6-406">Creates an outgoing `Message` from operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.DeserializeReply%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="6c8a6-407">Converte un `Message` in ingresso in un valore restituito/parametri out</span><span class="sxs-lookup"><span data-stu-id="6c8a6-407">Converts an incoming `Message` to a return value/out parameters</span></span>|  
  
## <a name="serialization"></a><span data-ttu-id="6c8a6-408">Serializzazione</span><span class="sxs-lookup"><span data-stu-id="6c8a6-408">Serialization</span></span>  
 <span data-ttu-id="6c8a6-409">Quando si utilizzano i contratti di messaggio o i parametri per descrivere il contenuto del messaggio, è necessario utilizzare la serializzazione per eseguire la conversione tra i tipi .NET Framework e la rappresentazione XML Infoset.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-409">Whenever you use message contracts or parameters to describe message contents, you must use serialization to convert between .NET Framework types and XML Infoset representation.</span></span> <span data-ttu-id="6c8a6-410">La serializzazione è utilizzata in altre posizioni in WCF, ad esempio, <xref:System.ServiceModel.Channels.Message> dispone di un <xref:System.ServiceModel.Channels.Message.GetBody%2A> metodo generico che è possibile utilizzare per leggere l'intero corpo del messaggio deserializzato in un oggetto.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-410">Serialization is used in other places in WCF, for example, <xref:System.ServiceModel.Channels.Message> has a Generic <xref:System.ServiceModel.Channels.Message.GetBody%2A> method that you can use to read the entire body of the message deserialized into an object.</span></span>  
  
 <span data-ttu-id="6c8a6-411">WCF supporta due tecnologie di serializzazione "predefinite" per serializzare e deserializzare parametri e parti del messaggio: <xref:System.Runtime.Serialization.DataContractSerializer> e `XmlSerializer` .</span><span class="sxs-lookup"><span data-stu-id="6c8a6-411">WCF supports two serialization technologies "out of the box" for serializing and deserializing parameters and message parts: the <xref:System.Runtime.Serialization.DataContractSerializer> and the `XmlSerializer`.</span></span> <span data-ttu-id="6c8a6-412">È inoltre possibile scrivere serializzatori personalizzati.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-412">Additionally, you can write custom serializers.</span></span> <span data-ttu-id="6c8a6-413">Tuttavia, altre parti di WCF, ad esempio il `GetBody` metodo generico o la serializzazione di errori SOAP, possono essere limitate a usare solo le <xref:System.Runtime.Serialization.XmlObjectSerializer> sottoclassi ( <xref:System.Runtime.Serialization.DataContractSerializer> e <xref:System.Runtime.Serialization.NetDataContractSerializer> , ma non <xref:System.Xml.Serialization.XmlSerializer> ) oppure possono anche essere hardcoded per usare solo <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="6c8a6-413">However, other parts of WCF (such as the Generic `GetBody` method or SOAP fault serialization) may be restricted to use only the <xref:System.Runtime.Serialization.XmlObjectSerializer> subclasses (<xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>, but not the <xref:System.Xml.Serialization.XmlSerializer>), or may even be hard-coded to use only the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span>  
  
 <span data-ttu-id="6c8a6-414">`XmlSerializer`È il motore di serializzazione utilizzato nei servizi Web ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-414">The `XmlSerializer` is the serialization engine used in ASP.NET Web services.</span></span> <span data-ttu-id="6c8a6-415">`DataContractSerializer` è il nuovo motore di serializzazione che riconosce il nuovo modello di programmazione del contratto dati.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-415">The `DataContractSerializer` is the new serialization engine that understands the new data contract programming model.</span></span> <span data-ttu-id="6c8a6-416">`DataContractSerializer` è la scelta predefinita e la scelta di utilizzare `XmlSerializer` può essere fatta in base a ogni singola operazione utilizzando l'attributo <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> .</span><span class="sxs-lookup"><span data-stu-id="6c8a6-416">`DataContractSerializer` is the default choice, and the choice to use the `XmlSerializer` can be made on a per-operation basis using the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> attribute.</span></span>  
  
 <span data-ttu-id="6c8a6-417"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> e <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> sono i comportamenti dell'operazione responsabili del collegamento dei formattatori dei messaggi rispettivamente per `DataContractSerializer` e `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-417"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> and <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> are the operation behaviors responsible for plugging in the message formatters for the `DataContractSerializer` and the `XmlSerializer`, respectively.</span></span> <span data-ttu-id="6c8a6-418">Il comportamento <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> può di fatto operare con qualsiasi serializzatore che deriva da <xref:System.Runtime.Serialization.XmlObjectSerializer>, compreso <xref:System.Runtime.Serialization.NetDataContractSerializer> (descritto in dettaglio nella sezione sull'utilizzo della serializzazione autonoma).</span><span class="sxs-lookup"><span data-stu-id="6c8a6-418">The <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> behavior can actually operate with any serializer that derives from <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.NetDataContractSerializer> (described in detail in Using Stand-Alone Serialization).</span></span> <span data-ttu-id="6c8a6-419">Il comportamento chiama uno degli overload del metodo virtuale `CreateSerializer` per ottenere il serializzatore.</span><span class="sxs-lookup"><span data-stu-id="6c8a6-419">The behavior calls one of the `CreateSerializer` virtual method overloads to obtain the serializer.</span></span> <span data-ttu-id="6c8a6-420">Per collegare un serializzatore diverso, creare una nuova sottoclasse <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> ed eseguire l'override di entrambi gli overload `CreateSerializer` .</span><span class="sxs-lookup"><span data-stu-id="6c8a6-420">To plug in a different serializer, create a new <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> subclass and override both `CreateSerializer` overloads.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6c8a6-421">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="6c8a6-421">See also</span></span>

- [<span data-ttu-id="6c8a6-422">Specifying Data Transfer in Service Contracts</span><span class="sxs-lookup"><span data-stu-id="6c8a6-422">Specifying Data Transfer in Service Contracts</span></span>](specifying-data-transfer-in-service-contracts.md)
