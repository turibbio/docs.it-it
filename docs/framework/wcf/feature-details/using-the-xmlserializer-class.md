---
title: Utilizzo della classe XmlSerializer
description: Informazioni su XmlSerializer, utilizzato da WCF per serializzare i dati dell'applicazione in XML trasmessi tra client e servizi.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- XmlSerializer [WCF], using
ms.assetid: c680602d-39d3-44f1-bf22-8e6654ad5069
ms.openlocfilehash: f7473de3f34ba543b4fabfe93167ea267f16dda5
ms.sourcegitcommit: 358a28048f36a8dca39a9fe6e6ac1f1913acadd5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/23/2020
ms.locfileid: "85246382"
---
# <a name="using-the-xmlserializer-class"></a><span data-ttu-id="91894-103">Utilizzo della classe XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="91894-103">Using the XmlSerializer Class</span></span>

<span data-ttu-id="91894-104">Windows Communication Foundation (WCF) può utilizzare due diverse tecnologie di serializzazione per trasformare i dati nell'applicazione in XML trasmessi tra client e servizi, un processo denominato serializzazione.</span><span class="sxs-lookup"><span data-stu-id="91894-104">Windows Communication Foundation (WCF) can use two different serialization technologies to turn the data in your application into XML that is transmitted between clients and services, a process called serialization.</span></span>

## <a name="datacontractserializer-as-the-default"></a><span data-ttu-id="91894-105">DataContractSerializer come impostazione predefinita</span><span class="sxs-lookup"><span data-stu-id="91894-105">DataContractSerializer as the Default</span></span>

<span data-ttu-id="91894-106">Per impostazione predefinita, WCF usa la <xref:System.Runtime.Serialization.DataContractSerializer> classe per serializzare i tipi di dati.</span><span class="sxs-lookup"><span data-stu-id="91894-106">By default WCF uses the <xref:System.Runtime.Serialization.DataContractSerializer> class to serialize data types.</span></span> <span data-ttu-id="91894-107">Questo serializzatore supporta i tipi seguenti:</span><span class="sxs-lookup"><span data-stu-id="91894-107">This serializer supports the following types:</span></span>

- <span data-ttu-id="91894-108">Tipi primitivi (ad esempio, integer, stringhe e matrici di byte), nonché alcuni tipi speciali, ad esempio <xref:System.Xml.XmlElement> e <xref:System.DateTime>, che vengono trattati come primitivi.</span><span class="sxs-lookup"><span data-stu-id="91894-108">Primitive types (for example, integers, strings, and byte arrays), as well as some special types, such as <xref:System.Xml.XmlElement> and <xref:System.DateTime>, which are treated as primitives.</span></span>

- <span data-ttu-id="91894-109">Tipi di contratti dati (tipi contrassegnati con l'attributo <xref:System.Runtime.Serialization.DataContractAttribute>).</span><span class="sxs-lookup"><span data-stu-id="91894-109">Data contract types (types marked with the <xref:System.Runtime.Serialization.DataContractAttribute> attribute).</span></span>

- <span data-ttu-id="91894-110">Tipi contrassegnati con l'attributo <xref:System.SerializableAttribute>, inclusi i tipi che implementano l'interfaccia <xref:System.Runtime.Serialization.ISerializable>.</span><span class="sxs-lookup"><span data-stu-id="91894-110">Types marked with the <xref:System.SerializableAttribute> attribute, which include types that implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span>

- <span data-ttu-id="91894-111">Tipi che implementano l'interfaccia <xref:System.Xml.Serialization.IXmlSerializable>.</span><span class="sxs-lookup"><span data-stu-id="91894-111">Types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>

- <span data-ttu-id="91894-112">Molti tipi di raccolte comuni, inclusi molti tipi di raccolte generiche.</span><span class="sxs-lookup"><span data-stu-id="91894-112">Many common collection types, which include many generic collection types.</span></span>

<span data-ttu-id="91894-113">Molti .NET Framework tipi rientrano nelle ultime due categorie e sono quindi serializzabili.</span><span class="sxs-lookup"><span data-stu-id="91894-113">Many .NET Framework types fall into the latter two categories and are thus serializable.</span></span> <span data-ttu-id="91894-114">Anche le matrici di tipi serializzabili sono serializzabili.</span><span class="sxs-lookup"><span data-stu-id="91894-114">Arrays of serializable types are also serializable.</span></span> <span data-ttu-id="91894-115">Per un elenco completo, vedere [specifica trasferimento dati nei contratti di servizio](specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="91894-115">For a complete list, see [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span>

<span data-ttu-id="91894-116"><xref:System.Runtime.Serialization.DataContractSerializer>, Utilizzato insieme ai tipi di contratto dati, è il metodo consigliato per la scrittura di nuovi servizi WCF.</span><span class="sxs-lookup"><span data-stu-id="91894-116">The <xref:System.Runtime.Serialization.DataContractSerializer>, used together with data contract types, is the recommended way to write new WCF services.</span></span> <span data-ttu-id="91894-117">Per ulteriori informazioni, vedere [utilizzo di contratti dati](using-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="91894-117">For more information, see [Using Data Contracts](using-data-contracts.md).</span></span>

## <a name="when-to-use-the-xmlserializer-class"></a><span data-ttu-id="91894-118">Quando usare la classe XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="91894-118">When to Use the XmlSerializer Class</span></span>

<span data-ttu-id="91894-119">WCF supporta inoltre la <xref:System.Xml.Serialization.XmlSerializer> classe.</span><span class="sxs-lookup"><span data-stu-id="91894-119">WCF also supports the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="91894-120">La <xref:System.Xml.Serialization.XmlSerializer> classe non è univoca per WCF.</span><span class="sxs-lookup"><span data-stu-id="91894-120">The <xref:System.Xml.Serialization.XmlSerializer> class is not unique to WCF.</span></span> <span data-ttu-id="91894-121">Si tratta dello stesso motore di serializzazione utilizzato dai servizi Web ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="91894-121">It is the same serialization engine that ASP.NET Web services use.</span></span> <span data-ttu-id="91894-122">La classe <xref:System.Xml.Serialization.XmlSerializer> supporta un set di tipi molto più ristretto rispetto alla classe <xref:System.Runtime.Serialization.DataContractSerializer>, ma garantisce un controllo maggiore sul contenuto XML risultante e un supporto maggiore dello standard XSD (XML Schema Definition Language).</span><span class="sxs-lookup"><span data-stu-id="91894-122">The <xref:System.Xml.Serialization.XmlSerializer> class supports a much narrower set of types than the <xref:System.Runtime.Serialization.DataContractSerializer> class, but allows much more control over the resulting XML and supports much more of the XML Schema definition language (XSD) standard.</span></span> <span data-ttu-id="91894-123">Inoltre, non richiede attributi dichiarativi sui tipi serializzabili.</span><span class="sxs-lookup"><span data-stu-id="91894-123">It also does not require any declarative attributes on the serializable types.</span></span> <span data-ttu-id="91894-124">Per ulteriori informazioni, vedere l'argomento relativo alla serializzazione XML nella documentazione di .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="91894-124">For more information, see the XML Serialization topic in the .NET Framework documentation.</span></span> <span data-ttu-id="91894-125">La classe <xref:System.Xml.Serialization.XmlSerializer> non supporta i tipi di contratto dati.</span><span class="sxs-lookup"><span data-stu-id="91894-125">The <xref:System.Xml.Serialization.XmlSerializer> class does not support data contract types.</span></span>

<span data-ttu-id="91894-126">Quando si usa Svcutil.exe o la funzionalità **Aggiungi riferimento al servizio** in Visual Studio per generare il codice client per un servizio di terze parti o per accedere a uno schema di terze parti, viene selezionato automaticamente un serializzatore appropriato.</span><span class="sxs-lookup"><span data-stu-id="91894-126">When using Svcutil.exe or the **Add Service Reference** feature in Visual Studio to generate client code for a third-party service, or to access a third-party schema, an appropriate serializer is automatically selected for you.</span></span> <span data-ttu-id="91894-127">Se lo schema non è compatibile con <xref:System.Runtime.Serialization.DataContractSerializer>, viene selezionato <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="91894-127">If the schema is not compatible with the <xref:System.Runtime.Serialization.DataContractSerializer>, the <xref:System.Xml.Serialization.XmlSerializer> is selected.</span></span>

## <a name="manually-switching-to-the-xmlserializer"></a><span data-ttu-id="91894-128">Passaggio manuale a XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="91894-128">Manually Switching to the XmlSerializer</span></span>

<span data-ttu-id="91894-129">In alcuni casi può essere necessario passare manualmente a <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="91894-129">At times, you may have to manually switch to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="91894-130">Ciò si verifica, ad esempio, nei casi seguenti:</span><span class="sxs-lookup"><span data-stu-id="91894-130">This happens, for example, in the following cases:</span></span>

- <span data-ttu-id="91894-131">Quando si esegue la migrazione di un'applicazione da servizi Web ASP.NET a WCF, potrebbe essere necessario riutilizzare i <xref:System.Xml.Serialization.XmlSerializer> tipi compatibili con esistenti anziché creare nuovi tipi di contratto dati.</span><span class="sxs-lookup"><span data-stu-id="91894-131">When migrating an application from ASP.NET Web services to WCF, you may want to reuse existing, <xref:System.Xml.Serialization.XmlSerializer>-compatible types instead of creating new data contract types.</span></span>

- <span data-ttu-id="91894-132">Se è importante controllare in modo accurato il contenuto XML presente nei messaggi ma non è disponibile un documento WSDL (Web Services Description Language), ad esempio, quando si crea un servizio con tipi che devono conformarsi a uno specifico schema standardizzato pubblicato che non è compatibile con DataContractSerializer.</span><span class="sxs-lookup"><span data-stu-id="91894-132">When precise control over the XML that appears in messages is important, but a Web Services Description Language (WSDL) document is not available, for example, when creating a service with types that have to comply to a certain standardized, published schema that is not compatible with the DataContractSerializer.</span></span>

- <span data-ttu-id="91894-133">Quando si creano servizi che seguono lo standard della codifica SOAP legacy.</span><span class="sxs-lookup"><span data-stu-id="91894-133">When creating services that follow the legacy SOAP Encoding standard.</span></span>

<span data-ttu-id="91894-134">In questi e altri casi è possibile passare manualmente alla classe <xref:System.Xml.Serialization.XmlSerializer> applicando l'attributo `XmlSerializerFormatAttribute` al servizio, come illustrato nel codice seguente.</span><span class="sxs-lookup"><span data-stu-id="91894-134">In these and other cases, you can manually switch to the <xref:System.Xml.Serialization.XmlSerializer> class by applying the `XmlSerializerFormatAttribute` attribute to your service, as shown in the following code.</span></span>

[!code-csharp[c_XmlSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#1)]
[!code-vb[c_XmlSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#1)]

## <a name="security-considerations"></a><span data-ttu-id="91894-135">Considerazioni relative alla sicurezza</span><span class="sxs-lookup"><span data-stu-id="91894-135">Security Considerations</span></span>

> [!NOTE]
> <span data-ttu-id="91894-136">È importante fare attenzione quando si passa ai motori di serializzazione.</span><span class="sxs-lookup"><span data-stu-id="91894-136">It is important to be careful when switching serialization engines.</span></span> <span data-ttu-id="91894-137">Lo stesso tipo può essere serializzato in XML in modo diverso a seconda del serializzatore usato.</span><span class="sxs-lookup"><span data-stu-id="91894-137">The same type can serialize to XML differently depending on the serializer being used.</span></span> <span data-ttu-id="91894-138">Se si usa accidentalmente il serializzatore sbagliato, potrebbero essere diffuse informazioni dal tipo che non si aveva intenzione di diffondere.</span><span class="sxs-lookup"><span data-stu-id="91894-138">If you accidentally use the wrong serializer, you might be disclosing information from the type that you did not intend to disclose.</span></span>

<span data-ttu-id="91894-139">Ad esempio, la classe <xref:System.Runtime.Serialization.DataContractSerializer> serializza solo membri contrassegnati con l'attributo <xref:System.Runtime.Serialization.DataMemberAttribute> quando si serializzano tipi di contratto dati.</span><span class="sxs-lookup"><span data-stu-id="91894-139">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> class only serializes members marked with the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute when serializing data contract types.</span></span> <span data-ttu-id="91894-140">La classe <xref:System.Xml.Serialization.XmlSerializer> serializza qualsiasi membro pubblico.</span><span class="sxs-lookup"><span data-stu-id="91894-140">The <xref:System.Xml.Serialization.XmlSerializer> class serializes any public member.</span></span> <span data-ttu-id="91894-141">Vedere il tipo nel codice seguente.</span><span class="sxs-lookup"><span data-stu-id="91894-141">See the type in the following code.</span></span>

[!code-csharp[c_XmlSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#2)]
[!code-vb[c_XmlSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#2)]

<span data-ttu-id="91894-142">Se il tipo viene usato inavvertitamente in un contratto di servizio in cui è selezionata la classe <xref:System.Xml.Serialization.XmlSerializer>, il membro `creditCardNumber` viene serializzato, operazione probabilmente non voluta.</span><span class="sxs-lookup"><span data-stu-id="91894-142">If the type is inadvertently used in a service contract where the <xref:System.Xml.Serialization.XmlSerializer> class is selected, the `creditCardNumber` member is serialized, which is probably not intended.</span></span>

<span data-ttu-id="91894-143">Anche se la classe <xref:System.Runtime.Serialization.DataContractSerializer> è l'impostazione predefinita, è possibile selezionarla in modo esplicito per il servizio (anche se questa operazione non è richiesta) applicando l'attributo <xref:System.ServiceModel.DataContractFormatAttribute> al tipo di contratto di servizio.</span><span class="sxs-lookup"><span data-stu-id="91894-143">Even though the <xref:System.Runtime.Serialization.DataContractSerializer> class is the default, you can explicitly select it for your service (although doing this should never be required) by applying the <xref:System.ServiceModel.DataContractFormatAttribute> attribute to the service contract type.</span></span>

<span data-ttu-id="91894-144">Il serializzatore usato per il servizio è parte integrante del contratto e non può essere modificato selezionando un'associazione diversa o modificando le altre impostazioni di configurazione.</span><span class="sxs-lookup"><span data-stu-id="91894-144">The serializer used for the service is an integral part of the contract and cannot be changed by selecting a different binding or by changing other configuration settings.</span></span>

<span data-ttu-id="91894-145">Altre importanti considerazioni di sicurezza riguardano la classe <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="91894-145">Other important security considerations apply to the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="91894-146">In primo luogo, è consigliabile che qualsiasi applicazione WCF che utilizza la <xref:System.Xml.Serialization.XmlSerializer> classe venga firmata con una chiave protetta dalla divulgazione.</span><span class="sxs-lookup"><span data-stu-id="91894-146">First, it is strongly recommended that any WCF application that uses the <xref:System.Xml.Serialization.XmlSerializer> class is signed with a key that is safeguarded from disclosure.</span></span> <span data-ttu-id="91894-147">Questa indicazione è valida sia quando si esegue un passaggio manuale a <xref:System.Xml.Serialization.XmlSerializer> che quando si esegue un passaggio automatico (mediante Svcutil.exe, Aggiungi riferimento al servizio o uno strumento simile).</span><span class="sxs-lookup"><span data-stu-id="91894-147">This recommendation applies both when a manual switch to the <xref:System.Xml.Serialization.XmlSerializer> is performed and when an automatic switch is performed (by Svcutil.exe, Add Service Reference, or a similar tool).</span></span> <span data-ttu-id="91894-148">Questo perché il <xref:System.Xml.Serialization.XmlSerializer> motore di serializzazione supporta il caricamento di *assembly di serializzazione pregenerati* , purché siano firmati con la stessa chiave dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="91894-148">This is because the <xref:System.Xml.Serialization.XmlSerializer> serialization engine supports the loading of *pre-generated serialization assemblies* as long as they are signed with the same key as the application.</span></span> <span data-ttu-id="91894-149">Un'applicazione non firmata è priva di qualsiasi protezione rispetto alla possibilità che un assembly dannoso corrispondente al nome previsto dell'assembly di serializzazione pregenerato venga posizionato nella cartella dell'applicazione o nella Global Assembly Cache.</span><span class="sxs-lookup"><span data-stu-id="91894-149">An unsigned application is completely unprotected from the possibility of a malicious assembly matching the expected name of the pre-generated serialization assembly being placed in the application folder or the global assembly cache.</span></span> <span data-ttu-id="91894-150">L'autore di un attacco dovrà comunque ottenere l'accesso in scrittura a uno di questi due percorsi prima di tentare questa azione.</span><span class="sxs-lookup"><span data-stu-id="91894-150">Of course, an attacker must first gain write access to one of these two locations to attempt this action.</span></span>

<span data-ttu-id="91894-151">Un'altra minaccia che esiste quando si usa <xref:System.Xml.Serialization.XmlSerializer> riguarda l'accesso in scrittura alla cartella temporanea del sistema.</span><span class="sxs-lookup"><span data-stu-id="91894-151">Another threat that exists whenever you use <xref:System.Xml.Serialization.XmlSerializer> is related to write access to the system temporary folder.</span></span> <span data-ttu-id="91894-152">Il <xref:System.Xml.Serialization.XmlSerializer> motore di serializzazione crea e USA *assembly di serializzazione* temporanei in questa cartella.</span><span class="sxs-lookup"><span data-stu-id="91894-152">The <xref:System.Xml.Serialization.XmlSerializer> serialization engine creates and uses temporary *serialization assemblies* in this folder.</span></span> <span data-ttu-id="91894-153">È quindi necessario tenere presente che qualsiasi processo con accesso in scrittura alla cartella temporanea può sovrascrivere questi assembly di serializzazione con codice dannoso.</span><span class="sxs-lookup"><span data-stu-id="91894-153">You should be aware that any process with write access to the temporary folder may overwrite these serialization assemblies with malicious code.</span></span>

## <a name="rules-for-xmlserializer-support"></a><span data-ttu-id="91894-154">Regole per il supporto di XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="91894-154">Rules for XmlSerializer support</span></span>

<span data-ttu-id="91894-155">Non è possibile applicare direttamente attributi compatibili con <xref:System.Xml.Serialization.XmlSerializer> ai parametri o ai valori restituiti dell'operazione del contratto.</span><span class="sxs-lookup"><span data-stu-id="91894-155">You cannot directly apply <xref:System.Xml.Serialization.XmlSerializer>-compatible attributes to contract operation parameters or return values.</span></span> <span data-ttu-id="91894-156">Tali attributi possono tuttavia essere applicati ai messaggi tipizzati (parti del corpo del contratto di messaggio), come illustrato nel codice seguente.</span><span class="sxs-lookup"><span data-stu-id="91894-156">However, they can be applied to typed messages (message contract body parts), as shown in the following code.</span></span>

[!code-csharp[c_XmlSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#3)]
[!code-vb[c_XmlSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#3)]

<span data-ttu-id="91894-157">Se applicati ai membri del messaggio tipizzato, questi attributi eseguono l'override delle proprietà in conflitto negli attributi del messaggio tipizzato.</span><span class="sxs-lookup"><span data-stu-id="91894-157">When applied to typed message members, these attributes override properties that conflict on the typed message attributes.</span></span> <span data-ttu-id="91894-158">Ad esempio, nel codice seguente `ElementName` esegue l'override di `Name`.</span><span class="sxs-lookup"><span data-stu-id="91894-158">For example, in the following code, `ElementName` overrides `Name`.</span></span>

[!code-csharp[c_XmlSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#4)]
[!code-vb[c_XmlSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#4)]

<span data-ttu-id="91894-159">L'attributo <xref:System.ServiceModel.MessageHeaderArrayAttribute> non è supportato quando si usa <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="91894-159">The <xref:System.ServiceModel.MessageHeaderArrayAttribute> attribute is not supported when using the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>

> [!NOTE]
> <span data-ttu-id="91894-160">In questo caso, <xref:System.Xml.Serialization.XmlSerializer> genera la seguente eccezione, che viene rilasciata prima di WCF: "un elemento dichiarato al livello principale di uno schema non può avere `maxOccurs` > 1.</span><span class="sxs-lookup"><span data-stu-id="91894-160">In this case, the <xref:System.Xml.Serialization.XmlSerializer> throws the following exception, which is released prior to WCF: "An element declared at the top level of a schema cannot have `maxOccurs` > 1.</span></span> <span data-ttu-id="91894-161">Fornire un elemento wrapper per "more" usando `XmlArray` o `XmlArrayItem` anziché `XmlElementAttribute`, oppure usando lo stile di parametro Wrapped".</span><span class="sxs-lookup"><span data-stu-id="91894-161">Provide a wrapper element for 'more' by using `XmlArray` or `XmlArrayItem` instead of `XmlElementAttribute`, or by using the Wrapped parameter style."</span></span>
>
> <span data-ttu-id="91894-162">Se si riceve tale eccezione, verificare se questa situazione è applicabile.</span><span class="sxs-lookup"><span data-stu-id="91894-162">If you receive such an exception, investigate whether this situation applies.</span></span>

<span data-ttu-id="91894-163">WCF non supporta gli <xref:System.Xml.Serialization.SoapIncludeAttribute> attributi e <xref:System.Xml.Serialization.XmlIncludeAttribute> nei contratti di messaggio e nei contratti di operazione <xref:System.Runtime.Serialization.KnownTypeAttribute> . utilizzare invece l'attributo.</span><span class="sxs-lookup"><span data-stu-id="91894-163">WCF does not support the <xref:System.Xml.Serialization.SoapIncludeAttribute> and <xref:System.Xml.Serialization.XmlIncludeAttribute> attributes in message contracts and operation contracts; use the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute instead.</span></span>

## <a name="types-that-implement-the-ixmlserializable-interface"></a><span data-ttu-id="91894-164">Tipi che implementano l'interfaccia IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="91894-164">Types that Implement the IXmlSerializable Interface</span></span>

<span data-ttu-id="91894-165">I tipi che implementano l'interfaccia `IXmlSerializable` sono completamente supportati da `DataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="91894-165">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="91894-166">L'attributo <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> deve essere applicato sempre a questi tipi per controllarne lo schema.</span><span class="sxs-lookup"><span data-stu-id="91894-166">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>

> [!WARNING]
> <span data-ttu-id="91894-167">Se si serializzano dei tipi polimorfici è necessario applicare a tali tipi l'attributo <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> per assicurare che venga serializzato il tipo corretto.</span><span class="sxs-lookup"><span data-stu-id="91894-167">If you are serializing polymorphic types you must apply the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> to the type to ensure the correct type is serialized.</span></span>

<span data-ttu-id="91894-168">Esistono tre varietà di tipi che implementano `IXmlSerializable`: i tipi che rappresentano contenuto arbitrario, i tipi che rappresentano un singolo elemento e i tipi <xref:System.Data.DataSet> legacy.</span><span class="sxs-lookup"><span data-stu-id="91894-168">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>

- <span data-ttu-id="91894-169">I tipi di contenuto usano un metodo del provider dello schema specificato dall'attributo `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="91894-169">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="91894-170">Il metodo non restituisce `null` e la proprietà <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> dell'attributo mantiene il valore predefinito `false`.</span><span class="sxs-lookup"><span data-stu-id="91894-170">The method does not return `null` and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="91894-171">Si tratta dell'utilizzo più comune di tipi `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="91894-171">This is the most common usage of `IXmlSerializable` types.</span></span>

- <span data-ttu-id="91894-172">I tipi di elemento vengono usati quando un tipo `IXmlSerializable` deve controllare il nome del relativo elemento radice.</span><span class="sxs-lookup"><span data-stu-id="91894-172">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="91894-173">Per contrassegnare un tipo come tipo di elemento, impostare la proprietà <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> dell'attributo <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> su `true` o fare in modo che il metodo del provider dello schema restituisca `null`.</span><span class="sxs-lookup"><span data-stu-id="91894-173">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return `null` from the schema provider method.</span></span> <span data-ttu-id="91894-174">Il metodo del provider dello schema è facoltativo per i tipi di elemento; è infatti possibile specificare `null` anziché il nome del metodo in `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="91894-174">Having a schema provider method is optional for element types – you may specify `null` instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="91894-175">Tuttavia, se `IsAny` è `true` ed è specificato un metodo del provider dello schema, il metodo deve restituire `null`.</span><span class="sxs-lookup"><span data-stu-id="91894-175">However, if `IsAny` is `true` and a schema provider method is specified, the method must return `null`.</span></span>

- <span data-ttu-id="91894-176">I tipi <xref:System.Data.DataSet> legacy sono tipi `IXmlSerializable` non contrassegnati con l'attributo `XmlSchemaProviderAttribute`,</span><span class="sxs-lookup"><span data-stu-id="91894-176">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="91894-177">che si basano sul metodo <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> per la generazione dello schema.</span><span class="sxs-lookup"><span data-stu-id="91894-177">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="91894-178">Questo modello è usato per il tipo `DataSet` e le relative classi derivate del dataset tipizzato nelle versioni precedenti di .NET Framework, ma ora è obsoleto ed è supportato solo per elementi legacy.</span><span class="sxs-lookup"><span data-stu-id="91894-178">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="91894-179">Non è consigliabile basarsi su questo modello, bensì applicare sempre `XmlSchemaProviderAttribute` ai tipi `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="91894-179">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>

### <a name="ixmlserializable-content-types"></a><span data-ttu-id="91894-180">Tipi di contenuto IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="91894-180">IXmlSerializable Content Types</span></span>

<span data-ttu-id="91894-181">Quando si serializza un membro dati di un tipo che implementa `IXmlSerializable` e il tipo di contenuto rispecchia la definizione precedente, il serializzatore scrive l'elemento wrapper per il membro dati e passa il controllo al metodo <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A>.</span><span class="sxs-lookup"><span data-stu-id="91894-181">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="91894-182">L'implementazione <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> può scrivere qualsiasi elemento XML e può anche aggiungere attributi all'elemento wrapper.</span><span class="sxs-lookup"><span data-stu-id="91894-182">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, which includes adding attributes to the wrapper element.</span></span> <span data-ttu-id="91894-183">Quando l'operazione `WriteXml` è stata completata, il serializzatore chiude l'elemento.</span><span class="sxs-lookup"><span data-stu-id="91894-183">After `WriteXml` is done, the serializer closes the element.</span></span>

<span data-ttu-id="91894-184">Quando si deserializza un membro dati di un tipo che implementa `IXmlSerializable` e il tipo di contenuto rispecchia la definizione precedente, il deserializzatore posiziona il lettore XML sull'elemento wrapper per il membro dati e passa il controllo al metodo <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A>.</span><span class="sxs-lookup"><span data-stu-id="91894-184">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="91894-185">Il metodo deve leggere l'elemento intero, inclusi i tag di inizio e fine.</span><span class="sxs-lookup"><span data-stu-id="91894-185">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="91894-186">Verificare che il codice `ReadXml` gestisca l'eventualità che l'elemento sia vuoto.</span><span class="sxs-lookup"><span data-stu-id="91894-186">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="91894-187">Inoltre, l'implementazione `ReadXml` non deve basarsi sull'uso di un nome specifico per l'elemento wrapper,</span><span class="sxs-lookup"><span data-stu-id="91894-187">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="91894-188">poiché il nome viene scelto dal serializzatore e quindi può variare.</span><span class="sxs-lookup"><span data-stu-id="91894-188">The name is chosen by the serializer can vary.</span></span>

<span data-ttu-id="91894-189">È consentito assegnare tipi di contenuto `IXmlSerializable` in modo polimorfico, ad esempio, ai membri dati di tipo <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="91894-189">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="91894-190">È inoltre consentito che le istanze del tipo siano Null.</span><span class="sxs-lookup"><span data-stu-id="91894-190">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="91894-191">Infine, è possibile usare tipi `IXmlSerializable` con il mantenimento dell'oggetto grafico abilitato e con <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="91894-191">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="91894-192">Per tutte queste funzionalità è necessario che il serializzatore WCF alleghi determinati attributi nell'elemento wrapper ("nil" e "Type" nello spazio dei nomi dell'istanza di XML Schema e "ID", "ref", "Type" e "assembly" in uno spazio dei nomi specifico di WCF).</span><span class="sxs-lookup"><span data-stu-id="91894-192">All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</span></span>

#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="91894-193">Attributi da ignorare quando si implementa ReadXml</span><span class="sxs-lookup"><span data-stu-id="91894-193">Attributes to Ignore when Implementing ReadXml</span></span>

<span data-ttu-id="91894-194">Prima di passare il controllo al codice `ReadXml`, il deserializzatore esamina l'elemento XML, rileva questi attributi XML speciali e interviene su di essi.</span><span class="sxs-lookup"><span data-stu-id="91894-194">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="91894-195">Ad esempio, se "nil" è `true`, un valore Null viene deserializzato e `ReadXml` non viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="91894-195">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="91894-196">Se viene rilevato il polimorfismo, il contenuto dell'elemento viene deserializzato come se si trattasse di un tipo diverso.</span><span class="sxs-lookup"><span data-stu-id="91894-196">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="91894-197">L'implementazione di `ReadXml` del tipo assegnato in modo polimorfico viene chiamata.</span><span class="sxs-lookup"><span data-stu-id="91894-197">The polymorphically-assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="91894-198">In ogni caso, un'implementazione `ReadXml` deve ignorare questi attributi speciali poiché vengono gestiti dal deserializzatore.</span><span class="sxs-lookup"><span data-stu-id="91894-198">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>

### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="91894-199">Considerazioni sullo schema per i tipi di contenuto IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="91894-199">Schema Considerations for IXmlSerializable Content Types</span></span>

<span data-ttu-id="91894-200">Se si esporta lo schema e un tipo di contenuto `IXmlSerializable`, viene chiamato il metodo del provider dello schema.</span><span class="sxs-lookup"><span data-stu-id="91894-200">When exporting schema and an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="91894-201">Al metodo del provider dello schema viene passata una classe <xref:System.Xml.Schema.XmlSchemaSet>.</span><span class="sxs-lookup"><span data-stu-id="91894-201">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="91894-202">Il metodo può aggiungere qualsiasi schema valido al set di schemi.</span><span class="sxs-lookup"><span data-stu-id="91894-202">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="91894-203">Il set di schemi contiene lo schema già conosciuto al momento dell'esportazione dello schema.</span><span class="sxs-lookup"><span data-stu-id="91894-203">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="91894-204">Quando il metodo del provider dello schema deve aggiungere un elemento al set di schemi, deve determinare se esiste una classe <xref:System.Xml.Schema.XmlSchema> con lo spazio dei nomi appropriato nel set.</span><span class="sxs-lookup"><span data-stu-id="91894-204">When the schema provider method must add an item to the schema set, it must determine whether an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="91894-205">In tal caso, il metodo del provider dello schema deve aggiungere il nuovo elemento alla classe `XmlSchema` esistente.</span><span class="sxs-lookup"><span data-stu-id="91894-205">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="91894-206">In caso contrario, deve creare una nuova istanza di `XmlSchema`.</span><span class="sxs-lookup"><span data-stu-id="91894-206">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="91894-207">Questo è importante se vengono usate matrici di tipi `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="91894-207">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="91894-208">Ad esempio, se un tipo `IXmlSerializable` viene esportato come tipo "A" nello spazio dei nomi "B", è possibile che quando il metodo del provider dello schema viene chiamato il set di schemi contenga già lo schema per "B" che contiene il tipo "ArrayOfA".</span><span class="sxs-lookup"><span data-stu-id="91894-208">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>

<span data-ttu-id="91894-209">Oltre ad aggiungere i tipi nella classe <xref:System.Xml.Schema.XmlSchemaSet>, il metodo del provider dello schema per i tipi di contenuto deve restituire un valore diverso da Null.</span><span class="sxs-lookup"><span data-stu-id="91894-209">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="91894-210">Può restituire un oggetto <xref:System.Xml.XmlQualifiedName> che specifica il nome del tipo di schema da usare per il tipo `IXmlSerializable` specificato.</span><span class="sxs-lookup"><span data-stu-id="91894-210">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="91894-211">Questo nome completo serve anche come nome e spazio dei nomi del contratto dati per il tipo.</span><span class="sxs-lookup"><span data-stu-id="91894-211">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="91894-212">È consentito restituire un tipo che non esiste nel set di schemi quando il metodo del provider di schema viene restituito.</span><span class="sxs-lookup"><span data-stu-id="91894-212">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="91894-213">Tuttavia, in genere al momento dell'esportazione di tutti i tipi correlati (il metodo <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> viene chiamato per tutti i tipi attinenti su <xref:System.Runtime.Serialization.XsdDataContractExporter> e si accede alla proprietà <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A>) il tipo esiste già nel set di schemi.</span><span class="sxs-lookup"><span data-stu-id="91894-213">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="91894-214">L'accesso alla proprietà `Schemas` prima che tutte le chiamate `Export` attinenti siano state effettuate può generare un'eccezione <xref:System.Xml.Schema.XmlSchemaException>.</span><span class="sxs-lookup"><span data-stu-id="91894-214">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> <span data-ttu-id="91894-215">Per ulteriori informazioni sul processo di esportazione, vedere [esportazione di schemi dalle classi](exporting-schemas-from-classes.md).</span><span class="sxs-lookup"><span data-stu-id="91894-215">For more information about the export process, see [Exporting Schemas from Classes](exporting-schemas-from-classes.md).</span></span>

<span data-ttu-id="91894-216">Il metodo del provider dello schema può restituire anche l'oggetto <xref:System.Xml.Schema.XmlSchemaType> da usare.</span><span class="sxs-lookup"><span data-stu-id="91894-216">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="91894-217">Il tipo può o meno essere anonimo.</span><span class="sxs-lookup"><span data-stu-id="91894-217">The type may or may not be anonymous.</span></span> <span data-ttu-id="91894-218">Se è anonimo, lo schema per il tipo `IXmlSerializable` viene esportato come tipo anonimo ogni volta che il tipo `IXmlSerializable` viene usato come membro dati.</span><span class="sxs-lookup"><span data-stu-id="91894-218">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="91894-219">Il tipo `IXmlSerializable` ha ancora un nome e uno spazio dei nomi del contratto dati</span><span class="sxs-lookup"><span data-stu-id="91894-219">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="91894-220">Questa operazione viene determinata come descritto nei [nomi dei contratti dati](data-contract-names.md) , ad eccezione del fatto che l' <xref:System.Runtime.Serialization.DataContractAttribute> attributo non può essere utilizzato per personalizzare il nome. Se non è anonimo, deve essere uno dei tipi in `XmlSchemaSet` .</span><span class="sxs-lookup"><span data-stu-id="91894-220">(This is determined as described in [Data Contract Names](data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="91894-221">Questo caso è equivalente alla restituzione del `XmlQualifiedName` del tipo.</span><span class="sxs-lookup"><span data-stu-id="91894-221">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>

<span data-ttu-id="91894-222">Inoltre, viene esportata una dichiarazione di elemento globale per il tipo.</span><span class="sxs-lookup"><span data-stu-id="91894-222">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="91894-223">Se al tipo non è applicato l'attributo <xref:System.Xml.Serialization.XmlRootAttribute>, l'elemento ha lo stesso nome e spazio dei nomi del contratto dati e la proprietà "nillable" sarà `true`.</span><span class="sxs-lookup"><span data-stu-id="91894-223">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is `true`.</span></span> <span data-ttu-id="91894-224">L'unica eccezione è rappresentata dallo spazio dei nomi dello schema ( `http://www.w3.org/2001/XMLSchema` ): se il contratto dati del tipo si trova in questo spazio dei nomi, l'elemento globale corrispondente si trova nello spazio dei nomi vuoto perché non è consentito aggiungere nuovi elementi allo spazio dei nomi dello schema.</span><span class="sxs-lookup"><span data-stu-id="91894-224">The only exception to this is the schema namespace (`http://www.w3.org/2001/XMLSchema`) – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="91894-225">Se al tipo è applicato l'attributo `XmlRootAttribute`, la dichiarazione di elemento globale viene esportata usando le proprietà <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> e <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A>.</span><span class="sxs-lookup"><span data-stu-id="91894-225">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="91894-226">L'impostazione predefinita quando è applicato l'attributo `XmlRootAttribute` è costituita dal nome del contratto dati, da un spazio dei nomi vuoto e da un valore "nillable" impostato su `true`.</span><span class="sxs-lookup"><span data-stu-id="91894-226">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being `true`.</span></span>

<span data-ttu-id="91894-227">Le stesse regole della dichiarazione di elemento globale si applicano ai tipi di dataset legacy.</span><span class="sxs-lookup"><span data-stu-id="91894-227">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="91894-228">Si noti che `XmlRootAttribute` non può eseguire l'override delle dichiarazioni di elemento globale aggiunte tramite codice personalizzato o aggiunte a `XmlSchemaSet` usando il metodo del provider dello schema o tramite `GetSchema` per i tipi di dataset legacy.</span><span class="sxs-lookup"><span data-stu-id="91894-228">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>

### <a name="ixmlserializable-element-types"></a><span data-ttu-id="91894-229">Tipi di elemento IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="91894-229">IXmlSerializable Element Types</span></span>

<span data-ttu-id="91894-230">I tipi di elemento `IXmlSerializable` hanno la proprietà `IsAny` impostata su `true` o il relativo metodo del provider dello schema restituisce `null`.</span><span class="sxs-lookup"><span data-stu-id="91894-230">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>

<span data-ttu-id="91894-231">La serializzazione e deserializzazione di un tipo di elemento è molto simile alla serializzazione e deserializzazione di un tipo di contenuto.</span><span class="sxs-lookup"><span data-stu-id="91894-231">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="91894-232">Esistono tuttavia alcune importanti differenze:</span><span class="sxs-lookup"><span data-stu-id="91894-232">However, there are some important differences:</span></span>

- <span data-ttu-id="91894-233">Si presuppone che l'implementazione `WriteXml` scriva un solo elemento (che può ovviamente contenere più elementi figlio).</span><span class="sxs-lookup"><span data-stu-id="91894-233">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="91894-234">Non deve scrivere attributi all'esterno di questo singolo elemento, più elementi di pari livello o contenuto misto.</span><span class="sxs-lookup"><span data-stu-id="91894-234">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="91894-235">L'elemento può essere vuoto.</span><span class="sxs-lookup"><span data-stu-id="91894-235">The element may be empty.</span></span>

- <span data-ttu-id="91894-236">L'implementazione `ReadXml` non deve leggere l'elemento wrapper,</span><span class="sxs-lookup"><span data-stu-id="91894-236">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="91894-237">bensì deve leggere l'unico elemento prodotto da `WriteXml`.</span><span class="sxs-lookup"><span data-stu-id="91894-237">It is expected to read the one element that `WriteXml` produces.</span></span>

- <span data-ttu-id="91894-238">Quando si serializza regolarmente un tipo di elemento (ad esempio, come un membro dati in un contratto dati), il serializzatore restituisce un elemento wrapper prima di chiamare `WriteXml`, come per i tipi di contenuto.</span><span class="sxs-lookup"><span data-stu-id="91894-238">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="91894-239">Tuttavia, quando si serializza un tipo di elemento al primo livello, il serializzatore in genere non restituisce un elemento wrapper per l'elemento scritto da `WriteXml`, a meno che un nome e uno spazio dei nomi radice vengano specificati in modo esplicito durante la creazione del serializzatore nei costruttori `DataContractSerializer` o `NetDataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="91894-239">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace are explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="91894-240">Per ulteriori informazioni, vedere [serializzazione e deserializzazione](serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="91894-240">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

- <span data-ttu-id="91894-241">Quando si serializza un tipo di elemento al primo livello senza specificare il nome e lo spazio dei nomi radice in fase di costruzione, i metodi <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> e <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essenzialmente non eseguono alcuna operazione e il metodo <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> chiama `WriteXml`.</span><span class="sxs-lookup"><span data-stu-id="91894-241">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially do nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="91894-242">In questo caso, l'oggetto serializzato non può essere `null` e non può essere assegnato in modo polimorfico.</span><span class="sxs-lookup"><span data-stu-id="91894-242">In this mode, the object being serialized cannot be `null` and cannot be polymorphically assigned.</span></span> <span data-ttu-id="91894-243">Inoltre, il mantenimento dell'oggetto grafico non può essere abilitato e `NetDataContractSerializer` non può essere usato.</span><span class="sxs-lookup"><span data-stu-id="91894-243">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>

- <span data-ttu-id="91894-244">Quando si deserializza un tipo di elemento al primo livello senza specificare il nome e lo spazio dei nomi radice in fase di costruzione, il metodo <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> restituisce `true` se riesce a trovare l'inizio di qualsiasi elemento.</span><span class="sxs-lookup"><span data-stu-id="91894-244">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="91894-245"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> con il parametro `verifyObjectName` impostato su `true` si comporta allo stesso modo di `IsStartObject` prima di leggere effettivamente l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="91894-245"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="91894-246">`ReadObject` passa quindi il controllo al metodo `ReadXml`.</span><span class="sxs-lookup"><span data-stu-id="91894-246">`ReadObject` then passes control to `ReadXml` method.</span></span>

<span data-ttu-id="91894-247">Lo schema esportato per i tipi di elemento è lo stesso del tipo `XmlElement`, come illustrato in una sezione precedente, con l'eccezione che il metodo del provider dello schema può aggiungere qualsiasi altro schema a <xref:System.Xml.Schema.XmlSchemaSet> come con i tipi di contenuto.</span><span class="sxs-lookup"><span data-stu-id="91894-247">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="91894-248">L'uso dell'attributo `XmlRootAttribute` con i tipi di elemento non è consentito e le dichiarazioni di elemento globale non vengono mai generate per questi tipi.</span><span class="sxs-lookup"><span data-stu-id="91894-248">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>

### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="91894-249">Differenze rispetto a XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="91894-249">Differences from the XmlSerializer</span></span>

<span data-ttu-id="91894-250">L'interfaccia `IXmlSerializable` e gli attributi `XmlSchemaProviderAttribute` e `XmlRootAttribute` vengono riconosciuti anche da <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="91894-250">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="91894-251">Tuttavia, esistono alcune differenze nel modo in cui questi elementi vengono gestiti nel modello del contratto dati.</span><span class="sxs-lookup"><span data-stu-id="91894-251">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="91894-252">Le differenze più importanti sono riepilogate nell'elenco seguente:</span><span class="sxs-lookup"><span data-stu-id="91894-252">The important differences are summarized in the following list:</span></span>

- <span data-ttu-id="91894-253">Il metodo del provider dello schema deve essere pubblico per poter essere usato in `XmlSerializer`, ma non deve essere pubblico per poter essere usato nel modello del contratto dati.</span><span class="sxs-lookup"><span data-stu-id="91894-253">The schema provider method must be public to be used in the `XmlSerializer`, but does not have to be public to be used in the data contract model.</span></span>

- <span data-ttu-id="91894-254">Il metodo del provider dello schema viene chiamato quando `IsAny` è `true` nel modello del contratto dati, ma non con `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="91894-254">The schema provider method is called when `IsAny` is `true` in the data contract model but not with the `XmlSerializer`.</span></span>

- <span data-ttu-id="91894-255">Quando l'attributo `XmlRootAttribute` non è presente per contenuto o i tipi di dataset legacy, `XmlSerializer` esporta una dichiarazione di elemento globale nello spazio dei nomi vuoto.</span><span class="sxs-lookup"><span data-stu-id="91894-255">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="91894-256">Nel modello del contratto dati, lo spazio dei nomi usato è in genere lo spazio dei nomi del contratto dati, come descritto in precedenza.</span><span class="sxs-lookup"><span data-stu-id="91894-256">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>

<span data-ttu-id="91894-257">Tenere presenti queste differenze durante la creazione di tipi che vengono usati con entrambe le tecnologie di serializzazione.</span><span class="sxs-lookup"><span data-stu-id="91894-257">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>

### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="91894-258">Importazione dello schema IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="91894-258">Importing IXmlSerializable Schema</span></span>

<span data-ttu-id="91894-259">Quando si importa uno schema generato dai tipi `IXmlSerializable`, si verificano alcuni possibili scenari:</span><span class="sxs-lookup"><span data-stu-id="91894-259">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>

- <span data-ttu-id="91894-260">Lo schema generato può essere uno schema del contratto dati valido come descritto in [riferimento allo schema del contratto dati](data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="91894-260">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span> <span data-ttu-id="91894-261">In questo caso, lo schema può essere importato normalmente e vengono generati tipi del contratto dati normali.</span><span class="sxs-lookup"><span data-stu-id="91894-261">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>

- <span data-ttu-id="91894-262">Lo schema generato può non essere uno schema valido del contratto dati.</span><span class="sxs-lookup"><span data-stu-id="91894-262">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="91894-263">Ad esempio, il metodo del provider dello schema può generare lo schema coinvolgendo gli attributi XML che non sono supportati nel modello del contratto dati.</span><span class="sxs-lookup"><span data-stu-id="91894-263">For example, your schema provider method may generate schema that involves XML attributes that are not supported in the data contract model.</span></span> <span data-ttu-id="91894-264">In questo caso, è possibile importare lo schema come tipi `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="91894-264">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="91894-265">Questa modalità di importazione non è attiva per impostazione predefinita, ma può essere abilitata facilmente, ad esempio con l' `/importXmlTypes` opzione della riga di comando per lo [strumento ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span><span class="sxs-lookup"><span data-stu-id="91894-265">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="91894-266">Questa operazione è descritta in dettaglio nello [schema di importazione per generare le classi](importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="91894-266">This is described in detail in the [Importing Schema to Generate Classes](importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="91894-267">Si noti che è necessario interagire direttamente con XML per le istanze del tipo.</span><span class="sxs-lookup"><span data-stu-id="91894-267">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="91894-268">Si può anche scegliere di usare una tecnologia di serializzazione diversa che supporti una gamma più ampia di schemi (vedere l'argomento relativo all'uso di `XmlSerializer`).</span><span class="sxs-lookup"><span data-stu-id="91894-268">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>

- <span data-ttu-id="91894-269">Può essere necessario riusare i tipi `IXmlSerializable` esistenti nel proxy anziché generare tipi nuovi.</span><span class="sxs-lookup"><span data-stu-id="91894-269">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="91894-270">In questo caso, è possibile usare la funzionalità dei tipi a cui è stato fatto riferimento descritta nell'argomento relativo all'importazione dello schema per generare i tipi per indicare il tipo da riusare.</span><span class="sxs-lookup"><span data-stu-id="91894-270">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="91894-271">Questa procedura corrisponde all'uso dell'opzione `/reference` in svcutil.exe, che specifica l'assembly contenente i tipi da riutilizzare.</span><span class="sxs-lookup"><span data-stu-id="91894-271">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>

### <a name="xmlserializer-legacy-behavior"></a><span data-ttu-id="91894-272">Comportamento legacy di XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="91894-272">XmlSerializer Legacy Behavior</span></span>

<span data-ttu-id="91894-273">In .NET Framework 4.0 e versioni precedenti, XmlSerializer generava assembly di serializzazione temporanei scrivendo codice C# in un file.</span><span class="sxs-lookup"><span data-stu-id="91894-273">In the .NET Framework 4.0 and earlier, the XmlSerializer generated temporary serialization assemblies by writing C# code to a file.</span></span> <span data-ttu-id="91894-274">Il file veniva quindi compilato in un assembly.</span><span class="sxs-lookup"><span data-stu-id="91894-274">The file was then compiled into an assembly.</span></span>  <span data-ttu-id="91894-275">Questo comportamento implicava alcune conseguenze indesiderate, ad esempio l'aumento del tempo di avvio del serializzatore.</span><span class="sxs-lookup"><span data-stu-id="91894-275">This behavior had some undesirable consequences like slowing the startup time for the serializer.</span></span> <span data-ttu-id="91894-276">In .NET Framework 4.5 questo comportamento è stato modificato in modo da generare assembly senza richiedere l'uso del compilatore.</span><span class="sxs-lookup"><span data-stu-id="91894-276">In .NET Framework 4.5, this behavior was changed to generate the assemblies without requiring use of the compiler.</span></span> <span data-ttu-id="91894-277">Alcuni sviluppatori potrebbero voler visualizzare il codice C# generato.</span><span class="sxs-lookup"><span data-stu-id="91894-277">Some developers may wish to see the generated C# code.</span></span> <span data-ttu-id="91894-278">È possibile specificare di usare questo comportamento legacy tramite la configurazione seguente:</span><span class="sxs-lookup"><span data-stu-id="91894-278">You can specify to use this legacy behavior by the following configuration:</span></span>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
  <system.xml.serialization>
    <xmlSerializer tempFilesLocation='e:\temp\XmlSerializerBug' useLegacySerializerGeneration="true" />
  </system.xml.serialization>
  <system.diagnostics>
    <switches>
      <add name="XmlSerialization.Compilation" value="1" />
    </switches>
  </system.diagnostics>
</configuration>
```

<span data-ttu-id="91894-279">Se si verificano problemi di compatibilità, ad esempio se `XmlSerializer` non si riesce a serializzare una classe derivata con un nuovo override non pubblico, è possibile tornare al `XMLSerializer` comportamento legacy usando la configurazione seguente:</span><span class="sxs-lookup"><span data-stu-id="91894-279">If you run into compatibility issues,  such as the `XmlSerializer` failing to serialize a derived class with a non-public new override, you can switch back to the  `XMLSerializer` legacy behavior by using the following configuration:</span></span>

```xml
<configuration>
  <appSettings>
    <add key="System:Xml:Serialization:UseLegacySerializerGeneration" value="true" />
  </appSettings>
</configuration>
```

<span data-ttu-id="91894-280">In alternativa alla configurazione precedente, è possibile usare la configurazione seguente in un computer che esegue .NET Framework 4,5 o versione successiva:</span><span class="sxs-lookup"><span data-stu-id="91894-280">As an alternative to the above configuration, you can use the following configuration on a machine running .NET Framework 4.5 or later version:</span></span>

```xml
<configuration>
  <system.xml.serialization>
    <xmlSerializer useLegacySerializerGeneration="true"/>
  </system.xml.serialization>
</configuration>
```

> [!NOTE]
> <span data-ttu-id="91894-281">Il `<xmlSerializer useLegacySerializerGeneration="true"/>` Commuter funziona solo su un computer che esegue .NET Framework 4,5 o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="91894-281">The `<xmlSerializer useLegacySerializerGeneration="true"/>` switch only works on a machine running .NET Framework 4.5 or later version.</span></span> <span data-ttu-id="91894-282">L' `appSettings` approccio precedente funziona in tutte le versioni .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="91894-282">The above `appSettings` approach works on all .NET Framework versions.</span></span>

## <a name="see-also"></a><span data-ttu-id="91894-283">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="91894-283">See also</span></span>

- <xref:System.ServiceModel.DataContractFormatAttribute>
- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.Serialization.XmlSerializer>
- <xref:System.ServiceModel.MessageHeaderArrayAttribute>
- [<span data-ttu-id="91894-284">Specifying Data Transfer in Service Contracts</span><span class="sxs-lookup"><span data-stu-id="91894-284">Specifying Data Transfer in Service Contracts</span></span>](specifying-data-transfer-in-service-contracts.md)
- [<span data-ttu-id="91894-285">Using Data Contracts</span><span class="sxs-lookup"><span data-stu-id="91894-285">Using Data Contracts</span></span>](using-data-contracts.md)
- [<span data-ttu-id="91894-286">Procedura: migliorare il tempo di avvio di applicazioni client WCF usando XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="91894-286">How to: Improve the Startup Time of WCF Client Applications using the XmlSerializer</span></span>](startup-time-of-wcf-client-applications-using-the-xmlserializer.md)
