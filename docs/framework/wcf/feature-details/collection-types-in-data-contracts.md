---
title: Tipi di raccolta nei contratti dati
description: Informazioni sul modo in cui il modello di contratto dati considera le raccolte nella .NET Framework e in che modo WCF supporta la serializzazione dei dati per i tipi di raccolta.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- collection types [WCF], data contracts
- data contracts [WCF], collection types
- collection types [WCF]
ms.assetid: 9b45b28e-0a82-4ea3-8c33-ec0094aff9d5
ms.openlocfilehash: 83acf1f74bf3cb117f3f94743eda32d3f2cc4b82
ms.sourcegitcommit: 358a28048f36a8dca39a9fe6e6ac1f1913acadd5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/23/2020
ms.locfileid: "85245180"
---
# <a name="collection-types-in-data-contracts"></a><span data-ttu-id="81d28-103">Tipi di raccolta nei contratti dati</span><span class="sxs-lookup"><span data-stu-id="81d28-103">Collection Types in Data Contracts</span></span>

<span data-ttu-id="81d28-104">Una *raccolta* costituisce un elenco di elementi di un certo tipo.</span><span class="sxs-lookup"><span data-stu-id="81d28-104">A *collection* is a list of items of a certain type.</span></span> <span data-ttu-id="81d28-105">Nel .NET Framework, tali elenchi possono essere rappresentati mediante matrici o una varietà di altri tipi (elenco generico, generico <xref:System.ComponentModel.BindingList%601> , <xref:System.Collections.Specialized.StringCollection> o <xref:System.Collections.ArrayList> ).</span><span class="sxs-lookup"><span data-stu-id="81d28-105">In the .NET Framework, such lists can be represented using arrays or a variety of other types (Generic List, Generic <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, or <xref:System.Collections.ArrayList>).</span></span> <span data-ttu-id="81d28-106">Una raccolta, ad esempio, può contenere un elenco di indirizzi per un determinato cliente.</span><span class="sxs-lookup"><span data-stu-id="81d28-106">For example, a collection may hold a list of Addresses for a given Customer.</span></span> <span data-ttu-id="81d28-107">Queste raccolte vengono denominate *raccolte di elenchi*, indipendentemente dal tipo effettivo.</span><span class="sxs-lookup"><span data-stu-id="81d28-107">These collections are called *list collections*, regardless of their actual type.</span></span>

<span data-ttu-id="81d28-108">Esiste una forma speciale di raccolta che rappresenta un'associazione tra un elemento (la "chiave") e un altro elemento (il "valore").</span><span class="sxs-lookup"><span data-stu-id="81d28-108">A special form of collection exists that represents an association between one item (the "key") and another (the "value").</span></span> <span data-ttu-id="81d28-109">Nel .NET Framework sono rappresentati da tipi come <xref:System.Collections.Hashtable> e dal dizionario generico.</span><span class="sxs-lookup"><span data-stu-id="81d28-109">In the .NET Framework, these are represented by types such as <xref:System.Collections.Hashtable> and the generic dictionary.</span></span> <span data-ttu-id="81d28-110">Una raccolta di associazioni, ad esempio, può eseguire il mapping di una città (la "chiave") alla relativa popolazione (il "valore")</span><span class="sxs-lookup"><span data-stu-id="81d28-110">For example, an association collection may map a city ("key") to its population ("value").</span></span> <span data-ttu-id="81d28-111">Queste raccolte vengono denominate *raccolte di dizionario*, indipendentemente dal tipo effettivo.</span><span class="sxs-lookup"><span data-stu-id="81d28-111">These collections are called *dictionary collections*, regardless of their actual type.</span></span>

<span data-ttu-id="81d28-112">Le raccolte ricevono un trattamento speciale nel modello del contratto dati.</span><span class="sxs-lookup"><span data-stu-id="81d28-112">Collections receive special treatment in the data contract model.</span></span>

<span data-ttu-id="81d28-113">I tipi che implementano l'interfaccia <xref:System.Collections.IEnumerable> , tra cui matrici e raccolte generiche, vengono riconosciuti come raccolte.</span><span class="sxs-lookup"><span data-stu-id="81d28-113">Types that implement the <xref:System.Collections.IEnumerable> interface, including arrays and generic collections, are recognized as collections.</span></span> <span data-ttu-id="81d28-114">Di questi, i tipi che implementano l'interfaccia <xref:System.Collections.IDictionary> o l'interfaccia <xref:System.Collections.Generic.IDictionary%602> generica sono raccolte di dizionario mentre tutti gli altri sono raccolte di elenco.</span><span class="sxs-lookup"><span data-stu-id="81d28-114">Of those, types that implement the <xref:System.Collections.IDictionary> or Generic <xref:System.Collections.Generic.IDictionary%602> interfaces are dictionary collections; all others are list collections.</span></span>

<span data-ttu-id="81d28-115">I requisiti aggiuntivi sui tipi di raccolta, ad esempio la presenza di un metodo denominato `Add` e di un costruttore senza parametri, vengono descritti in dettaglio nelle sezioni seguenti.</span><span class="sxs-lookup"><span data-stu-id="81d28-115">Additional requirements on collection types, such as having a method called `Add` and a parameterless constructor, are discussed in detail in the following sections.</span></span> <span data-ttu-id="81d28-116">La presenza di questi requisiti garantisce che i tipi di raccolta possano essere serializzati e deserializzati</span><span class="sxs-lookup"><span data-stu-id="81d28-116">This ensures that collection types can be both serialized and deserialized.</span></span> <span data-ttu-id="81d28-117">Ciò significa che alcune raccolte non sono supportate direttamente, ad esempio l'oggetto generico <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (perché non ha un costruttore senza parametri).</span><span class="sxs-lookup"><span data-stu-id="81d28-117">This means that some collections are not directly supported, such as the Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (because it has no parameterless constructor).</span></span> <span data-ttu-id="81d28-118">Per informazioni su come evitare queste restrizioni, tuttavia, vedere la sezione "Utilizzo di tipi di interfacce di raccolta e raccolte di sola lettura" più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="81d28-118">However, for information about circumventing these restrictions, see the section "Using Collection Interface Types and Read-Only Collections" later in this topic.</span></span>

<span data-ttu-id="81d28-119">I tipi contenuti nelle raccolte devono essere tipi di contratto dati o devono poter essere serializzati in altro modo.</span><span class="sxs-lookup"><span data-stu-id="81d28-119">The types contained in collections must be data contract types, or be otherwise serializable.</span></span> <span data-ttu-id="81d28-120">Per ulteriori informazioni, vedere [tipi supportati dal serializzatore di contratti dati](types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="81d28-120">For more information, see [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md).</span></span>

<span data-ttu-id="81d28-121">Per ulteriori informazioni su ciò che non è considerato una raccolta valida, oltre che sulla modalità di serializzazione delle raccolte, vedere le informazioni sulla serializzazione delle raccolte nella sezione "regole avanzate di raccolta" di questo argomento.</span><span class="sxs-lookup"><span data-stu-id="81d28-121">For more information about what is and what is not considered a valid collection, as well as about how collections are serialized, see the information about serializing collections in the "Advanced Collection Rules" section of this topic.</span></span>

## <a name="interchangeable-collections"></a><span data-ttu-id="81d28-122">Raccolte intercambiabili</span><span class="sxs-lookup"><span data-stu-id="81d28-122">Interchangeable Collections</span></span>

<span data-ttu-id="81d28-123">Si suppone che tutte le raccolte di elenco dello stesso tipo dispongano dello stesso contratto dati (a meno che non vengano personalizzate con l'attributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> , come viene descritto più avanti in questo argomento).</span><span class="sxs-lookup"><span data-stu-id="81d28-123">All list collections of the same type are considered to have the same data contract (unless they are customized using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, as discussed later in this topic).</span></span> <span data-ttu-id="81d28-124">Pertanto, ad esempio, i contratti dati seguenti sono equivalenti.</span><span class="sxs-lookup"><span data-stu-id="81d28-124">Thus, for example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#0](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#0)]
[!code-vb[c_collection_types_in_data_contracts#0](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#0)]

<span data-ttu-id="81d28-125">Entrambi i contratti dati generano XML simile al codice seguente.</span><span class="sxs-lookup"><span data-stu-id="81d28-125">Both data contracts result in XML similar to the following code.</span></span>

```xml
<PurchaseOrder>
    <customerName>...</customerName>
    <items>
        <Item>...</Item>
        <Item>...</Item>
        <Item>...</Item>
        ...
    </items>
    <comments>
        <string>...</string>
        <string>...</string>
        <string>...</string>
        ...
    </comments>
</PurchaseOrder>
```

<span data-ttu-id="81d28-126">L'intercambiabilità delle raccolte consente di utilizzare, ad esempio, un tipo di raccolta ottimizzato per le prestazioni nel server e un tipo di raccolta progettato per essere associato ai componenti dell'interfaccia utente nel client.</span><span class="sxs-lookup"><span data-stu-id="81d28-126">Collection interchangeability allows you to use, for example, a collection type optimized for performance on the server and a collection type designed to be bound to user interface components on the client.</span></span>

<span data-ttu-id="81d28-127">Come per le raccolte di elenco, si suppone che tutte le raccolte di dizionario con lo stesso tipo di chiave e valore dispongano dello stesso contratto dati (a meno che non vengano personalizzate con l'attributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> ).</span><span class="sxs-lookup"><span data-stu-id="81d28-127">Similar to list collections, all dictionary collections that have the same key and value types are considered to have the same data contract (unless customized by the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute).</span></span>

<span data-ttu-id="81d28-128">Ai fini dell'equivalenza delle raccolte vale solo il tipo di contratto dati, non i tipi .NET.</span><span class="sxs-lookup"><span data-stu-id="81d28-128">Only the data contract type matters as far as collection equivalence is concerned, not .NET types.</span></span> <span data-ttu-id="81d28-129">Una raccolta Type1 è considerata equivalente a una raccolta Type2 se Type1 e Type2 presentano contratti dati equivalenti.</span><span class="sxs-lookup"><span data-stu-id="81d28-129">That is, a collection of Type1 is considered equivalent to a collection of Type2 if Type1 and Type2 have equivalent data contracts.</span></span>

<span data-ttu-id="81d28-130">Si suppone che raccolte non generiche dispongano dello stesso contratto dati di raccolte generiche di tipo `Object`.</span><span class="sxs-lookup"><span data-stu-id="81d28-130">Non-generic collections are considered to have the same data contract as generic collections of type `Object`.</span></span> <span data-ttu-id="81d28-131">Ad esempio, i contratti dati per <xref:System.Collections.ArrayList> e per un oggetto <xref:System.Collections.Generic.List%601> generico di `Object` sono uguali.</span><span class="sxs-lookup"><span data-stu-id="81d28-131">(For example, the data contracts for <xref:System.Collections.ArrayList> and Generic <xref:System.Collections.Generic.List%601> of `Object` are the same.)</span></span>

## <a name="using-collection-interface-types-and-read-only-collections"></a><span data-ttu-id="81d28-132">Utilizzo di tipi di interfacce di raccolta e raccolte di sola lettura</span><span class="sxs-lookup"><span data-stu-id="81d28-132">Using Collection Interface Types and Read-Only Collections</span></span>

<span data-ttu-id="81d28-133">Anche per i tipi di interfaccia di raccolta (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, <xref:System.Collections.Generic.IDictionary%602>generico o interfacce che derivano da queste interfacce) si suppone che dispongano di contratti dati di raccolta, equivalenti a contratti dati di raccolta per tipi di raccolta effettivi.</span><span class="sxs-lookup"><span data-stu-id="81d28-133">Collection interface types (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, generic <xref:System.Collections.Generic.IDictionary%602>, or interfaces derived from these interfaces) are also considered as having collection data contracts, equivalent to collection data contracts for actual collection types.</span></span> <span data-ttu-id="81d28-134">È dunque possibile dichiarare il tipo serializzato come tipo di interfaccia di raccolta e i risultati sono gli stessi che verrebbero ottenuti se fosse utilizzato un tipo di raccolta effettivo.</span><span class="sxs-lookup"><span data-stu-id="81d28-134">Thus, it is possible to declare the type being serialized as a collection interface type and the results are the same as if an actual collection type had been used.</span></span> <span data-ttu-id="81d28-135">I contratti dati seguenti, ad esempio, sono equivalenti.</span><span class="sxs-lookup"><span data-stu-id="81d28-135">For example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#1)]
[!code-vb[c_collection_types_in_data_contracts#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#1)]

<span data-ttu-id="81d28-136">Durante la serializzazione, quando il tipo dichiarato è un'interfaccia, il tipo dell'istanza effettivo utilizzato può essere qualsiasi tipo che implementa quell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="81d28-136">During serialization, when the declared type is an interface, the actual instance type used can be any type that implements that interface.</span></span> <span data-ttu-id="81d28-137">Le restrizioni discusse in precedenza (con un costruttore senza parametri e un `Add` metodo) non sono applicabili.</span><span class="sxs-lookup"><span data-stu-id="81d28-137">Restrictions discussed previously (having a parameterless constructor and an `Add` method) do not apply.</span></span> <span data-ttu-id="81d28-138">È ad esempio possibile impostare indirizzi in Customer2 su un'istanza della classe <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> generica di Address, anche se non si può dichiarare direttamente un membro dati di tipo <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>generico.</span><span class="sxs-lookup"><span data-stu-id="81d28-138">For example, you can set addresses in Customer2 to an instance of Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> of Address, even though you cannot directly declare a data member of type Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>

<span data-ttu-id="81d28-139">Durante la deserializzazione, quando il tipo dichiarato è un'interfaccia, il motore di serializzazione sceglie un tipo che implementi l'interfaccia dichiarata e viene creata un'istanza del tipo.</span><span class="sxs-lookup"><span data-stu-id="81d28-139">During deserialization, when the declared type is an interface, the serialization engine chooses a type that implements the declared interface, and the type is instantiated.</span></span> <span data-ttu-id="81d28-140">Il meccanismo dei tipi noti (descritto in [tipi noti del contratto dati](data-contract-known-types.md)) non ha alcun effetto. la scelta del tipo è incorporata in WCF.</span><span class="sxs-lookup"><span data-stu-id="81d28-140">The known types mechanism (described in [Data Contract Known Types](data-contract-known-types.md)) has no effect here; the choice of type is built into WCF.</span></span>

## <a name="customizing-collection-types"></a><span data-ttu-id="81d28-141">Personalizzazione dei tipi di raccolta</span><span class="sxs-lookup"><span data-stu-id="81d28-141">Customizing Collection Types</span></span>

<span data-ttu-id="81d28-142">È possibile personalizzare i tipi di raccolta utilizzando l'attributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> , che presenta molti utilizzi.</span><span class="sxs-lookup"><span data-stu-id="81d28-142">You can customize collection types by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, which has several uses.</span></span>

<span data-ttu-id="81d28-143">Si noti che la personalizzazione dei tipi di raccolta compromette l'intercambiabilità delle raccolte, pertanto si consiglia in genere di evitare l'applicazione di questo attributo quando possibile.</span><span class="sxs-lookup"><span data-stu-id="81d28-143">Note that customizing collection types compromises collection interchangeability, so it is generally recommended to avoid applying this attribute whenever possible.</span></span> <span data-ttu-id="81d28-144">Per ulteriori informazioni su questo problema, vedere la sezione "regole avanzate di raccolta" più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="81d28-144">For more information about this issue, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="collection-data-contract-naming"></a><span data-ttu-id="81d28-145">Denominazione del contratto dati della raccolta</span><span class="sxs-lookup"><span data-stu-id="81d28-145">Collection Data Contract Naming</span></span>

<span data-ttu-id="81d28-146">Le regole per la denominazione dei tipi di raccolta sono simili a quelle per la denominazione dei tipi di contratto dati normali, come viene descritto in [Data Contract Names](data-contract-names.md), ad eccezione di alcune importanti differenze:</span><span class="sxs-lookup"><span data-stu-id="81d28-146">The rules for naming collection types are similar to those for naming regular data contract types, as described in [Data Contract Names](data-contract-names.md), although some important differences exist:</span></span>

- <span data-ttu-id="81d28-147">Per personalizzare il nome viene utilizzato l'attributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> anziché l'attributo <xref:System.Runtime.Serialization.DataContractAttribute> .</span><span class="sxs-lookup"><span data-stu-id="81d28-147">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is used to customize the name, instead of the <xref:System.Runtime.Serialization.DataContractAttribute> attribute.</span></span> <span data-ttu-id="81d28-148">Anche l'attributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> dispone delle proprietà `Name` e `Namespace` .</span><span class="sxs-lookup"><span data-stu-id="81d28-148">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute also has `Name` and `Namespace` properties.</span></span>

- <span data-ttu-id="81d28-149">Quando l'attributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> non viene applicato, il nome e lo spazio dei nomi predefiniti per i tipi di raccolta dipendono dai nomi e dagli spazi dei nomi dei tipi contenuti nella raccolta.</span><span class="sxs-lookup"><span data-stu-id="81d28-149">When the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is not applied, the default name and namespace for collection types depend on the names and namespaces of types contained within the collection.</span></span> <span data-ttu-id="81d28-150">Non vengono influenzati dal nome e dallo spazio dei nomi del tipo di raccolta stesso.</span><span class="sxs-lookup"><span data-stu-id="81d28-150">They are not affected by the name and namespace of the collection type itself.</span></span> <span data-ttu-id="81d28-151">Per un esempio, vedere i tipi seguenti.</span><span class="sxs-lookup"><span data-stu-id="81d28-151">For an example, see the following types.</span></span>

  ```csharp
  public CustomerList1 : Collection<string> {}
  public StringList1 : Collection<string> {}
  ```

<span data-ttu-id="81d28-152">Il nome del contratto dati di entrambi i tipi è "ArrayOfstring" e non "CustomerList1" o "StringList1".</span><span class="sxs-lookup"><span data-stu-id="81d28-152">Both types’ data contract name is "ArrayOfstring" and not "CustomerList1" or "StringList1".</span></span> <span data-ttu-id="81d28-153">Ciò significa che eseguendo la serializzazione di uno qualsiasi di questi tipi a livello di radice si ottiene codice XML simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="81d28-153">This means that serializing any one of these types at the root level yields XML similar to the following code.</span></span>

```xml
<ArrayOfstring>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</ArrayOfstring>
```

<span data-ttu-id="81d28-154">Questa regola di denominazione è stata scelta per avere la certezza che i tipi non personalizzati che rappresentano un elenco di stringhe abbiano lo stesso contratto dati e la stessa rappresentazione XML.</span><span class="sxs-lookup"><span data-stu-id="81d28-154">This naming rule was chosen to ensure that any non-customized type that represents a list of strings has the same data contract and XML representation.</span></span> <span data-ttu-id="81d28-155">In questo modo l'intercambiabilità delle raccolte è possibile.</span><span class="sxs-lookup"><span data-stu-id="81d28-155">This makes collection interchangeability possible.</span></span> <span data-ttu-id="81d28-156">Nell'esempio CustomerList1 e StringList1 sono completamente intercambiabili.</span><span class="sxs-lookup"><span data-stu-id="81d28-156">In this example, CustomerList1 and StringList1 are completely interchangeable.</span></span>

<span data-ttu-id="81d28-157">Quando viene applicato l'attributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> , tuttavia, la raccolta diventa un contratto dati di una raccolta personalizzata, anche se nell'attributo non è impostata alcuna proprietà.</span><span class="sxs-lookup"><span data-stu-id="81d28-157">However, when the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is applied, the collection becomes a customized collection data contract, even if no properties are set on the attribute.</span></span> <span data-ttu-id="81d28-158">Il nome e lo spazio dei nomi del contratto dati della raccolta dipendono quindi dal tipo di raccolta stesso.</span><span class="sxs-lookup"><span data-stu-id="81d28-158">The name and namespace of the collection data contract then depend on the collection type itself.</span></span> <span data-ttu-id="81d28-159">Per un esempio, vedere il tipo seguente.</span><span class="sxs-lookup"><span data-stu-id="81d28-159">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#2)]
[!code-vb[c_collection_types_in_data_contracts#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#2)]

<span data-ttu-id="81d28-160">Quando viene serializzato, l'XML risultante è simile al codice seguente.</span><span class="sxs-lookup"><span data-stu-id="81d28-160">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CustomerList2>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</CustomerList2>
```

<span data-ttu-id="81d28-161">Si noti che questo codice non è più equivalente alla rappresentazione XML dei tipi non personalizzati.</span><span class="sxs-lookup"><span data-stu-id="81d28-161">Notice that this is no longer equivalent to the XML representation of the non-customized types.</span></span>

- <span data-ttu-id="81d28-162">È quindi possibile utilizzare le proprietà `Name` e `Namespace` per personalizzare ulteriormente la denominazione.</span><span class="sxs-lookup"><span data-stu-id="81d28-162">You can use the `Name` and `Namespace` properties to further customize the naming.</span></span> <span data-ttu-id="81d28-163">Fare riferimento alla classe seguente.</span><span class="sxs-lookup"><span data-stu-id="81d28-163">See the following class.</span></span>

  [!code-csharp[c_collection_types_in_data_contracts#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#3)]
  [!code-vb[c_collection_types_in_data_contracts#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#3)]

<span data-ttu-id="81d28-164">L'XML risultante è simile al codice seguente.</span><span class="sxs-lookup"><span data-stu-id="81d28-164">The resulting XML is similar to the following.</span></span>

```xml
<cust_list>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</cust_list>
```

<span data-ttu-id="81d28-165">Per ulteriori informazioni, vedere la sezione "regole avanzate di raccolta" più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="81d28-165">For more information, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="customizing-the-repeating-element-name-in-list-collections"></a><span data-ttu-id="81d28-166">Personalizzazione del nome dell'elemento ripetuto nelle raccolte di elenco</span><span class="sxs-lookup"><span data-stu-id="81d28-166">Customizing the Repeating Element Name in List Collections</span></span>

<span data-ttu-id="81d28-167">Le raccolte di elenco contengono voci ripetute.</span><span class="sxs-lookup"><span data-stu-id="81d28-167">List collections contain repeating entries.</span></span> <span data-ttu-id="81d28-168">Normalmente ogni voce ripetuta è rappresentata come un elemento denominato secondo il nome del contratto dati del tipo contenuto nella raccolta.</span><span class="sxs-lookup"><span data-stu-id="81d28-168">Normally, each repeating entry is represented as an element named according to the data contract name of the type contained in the collection.</span></span>

<span data-ttu-id="81d28-169">Negli esempi `CustomerList` , le raccolte contengono stringhe.</span><span class="sxs-lookup"><span data-stu-id="81d28-169">In the `CustomerList` examples, the collections contained strings.</span></span> <span data-ttu-id="81d28-170">Il nome del contratto dati per il tipo primitivo stringa è "String", quindi l'elemento ripetuto è " \<string> ".</span><span class="sxs-lookup"><span data-stu-id="81d28-170">The data contract name for the string primitive type is "string", so the repeating element was "\<string>".</span></span>

<span data-ttu-id="81d28-171">Utilizzando la proprietà <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> nell'attributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> , tuttavia, questo nome di elemento ripetuto può essere personalizzato.</span><span class="sxs-lookup"><span data-stu-id="81d28-171">However, using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property on the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, this repeating element name can be customized.</span></span> <span data-ttu-id="81d28-172">Per un esempio, vedere il tipo seguente.</span><span class="sxs-lookup"><span data-stu-id="81d28-172">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#4)]
[!code-vb[c_collection_types_in_data_contracts#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#4)]

<span data-ttu-id="81d28-173">L'XML risultante è simile al codice seguente.</span><span class="sxs-lookup"><span data-stu-id="81d28-173">The resulting XML is similar to the following.</span></span>

```xml
<CustomerList4>
    <customer>...</customer>
    <customer>...</customer>
    <customer>...</customer>
    ...
</CustomerList4>
```

<span data-ttu-id="81d28-174">Lo spazio dei nomi dell'elemento ripetuto è sempre uguale allo spazio dei nomi del contratto dati della raccolta, che può essere personalizzato tramite la proprietà `Namespace` , come descritto in precedenza.</span><span class="sxs-lookup"><span data-stu-id="81d28-174">The namespace of the repeating element is always the same as the namespace of the collection data contract, which can be customized using the `Namespace` property, as described previously.</span></span>

### <a name="customizing-dictionary-collections"></a><span data-ttu-id="81d28-175">Personalizzazione di raccolte di dizionario</span><span class="sxs-lookup"><span data-stu-id="81d28-175">Customizing Dictionary Collections</span></span>

<span data-ttu-id="81d28-176">Le raccolte di dizionario sono essenzialmente elenchi di voci, in cui ogni voce presenta una chiave seguita da un valore.</span><span class="sxs-lookup"><span data-stu-id="81d28-176">Dictionary collections are essentially lists of entries, where each entry has a key followed by a value.</span></span> <span data-ttu-id="81d28-177">Come per gli elenchi normali, è possibile modificare il nome di elemento corrispondente all'elemento ripetuto utilizzando la proprietà <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> .</span><span class="sxs-lookup"><span data-stu-id="81d28-177">Just as with regular lists, you can change the element name that corresponds to the repeating element by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property.</span></span>

<span data-ttu-id="81d28-178">È inoltre possibile modificare i nomi di elemento che rappresentano la chiave e il valore utilizzando le proprietà <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> e <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> .</span><span class="sxs-lookup"><span data-stu-id="81d28-178">Additionally, you can change the element names that represent the key and the value by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> and <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> properties.</span></span> <span data-ttu-id="81d28-179">Gli spazi dei nomi di questi elementi sono gli stessi dello spazio dei nomi del contratto dati della raccolta.</span><span class="sxs-lookup"><span data-stu-id="81d28-179">The namespaces for these elements are the same as the namespace of the collection data contract.</span></span>

<span data-ttu-id="81d28-180">Per un esempio, vedere il tipo seguente.</span><span class="sxs-lookup"><span data-stu-id="81d28-180">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#5)]
[!code-vb[c_collection_types_in_data_contracts#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#5)]

<span data-ttu-id="81d28-181">Quando viene serializzato, l'XML risultante è simile al codice seguente.</span><span class="sxs-lookup"><span data-stu-id="81d28-181">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CountriesOrRegionsWithCapitals>
    <entry>
        <countryorregion>USA</countryorregion>
        <capital>Washington</capital>
    </entry>
    <entry>
        <countryorregion>France</countryorregion>
        <capital>Paris</capital>
    </entry>
    ...
</CountriesOrRegionsWithCapitals>
```

<span data-ttu-id="81d28-182">Per ulteriori informazioni sulle raccolte di dizionari, vedere la sezione "regole avanzate di raccolta" più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="81d28-182">For more information about dictionary collections, see the "Advanced Collection Rules" section later in this topic.</span></span>

## <a name="collections-and-known-types"></a><span data-ttu-id="81d28-183">Raccolte e tipi noti</span><span class="sxs-lookup"><span data-stu-id="81d28-183">Collections and Known Types</span></span>

<span data-ttu-id="81d28-184">Non è necessario aggiungere tipi di raccolta a tipi noti quando vengono utilizzati polimorficamente in luogo di altre raccolte o di altre interfacce di raccolta.</span><span class="sxs-lookup"><span data-stu-id="81d28-184">You do not need to add collection types to known types when used polymorphically in place of other collections or collection interfaces.</span></span> <span data-ttu-id="81d28-185">Se ad esempio si dichiara un membro dati di tipo <xref:System.Collections.IEnumerable> e lo si utilizza per inviare un'istanza di <xref:System.Collections.ArrayList>, non è necessario aggiungere <xref:System.Collections.ArrayList> a tipi noti.</span><span class="sxs-lookup"><span data-stu-id="81d28-185">For example, if you declare a data member of type <xref:System.Collections.IEnumerable> and use it to send an instance of <xref:System.Collections.ArrayList>, you do not need to add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="81d28-186">Quando si utilizzano raccolte in modo polimorfico al posto di tipi diversi da raccolte, è necessario aggiungerli ai tipi noti.</span><span class="sxs-lookup"><span data-stu-id="81d28-186">When you use collections polymorphically in place of non-collection types, they must be added to known types.</span></span> <span data-ttu-id="81d28-187">Ad esempio, se si dichiara un membro dati di tipo `Object` e lo si utilizza per inviare un'istanza di <xref:System.Collections.ArrayList>, aggiungere <xref:System.Collections.ArrayList> ai tipi noti.</span><span class="sxs-lookup"><span data-stu-id="81d28-187">For example, if you declare a data member of type `Object` and use it to send an instance of <xref:System.Collections.ArrayList>, add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="81d28-188">Ciò non consente di serializzare eventuali raccolte equivalenti polimorficamente.</span><span class="sxs-lookup"><span data-stu-id="81d28-188">This does not allow you to serialize any equivalent collection polymorphically.</span></span> <span data-ttu-id="81d28-189">Ad esempio, quando si aggiunge <xref:System.Collections.ArrayList> all'elenco di tipi noti nell'esempio precedente, non è consentito assegnare la classe `Array of Object` , anche se presenta un contratto dati equivalente.</span><span class="sxs-lookup"><span data-stu-id="81d28-189">For example, when you add <xref:System.Collections.ArrayList> to the list of known types in the preceding example, this does not let you assign the `Array of Object` class, even though it has an equivalent data contract.</span></span> <span data-ttu-id="81d28-190">Il comportamento normale di tipi noti nel caso della serializzazione per tipi diversi da raccolte non è diverso, ma è particolarmente importante essere a conoscenza di tale funzionamento nel caso delle raccolte perché capita frequentemente che si equivalgano.</span><span class="sxs-lookup"><span data-stu-id="81d28-190">This is no different from regular known types behavior on serialization for non-collection types, but it is especially important to understand in the case of collections because it is very common for collections to be equivalent.</span></span>

<span data-ttu-id="81d28-191">Durante la serializzazione solo un tipo può essere conosciuto in un determinato ambito per un contratto dati specificato e le raccolte equivalenti presentano tutti gli stessi contratti dati.</span><span class="sxs-lookup"><span data-stu-id="81d28-191">During serialization, only one type can be known in any given scope for a given data contract, and equivalent collections all have the same data contracts.</span></span> <span data-ttu-id="81d28-192">Nell'esempio precedente, ciò significa che non è possibile aggiungere sia <xref:System.Collections.ArrayList> sia `Array of Object` ai tipi noti nello stesso ambito.</span><span class="sxs-lookup"><span data-stu-id="81d28-192">This means that, in the previous example, you cannot add both <xref:System.Collections.ArrayList> and `Array of Object` to known types at the same scope.</span></span> <span data-ttu-id="81d28-193">Anche questo caso è equivalente al comportamento dei tipi noti per tipi diversi da raccolte ma è particolarmente importante esserne a conoscenza per quanto riguarda le raccolte.</span><span class="sxs-lookup"><span data-stu-id="81d28-193">Again, this is equivalent to known types behavior for non-collection types, but it is especially important to understand for collections.</span></span>

<span data-ttu-id="81d28-194">È inoltre possibile che i tipi noti siano necessari come contenuto di raccolte.</span><span class="sxs-lookup"><span data-stu-id="81d28-194">Known types may also be required for contents of collections.</span></span> <span data-ttu-id="81d28-195">Se un elemento <xref:System.Collections.ArrayList> , ad esempio, contiene effettivamente istanze di `Type1` e `Type2`, entrambi questi tipi devono essere aggiunti ai tipi noti.</span><span class="sxs-lookup"><span data-stu-id="81d28-195">For example, if an <xref:System.Collections.ArrayList> actually contains instances of `Type1` and `Type2`, both of these types should be added to known types.</span></span>

<span data-ttu-id="81d28-196">Nell'esempio seguente viene illustrato un oggetto grafico costruito correttamente in cui sono utilizzati raccolte e tipi noti.</span><span class="sxs-lookup"><span data-stu-id="81d28-196">The following example shows a properly constructed object graph using collections and known types.</span></span> <span data-ttu-id="81d28-197">L'esempio è stato studiato appositamente in quanto in un'applicazione effettiva i membri dati seguenti non verrebbero normalmente definiti `Object`e quindi non si verificherebbero problemi di polimorfismo/tipi noti.</span><span class="sxs-lookup"><span data-stu-id="81d28-197">The example is somewhat contrived, because in an actual application you would normally not define the following data members as `Object`, and thus do not have any known type/polymorphism issues.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#6)]
[!code-vb[c_collection_types_in_data_contracts#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#6)]

<span data-ttu-id="81d28-198">In fase di deserializzazione, se il tipo dichiarato è un tipo di raccolta, ne viene creata un'istanza indipendentemente dal tipo effettivamente inviato.</span><span class="sxs-lookup"><span data-stu-id="81d28-198">On deserialization, if the declared type is a collection type, the declared type is instantiated regardless of the type that was actually sent.</span></span> <span data-ttu-id="81d28-199">Se il tipo dichiarato è un'interfaccia di raccolta, il deserializzatore sceglie un tipo di cui creare un'istanza senza considerare i tipi noti.</span><span class="sxs-lookup"><span data-stu-id="81d28-199">If the declared type is a collection interface, the deserializer picks a type to be instantiated with no regard to known types.</span></span>

<span data-ttu-id="81d28-200">In fase di deserializzazione, inoltre, se il tipo dichiarato non è un tipo di raccolta ma viene inviato un tipo di raccolta, dall'elenco dei tipi noti viene selezionato un tipo di raccolta corrispondente.</span><span class="sxs-lookup"><span data-stu-id="81d28-200">Also on deserialization, if the declared type is not a collection type but a collection type is being sent, a matching collection type is picked out of the known types list.</span></span> <span data-ttu-id="81d28-201">In fase di deserializzazione è possibile aggiungere tipi di interfaccia di raccolta all'elenco di tipi noti.</span><span class="sxs-lookup"><span data-stu-id="81d28-201">It is possible to add collection interface types to the list of known types on deserialization.</span></span> <span data-ttu-id="81d28-202">Anche in questo caso il motore di deserializzazione sceglie un tipo di cui creare un'istanza.</span><span class="sxs-lookup"><span data-stu-id="81d28-202">In this case, the deserialization engine again picks a type to be instantiated.</span></span>

## <a name="collections-and-the-netdatacontractserializer-class"></a><span data-ttu-id="81d28-203">Raccolte e classe NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="81d28-203">Collections and the NetDataContractSerializer Class</span></span>

<span data-ttu-id="81d28-204">Quando si utilizza la classe <xref:System.Runtime.Serialization.NetDataContractSerializer> , i tipi di raccolta non personalizzati (senza l'attributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> ) che non sono matrici perdono il relativo significato speciale.</span><span class="sxs-lookup"><span data-stu-id="81d28-204">When the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use, non-customized collection types (without the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute) that are not arrays lose their special meaning.</span></span>

<span data-ttu-id="81d28-205">Tipi di raccolta non personalizzati contrassegnati con l'attributo <xref:System.SerializableAttribute> possono comunque essere serializzati dalla classe <xref:System.Runtime.Serialization.NetDataContractSerializer> secondo l'attributo <xref:System.SerializableAttribute> o le regole dell'interfaccia <xref:System.Runtime.Serialization.ISerializable> .</span><span class="sxs-lookup"><span data-stu-id="81d28-205">Non-customized collection types marked with the <xref:System.SerializableAttribute> attribute can still be serialized by the <xref:System.Runtime.Serialization.NetDataContractSerializer> class according to the <xref:System.SerializableAttribute> attribute or the <xref:System.Runtime.Serialization.ISerializable> interface rules.</span></span>

<span data-ttu-id="81d28-206">Tipi di raccolta personalizzati, interfacce di raccolta e matrici vengono comunque considerati raccolte, anche quando la classe <xref:System.Runtime.Serialization.NetDataContractSerializer> è in uso.</span><span class="sxs-lookup"><span data-stu-id="81d28-206">Customized collection types, collection interfaces, and arrays are still treated as collections, even when the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use.</span></span>

## <a name="collections-and-schema"></a><span data-ttu-id="81d28-207">Raccolte e schema</span><span class="sxs-lookup"><span data-stu-id="81d28-207">Collections and Schema</span></span>

<span data-ttu-id="81d28-208">Tutte le raccolte equivalenti presentano la stessa rappresentazione nello schema XSD (XML Schema Definition Language).</span><span class="sxs-lookup"><span data-stu-id="81d28-208">All equivalent collections have the same representation in XML Schema definition language (XSD) schema.</span></span> <span data-ttu-id="81d28-209">Per questo motivo in genere non si ottiene, nel codice client generato, lo stesso tipo di raccolta del codice generato nel server.</span><span class="sxs-lookup"><span data-stu-id="81d28-209">Because of this, you normally do not get the same collection type in the generated client code as the one on the server.</span></span> <span data-ttu-id="81d28-210">Il server, ad esempio, può utilizzare un contratto dati con <xref:System.Collections.Generic.List%601> generico del membro dati Integer ma nel codice client generato lo stesso membro dati può diventare una matrice di numeri interi.</span><span class="sxs-lookup"><span data-stu-id="81d28-210">For example, the server may use a data contract with a Generic <xref:System.Collections.Generic.List%601> of Integer data member, but in the generated client code the same data member may become an array of integers.</span></span>

<span data-ttu-id="81d28-211">Le raccolte di dizionario sono contrassegnate con un'annotazione dello schema specifica di WCF che indica che si tratta di dizionari. in caso contrario, non sono distinguibili da semplici elenchi contenenti voci con una chiave e un valore.</span><span class="sxs-lookup"><span data-stu-id="81d28-211">Dictionary collections are marked with a WCF-specific schema annotation that indicate that they are dictionaries; otherwise, they are indistinguishable from simple lists that contain entries with a key and a value.</span></span> <span data-ttu-id="81d28-212">Per una descrizione più precisa del modo in cui le raccolte vengono rappresentate nello schema del contratto dati, vedere [Data Contract Schema Reference](data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="81d28-212">For an exact description of how collections are represented in data contract schema, see [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span>

<span data-ttu-id="81d28-213">Per impostazione predefinita i tipi non vengono generati per raccolte non personalizzate nel codice importato.</span><span class="sxs-lookup"><span data-stu-id="81d28-213">By default, types are not generated for non-customized collections in imported code.</span></span> <span data-ttu-id="81d28-214">I membri dati di tipi di raccolta di elenco sono importati come matrici e i membri dati di tipi di raccolta di dizionario sono importati come dizionario generico.</span><span class="sxs-lookup"><span data-stu-id="81d28-214">Data members of list collection types are imported as arrays, and data members of dictionary collection types are imported as Generic Dictionary.</span></span>

<span data-ttu-id="81d28-215">Per le raccolte personalizzate, tuttavia, vengono generati tipi separati, contrassegnati con l'attributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> .</span><span class="sxs-lookup"><span data-stu-id="81d28-215">However, for customized collections, separate types are generated, marked with the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute.</span></span> <span data-ttu-id="81d28-216">Un tipo di raccolta personalizzato nello schema è uno che non usa lo spazio dei nomi predefinito, il nome, il nome dell'elemento ripetuto o i nomi degli elementi chiave/valore. Questi tipi sono tipi vuoti che derivano da Generic <xref:System.Collections.Generic.List%601> per i tipi di elenco e dizionario generico per i tipi di dizionario.</span><span class="sxs-lookup"><span data-stu-id="81d28-216">(A customized collection type in the schema is one that does not use the default namespace, name, repeating element name, or key/value element names.) These types are empty types that derive from Generic <xref:System.Collections.Generic.List%601> for list types and Generic Dictionary for dictionary types.</span></span>

<span data-ttu-id="81d28-217">È ad esempio possibile che nel server siano presenti i tipi seguenti.</span><span class="sxs-lookup"><span data-stu-id="81d28-217">For example, you may have the following types on the server.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#7)]
[!code-vb[c_collection_types_in_data_contracts#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#7)]

<span data-ttu-id="81d28-218">Quando lo schema viene esportato per poi essere nuovamente importato, il codice client generato è simile al seguente (per facilità di lettura vengono mostrati i campi anziché le proprietà):</span><span class="sxs-lookup"><span data-stu-id="81d28-218">When the schema is exported and imported back again, the generated client code is similar to the following (fields are shown instead of properties for ease of reading).</span></span>

[!code-csharp[c_collection_types_in_data_contracts#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#8)]
[!code-vb[c_collection_types_in_data_contracts#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#8)]

<span data-ttu-id="81d28-219">È consigliabile utilizzare tipi diversi nel codice generato anziché i tipi predefiniti.</span><span class="sxs-lookup"><span data-stu-id="81d28-219">You may want to use different types in generated code than the default ones.</span></span> <span data-ttu-id="81d28-220">È ad esempio opportuno utilizzare <xref:System.ComponentModel.BindingList%601> generico anziché matrici normali dei membri dati per semplificarne l'associazione ai componenti dell'interfaccia utente.</span><span class="sxs-lookup"><span data-stu-id="81d28-220">For example, you may want to use Generic <xref:System.ComponentModel.BindingList%601> instead of regular arrays for your data members to make it easier to bind them to user interface components.</span></span>

<span data-ttu-id="81d28-221">Per scegliere i tipi di raccolta da generare, durante l'importazione dello schema passare un elenco dei tipi di raccolta che si desidera utilizzare nella proprietà <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> dell'oggetto <xref:System.Runtime.Serialization.ImportOptions> .</span><span class="sxs-lookup"><span data-stu-id="81d28-221">To choose collection types to generate, pass a list of collection types you want to use into the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property of the <xref:System.Runtime.Serialization.ImportOptions> object when importing schema.</span></span> <span data-ttu-id="81d28-222">Questi tipi sono chiamati *tipi di raccolta a cui viene fatto riferimento*.</span><span class="sxs-lookup"><span data-stu-id="81d28-222">These types are called *referenced collection types*.</span></span>

<span data-ttu-id="81d28-223">Quando si fa riferimento a tipi generici, deve trattarsi di generics completamente aperti o di generics completamente chiusi.</span><span class="sxs-lookup"><span data-stu-id="81d28-223">When generic types are being referenced, they must either be fully-open generics or fully-closed generics.</span></span>

> [!NOTE]
> <span data-ttu-id="81d28-224">Quando si usa lo strumento Svcutil.exe, questo riferimento può essere eseguito usando l'opzione della riga di comando **/collectionType** (forma breve: **/ct**).</span><span class="sxs-lookup"><span data-stu-id="81d28-224">When using the Svcutil.exe tool, this reference can be accomplished by using the **/collectionType** command-line switch (short form: **/ct**).</span></span> <span data-ttu-id="81d28-225">È importante ricordare che è anche necessario specificare l'assembly per i tipi di raccolta a cui viene fatto riferimento usando l'opzione **/reference** (forma breve: **/r**).</span><span class="sxs-lookup"><span data-stu-id="81d28-225">Keep in mind that you must also specify the assembly for the referenced collection types using the **/reference** switch (short form: **/r**).</span></span> <span data-ttu-id="81d28-226">Se il tipo è generico, deve essere seguito da una virgoletta inversa e dal numero di parametri generici.</span><span class="sxs-lookup"><span data-stu-id="81d28-226">If the type is generic, it must be followed by a back quote and the number of generic parameters.</span></span> <span data-ttu-id="81d28-227">La virgoletta indietro ( \` ) non deve essere confusa con il carattere virgoletta singola (').</span><span class="sxs-lookup"><span data-stu-id="81d28-227">The back quote (\`) is not to be confused with the single quote (‘) character.</span></span> <span data-ttu-id="81d28-228">È possibile specificare più tipi di raccolta a cui viene fatto riferimento usando l'opzione **/collectionType** più di una volta.</span><span class="sxs-lookup"><span data-stu-id="81d28-228">You can specify multiple referenced collection types by using the **/collectionType** switch more than once.</span></span>

<span data-ttu-id="81d28-229">Ad esempio, per fare in modo che tutti gli elenchi vengano importati come oggetto <xref:System.Collections.Generic.List%601>generico.</span><span class="sxs-lookup"><span data-stu-id="81d28-229">For example, to cause all lists to be imported as Generic <xref:System.Collections.Generic.List%601>.</span></span>

```console
svcutil.exe MyService.wsdl MyServiceSchema.xsd /r:C:\full_path_to_system_dll\System.dll /ct:System.Collections.Generic.List`1
```

<span data-ttu-id="81d28-230">Quando si importa una raccolta, l'elenco di tipi di raccolta a cui si fa riferimento viene analizzato e viene utilizzata la raccolta con la migliore corrispondenza trovata, come tipo di membro dati (per le raccolte non personalizzate) o come tipo di base per la derivazione (per le raccolte personalizzate).</span><span class="sxs-lookup"><span data-stu-id="81d28-230">When importing any collection, this list of referenced collection types is scanned, and the best-matching collection is used if one is found, either as a data member type (for non-customized collections) or as a base type to derive from (for customized collections).</span></span> <span data-ttu-id="81d28-231">I dizionari vengono associati solo a dizionari mentre gli elenchi a elenchi.</span><span class="sxs-lookup"><span data-stu-id="81d28-231">Dictionaries are only matched against dictionaries, while lists are matched against lists.</span></span>

<span data-ttu-id="81d28-232">Se ad esempio si aggiungono la classe <xref:System.ComponentModel.BindingList%601> generica e la classe <xref:System.Collections.Hashtable> all'elenco di tipi a cui viene fatto riferimento, il codice client generato per l'esempio precedente sarà simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="81d28-232">For example, if you add the Generic <xref:System.ComponentModel.BindingList%601> and <xref:System.Collections.Hashtable> to the list of referenced types, the generated client code for the preceding example is similar to the following.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#9)]
[!code-vb[c_collection_types_in_data_contracts#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#9)]

<span data-ttu-id="81d28-233">È possibile specificare i tipi di interfaccia di raccolta nell'ambito dei tipi di raccolta a cui si fa riferimento, ma non è possibile specificare tipi di raccolta non validi (ad esempio tipi senza il metodo `Add` o il costruttore pubblico).</span><span class="sxs-lookup"><span data-stu-id="81d28-233">You can specify collection interface types as part of your referenced collection types, but you cannot specify invalid collection types (such as ones with no `Add` method or public constructor).</span></span>

<span data-ttu-id="81d28-234">Un generico chiuso è considerato la corrispondenza migliore</span><span class="sxs-lookup"><span data-stu-id="81d28-234">A closed generic is considered to be the best match.</span></span> <span data-ttu-id="81d28-235">(i tipi non generici sono considerati equivalenti ai generics chiusi di `Object`).</span><span class="sxs-lookup"><span data-stu-id="81d28-235">(Non-generic types are considered equivalent to closed generics of `Object`).</span></span> <span data-ttu-id="81d28-236">Se ad esempio i tipi <xref:System.Collections.Generic.List%601> generico di <xref:System.DateTime>, <xref:System.ComponentModel.BindingList%601> generico (generico aperto) e <xref:System.Collections.ArrayList> sono tipi di raccolta a cui viene fatto riferimento, viene generato il codice seguente:</span><span class="sxs-lookup"><span data-stu-id="81d28-236">For example, if the types Generic <xref:System.Collections.Generic.List%601> of <xref:System.DateTime>, Generic <xref:System.ComponentModel.BindingList%601> (open generic), and <xref:System.Collections.ArrayList> are the referenced collection types, the following is generated.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#10)]
[!code-vb[c_collection_types_in_data_contracts#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#10)]

<span data-ttu-id="81d28-237">Per le raccolte di elenchi, sono supportati solo i casi illustrati nella tabella seguente:</span><span class="sxs-lookup"><span data-stu-id="81d28-237">For list collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="81d28-238">Tipo a cui viene fatto riferimento</span><span class="sxs-lookup"><span data-stu-id="81d28-238">Referenced type</span></span>|<span data-ttu-id="81d28-239">Interfaccia implementata dal tipo a cui viene fatto riferimento</span><span class="sxs-lookup"><span data-stu-id="81d28-239">Interface implemented by referenced type</span></span>|<span data-ttu-id="81d28-240">Esempio</span><span class="sxs-lookup"><span data-stu-id="81d28-240">Example</span></span>|<span data-ttu-id="81d28-241">Tipo trattato come:</span><span class="sxs-lookup"><span data-stu-id="81d28-241">Type treated as:</span></span>|
|---------------------|----------------------------------------------|-------------|----------------------|
|<span data-ttu-id="81d28-242">Non generico o generico chiuso (qualsiasi numero di parametri)</span><span class="sxs-lookup"><span data-stu-id="81d28-242">Non-generic or closed generic (any number of parameters)</span></span>|<span data-ttu-id="81d28-243">Non generico</span><span class="sxs-lookup"><span data-stu-id="81d28-243">Non-generic</span></span>|`MyType : IList`<br /><br /> <span data-ttu-id="81d28-244">oppure</span><span class="sxs-lookup"><span data-stu-id="81d28-244">or</span></span><br /><br /> `MyType<T> : IList`<br /><br /> <span data-ttu-id="81d28-245">dove T= `int`</span><span class="sxs-lookup"><span data-stu-id="81d28-245">where T= `int`</span></span>|<span data-ttu-id="81d28-246">Generico chiuso di `Object` (ad esempio, `IList<object>`)</span><span class="sxs-lookup"><span data-stu-id="81d28-246">Closed generic of `Object` (for example, `IList<object>`)</span></span>|
|<span data-ttu-id="81d28-247">Non generico o generico chiuso (qualsiasi numero di parametri che non corrispondono necessariamente al tipo di raccolta)</span><span class="sxs-lookup"><span data-stu-id="81d28-247">Non-generic or closed generic (any number of parameters that do not necessarily match the collection type)</span></span>|<span data-ttu-id="81d28-248">Generico chiuso</span><span class="sxs-lookup"><span data-stu-id="81d28-248">Closed generic</span></span>|`MyType : IList<string>`<br /><br /> <span data-ttu-id="81d28-249">oppure</span><span class="sxs-lookup"><span data-stu-id="81d28-249">or</span></span><br /><br /> <span data-ttu-id="81d28-250">`MyType<T> : IList<string>` dove T=`int`</span><span class="sxs-lookup"><span data-stu-id="81d28-250">`MyType<T> : IList<string>` where T=`int`</span></span>|<span data-ttu-id="81d28-251">Generico chiuso (ad esempio `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="81d28-251">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="81d28-252">Generico chiuso con qualsiasi numero di parametri</span><span class="sxs-lookup"><span data-stu-id="81d28-252">Closed generic with any number of parameters</span></span>|<span data-ttu-id="81d28-253">Generico aperto che utilizza qualsiasi parametro del tipo</span><span class="sxs-lookup"><span data-stu-id="81d28-253">Open generic using any one of the type’s parameters</span></span>|`MyType<T,U,V> : IList<U>`<br /><br /> <span data-ttu-id="81d28-254">dove T=`int`, U=`string`, V=`bool`</span><span class="sxs-lookup"><span data-stu-id="81d28-254">where T=`int`, U=`string`, V=`bool`</span></span>|<span data-ttu-id="81d28-255">Generico chiuso (ad esempio `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="81d28-255">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="81d28-256">Generico aperto con un parametro</span><span class="sxs-lookup"><span data-stu-id="81d28-256">Open generic with one parameter</span></span>|<span data-ttu-id="81d28-257">Generico aperto che utilizza il parametro del tipo</span><span class="sxs-lookup"><span data-stu-id="81d28-257">Open generic using the type’s parameter</span></span>|<span data-ttu-id="81d28-258">`MyType<T> : IList<T>`, T è aperto</span><span class="sxs-lookup"><span data-stu-id="81d28-258">`MyType<T> : IList<T>`, T is open</span></span>|<span data-ttu-id="81d28-259">Generico aperto (ad esempio `IList<T>`)</span><span class="sxs-lookup"><span data-stu-id="81d28-259">Open generic (for example, `IList<T>`)</span></span>|

<span data-ttu-id="81d28-260">Se un tipo implementa più di un'interfaccia della raccolta di elenco, vengono applicate le restrizioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="81d28-260">If a type implements more than one list collection interface, the following restrictions apply:</span></span>

- <span data-ttu-id="81d28-261">Se il tipo implementa <xref:System.Collections.Generic.IEnumerable%601> generico (o le interfacce derivate) più volte per tipi diversi, non viene considerato un tipo di raccolta a cui fare riferimento valido e viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="81d28-261">If the type implements Generic <xref:System.Collections.Generic.IEnumerable%601> (or its derived interfaces) multiple times for different types, the type is not considered a valid referenced collection type and is ignored.</span></span> <span data-ttu-id="81d28-262">Questa condizione è vera anche se alcune implementazioni non sono valide o utilizzano generics aperti.</span><span class="sxs-lookup"><span data-stu-id="81d28-262">This is true even if some implementations are invalid or use open generics.</span></span> <span data-ttu-id="81d28-263">Un tipo che implementa <xref:System.Collections.Generic.IEnumerable%601> generico di `int` e <xref:System.Collections.Generic.IEnumerable%601> generico di T, ad esempio, non verrebbe mai utilizzato come raccolta a cui si fa riferimento di `int` o di qualsiasi altro tipo, indipendentemente dalla circostanza che il tipo abbia un metodo `Add` che accetta `int` o un metodo `Add` che accetta un parametro di tipo T o entrambi.</span><span class="sxs-lookup"><span data-stu-id="81d28-263">For example, a type that implements Generic <xref:System.Collections.Generic.IEnumerable%601> of `int` and Generic <xref:System.Collections.Generic.IEnumerable%601> of T would never be used as a referenced collection of `int` or any other type, regardless of whether the type has an `Add` method accepting `int` or an `Add` method accepting a parameter of type T, or both.</span></span>

- <span data-ttu-id="81d28-264">Se il tipo implementa un'interfaccia di raccolta generica oltre a <xref:System.Collections.IList>, non viene mai utilizzato come tipo di raccolta a cui si fa riferimento, a meno che l'interfaccia di raccolta generica non sia una generica chiusa di tipo <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="81d28-264">If the type implements a generic collection interface as well as <xref:System.Collections.IList>, the type is never used as a referenced collection type unless the generic collection interface is a closed generic of type <xref:System.Object>.</span></span>

<span data-ttu-id="81d28-265">Per le raccolte di dizionario, sono supportati solo i casi illustrati nella tabella seguente:</span><span class="sxs-lookup"><span data-stu-id="81d28-265">For dictionary collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="81d28-266">Tipo a cui viene fatto riferimento</span><span class="sxs-lookup"><span data-stu-id="81d28-266">Referenced type</span></span>|<span data-ttu-id="81d28-267">Interfaccia implementata dal tipo a cui viene fatto riferimento</span><span class="sxs-lookup"><span data-stu-id="81d28-267">Interface implemented by referenced type</span></span>|<span data-ttu-id="81d28-268">Esempio</span><span class="sxs-lookup"><span data-stu-id="81d28-268">Example</span></span>|<span data-ttu-id="81d28-269">Tipo trattato come</span><span class="sxs-lookup"><span data-stu-id="81d28-269">Type treated as</span></span>|
|---------------------|----------------------------------------------|-------------|---------------------|
|<span data-ttu-id="81d28-270">Non generico o generico chiuso (qualsiasi numero di parametri)</span><span class="sxs-lookup"><span data-stu-id="81d28-270">Non-generic or closed generic (any number of parameters)</span></span>|<xref:System.Collections.IDictionary>|`MyType : IDictionary`<br /><br /> <span data-ttu-id="81d28-271">oppure</span><span class="sxs-lookup"><span data-stu-id="81d28-271">or</span></span><br /><br /> <span data-ttu-id="81d28-272">`MyType<T> : IDictionary` dove T=`int`</span><span class="sxs-lookup"><span data-stu-id="81d28-272">`MyType<T> : IDictionary` where T=`int`</span></span>|<span data-ttu-id="81d28-273">Generico chiuso `IDictionary<object,object>`</span><span class="sxs-lookup"><span data-stu-id="81d28-273">Closed generic `IDictionary<object,object>`</span></span>|
|<span data-ttu-id="81d28-274">Generico chiuso (qualsiasi numero di parametri)</span><span class="sxs-lookup"><span data-stu-id="81d28-274">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="81d28-275"><xref:System.Collections.Generic.IDictionary%602>, chiuso</span><span class="sxs-lookup"><span data-stu-id="81d28-275"><xref:System.Collections.Generic.IDictionary%602>, closed</span></span>|<span data-ttu-id="81d28-276">`MyType<T> : IDictionary<string, bool>` dove T=`int`</span><span class="sxs-lookup"><span data-stu-id="81d28-276">`MyType<T> : IDictionary<string, bool>` where T=`int`</span></span>|<span data-ttu-id="81d28-277">Generico chiuso (ad esempio `IDIctionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="81d28-277">Closed generic (for example, `IDIctionary<string,bool>`)</span></span>|
|<span data-ttu-id="81d28-278">Generico chiuso (qualsiasi numero di parametri)</span><span class="sxs-lookup"><span data-stu-id="81d28-278">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="81d28-279"><xref:System.Collections.Generic.IDictionary%602>generico, la chiave o il valore è chiuso, l'altro è aperto e utilizza uno dei parametri del tipo</span><span class="sxs-lookup"><span data-stu-id="81d28-279">Generic <xref:System.Collections.Generic.IDictionary%602>, one of either key or value is closed, the other is open and uses one of type’s parameters</span></span>|<span data-ttu-id="81d28-280">`MyType<T,U,V> : IDictionary<string,V>` dove T=`int`, U=`float`, V=`bool`</span><span class="sxs-lookup"><span data-stu-id="81d28-280">`MyType<T,U,V> : IDictionary<string,V>` where T=`int`, U=`float`,V=`bool`</span></span><br /><br /> <span data-ttu-id="81d28-281">oppure</span><span class="sxs-lookup"><span data-stu-id="81d28-281">or</span></span><br /><br /> <span data-ttu-id="81d28-282">`MyType<Z> : IDictionary<Z,bool>` dove Z=`string`</span><span class="sxs-lookup"><span data-stu-id="81d28-282">`MyType<Z> : IDictionary<Z,bool>` where Z=`string`</span></span>|<span data-ttu-id="81d28-283">Generico chiuso (ad esempio `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="81d28-283">Closed generic (For example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="81d28-284">Generico chiuso (qualsiasi numero di parametri)</span><span class="sxs-lookup"><span data-stu-id="81d28-284">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="81d28-285"><xref:System.Collections.Generic.IDictionary%602>generico, chiave e valore sono aperti e ognuno utilizza uno dei parametri del tipo</span><span class="sxs-lookup"><span data-stu-id="81d28-285">Generic <xref:System.Collections.Generic.IDictionary%602>, both key and value are open and each uses one of the type’s parameters</span></span>|<span data-ttu-id="81d28-286">`MyType<T,U,V> : IDictionary<V,U>` dove T=`int`, U=`bool`, V=`string`</span><span class="sxs-lookup"><span data-stu-id="81d28-286">`MyType<T,U,V> : IDictionary<V,U>` where T=`int`, U=`bool`, V=`string`</span></span>|<span data-ttu-id="81d28-287">Generico chiuso (ad esempio `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="81d28-287">Closed generic (for example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="81d28-288">Generico aperto (due parametri)</span><span class="sxs-lookup"><span data-stu-id="81d28-288">Open generic (two parameters)</span></span>|<span data-ttu-id="81d28-289"><xref:System.Collections.Generic.IDictionary%602>generico, aperto, utilizza entrambi i parametri generici del tipo nell'ordine in cui sono visualizzati.</span><span class="sxs-lookup"><span data-stu-id="81d28-289">Generic <xref:System.Collections.Generic.IDictionary%602>, open, uses both of the type’s generic parameters in the order they appear</span></span>|<span data-ttu-id="81d28-290">`MyType<K,V> : IDictionary<K,V>`, K e V entrambi aperti</span><span class="sxs-lookup"><span data-stu-id="81d28-290">`MyType<K,V> : IDictionary<K,V>`, K and V both open</span></span>|<span data-ttu-id="81d28-291">Generico aperto (ad esempio `IDictionary<K,V>`)</span><span class="sxs-lookup"><span data-stu-id="81d28-291">Open generic (for example, `IDictionary<K,V>`)</span></span>|

<span data-ttu-id="81d28-292">Se il tipo implementa sia <xref:System.Collections.IDictionary> che <xref:System.Collections.Generic.IDictionary%602>generico, solo <xref:System.Collections.Generic.IDictionary%602> generico viene considerato.</span><span class="sxs-lookup"><span data-stu-id="81d28-292">If the type implements both <xref:System.Collections.IDictionary> and Generic <xref:System.Collections.Generic.IDictionary%602>, only Generic <xref:System.Collections.Generic.IDictionary%602> is considered.</span></span>

<span data-ttu-id="81d28-293">Il riferimento a tipi generici parziali non è supportato.</span><span class="sxs-lookup"><span data-stu-id="81d28-293">Referencing partial generic types is not supported.</span></span>

<span data-ttu-id="81d28-294">I duplicati non sono consentiti, ad esempio non è possibile aggiungere l'oggetto <xref:System.Collections.Generic.List%601> generico di `Integer` e la raccolta generica di `Integer` a <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, perché ciò renderebbe impossibile stabilire quale utilizzare quando nello schema viene trovato un elenco di valori integer.</span><span class="sxs-lookup"><span data-stu-id="81d28-294">Duplicates are not allowed, for example, you cannot add both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` to <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, because this makes it impossible to determine which one to use when a list of integers is found in the schema.</span></span> <span data-ttu-id="81d28-295">I duplicati vengono rilevati solo se nello schema esiste un tipo che espone il problema dei duplicati.</span><span class="sxs-lookup"><span data-stu-id="81d28-295">Duplicates are detected only if there is a type in the schema that exposes the duplicates problem.</span></span> <span data-ttu-id="81d28-296">Se ad esempio lo schema importato non contiene elenchi di numeri interi, è consentito disporre sia di <xref:System.Collections.Generic.List%601> generico di `Integer` che della raccolta generica di `Integer` nella proprietà <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, ma nessuno esercita alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="81d28-296">For example, if the schema being imported does not contain lists of integers, it is allowed to have both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` in the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, but neither has any effect.</span></span>

## <a name="advanced-collection-rules"></a><span data-ttu-id="81d28-297">Regole avanzate di inserimento in raccolte</span><span class="sxs-lookup"><span data-stu-id="81d28-297">Advanced Collection Rules</span></span>

### <a name="serializing-collections"></a><span data-ttu-id="81d28-298">Serializzazione delle raccolte</span><span class="sxs-lookup"><span data-stu-id="81d28-298">Serializing Collections</span></span>

<span data-ttu-id="81d28-299">Di seguito vengono elencate le regole per la serializzazione delle raccolte:</span><span class="sxs-lookup"><span data-stu-id="81d28-299">The following is a list of collection rules for serialization:</span></span>

- <span data-ttu-id="81d28-300">La combinazione di tipi di raccolta (con raccolte di raccolte) è consentita.</span><span class="sxs-lookup"><span data-stu-id="81d28-300">Combining collection types (having collections of collections) is allowed.</span></span> <span data-ttu-id="81d28-301">Le matrici di matrici vengono trattate come raccolte di raccolte.</span><span class="sxs-lookup"><span data-stu-id="81d28-301">Jagged arrays are treated as collections of collections.</span></span> <span data-ttu-id="81d28-302">Le matrici multidimensionali non sono supportate.</span><span class="sxs-lookup"><span data-stu-id="81d28-302">Multidimensional arrays are not supported.</span></span>

- <span data-ttu-id="81d28-303">Matrici di byte e matrici di <xref:System.Xml.XmlNode> sono tipi speciali di matrici trattati come primitivi, non come raccolte.</span><span class="sxs-lookup"><span data-stu-id="81d28-303">Arrays of byte and arrays of <xref:System.Xml.XmlNode> are special array types that are treated as primitives, not collections.</span></span> <span data-ttu-id="81d28-304">La serializzazione di una matrice di byte genera un singolo elemento XML contenente un blocco di dati con codifica Base64 anziché un elemento separato per ogni byte.</span><span class="sxs-lookup"><span data-stu-id="81d28-304">Serializing an array of byte results in a single XML element that contains a chunk of Base64-encoded data, instead of a separate element for each byte.</span></span> <span data-ttu-id="81d28-305">Per ulteriori informazioni sul modo <xref:System.Xml.XmlNode> in cui viene trattata una matrice di, vedere [tipi XML e ADO.NET nei contratti dati](xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="81d28-305">For more information about how an array of <xref:System.Xml.XmlNode> is treated, see [XML and ADO.NET Types in Data Contracts](xml-and-ado-net-types-in-data-contracts.md).</span></span> <span data-ttu-id="81d28-306">Questi tipi speciali, naturalmente, possono fare parte delle raccolte: una matrice di matrice di byte sfocia in più elementi XML, ognuno dei quali contiene un blocco di dati con codifica Base64.</span><span class="sxs-lookup"><span data-stu-id="81d28-306">Of course, these special types can themselves participate in collections: an array of array of byte results in multiple XML elements, with each containing a chunk of Base64-encoded data.</span></span>

- <span data-ttu-id="81d28-307">Se l'attributo <xref:System.Runtime.Serialization.DataContractAttribute> viene applicato a un tipo di raccolta, il tipo viene trattato come tipo di contratto dati normale, non come una raccolta.</span><span class="sxs-lookup"><span data-stu-id="81d28-307">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a collection type, the type is treated as a regular data contract type, not as a collection.</span></span>

- <span data-ttu-id="81d28-308">Se un tipo di raccolta implementa l'interfaccia <xref:System.Xml.Serialization.IXmlSerializable> , vengono applicate le regole seguenti, dato un tipo `myType:IList<string>, IXmlSerializable`:</span><span class="sxs-lookup"><span data-stu-id="81d28-308">If a collection type implements the <xref:System.Xml.Serialization.IXmlSerializable> interface, the following rules apply, given a type `myType:IList<string>, IXmlSerializable`:</span></span>

  - <span data-ttu-id="81d28-309">Il tipo di dichiarato è `IList<string>`, il tipo è serializzato come elenco.</span><span class="sxs-lookup"><span data-stu-id="81d28-309">If the declared type is `IList<string>`, the type is serialized as a list.</span></span>

  - <span data-ttu-id="81d28-310">Il tipo di dichiarato è `myType`, ed è serializzato come `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="81d28-310">If the declared type is `myType`, it is serialized as `IXmlSerializable`.</span></span>

  - <span data-ttu-id="81d28-311">Se il tipo dichiarato è `IXmlSerializable`, viene serializzato come `IXmlSerializable`, ma solo se si aggiunge `myType` all'elenco dei tipi noti.</span><span class="sxs-lookup"><span data-stu-id="81d28-311">If the declared type is `IXmlSerializable`, it is serialized as `IXmlSerializable`, but only if you add `myType` to the list of known types.</span></span>

- <span data-ttu-id="81d28-312">Le raccolte vengono serializzate e deserializzate tramite i metodi illustrati nella tabella seguente:</span><span class="sxs-lookup"><span data-stu-id="81d28-312">Collections are serialized and deserialized using the methods shown in the following table.</span></span>

|<span data-ttu-id="81d28-313">Il tipo di raccolta implementa</span><span class="sxs-lookup"><span data-stu-id="81d28-313">Collection type implements</span></span>|<span data-ttu-id="81d28-314">Metodo/i chiamato/i durante la serializzazione</span><span class="sxs-lookup"><span data-stu-id="81d28-314">Method(s) called on serialization</span></span>|<span data-ttu-id="81d28-315">Metodo/i chiamato/i durante la deserializzazione</span><span class="sxs-lookup"><span data-stu-id="81d28-315">Method(s) called on deserialization</span></span>|
|--------------------------------|-----------------------------------------|-------------------------------------------|
|Generic <ph id="ph1">&lt;xref:System.Collections.Generic.IDictionary%602&gt;</ph>|<span data-ttu-id="81d28-317">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="81d28-317">`get_Keys`, `get_Values`</span></span>|<span data-ttu-id="81d28-318">Add generico</span><span class="sxs-lookup"><span data-stu-id="81d28-318">Generic Add</span></span>|
|<xref:System.Collections.IDictionary>|<span data-ttu-id="81d28-319">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="81d28-319">`get_Keys`, `get_Values`</span></span>|`Add`|
|Generic <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601&gt;</ph>|<span data-ttu-id="81d28-321">Indicizzatore <xref:System.Collections.Generic.IList%601> generico</span><span class="sxs-lookup"><span data-stu-id="81d28-321">Generic <xref:System.Collections.Generic.IList%601> indexer</span></span>|<span data-ttu-id="81d28-322">Add generico</span><span class="sxs-lookup"><span data-stu-id="81d28-322">Generic Add</span></span>|
|Generic <ph id="ph1">&lt;xref:System.Collections.Generic.ICollection%601&gt;</ph>|<span data-ttu-id="81d28-324">Enumeratore</span><span class="sxs-lookup"><span data-stu-id="81d28-324">Enumerator</span></span>|<span data-ttu-id="81d28-325">Add generico</span><span class="sxs-lookup"><span data-stu-id="81d28-325">Generic Add</span></span>|
|<xref:System.Collections.IList>|<span data-ttu-id="81d28-326">Indicizzatore<xref:System.Collections.IList></span><span class="sxs-lookup"><span data-stu-id="81d28-326"><xref:System.Collections.IList> Indexer</span></span>|`Add`|
|Generic <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>|`GetEnumerator`|<span data-ttu-id="81d28-328">Metodo non statico denominato `Add` che accetta un parametro del tipo appropriato (il tipo del parametro generico o uno dei tipi di base).</span><span class="sxs-lookup"><span data-stu-id="81d28-328">A non-static method called `Add` that takes one parameter of the appropriate type (the type of the generic parameter or one of its base types).</span></span> <span data-ttu-id="81d28-329">È necessario che tale metodo esista affinché il serializzatore tratti un tipo di raccolta come raccolta sia durante la serializzazione che durante la deserializzazione.</span><span class="sxs-lookup"><span data-stu-id="81d28-329">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|
|<span data-ttu-id="81d28-330"><xref:System.Collections.IEnumerable> (e di conseguenza <xref:System.Collections.ICollection>, interfaccia derivata)</span><span class="sxs-lookup"><span data-stu-id="81d28-330"><xref:System.Collections.IEnumerable> (and thus <xref:System.Collections.ICollection>, which derives from it)</span></span>|`GetEnumerator`|<span data-ttu-id="81d28-331">Metodo non statico denominato `Add` che accetta un parametro di tipo `Object`.</span><span class="sxs-lookup"><span data-stu-id="81d28-331">A non-static method called `Add` that takes one parameter of type `Object`.</span></span> <span data-ttu-id="81d28-332">È necessario che tale metodo esista affinché il serializzatore tratti un tipo di raccolta come raccolta sia durante la serializzazione che durante la deserializzazione.</span><span class="sxs-lookup"><span data-stu-id="81d28-332">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|

<span data-ttu-id="81d28-333">Nella tabella precedente sono elencate le interfacce di raccolta in ordine decrescente di precedenza.</span><span class="sxs-lookup"><span data-stu-id="81d28-333">The preceding table lists collection interfaces in descending order of precedence.</span></span> <span data-ttu-id="81d28-334">Se un tipo implementa sia <xref:System.Collections.IList> che <xref:System.Collections.Generic.IEnumerable%601>generico, ad esempio, la raccolta viene serializzata e deserializzata secondo le regole di <xref:System.Collections.IList> :</span><span class="sxs-lookup"><span data-stu-id="81d28-334">This means, for example, that if a type implements both <xref:System.Collections.IList> and Generic <xref:System.Collections.Generic.IEnumerable%601>, the collection is serialized and deserialized according to the <xref:System.Collections.IList> rules:</span></span>

- <span data-ttu-id="81d28-335">Alla deserializzazione, tutte le raccolte vengono deserializzate creando innanzitutto un'istanza del tipo chiamando il costruttore senza parametri, che deve essere presente affinché il serializzatore tratti un tipo di raccolta come raccolta durante la serializzazione e la deserializzazione.</span><span class="sxs-lookup"><span data-stu-id="81d28-335">At deserialization, all collections are deserialized by first creating an instance of the type by calling the parameterless constructor, which must be present for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>

- <span data-ttu-id="81d28-336">Se la stessa interfaccia di raccolta generica viene implementata più di una volta (ad esempio se un tipo implementa sia <xref:System.Collections.Generic.ICollection%601> generica di `Integer` che <xref:System.Collections.Generic.ICollection%601> generica di <xref:System.String>) e non viene trovata nessuna interfaccia con un livello di precedenza maggiore, la raccolta non viene trattata come raccolta valida.</span><span class="sxs-lookup"><span data-stu-id="81d28-336">If the same generic collection interface is implemented more than once (for example, if a type implements both Generic <xref:System.Collections.Generic.ICollection%601> of `Integer` and Generic <xref:System.Collections.Generic.ICollection%601> of <xref:System.String>) and no higher-precedence interface is found, the collection is not treated as a valid collection.</span></span>

- <span data-ttu-id="81d28-337">L'attributo <xref:System.SerializableAttribute> può essere applicato ai tipi di raccolta, i quali possono implementare l'interfaccia <xref:System.Runtime.Serialization.ISerializable> .</span><span class="sxs-lookup"><span data-stu-id="81d28-337">Collection types can have the <xref:System.SerializableAttribute> attribute applied to them and can implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span> <span data-ttu-id="81d28-338">Entrambi vengono ignorati.</span><span class="sxs-lookup"><span data-stu-id="81d28-338">Both of these are ignored.</span></span> <span data-ttu-id="81d28-339">Se, tuttavia, il tipo non soddisfa pienamente i requisiti del tipo di raccolta (ad esempio, manca il metodo `Add` ), il tipo non viene considerato un tipo di raccolta, di conseguenza per stabilire se il tipo può essere serializzato, vengono utilizzati l'attributo <xref:System.SerializableAttribute> e l'interfaccia <xref:System.Runtime.Serialization.ISerializable> .</span><span class="sxs-lookup"><span data-stu-id="81d28-339">However, if the type does not fully meet collection type requirements (for example, the `Add` method is missing), the type is not considered a collection type, and thus the <xref:System.SerializableAttribute> attribute and the <xref:System.Runtime.Serialization.ISerializable> interface are used to determine whether the type can be serialized.</span></span>

- <span data-ttu-id="81d28-340">L'applicazione dell'attributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> a una raccolta per personalizzarlo rimuove il meccanismo di fallback di <xref:System.SerializableAttribute> precedente.</span><span class="sxs-lookup"><span data-stu-id="81d28-340">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a collection to customize it removes the <xref:System.SerializableAttribute> preceding fallback mechanism.</span></span> <span data-ttu-id="81d28-341">Se invece una raccolta personalizzata non soddisfa i requisiti del tipo di raccolta, viene generata un'eccezione <xref:System.Runtime.Serialization.InvalidDataContractException> .</span><span class="sxs-lookup"><span data-stu-id="81d28-341">Instead, if a customized collection does not meet collection type requirements, an <xref:System.Runtime.Serialization.InvalidDataContractException> exception is thrown.</span></span> <span data-ttu-id="81d28-342">La stringa di eccezione contiene spesso informazioni che spiegano il motivo per cui un determinato tipo non viene considerato una raccolta valida (nessun `Add` metodo, nessun costruttore senza parametri e così via), quindi è spesso utile applicare l' <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attributo a scopo di debug.</span><span class="sxs-lookup"><span data-stu-id="81d28-342">The exception string often contains information that explains why a given type is not considered a valid collection (no `Add` method, no parameterless constructor, and so on), so it is often useful to apply the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute for debugging purposes.</span></span>

### <a name="collection-naming"></a><span data-ttu-id="81d28-343">Denominazione di raccolte</span><span class="sxs-lookup"><span data-stu-id="81d28-343">Collection Naming</span></span>

<span data-ttu-id="81d28-344">Di seguito vengono elencate le regole di denominazione delle raccolte:</span><span class="sxs-lookup"><span data-stu-id="81d28-344">The following is a list of collection naming rules:</span></span>

- <span data-ttu-id="81d28-345">Lo spazio dei nomi predefinito per tutti i contratti dati della raccolta dizionario, nonché per i contratti dati della raccolta di elenchi contenenti tipi primitivi, è `http://schemas.microsoft.com/2003/10/Serialization/Arrays` a meno che non venga sottoposto a override tramite lo spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="81d28-345">The default namespace for all dictionary collection data contracts, as well as for list collection data contracts that contain primitive types, is `http://schemas.microsoft.com/2003/10/Serialization/Arrays` unless overridden using Namespace.</span></span> <span data-ttu-id="81d28-346">I tipi che eseguono il mapping a tipi XSD incorporati, nonché i tipi `char`, `Timespan`e `Guid` , vengono considerati primitivi a questo scopo.</span><span class="sxs-lookup"><span data-stu-id="81d28-346">Types that map to built-in XSD types, as well as `char`, `Timespan`, and `Guid` types, are considered primitives for this purpose.</span></span>

- <span data-ttu-id="81d28-347">Lo spazio dei nomi predefinito per tipi di raccolta che contengono tipi non primitivi corrisponde allo spazio dei nomi del contratto dati del tipo contenuto nella raccolta, a meno che non venga eseguito l'override utilizzando Namespace.</span><span class="sxs-lookup"><span data-stu-id="81d28-347">The default namespace for collection types that contain non-primitive types, unless it is overridden using Namespace, is the same as the data contract namespace of the type contained in the collection.</span></span>

- <span data-ttu-id="81d28-348">Il nome predefinito per i contratti dati delle raccolte di elenco, a meno che non venga sottoposto a override utilizzando Name, è la stringa "ArrayOf" associata al nome del contratto dati del tipo contenuto nella raccolta.</span><span class="sxs-lookup"><span data-stu-id="81d28-348">The default name for list collection data contracts, unless overridden using Name, is the string "ArrayOf" combined with the data contract name of the type contained in the collection.</span></span> <span data-ttu-id="81d28-349">Il nome del contratto dati per un elenco generico di numeri interi è, ad esempio, "ArrayOfint".</span><span class="sxs-lookup"><span data-stu-id="81d28-349">For example, the data contract name for a Generic List of Integers is "ArrayOfint".</span></span> <span data-ttu-id="81d28-350">È importante ricordare che il nome del contratto dati di `Object` è "anyType", quindi il nome del contratto dati di elenchi non generici come <xref:System.Collections.ArrayList> è "ArrayOfanyType".</span><span class="sxs-lookup"><span data-stu-id="81d28-350">Keep in mind that the data contract name of `Object` is "anyType", so the data contract name of non-generic lists like <xref:System.Collections.ArrayList> is "ArrayOfanyType".</span></span>

<span data-ttu-id="81d28-351">Il nome predefinito per i contratti dati delle raccolte di dizionario, a meno che non venga sottoposto a override utilizzando `Name`, è la stringa "ArrayOfKeyValueOf" associata al nome del contratto dati del tipo di chiave seguito dal nome del contratto dati del tipo di valore.</span><span class="sxs-lookup"><span data-stu-id="81d28-351">The default name for dictionary collection data contracts, unless overridden using `Name`, is the string "ArrayOfKeyValueOf" combined with the data contract name of the key type followed by the data contract name of the value type.</span></span> <span data-ttu-id="81d28-352">Il nome del contratto dati per un dizionario generico di stringa e numero intero, ad esempio, è "ArrayOfKeyValueOfstringint".</span><span class="sxs-lookup"><span data-stu-id="81d28-352">For example, the data contract name for a Generic Dictionary of String and Integer is "ArrayOfKeyValueOfstringint".</span></span> <span data-ttu-id="81d28-353">Inoltre, se il tipo di chiave o il tipo di valore non sono tipi primitivi, un hash di spazio dei nomi degli spazi dei nomi del contratto dati dei tipi di chiave e valore viene aggiunto al nome.</span><span class="sxs-lookup"><span data-stu-id="81d28-353">Additionally, if either the key or the value types are not primitive types, a namespace hash of the data contract namespaces of the key and value types is appended to the name.</span></span> <span data-ttu-id="81d28-354">Per ulteriori informazioni sugli hash dello spazio dei nomi, vedere [nomi di contratto dati](data-contract-names.md).</span><span class="sxs-lookup"><span data-stu-id="81d28-354">For more information about namespace hashes, see [Data Contract Names](data-contract-names.md).</span></span>

<span data-ttu-id="81d28-355">Ogni contratto dati della raccolta di dizionario dispone di un contratto dati complementare che rappresenta una voce del dizionario.</span><span class="sxs-lookup"><span data-stu-id="81d28-355">Each dictionary collection data contract has a companion data contract that represents one entry in the dictionary.</span></span> <span data-ttu-id="81d28-356">Il nome è lo stesso del contratto dati del dizionario, ad eccezione del prefisso "ArrayOf", e lo spazio dei nomi corrisponde a quello del contratto dati del dizionario.</span><span class="sxs-lookup"><span data-stu-id="81d28-356">Its name is the same as for the dictionary data contract, except for the "ArrayOf" prefix, and its namespace is the same as for the dictionary data contract.</span></span> <span data-ttu-id="81d28-357">Per il contratto dati del dizionario "ArrayOfKeyValueOfstringint", ad esempio, il contratto dati "KeyValueofstringint" rappresenta una voce del dizionario.</span><span class="sxs-lookup"><span data-stu-id="81d28-357">For example, for the "ArrayOfKeyValueOfstringint" dictionary data contract, the "KeyValueofstringint" data contract represents one entry in the dictionary.</span></span> <span data-ttu-id="81d28-358">È possibile personalizzare il nome di questo contratto dati utilizzando la proprietà `ItemName` , come viene descritto nella prossima sezione.</span><span class="sxs-lookup"><span data-stu-id="81d28-358">You can customize the name of this data contract by using the `ItemName` property, as described in the next section.</span></span>

<span data-ttu-id="81d28-359">Le regole di denominazione dei tipi generici, descritte in [Data Contract Names](data-contract-names.md), si applicano completamente ai tipi di raccolta, ovvero è possibile usare parentesi graffe all'interno di Name per indicare parametri di tipi generici.</span><span class="sxs-lookup"><span data-stu-id="81d28-359">Generic type naming rules, as described in [Data Contract Names](data-contract-names.md), fully apply to collection types; that is, you can use curly braces within Name to indicate generic type parameters.</span></span> <span data-ttu-id="81d28-360">Tuttavia, i numeri tra parentesi graffe si riferiscono a parametri generici e non a tipi contenuti nella raccolta.</span><span class="sxs-lookup"><span data-stu-id="81d28-360">However, numbers within the braces refer to generic parameters and not types contained within the collection.</span></span>

## <a name="collection-customization"></a><span data-ttu-id="81d28-361">Personalizzazione di raccolte</span><span class="sxs-lookup"><span data-stu-id="81d28-361">Collection Customization</span></span>

<span data-ttu-id="81d28-362">Gli utilizzi seguenti dell'attributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> non sono consentiti e generano un'eccezione <xref:System.Runtime.Serialization.InvalidDataContractException> :</span><span class="sxs-lookup"><span data-stu-id="81d28-362">The following uses of the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute are forbidden and result in an <xref:System.Runtime.Serialization.InvalidDataContractException> exception:</span></span>

- <span data-ttu-id="81d28-363">Applicare l'attributo <xref:System.Runtime.Serialization.DataContractAttribute> a un tipo al quale è stato applicato l'attributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> oppure a uno dei tipi derivati.</span><span class="sxs-lookup"><span data-stu-id="81d28-363">Applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to a type to which the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute has been applied, or to one of its derived types.</span></span>

- <span data-ttu-id="81d28-364">Applicare l'attributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> a un tipo che implementa l'interfaccia <xref:System.Xml.Serialization.IXmlSerializable> .</span><span class="sxs-lookup"><span data-stu-id="81d28-364">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a type that implements the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>

- <span data-ttu-id="81d28-365">Applicare l'attributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> a un tipo diverso da una raccolta.</span><span class="sxs-lookup"><span data-stu-id="81d28-365">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a non-collection type.</span></span>

- <span data-ttu-id="81d28-366">Tentare di impostare <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> o <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> su un attributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> applicato a un tipo diverso da un dizionario.</span><span class="sxs-lookup"><span data-stu-id="81d28-366">Attempting to set <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> or <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> on a <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute applied to a non-dictionary type.</span></span>

### <a name="polymorphism-rules"></a><span data-ttu-id="81d28-367">Regole del polimorfismo</span><span class="sxs-lookup"><span data-stu-id="81d28-367">Polymorphism Rules</span></span>

<span data-ttu-id="81d28-368">Come indicato in precedenza, la personalizzazione delle raccolte mediante l'attributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> può interferire con l'intercambiabilità delle stesse.</span><span class="sxs-lookup"><span data-stu-id="81d28-368">As previously mentioned, customizing collections by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute may interfere with collection interchangeability.</span></span> <span data-ttu-id="81d28-369">Due tipi di raccolta personalizzati possono essere considerati equivalenti solo se il nome, lo spazio dei nomi, il nome dell'elemento nonché il nome di chiave e valore (se raccolte di dizionari) corrispondono.</span><span class="sxs-lookup"><span data-stu-id="81d28-369">Two customized collection types can only be considered equivalent if their name, namespace, item name, as well as key and value names (if these are dictionary collections) match.</span></span>

<span data-ttu-id="81d28-370">A causa delle personalizzazioni, è possibile utilizzare inavvertitamente il contratto dati di una raccolta laddove ne è previsto un altro.</span><span class="sxs-lookup"><span data-stu-id="81d28-370">Due to customizations, it is possible to inadvertently use one collection data contract where another is expected.</span></span> <span data-ttu-id="81d28-371">Questa evenienza deve essere evitata.</span><span class="sxs-lookup"><span data-stu-id="81d28-371">This should be avoided.</span></span> <span data-ttu-id="81d28-372">Vedere i tipi seguenti.</span><span class="sxs-lookup"><span data-stu-id="81d28-372">See the following types.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#11)]
[!code-vb[c_collection_types_in_data_contracts#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#11)]

<span data-ttu-id="81d28-373">In questo caso, un'istanza di `Marks1` può essere assegnata a `testMarks`.</span><span class="sxs-lookup"><span data-stu-id="81d28-373">In this case, an instance of `Marks1` can be assigned to `testMarks`.</span></span> <span data-ttu-id="81d28-374">`Marks2` , tuttavia, non deve essere utilizzato poiché il relativo contratto dati non viene considerato equivalente al contratto dati `IList<int>` .</span><span class="sxs-lookup"><span data-stu-id="81d28-374">However, `Marks2` should not be used because its data contract is not considered equivalent to the `IList<int>` data contract.</span></span> <span data-ttu-id="81d28-375">Il nome del contratto dati è "Marks2" e non "ArrayOfint" e il nome dell'elemento ripetuto è " \<mark> " e non " \<int> ".</span><span class="sxs-lookup"><span data-stu-id="81d28-375">The data contract name is "Marks2" and not "ArrayOfint", and the repeating element name is "\<mark>" and not "\<int>".</span></span>

<span data-ttu-id="81d28-376">Per l'assegnazione polimorfica delle raccolte vengono applicate le regole riportate nella tabella seguente:</span><span class="sxs-lookup"><span data-stu-id="81d28-376">The rules in the following table apply to polymorphic assignment of collections.</span></span>

|<span data-ttu-id="81d28-377">Tipo dichiarato</span><span class="sxs-lookup"><span data-stu-id="81d28-377">Declared type</span></span>|<span data-ttu-id="81d28-378">Assegnazione di una raccolta non personalizzata</span><span class="sxs-lookup"><span data-stu-id="81d28-378">Assigning a non-customized collection</span></span>|<span data-ttu-id="81d28-379">Assegnazione di una raccolta personalizzata</span><span class="sxs-lookup"><span data-stu-id="81d28-379">Assigning a customized collection</span></span>|
|-------------------|--------------------------------------------|---------------------------------------|
|<span data-ttu-id="81d28-380">Oggetto</span><span class="sxs-lookup"><span data-stu-id="81d28-380">Object</span></span>|<span data-ttu-id="81d28-381">Il nome del contratto è serializzato.</span><span class="sxs-lookup"><span data-stu-id="81d28-381">Contract name is serialized.</span></span>|<span data-ttu-id="81d28-382">Il nome del contratto è serializzato.</span><span class="sxs-lookup"><span data-stu-id="81d28-382">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="81d28-383">Viene utilizzata la personalizzazione.</span><span class="sxs-lookup"><span data-stu-id="81d28-383">Customization is used.</span></span>|
|<span data-ttu-id="81d28-384">Interfaccia di raccolta</span><span class="sxs-lookup"><span data-stu-id="81d28-384">Collection interface</span></span>|<span data-ttu-id="81d28-385">Il nome del contratto non è serializzato.</span><span class="sxs-lookup"><span data-stu-id="81d28-385">Contract name is not serialized.</span></span>|<span data-ttu-id="81d28-386">Il nome del contratto non è serializzato.</span><span class="sxs-lookup"><span data-stu-id="81d28-386">Contract name is not serialized.</span></span><br /><br /> <span data-ttu-id="81d28-387">La personalizzazione non viene utilizzata.\*</span><span class="sxs-lookup"><span data-stu-id="81d28-387">Customization is not used.\*</span></span>|
|<span data-ttu-id="81d28-388">Raccolta non personalizzata</span><span class="sxs-lookup"><span data-stu-id="81d28-388">Non-customized collection</span></span>|<span data-ttu-id="81d28-389">Il nome del contratto non è serializzato.</span><span class="sxs-lookup"><span data-stu-id="81d28-389">Contract name is not serialized.</span></span>|<span data-ttu-id="81d28-390">Il nome del contratto è serializzato.</span><span class="sxs-lookup"><span data-stu-id="81d28-390">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="81d28-391">Viene utilizzata la personalizzazione.\*\*</span><span class="sxs-lookup"><span data-stu-id="81d28-391">Customization is used.\*\*</span></span>|
|<span data-ttu-id="81d28-392">Raccolta personalizzata</span><span class="sxs-lookup"><span data-stu-id="81d28-392">Customized collection</span></span>|<span data-ttu-id="81d28-393">Il nome del contratto è serializzato.</span><span class="sxs-lookup"><span data-stu-id="81d28-393">Contract name is serialized.</span></span> <span data-ttu-id="81d28-394">La personalizzazione non viene utilizzata.\*\*</span><span class="sxs-lookup"><span data-stu-id="81d28-394">Customization is not used.\*\*</span></span>|<span data-ttu-id="81d28-395">Il nome del contratto è serializzato.</span><span class="sxs-lookup"><span data-stu-id="81d28-395">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="81d28-396">Viene utilizzata la personalizzazione del tipo assegnato.\*\*</span><span class="sxs-lookup"><span data-stu-id="81d28-396">Customization of the assigned type is used.\*\*</span></span>|

<span data-ttu-id="81d28-397">\*Con la <xref:System.Runtime.Serialization.NetDataContractSerializer> classe, in questo caso viene utilizzata la personalizzazione.</span><span class="sxs-lookup"><span data-stu-id="81d28-397">\*With the <xref:System.Runtime.Serialization.NetDataContractSerializer> class, customization is used in this case.</span></span> <span data-ttu-id="81d28-398">La classe <xref:System.Runtime.Serialization.NetDataContractSerializer> serializza inoltre il nome effettivo del tipo in questo caso, quindi la deserializzazione viene eseguita in base alle previsioni.</span><span class="sxs-lookup"><span data-stu-id="81d28-398">The <xref:System.Runtime.Serialization.NetDataContractSerializer> class also serializes the actual type name in this case, so deserialization works as expected.</span></span>

<span data-ttu-id="81d28-399">\*\*Questi casi generano istanze non valide per lo schema e pertanto devono essere evitate.</span><span class="sxs-lookup"><span data-stu-id="81d28-399">\*\*These cases result in schema-invalid instances and thus should be avoided.</span></span>

<span data-ttu-id="81d28-400">Nei casi in cui il nome del contratto è serializzato, il tipo di raccolta assegnato deve risultare nell'elenco dei tipi noti.</span><span class="sxs-lookup"><span data-stu-id="81d28-400">In the cases where the contract name is serialized, the assigned collection type should be in the known types list.</span></span> <span data-ttu-id="81d28-401">È anche vero il contrario: nei casi in cui il nome non è serializzato, l'aggiunta del tipo all'elenco dei tipi noti non è necessaria.</span><span class="sxs-lookup"><span data-stu-id="81d28-401">The opposite is also true: in the cases where the name is not serialized, adding the type to the known types list is not required.</span></span>

<span data-ttu-id="81d28-402">Una matrice di un tipo derivato può essere assegnata a una matrice di un tipo di base.</span><span class="sxs-lookup"><span data-stu-id="81d28-402">An array of a derived type can be assigned to an array of a base type.</span></span> <span data-ttu-id="81d28-403">In questo caso il nome del contratto per il tipo derivato viene serializzato per ogni elemento ripetuto.</span><span class="sxs-lookup"><span data-stu-id="81d28-403">In this case, the contract name for the derived type is serialized for each repeating element.</span></span> <span data-ttu-id="81d28-404">Se ad esempio un tipo `Book` deriva dal tipo `LibraryItem`, è possibile assegnare una matrice di `Book` a una matrice di `LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="81d28-404">For example, if a type `Book` derives from the type `LibraryItem`, you can assign an array of `Book` to an array of `LibraryItem`.</span></span> <span data-ttu-id="81d28-405">Quanto esposto sopra non vale per altri tipi di raccolta.</span><span class="sxs-lookup"><span data-stu-id="81d28-405">This does not apply to other collection types.</span></span> <span data-ttu-id="81d28-406">Ad esempio, non è possibile assegnare un oggetto `Generic List of Book` a un oggetto `Generic List of LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="81d28-406">For example, you cannot assign a `Generic List of Book` to a `Generic List of LibraryItem`.</span></span> <span data-ttu-id="81d28-407">È tuttavia possibile assegnare un `Generic List of LibraryItem` contenente istanze di `Book` .</span><span class="sxs-lookup"><span data-stu-id="81d28-407">You can, however, assign a `Generic List of LibraryItem` that contains `Book` instances.</span></span> <span data-ttu-id="81d28-408">In entrambi i casi, matrice e non matrice, `Book` deve essere presente nell'elenco dei tipi noti.</span><span class="sxs-lookup"><span data-stu-id="81d28-408">In both the array and the non-array case, `Book` should be in the known types list.</span></span>

## <a name="collections-and-object-reference-preservation"></a><span data-ttu-id="81d28-409">Raccolte e conservazione dei riferimenti all'oggetto</span><span class="sxs-lookup"><span data-stu-id="81d28-409">Collections and Object Reference Preservation</span></span>

<span data-ttu-id="81d28-410">Quando un serializzatore opera in una modalità che consente di preservare i riferimenti all'oggetto, la conservazione dei riferimenti all'oggetto si applica anche alle raccolte.</span><span class="sxs-lookup"><span data-stu-id="81d28-410">When a serializer functions in a mode where it preserves object references, object reference preservation also applies to collections.</span></span> <span data-ttu-id="81d28-411">In particolare, l'identità dell'oggetto viene conservata sia per raccolte intere che per elementi singoli contenuti nelle raccolte.</span><span class="sxs-lookup"><span data-stu-id="81d28-411">Specifically, object identity is preserved for both entire collections and individual items contained in collections.</span></span> <span data-ttu-id="81d28-412">Per i dizionari, l'identità dell'oggetto viene conservata sia per oggetti coppia di chiave e valore che per oggetti chiave e valore singoli.</span><span class="sxs-lookup"><span data-stu-id="81d28-412">For dictionaries, object identity is preserved both for the key/value pair objects and the individual key and value objects.</span></span>

## <a name="see-also"></a><span data-ttu-id="81d28-413">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="81d28-413">See also</span></span>

- <xref:System.Runtime.Serialization.CollectionDataContractAttribute>
