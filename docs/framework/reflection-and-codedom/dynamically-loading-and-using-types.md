---
title: Caricamento e utilizzo dinamico dei tipi
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
- cpp
helpviewer_keywords:
- late binding, about late binding
- early binding
- dynamically loading and using types
- implicit late binding
- reflection, dynamically using types
ms.assetid: db985bec-5942-40ec-b13a-771ae98623dc
ms.openlocfilehash: 940f334ec6a42c4d8da461d634051ff979b8f98d
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 10/30/2019
ms.locfileid: "73130257"
---
# <a name="dynamically-loading-and-using-types"></a><span data-ttu-id="37dcc-102">Caricamento e utilizzo dinamico dei tipi</span><span class="sxs-lookup"><span data-stu-id="37dcc-102">Dynamically Loading and Using Types</span></span>
<span data-ttu-id="37dcc-103">La reflection offre l'infrastruttura usata dai compilatori di linguaggi per implementare l'associazione tardiva implicita.</span><span class="sxs-lookup"><span data-stu-id="37dcc-103">Reflection provides infrastructure used by language compilers to implement implicit late binding.</span></span> <span data-ttu-id="37dcc-104">L'associazione è il processo di individuazione della dichiarazione (ovvero l'implementazione) che corrisponde a un tipo specificato in modo univoco.</span><span class="sxs-lookup"><span data-stu-id="37dcc-104">Binding is the process of locating the declaration (that is, the implementation) that corresponds to a uniquely specified type.</span></span> <span data-ttu-id="37dcc-105">Quando questo processo avviene in fase di esecuzione piuttosto che in fase di compilazione, esso viene chiamato associazione tardiva.</span><span class="sxs-lookup"><span data-stu-id="37dcc-105">When this process occurs at run time rather than at compile time, it is called late binding.</span></span> <span data-ttu-id="37dcc-106">Visual Basic consente di usare l'associazione tardiva implicita nel codice. Il compilatore Visual Basic chiama un metodo helper che usa la reflection per ottenere il tipo di oggetto.</span><span class="sxs-lookup"><span data-stu-id="37dcc-106">Visual Basic allows you to use implicit late binding in your code; the Visual Basic compiler calls a helper method that uses reflection to obtain the object type.</span></span> <span data-ttu-id="37dcc-107">Gli argomenti passati al metodo helper determinano la chiamata, in fase di esecuzione, del metodo appropriato.</span><span class="sxs-lookup"><span data-stu-id="37dcc-107">The arguments passed to the helper method cause the appropriate method to be invoked at run time.</span></span> <span data-ttu-id="37dcc-108">Questi argomenti sono l'istanza (un oggetto) su cui richiamare il metodo, il nome del metodo richiamato (una stringa) e gli argomenti passati al metodo richiamato (una matrice di oggetti).</span><span class="sxs-lookup"><span data-stu-id="37dcc-108">These arguments are the instance (an object) on which to invoke the method, the name of the invoked method (a string), and the arguments passed to the invoked method (an array of objects).</span></span>  
  
 <span data-ttu-id="37dcc-109">Nell'esempio seguente il compilatore Visual Basic usa la reflection in modo implicito per chiamare un metodo su un oggetto il cui tipo non è noto in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="37dcc-109">In the following example, the Visual Basic compiler uses reflection implicitly to call a method on an object whose type is not known at compile time.</span></span> <span data-ttu-id="37dcc-110">Una classe **HelloWorld** dispone di un metodo **PrintHello** che stampa il testo "Hello World" concatenato con il testo passato al metodo **PrintHello**.</span><span class="sxs-lookup"><span data-stu-id="37dcc-110">A **HelloWorld** class has a **PrintHello** method that prints out "Hello World" concatenated with some text that is passed to the **PrintHello** method.</span></span> <span data-ttu-id="37dcc-111">Il metodo **PrintHello** chiamato in questo esempio è in realtà un <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>. Il codice Visual Basic consente di richiamare il metodo **PrintHello** come se il tipo dell'oggetto (helloObj) fosse noto in fase di compilazione (associazione anticipata) piuttosto che in fase di esecuzione (associazione tardiva).</span><span class="sxs-lookup"><span data-stu-id="37dcc-111">The **PrintHello** method called in this example is actually a <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>; the Visual Basic code allows the **PrintHello** method to be invoked as if the type of the object (helloObj) were known at compile time (early binding) rather than at run time (late binding).</span></span>  
  
```vb
Module Hello  
    Sub Main()  
        ' Sets up the variable.  
        Dim helloObj As Object  
        ' Creates the object.  
        helloObj = new HelloWorld()  
        ' Invokes the print method as if it was early bound  
        ' even though it is really late bound.  
        helloObj.PrintHello("Visual Basic Late Bound")  
    End Sub  
End Module  
```  
  
## <a name="custom-binding"></a><span data-ttu-id="37dcc-112">Associazione personalizzata</span><span class="sxs-lookup"><span data-stu-id="37dcc-112">Custom Binding</span></span>  
 <span data-ttu-id="37dcc-113">Ai fini dell'associazione tardiva, oltre a essere usata in modo implicito dai compilatori, la reflection può essere usata in modo esplicito nel codice.</span><span class="sxs-lookup"><span data-stu-id="37dcc-113">In addition to being used implicitly by compilers for late binding, reflection can be used explicitly in code to accomplish late binding.</span></span>  
  
 <span data-ttu-id="37dcc-114">[Common Language Runtime](../../standard/clr.md) supporta più linguaggi di programmazione che seguono regole di associazione diverse.</span><span class="sxs-lookup"><span data-stu-id="37dcc-114">The [common language runtime](../../standard/clr.md) supports multiple programming languages, and the binding rules of these languages differ.</span></span> <span data-ttu-id="37dcc-115">In caso di associazione anticipata, i generatori di codice possono controllare completamente questa associazione.</span><span class="sxs-lookup"><span data-stu-id="37dcc-115">In the early-bound case, code generators can completely control this binding.</span></span> <span data-ttu-id="37dcc-116">Nell'associazione tardiva mediante reflection l'associazione deve essere invece controllata dall'associazione personalizzata.</span><span class="sxs-lookup"><span data-stu-id="37dcc-116">However, in late binding through reflection, binding must be controlled by customized binding.</span></span> <span data-ttu-id="37dcc-117">La classe <xref:System.Reflection.Binder> fornisce il controllo personalizzato sulla selezione e la chiamata dei membri.</span><span class="sxs-lookup"><span data-stu-id="37dcc-117">The <xref:System.Reflection.Binder> class provides custom control of member selection and invocation.</span></span>  
  
 <span data-ttu-id="37dcc-118">Usando l'associazione personalizzata, è possibile caricare un assembly in fase di esecuzione, ottenere informazioni sui tipi in esso contenuti, specificare il tipo desiderato e quindi richiamarne i metodi o usarne i campi o le proprietà.</span><span class="sxs-lookup"><span data-stu-id="37dcc-118">Using custom binding, you can load an assembly at run time, obtain information about types in that assembly, specify the type that you want, and then invoke methods or access fields or properties on that type.</span></span> <span data-ttu-id="37dcc-119">Questa tecnica è utile se non si conosce il tipo di un oggetto in fase di compilazione, come avviene ad esempio quando il tipo di oggetto dipende dall'input dell'utente.</span><span class="sxs-lookup"><span data-stu-id="37dcc-119">This technique is useful if you do not know an object's type at compile time, such as when the object type is dependent on user input.</span></span>  
  
 <span data-ttu-id="37dcc-120">Nell'esempio seguente viene illustrato un semplice binder personalizzato che non offre la conversione del tipo di argomento.</span><span class="sxs-lookup"><span data-stu-id="37dcc-120">The following example demonstrates a simple custom binder that provides no argument type conversion.</span></span> <span data-ttu-id="37dcc-121">Il codice per `Simple_Type.dll` precede l'esempio principale.</span><span class="sxs-lookup"><span data-stu-id="37dcc-121">Code for `Simple_Type.dll` precedes the main example.</span></span> <span data-ttu-id="37dcc-122">Assicurarsi di compilare `Simple_Type.dll` e di includere nel progetto un riferimento a esso durante la compilazione.</span><span class="sxs-lookup"><span data-stu-id="37dcc-122">Be sure to build `Simple_Type.dll` and then include a reference to it in the project at build time.</span></span>  
  
 [!code-cpp[Conceptual.Types.Dynamic#1](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source1.cpp#1)]
 [!code-csharp[Conceptual.Types.Dynamic#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source1.cs#1)]
 [!code-vb[Conceptual.Types.Dynamic#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source1.vb#1)]  
  
### <a name="invokemember-and-createinstance"></a><span data-ttu-id="37dcc-123">InvokeMember e CreateInstance</span><span class="sxs-lookup"><span data-stu-id="37dcc-123">InvokeMember and CreateInstance</span></span>  
 <span data-ttu-id="37dcc-124">Usare <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> per richiamare un membro di un tipo.</span><span class="sxs-lookup"><span data-stu-id="37dcc-124">Use <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> to invoke a member of a type.</span></span> <span data-ttu-id="37dcc-125">I metodi **CreateInstance** di varie classi, ad esempio <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> e <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=nameWithType>, sono forme speciali di **InvokeMember** che creano nuove istanze del tipo specificato.</span><span class="sxs-lookup"><span data-stu-id="37dcc-125">The **CreateInstance** methods of various classes, such as <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> and <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=nameWithType>, are specialized forms of **InvokeMember** that create new instances of the specified type.</span></span> <span data-ttu-id="37dcc-126">La classe **Binder** viene usata per la risoluzione dell'overload e la coercizione degli argomenti in questi metodi.</span><span class="sxs-lookup"><span data-stu-id="37dcc-126">The **Binder** class is used for overload resolution and argument coercion in these methods.</span></span>  
  
 <span data-ttu-id="37dcc-127">L'esempio seguente illustra le tre combinazioni possibili di coercizione degli argomenti (conversione del tipo) e selezione dei membri.</span><span class="sxs-lookup"><span data-stu-id="37dcc-127">The following example shows the three possible combinations of argument coercion (type conversion) and member selection.</span></span> <span data-ttu-id="37dcc-128">Nel caso 1 non è necessaria la coercizione degli argomenti né la selezione dei membri.</span><span class="sxs-lookup"><span data-stu-id="37dcc-128">In Case 1, no argument coercion or member selection is needed.</span></span> <span data-ttu-id="37dcc-129">Nel caso 2 è necessaria solo la selezione dei membri.</span><span class="sxs-lookup"><span data-stu-id="37dcc-129">In Case 2, only member selection is needed.</span></span> <span data-ttu-id="37dcc-130">Nel caso 3 è necessaria solo la coercizione degli argomenti.</span><span class="sxs-lookup"><span data-stu-id="37dcc-130">In Case 3, only argument coercion is needed.</span></span>  
  
 [!code-cpp[Conceptual.Types.Dynamic#2](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source2.cpp#2)]
 [!code-csharp[Conceptual.Types.Dynamic#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source2.cs#2)]
 [!code-vb[Conceptual.Types.Dynamic#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source2.vb#2)]  
  
 <span data-ttu-id="37dcc-131">La risoluzione dell'overload è necessaria quando vi sono più membri con lo stesso nome.</span><span class="sxs-lookup"><span data-stu-id="37dcc-131">Overload resolution is needed when more than one member with the same name is available.</span></span> <span data-ttu-id="37dcc-132">I metodi <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> e <xref:System.Reflection.Binder.BindToField%2A?displayProperty=nameWithType> vengono usati per risolvere l'associazione su un singolo membro.</span><span class="sxs-lookup"><span data-stu-id="37dcc-132">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.Binder.BindToField%2A?displayProperty=nameWithType> methods are used to resolve binding to a single member.</span></span> <span data-ttu-id="37dcc-133">**Binder.BindToMethod** offre anche la risoluzione delle proprietà mediante le funzioni di accesso alle proprietà **get** e **set**.</span><span class="sxs-lookup"><span data-stu-id="37dcc-133">**Binder.BindToMethod** also provides property resolution through the **get** and **set** property accessors.</span></span>  
  
 <span data-ttu-id="37dcc-134">**BindToMethod** restituisce <xref:System.Reflection.MethodBase> da richiamare o un riferimento Null (**Nothing** in Visual Basic) se non è possibile effettuare la chiamata.</span><span class="sxs-lookup"><span data-stu-id="37dcc-134">**BindToMethod** returns the <xref:System.Reflection.MethodBase> to invoke, or a null reference (**Nothing** in Visual Basic) if no such invocation is possible.</span></span> <span data-ttu-id="37dcc-135">**MethodBase** restituisce valori non necessariamente compresi tra quelli contenuti nel parametro *match*, sebbene questo sia il caso più frequente.</span><span class="sxs-lookup"><span data-stu-id="37dcc-135">The **MethodBase** return value need not be one of those contained in the *match* parameter, although that is the usual case.</span></span>  
  
 <span data-ttu-id="37dcc-136">Quando sono presenti argomenti ByRef, è possibile che debbano essere restituiti al chiamante.</span><span class="sxs-lookup"><span data-stu-id="37dcc-136">When ByRef arguments are present, the caller might want to get them back.</span></span> <span data-ttu-id="37dcc-137">Di conseguenza, **Binder** consentirà al client di eseguire il mapping della matrice di argomenti riportandola alla forma originale se **BindToMethod** ha modificato la matrice di argomenti.</span><span class="sxs-lookup"><span data-stu-id="37dcc-137">Therefore, **Binder** allows a client to map the array of arguments back to its original form if **BindToMethod** has manipulated the argument array.</span></span> <span data-ttu-id="37dcc-138">A questo scopo, è necessario garantire al chiamante che l'ordine degli argomenti resti inalterato.</span><span class="sxs-lookup"><span data-stu-id="37dcc-138">In order to do this, the caller must be guaranteed that the order of the arguments is unchanged.</span></span> <span data-ttu-id="37dcc-139">Quando gli argomenti vengono passati in base al nome, **Binder** riordina la matrice di argomenti, che rappresenta quanto viene visualizzato al chiamante.</span><span class="sxs-lookup"><span data-stu-id="37dcc-139">When arguments are passed by name, **Binder** reorders the argument array, and that is what the caller sees.</span></span> <span data-ttu-id="37dcc-140">Per altre informazioni, vedere <xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37dcc-140">For more information, see <xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="37dcc-141">Il set di membri disponibili è costituito dai membri definiti nel tipo o in qualsiasi tipo di base.</span><span class="sxs-lookup"><span data-stu-id="37dcc-141">The set of available members are those members defined in the type or any base type.</span></span> <span data-ttu-id="37dcc-142">Se si specifica <xref:System.Reflection.BindingFlags>, il set restituito comprenderà membri di qualsiasi accessibilità.</span><span class="sxs-lookup"><span data-stu-id="37dcc-142">If <xref:System.Reflection.BindingFlags> is specified, members of any accessibility will be returned in the set.</span></span> <span data-ttu-id="37dcc-143">Se **BindingFlags.NonPublic** non viene specificato, il binder dovrà applicare le regole di accessibilità.</span><span class="sxs-lookup"><span data-stu-id="37dcc-143">If **BindingFlags.NonPublic** is not specified, the binder must enforce accessibility rules.</span></span> <span data-ttu-id="37dcc-144">Quando si specifica il flag di associazione **Public** o **NonPublic** è necessario specificare anche il flag di associazione **Instance** o **Static**. In caso contrario non verrà restituito alcun membro.</span><span class="sxs-lookup"><span data-stu-id="37dcc-144">When specifying the **Public** or **NonPublic** binding flag, you must also specify the **Instance** or **Static** binding flag, or no members will be returned.</span></span>  
  
 <span data-ttu-id="37dcc-145">Se vi è un solo membro con il nome specificato, non occorrerà alcun callback e l'associazione verrà effettuata su quel metodo.</span><span class="sxs-lookup"><span data-stu-id="37dcc-145">If there is only one member of the given name, no callback is necessary, and binding is done on that method.</span></span> <span data-ttu-id="37dcc-146">Nel caso 1 dell'esempio di codice viene illustrato questo punto: è disponibile un solo metodo **PrintBob**, quindi il callback non è necessario.</span><span class="sxs-lookup"><span data-stu-id="37dcc-146">Case 1 of the code example illustrates this point: Only one **PrintBob** method is available, and therefore no callback is needed.</span></span>  
  
 <span data-ttu-id="37dcc-147">Se il set disponibile include più membri, tutti i metodi vengono passati a **BindToMethod** che seleziona il metodo appropriato e lo restituisce.</span><span class="sxs-lookup"><span data-stu-id="37dcc-147">If there is more than one member in the available set, all these methods are passed to **BindToMethod**, which selects the appropriate method and returns it.</span></span> <span data-ttu-id="37dcc-148">Nel caso 2 dell'esempio di codice sono presenti due metodi denominati **PrintValue**.</span><span class="sxs-lookup"><span data-stu-id="37dcc-148">In Case 2 of the code example, there are two methods named **PrintValue**.</span></span> <span data-ttu-id="37dcc-149">Il metodo appropriato viene selezionato dalla chiamata a **BindToMethod**.</span><span class="sxs-lookup"><span data-stu-id="37dcc-149">The appropriate method is selected by the call to **BindToMethod**.</span></span>  
  
 <span data-ttu-id="37dcc-150"><xref:System.Reflection.Binder.ChangeType%2A> esegue la coercizione degli argomenti (conversione del tipo) convertendo gli argomenti effettivi nel tipo di argomenti formali del metodo selezionato.</span><span class="sxs-lookup"><span data-stu-id="37dcc-150"><xref:System.Reflection.Binder.ChangeType%2A> performs argument coercion (type conversion), which converts the actual arguments to the type of the formal arguments of the selected method.</span></span> <span data-ttu-id="37dcc-151">**ChangeType** viene chiamato per ogni argomento anche se i tipi corrispondono esattamente.</span><span class="sxs-lookup"><span data-stu-id="37dcc-151">**ChangeType** is called for every argument even if the types match exactly.</span></span>  
  
 <span data-ttu-id="37dcc-152">Nel caso 3 dell'esempio di codice un argomento effettivo di tipo **String** con valore "5.5" viene passato a un metodo con un argomento formale di tipo **Double**.</span><span class="sxs-lookup"><span data-stu-id="37dcc-152">In Case 3 of the code example, an actual argument of type **String** with a value of "5.5" is passed to a method with a formal argument of type **Double**.</span></span> <span data-ttu-id="37dcc-153">Affinché la chiamata abbia esito positivo, il valore di stringa "5.5" deve essere convertito in un valore Double.</span><span class="sxs-lookup"><span data-stu-id="37dcc-153">For the invocation to succeed, the string value "5.5" must be converted to a double value.</span></span> <span data-ttu-id="37dcc-154">La conversione viene eseguita da **ChangeType**.</span><span class="sxs-lookup"><span data-stu-id="37dcc-154">**ChangeType** performs this conversion.</span></span>  
  
 <span data-ttu-id="37dcc-155">**ChangeType** esegue solo [coercizioni verso tipi più grandi](../../standard/base-types/type-conversion.md) o senza perdita di dati, come illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="37dcc-155">**ChangeType** performs only lossless or [widening coercions](../../standard/base-types/type-conversion.md), as shown in the following table.</span></span>  
  
|<span data-ttu-id="37dcc-156">Tipo di origine</span><span class="sxs-lookup"><span data-stu-id="37dcc-156">Source type</span></span>|<span data-ttu-id="37dcc-157">Tipo di destinazione</span><span class="sxs-lookup"><span data-stu-id="37dcc-157">Target type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="37dcc-158">Qualsiasi tipo</span><span class="sxs-lookup"><span data-stu-id="37dcc-158">Any type</span></span>|<span data-ttu-id="37dcc-159">Il relativo tipo di base</span><span class="sxs-lookup"><span data-stu-id="37dcc-159">Its base type</span></span>|  
|<span data-ttu-id="37dcc-160">Qualsiasi tipo</span><span class="sxs-lookup"><span data-stu-id="37dcc-160">Any type</span></span>|<span data-ttu-id="37dcc-161">L'interfaccia implementata</span><span class="sxs-lookup"><span data-stu-id="37dcc-161">Interface it implements</span></span>|  
|<span data-ttu-id="37dcc-162">Char</span><span class="sxs-lookup"><span data-stu-id="37dcc-162">Char</span></span>|<span data-ttu-id="37dcc-163">UInt16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="37dcc-163">UInt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="37dcc-164">Byte</span><span class="sxs-lookup"><span data-stu-id="37dcc-164">Byte</span></span>|<span data-ttu-id="37dcc-165">Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="37dcc-165">Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="37dcc-166">SByte</span><span class="sxs-lookup"><span data-stu-id="37dcc-166">SByte</span></span>|<span data-ttu-id="37dcc-167">Int16, Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="37dcc-167">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="37dcc-168">UInt16</span><span class="sxs-lookup"><span data-stu-id="37dcc-168">UInt16</span></span>|<span data-ttu-id="37dcc-169">UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="37dcc-169">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="37dcc-170">Int16</span><span class="sxs-lookup"><span data-stu-id="37dcc-170">Int16</span></span>|<span data-ttu-id="37dcc-171">Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="37dcc-171">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="37dcc-172">UInt32</span><span class="sxs-lookup"><span data-stu-id="37dcc-172">UInt32</span></span>|<span data-ttu-id="37dcc-173">UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="37dcc-173">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="37dcc-174">Int32</span><span class="sxs-lookup"><span data-stu-id="37dcc-174">Int32</span></span>|<span data-ttu-id="37dcc-175">Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="37dcc-175">Int64, Single, Double</span></span>|  
|<span data-ttu-id="37dcc-176">UInt64</span><span class="sxs-lookup"><span data-stu-id="37dcc-176">UInt64</span></span>|<span data-ttu-id="37dcc-177">Single, Double</span><span class="sxs-lookup"><span data-stu-id="37dcc-177">Single, Double</span></span>|  
|<span data-ttu-id="37dcc-178">Int64</span><span class="sxs-lookup"><span data-stu-id="37dcc-178">Int64</span></span>|<span data-ttu-id="37dcc-179">Single, Double</span><span class="sxs-lookup"><span data-stu-id="37dcc-179">Single, Double</span></span>|  
|<span data-ttu-id="37dcc-180">Single</span><span class="sxs-lookup"><span data-stu-id="37dcc-180">Single</span></span>|<span data-ttu-id="37dcc-181">Double</span><span class="sxs-lookup"><span data-stu-id="37dcc-181">Double</span></span>|  
|<span data-ttu-id="37dcc-182">Tipo non di riferimento</span><span class="sxs-lookup"><span data-stu-id="37dcc-182">Nonreference type</span></span>|<span data-ttu-id="37dcc-183">Tipo di riferimento</span><span class="sxs-lookup"><span data-stu-id="37dcc-183">Reference type</span></span>|  
  
 <span data-ttu-id="37dcc-184">La classe <xref:System.Type> include metodi **Get** che usano i parametri di tipo **Binder** per risolvere i riferimenti su un membro specifico.</span><span class="sxs-lookup"><span data-stu-id="37dcc-184">The <xref:System.Type> class has **Get** methods that use parameters of type **Binder** to resolve references to a particular member.</span></span> <span data-ttu-id="37dcc-185"><xref:System.Type.GetConstructor%2A?displayProperty=nameWithType>, <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> e <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> cercano un membro specifico del tipo corrente fornendo informazioni sulla relativa firma.</span><span class="sxs-lookup"><span data-stu-id="37dcc-185"><xref:System.Type.GetConstructor%2A?displayProperty=nameWithType>, <xref:System.Type.GetMethod%2A?displayProperty=nameWithType>, and <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> search for a particular member of the current type by providing signature information for that member.</span></span> <span data-ttu-id="37dcc-186"><xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=nameWithType> e <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=nameWithType> vengono chiamati per selezionare le informazioni sulla firma dei metodi appropriati.</span><span class="sxs-lookup"><span data-stu-id="37dcc-186"><xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=nameWithType> are called back on to select the given signature information of the appropriate methods.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="37dcc-187">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="37dcc-187">See also</span></span>

- <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>
- [<span data-ttu-id="37dcc-188">Visualizzazione delle informazioni sul tipo</span><span class="sxs-lookup"><span data-stu-id="37dcc-188">Viewing Type Information</span></span>](viewing-type-information.md)
- [<span data-ttu-id="37dcc-189">Conversione dei tipi nel .NET Framework</span><span class="sxs-lookup"><span data-stu-id="37dcc-189">Type Conversion in the .NET Framework</span></span>](../../standard/base-types/type-conversion.md)
