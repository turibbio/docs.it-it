---
title: Considerazioni sulle prestazioni (Entity Framework)
description: Informazioni sulle caratteristiche delle prestazioni di ADO.NET Entity Framework e considerazioni che consentono di migliorare le prestazioni delle applicazioni Entity Framework.
ms.date: 03/30/2017
ms.assetid: 61913f3b-4f42-4d9b-810f-2a13c2388a4a
ms.openlocfilehash: edf82e4db3e72fab1555eea9bfcd34cd34ddbba7
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/02/2020
ms.locfileid: "84286766"
---
# <a name="performance-considerations-entity-framework"></a><span data-ttu-id="128a6-103">Considerazioni sulle prestazioni (Entity Framework)</span><span class="sxs-lookup"><span data-stu-id="128a6-103">Performance Considerations (Entity Framework)</span></span>
<span data-ttu-id="128a6-104">In questo argomento vengono descritte le caratteristiche relative alle prestazioni di ADO.NET Entity Framework e vengono illustrate alcune considerazioni per migliorare le prestazioni di applicazioni Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="128a6-104">This topic describes performance characteristics of the ADO.NET Entity Framework and provides some considerations to help improve the performance of Entity Framework applications.</span></span>  
  
## <a name="stages-of-query-execution"></a><span data-ttu-id="128a6-105">Fasi di esecuzione di query</span><span class="sxs-lookup"><span data-stu-id="128a6-105">Stages of Query Execution</span></span>  
 <span data-ttu-id="128a6-106">Per capire meglio le prestazioni delle query in Entity Framework, è utile capire le operazioni che si verificano quando una query viene eseguita su un modello concettuale e restituisce dati come oggetti.</span><span class="sxs-lookup"><span data-stu-id="128a6-106">In order to better understand the performance of queries in the Entity Framework, it is helpful to understand the operations that occur when a query executes against a conceptual model and returns data as objects.</span></span> <span data-ttu-id="128a6-107">Nella tabella seguente viene descritta questa serie di operazioni.</span><span class="sxs-lookup"><span data-stu-id="128a6-107">The following table describes this series of operations.</span></span>  
  
|<span data-ttu-id="128a6-108">Operazione</span><span class="sxs-lookup"><span data-stu-id="128a6-108">Operation</span></span>|<span data-ttu-id="128a6-109">Costo relativo</span><span class="sxs-lookup"><span data-stu-id="128a6-109">Relative Cost</span></span>|<span data-ttu-id="128a6-110">Frequenza</span><span class="sxs-lookup"><span data-stu-id="128a6-110">Frequency</span></span>|<span data-ttu-id="128a6-111">Commenti</span><span class="sxs-lookup"><span data-stu-id="128a6-111">Comments</span></span>|  
|---------------|-------------------|---------------|--------------|  
|<span data-ttu-id="128a6-112">Caricamento di metadati</span><span class="sxs-lookup"><span data-stu-id="128a6-112">Loading metadata</span></span>|<span data-ttu-id="128a6-113">Moderato</span><span class="sxs-lookup"><span data-stu-id="128a6-113">Moderate</span></span>|<span data-ttu-id="128a6-114">Una volta in ogni dominio dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="128a6-114">Once in each application domain.</span></span>|<span data-ttu-id="128a6-115">I metadati del modello e di mapping usati da Entity Framework sono caricati in un <xref:System.Data.Metadata.Edm.MetadataWorkspace>.</span><span class="sxs-lookup"><span data-stu-id="128a6-115">Model and mapping metadata used by the Entity Framework is loaded into a <xref:System.Data.Metadata.Edm.MetadataWorkspace>.</span></span> <span data-ttu-id="128a6-116">Questi metadati sono memorizzati nella cache globalmente e sono disponibili per altre istanze di <xref:System.Data.Objects.ObjectContext> nello stesso dominio dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="128a6-116">This metadata is cached globally and is available to other instances of <xref:System.Data.Objects.ObjectContext> in the same application domain.</span></span>|  
|<span data-ttu-id="128a6-117">Apertura della connessione al database</span><span class="sxs-lookup"><span data-stu-id="128a6-117">Opening the database connection</span></span>|<span data-ttu-id="128a6-118">Moderato<sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="128a6-118">Moderate<sup>1</sup></span></span>|<span data-ttu-id="128a6-119">Secondo le necessità.</span><span class="sxs-lookup"><span data-stu-id="128a6-119">As needed.</span></span>|<span data-ttu-id="128a6-120">Poiché una connessione aperta al database utilizza una risorsa preziosa, la Entity Framework apre e chiude la connessione al database solo in base alle esigenze.</span><span class="sxs-lookup"><span data-stu-id="128a6-120">Because an open connection to the database consumes a valuable resource, the Entity Framework opens and closes the database connection only as needed.</span></span> <span data-ttu-id="128a6-121">È possibile aprire anche in modo esplicito la connessione.</span><span class="sxs-lookup"><span data-stu-id="128a6-121">You can also explicitly open the connection.</span></span> <span data-ttu-id="128a6-122">Per ulteriori informazioni, vedere [gestione delle connessioni e delle transazioni](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="128a6-122">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>|  
|<span data-ttu-id="128a6-123">Generazione di visualizzazioni</span><span class="sxs-lookup"><span data-stu-id="128a6-123">Generating views</span></span>|<span data-ttu-id="128a6-124">Alta</span><span class="sxs-lookup"><span data-stu-id="128a6-124">High</span></span>|<span data-ttu-id="128a6-125">Una volta in ogni dominio dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="128a6-125">Once in each application domain.</span></span> <span data-ttu-id="128a6-126">Possono essere generate anticipatamente.</span><span class="sxs-lookup"><span data-stu-id="128a6-126">(Can be pre-generated.)</span></span>|<span data-ttu-id="128a6-127">Prima di poter eseguire una query su un modello concettuale o salvare delle modifiche all'origine dati, Entity Framework deve generare un set di visualizzazioni query locali per accedere al database.</span><span class="sxs-lookup"><span data-stu-id="128a6-127">Before the Entity Framework can execute a query against a conceptual model or save changes to the data source, it must generate a set of local query views to access the database.</span></span> <span data-ttu-id="128a6-128">A causa del costo elevato della generazione di queste visualizzazioni, è possibile generarle in anticipo e aggiungerle al progetto in fase di progettazione.</span><span class="sxs-lookup"><span data-stu-id="128a6-128">Because of the high cost of generating these views, you can pre-generate the views and add them to the project at design-time.</span></span> <span data-ttu-id="128a6-129">Per altre informazioni, vedere [procedura: pre-generare viste per migliorare le prestazioni di esecuzione delle query](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="128a6-129">For more information, see [How to: Pre-Generate Views to Improve Query Performance](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>|  
|<span data-ttu-id="128a6-130">Preparazione della query</span><span class="sxs-lookup"><span data-stu-id="128a6-130">Preparing the query</span></span>|<span data-ttu-id="128a6-131">Moderato<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="128a6-131">Moderate<sup>2</sup></span></span>|<span data-ttu-id="128a6-132">Una volta per ogni query univoca.</span><span class="sxs-lookup"><span data-stu-id="128a6-132">Once for each unique query.</span></span>|<span data-ttu-id="128a6-133">Include i costi per creare il comando della query, generare un albero dei comandi basato sui metadati del modello e di mapping e definire la forma dei dati restituiti.</span><span class="sxs-lookup"><span data-stu-id="128a6-133">Includes the costs to compose the query command, generate a command tree based on model and mapping metadata, and define the shape of the returned data.</span></span> <span data-ttu-id="128a6-134">Poiché vengono memorizzati nella cache sia i comandi delle query Entity SQL sia le query LINQ, le successive esecuzioni dei comandi della stessa query sono più veloci.</span><span class="sxs-lookup"><span data-stu-id="128a6-134">Because now both Entity SQL query commands and LINQ queries are cached, later executions of the same query take less time.</span></span> <span data-ttu-id="128a6-135">Tuttavia, è possibile usare le query LINQ compilate per ridurre il costo nelle esecuzioni successive e le query compilate possono essere più efficienti di quelle LINQ che vengono memorizzate nella cache automaticamente.</span><span class="sxs-lookup"><span data-stu-id="128a6-135">You can still use compiled LINQ queries to reduce this cost in later executions and compiled queries can be more efficient than LINQ queries that are automatically cached.</span></span> <span data-ttu-id="128a6-136">Per ulteriori informazioni, vedere [query compilate (LINQ to Entities)](./language-reference/compiled-queries-linq-to-entities.md).</span><span class="sxs-lookup"><span data-stu-id="128a6-136">For more information, see [Compiled Queries  (LINQ to Entities)](./language-reference/compiled-queries-linq-to-entities.md).</span></span> <span data-ttu-id="128a6-137">Per informazioni generali sull'esecuzione di query LINQ, vedere [LINQ to Entities](./language-reference/linq-to-entities.md).</span><span class="sxs-lookup"><span data-stu-id="128a6-137">For general information about LINQ query execution, see [LINQ to Entities](./language-reference/linq-to-entities.md).</span></span> <span data-ttu-id="128a6-138">**Nota:**  LINQ to Entities le query che applicano l' `Enumerable.Contains` operatore alle raccolte in memoria non vengono memorizzate automaticamente nella cache.</span><span class="sxs-lookup"><span data-stu-id="128a6-138">**Note:**  LINQ to Entities queries that apply the `Enumerable.Contains` operator to in-memory collections are not automatically cached.</span></span> <span data-ttu-id="128a6-139">Inoltre, la parametrizzazione delle raccolte in memoria nelle query LINQ compilate non è consentita.</span><span class="sxs-lookup"><span data-stu-id="128a6-139">Also parameterizing in-memory collections in compiled LINQ queries is not allowed.</span></span>|  
|<span data-ttu-id="128a6-140">Esecuzione della query</span><span class="sxs-lookup"><span data-stu-id="128a6-140">Executing the query</span></span>|<span data-ttu-id="128a6-141">Basso<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="128a6-141">Low<sup>2</sup></span></span>|<span data-ttu-id="128a6-142">Una volta per ogni query.</span><span class="sxs-lookup"><span data-stu-id="128a6-142">Once for each query.</span></span>|<span data-ttu-id="128a6-143">Costo dell'esecuzione del comando sull'origine dati tramite il provider di dati ADO.NET.</span><span class="sxs-lookup"><span data-stu-id="128a6-143">The cost of executing the command against the data source by using the ADO.NET data provider.</span></span> <span data-ttu-id="128a6-144">Poiché la maggior parte delle origini dati memorizzano nella cache i piani di query, è possibile che le successive esecuzioni della stessa query siano ancor più veloci.</span><span class="sxs-lookup"><span data-stu-id="128a6-144">Because most data sources cache query plans, later executions of the same query may take even less time.</span></span>|  
|<span data-ttu-id="128a6-145">Caricamento e convalida di tipi</span><span class="sxs-lookup"><span data-stu-id="128a6-145">Loading and validating types</span></span>|<span data-ttu-id="128a6-146">Basso<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="128a6-146">Low<sup>3</sup></span></span>|<span data-ttu-id="128a6-147">Una volta per ciascuna istanza <xref:System.Data.Objects.ObjectContext>.</span><span class="sxs-lookup"><span data-stu-id="128a6-147">Once for each <xref:System.Data.Objects.ObjectContext> instance.</span></span>|<span data-ttu-id="128a6-148">I tipi vengono caricati e convalidati rispetto ai tipi definiti nel modello concettuale.</span><span class="sxs-lookup"><span data-stu-id="128a6-148">Types are loaded and validated against the types that the conceptual model defines.</span></span>|  
|<span data-ttu-id="128a6-149">Rilevamento</span><span class="sxs-lookup"><span data-stu-id="128a6-149">Tracking</span></span>|<span data-ttu-id="128a6-150">Basso<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="128a6-150">Low<sup>3</sup></span></span>|<span data-ttu-id="128a6-151">Una volta per ogni oggetto restituito da una query.</span><span class="sxs-lookup"><span data-stu-id="128a6-151">Once for each object that a query returns.</span></span> <span data-ttu-id="128a6-152"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="128a6-152"><sup>4</sup></span></span>|<span data-ttu-id="128a6-153">Se una query usa l'opzione di merge <xref:System.Data.Objects.MergeOption.NoTracking>, questa fase non influisce sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="128a6-153">If a query uses the <xref:System.Data.Objects.MergeOption.NoTracking> merge option, this stage does not affect performance.</span></span><br /><br /> <span data-ttu-id="128a6-154">Se la query usa l'opzione di merge <xref:System.Data.Objects.MergeOption.AppendOnly>, <xref:System.Data.Objects.MergeOption.PreserveChanges> o <xref:System.Data.Objects.MergeOption.OverwriteChanges>, i risultati della query vengono rilevati nell'oggetto <xref:System.Data.Objects.ObjectStateManager>.</span><span class="sxs-lookup"><span data-stu-id="128a6-154">If the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly>, <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> merge option, query results are tracked in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="128a6-155">Un oggetto <xref:System.Data.EntityKey> viene generato per ogni oggetto rilevato che la query restituisce e viene usato per creare un oggetto <xref:System.Data.Objects.ObjectStateEntry> in <xref:System.Data.Objects.ObjectStateManager>.</span><span class="sxs-lookup"><span data-stu-id="128a6-155">An <xref:System.Data.EntityKey> is generated for each tracked object that the query returns and is used to create an <xref:System.Data.Objects.ObjectStateEntry> in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="128a6-156">Se è possibile trovare un oggetto <xref:System.Data.Objects.ObjectStateEntry> per <xref:System.Data.EntityKey>, viene restituito l'oggetto esistente.</span><span class="sxs-lookup"><span data-stu-id="128a6-156">If an existing <xref:System.Data.Objects.ObjectStateEntry> can be found for the <xref:System.Data.EntityKey>, the existing object is returned.</span></span> <span data-ttu-id="128a6-157">Se viene usata l'opzione <xref:System.Data.Objects.MergeOption.PreserveChanges> o <xref:System.Data.Objects.MergeOption.OverwriteChanges>, l'oggetto viene aggiornato prima di essere restituito.</span><span class="sxs-lookup"><span data-stu-id="128a6-157">If the <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> option is used, the object is updated before it is returned.</span></span><br /><br /> <span data-ttu-id="128a6-158">Per ulteriori informazioni, vedere [risoluzione delle identità, gestione dello stato e rilevamento modifiche](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="128a6-158">For more information, see [Identity Resolution, State Management, and Change Tracking](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
|<span data-ttu-id="128a6-159">Materializzazione degli oggetti</span><span class="sxs-lookup"><span data-stu-id="128a6-159">Materializing the objects</span></span>|<span data-ttu-id="128a6-160">Moderato<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="128a6-160">Moderate<sup>3</sup></span></span>|<span data-ttu-id="128a6-161">Una volta per ogni oggetto restituito da una query.</span><span class="sxs-lookup"><span data-stu-id="128a6-161">Once for each object that a query returns.</span></span> <span data-ttu-id="128a6-162"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="128a6-162"><sup>4</sup></span></span>|<span data-ttu-id="128a6-163">Processo di lettura dell'oggetto <xref:System.Data.Common.DbDataReader> restituito, di creazione di oggetti e di impostazione di valori di proprietà che si basano sui valori in ciascuna istanza della classe <xref:System.Data.Common.DbDataRecord>.</span><span class="sxs-lookup"><span data-stu-id="128a6-163">The process of reading the returned <xref:System.Data.Common.DbDataReader> object and creating objects and setting property values that are based on the values in each instance of the <xref:System.Data.Common.DbDataRecord> class.</span></span> <span data-ttu-id="128a6-164">Se l'oggetto esiste già in <xref:System.Data.Objects.ObjectContext> e la query usa l'opzione di unione <xref:System.Data.Objects.MergeOption.AppendOnly> o <xref:System.Data.Objects.MergeOption.PreserveChanges>, questa fase non influisce sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="128a6-164">If the object already exists in the <xref:System.Data.Objects.ObjectContext> and the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly> or <xref:System.Data.Objects.MergeOption.PreserveChanges> merge options, this stage does not affect performance.</span></span> <span data-ttu-id="128a6-165">Per ulteriori informazioni, vedere [risoluzione delle identità, gestione dello stato e rilevamento modifiche](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="128a6-165">For more information, see [Identity Resolution, State Management, and Change Tracking](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
  
 <span data-ttu-id="128a6-166"><sup>1</sup> quando un provider dell'origine dati implementa il pool di connessioni, il costo di apertura di una connessione viene distribuito nel pool.</span><span class="sxs-lookup"><span data-stu-id="128a6-166"><sup>1</sup> When a data source provider implements connection pooling, the cost of opening a connection is distributed across the pool.</span></span> <span data-ttu-id="128a6-167">Il provider .NET per SQL Server supporta i pool di connessioni.</span><span class="sxs-lookup"><span data-stu-id="128a6-167">The .NET Provider for SQL Server supports connection pooling.</span></span>  
  
 <span data-ttu-id="128a6-168"><sup>2</sup> aumentano i costi con maggiore complessità delle query.</span><span class="sxs-lookup"><span data-stu-id="128a6-168"><sup>2</sup> Cost increases with increased query complexity.</span></span>  
  
 <span data-ttu-id="128a6-169"><sup>3</sup> il costo totale aumenta in modo proporzionale al numero di oggetti restituiti dalla query.</span><span class="sxs-lookup"><span data-stu-id="128a6-169"><sup>3</sup> Total cost increases proportional to the number of objects returned by the query.</span></span>  
  
 <span data-ttu-id="128a6-170"><sup>4</sup> questo sovraccarico non è necessario per le query EntityClient perché le query EntityClient restituiscono un <xref:System.Data.EntityClient.EntityDataReader> anziché oggetti.</span><span class="sxs-lookup"><span data-stu-id="128a6-170"><sup>4</sup> This overhead is not required for EntityClient queries because EntityClient queries return an <xref:System.Data.EntityClient.EntityDataReader> instead of objects.</span></span> <span data-ttu-id="128a6-171">Per ulteriori informazioni, vedere [Provider EntityClient per Entity Framework](entityclient-provider-for-the-entity-framework.md).</span><span class="sxs-lookup"><span data-stu-id="128a6-171">For more information, see [EntityClient Provider for the Entity Framework](entityclient-provider-for-the-entity-framework.md).</span></span>  
  
## <a name="additional-considerations"></a><span data-ttu-id="128a6-172">Ulteriori considerazioni</span><span class="sxs-lookup"><span data-stu-id="128a6-172">Additional Considerations</span></span>  
 <span data-ttu-id="128a6-173">Di seguito sono illustrate altre considerazioni che possono influire sulle prestazioni di applicazioni Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="128a6-173">The following are other considerations that may affect the performance of Entity Framework applications.</span></span>  
  
### <a name="query-execution"></a><span data-ttu-id="128a6-174">Esecuzione di query</span><span class="sxs-lookup"><span data-stu-id="128a6-174">Query Execution</span></span>  
 <span data-ttu-id="128a6-175">Poiché le query possono richiedere l'uso intenso delle risorse, è bene considerare in quale punto del codice e in quale computer viene eseguita una query.</span><span class="sxs-lookup"><span data-stu-id="128a6-175">Because queries can be resource intensive, consider at what point in your code and on what computer a query is executed.</span></span>  
  
#### <a name="deferred-versus-immediate-execution"></a><span data-ttu-id="128a6-176">Esecuzione posticipata e immediata</span><span class="sxs-lookup"><span data-stu-id="128a6-176">Deferred versus immediate execution</span></span>  
 <span data-ttu-id="128a6-177">Quando si crea un oggetto <xref:System.Data.Objects.ObjectQuery%601> o una query LINQ, è possibile che la query non sia eseguita immediatamente.</span><span class="sxs-lookup"><span data-stu-id="128a6-177">When you create an <xref:System.Data.Objects.ObjectQuery%601> or LINQ query, the query may not be executed immediately.</span></span> <span data-ttu-id="128a6-178">L'esecuzione della query è rinviata fino a quando i risultati non diventano necessari, ad esempio durante un'enumerazione `foreach` (C#) o `For Each` (Visual Basic) o quando è assegnata per completare una raccolta <xref:System.Collections.Generic.List%601>.</span><span class="sxs-lookup"><span data-stu-id="128a6-178">Query execution is deferred until the results are needed, such as during a `foreach` (C#) or `For Each` (Visual Basic) enumeration or when it is assigned to fill a <xref:System.Collections.Generic.List%601> collection.</span></span> <span data-ttu-id="128a6-179">L'esecuzione della query inizia immediatamente quando si chiama il metodo <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> in un oggetto <xref:System.Data.Objects.ObjectQuery%601> o quando si chiama un metodo LINQ che restituisce una query Singleton, ad esempio <xref:System.Linq.Enumerable.First%2A> o <xref:System.Linq.Enumerable.Any%2A>.</span><span class="sxs-lookup"><span data-stu-id="128a6-179">Query execution begins immediately when you call the <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> method on an <xref:System.Data.Objects.ObjectQuery%601> or when you call a LINQ method that returns a singleton query, such as <xref:System.Linq.Enumerable.First%2A> or <xref:System.Linq.Enumerable.Any%2A>.</span></span> <span data-ttu-id="128a6-180">Per ulteriori informazioni, vedere [query di oggetti](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) ed [esecuzione di query (LINQ to Entities)](./language-reference/query-execution.md).</span><span class="sxs-lookup"><span data-stu-id="128a6-180">For more information, see [Object Queries](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) and [Query Execution (LINQ to Entities)](./language-reference/query-execution.md).</span></span>  
  
#### <a name="client-side-execution-of-linq-queries"></a><span data-ttu-id="128a6-181">Esecuzione di query LINQ sul lato client</span><span class="sxs-lookup"><span data-stu-id="128a6-181">Client-side execution of LINQ queries</span></span>  
 <span data-ttu-id="128a6-182">Sebbene l'esecuzione di una query LINQ avvenga nel computer che ospita l'origine dati, è possibile che alcune parti della query LINQ vengano valutate nel computer client.</span><span class="sxs-lookup"><span data-stu-id="128a6-182">Although the execution of a LINQ query occurs on the computer that hosts the data source, some parts of a LINQ query may be evaluated on the client computer.</span></span> <span data-ttu-id="128a6-183">Per ulteriori informazioni, vedere la sezione esecuzione dello Store di [esecuzione di query (LINQ to Entities)](./language-reference/query-execution.md).</span><span class="sxs-lookup"><span data-stu-id="128a6-183">For more information, see the Store Execution section of [Query Execution (LINQ to Entities)](./language-reference/query-execution.md).</span></span>  
  
### <a name="query-and-mapping-complexity"></a><span data-ttu-id="128a6-184">Complessità delle query e del mapping</span><span class="sxs-lookup"><span data-stu-id="128a6-184">Query and Mapping Complexity</span></span>  
 <span data-ttu-id="128a6-185">La complessità di query singole e del mapping nel modello dell'entità influirà in modo significativo sulle prestazioni delle query.</span><span class="sxs-lookup"><span data-stu-id="128a6-185">The complexity of individual queries and of the mapping in the entity model will have a significant effect on query performance.</span></span>  
  
#### <a name="mapping-complexity"></a><span data-ttu-id="128a6-186">Complessità del mapping</span><span class="sxs-lookup"><span data-stu-id="128a6-186">Mapping complexity</span></span>  
 <span data-ttu-id="128a6-187">I modelli che sono più complessi di un mapping uno a uno tra entità nel modello concettuale e tabelle nel modello di archiviazione generano comandi più complessi rispetto ai modelli che dispongono di un mapping uno a uno.</span><span class="sxs-lookup"><span data-stu-id="128a6-187">Models that are more complex than a simple one-to-one mapping between entities in the conceptual model and tables in the storage model generate more complex commands than models that have a one-to-one mapping.</span></span>  
  
#### <a name="query-complexity"></a><span data-ttu-id="128a6-188">Complessità delle query</span><span class="sxs-lookup"><span data-stu-id="128a6-188">Query complexity</span></span>  
 <span data-ttu-id="128a6-189">Le query con un elevato numero di join nei comandi che sono eseguite sull'origine dati o che restituiscono una grande quantità di dati influiscono sulle prestazioni nei seguenti modi:</span><span class="sxs-lookup"><span data-stu-id="128a6-189">Queries that require a large number of joins in the commands that are executed against the data source or that return a large amount of data may affect performance in the following ways:</span></span>  
  
- <span data-ttu-id="128a6-190">Le query su un modello concettuale che sembrano semplici possono comportare l'esecuzione di query più complesse sull'origine dati.</span><span class="sxs-lookup"><span data-stu-id="128a6-190">Queries against a conceptual model that seem simple may result in the execution of more complex queries against the data source.</span></span> <span data-ttu-id="128a6-191">Il motivo consiste nel fatto che Entity Framework traduce una query su un modello concettuale in una equivalente query sull'origine dati.</span><span class="sxs-lookup"><span data-stu-id="128a6-191">This can occur because the Entity Framework translates a query against a conceptual model into an equivalent query against the data source.</span></span> <span data-ttu-id="128a6-192">Quando un singolo set di entità nel modello concettuale esegue il mapping a più tabelle nell'origine dati, o quando una relazione tra entità viene mappata a una tabella di join, è possibile che il comando di query eseguito sulla query dell'origine dati richieda uno o più join.</span><span class="sxs-lookup"><span data-stu-id="128a6-192">When a single entity set in the conceptual model maps to more than one table in the data source, or when a relationship between entities is mapped to a join table, the query command executed against the data source query may require one or more joins.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="128a6-193">Usare il metodo <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> della classe <xref:System.Data.Objects.ObjectQuery%601> o <xref:System.Data.EntityClient.EntityCommand> per visualizzare i comandi che sono eseguiti sull'origine dati per una data query.</span><span class="sxs-lookup"><span data-stu-id="128a6-193">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method of the <xref:System.Data.Objects.ObjectQuery%601> or <xref:System.Data.EntityClient.EntityCommand> classes to view the commands that are executed against the data source for a given query.</span></span> <span data-ttu-id="128a6-194">Per altre informazioni, vedere [procedura: visualizzare i comandi di archiviazione](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="128a6-194">For more information, see [How to: View the Store Commands](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
- <span data-ttu-id="128a6-195">Le query Entity SQL annidate possono creare join nel server e possono restituire un elevato numero di righe.</span><span class="sxs-lookup"><span data-stu-id="128a6-195">Nested Entity SQL queries may create joins on the server and can return a large number of rows.</span></span>  
  
     <span data-ttu-id="128a6-196">Di seguito è riportato un esempio di query annidata in una clausola di proiezione:</span><span class="sxs-lookup"><span data-stu-id="128a6-196">The following is an example of a nested query in a projection clause:</span></span>  
  
    ```sql  
    SELECT c, (SELECT c, (SELECT c FROM AdventureWorksModel.Vendor AS c  ) As Inner2
        FROM AdventureWorksModel.JobCandidate AS c  ) As Inner1
        FROM AdventureWorksModel.EmployeeDepartmentHistory AS c  
    ```  
  
     <span data-ttu-id="128a6-197">Inoltre, tali query fanno in modo che la pipeline delle query generi un'unica query con duplicazione di oggetti tra le query annidate.</span><span class="sxs-lookup"><span data-stu-id="128a6-197">In addition, such queries cause the query pipeline to generate a single query with duplication of objects across nested queries.</span></span> <span data-ttu-id="128a6-198">Per questo motivo una singola colonna può essere duplicata più volte.</span><span class="sxs-lookup"><span data-stu-id="128a6-198">Because of this, a single column may be duplicated multiple times.</span></span> <span data-ttu-id="128a6-199">In alcuni database, tra cui SQL Server, questo può causare un forte aumento delle dimensioni della tabella TempDB, con effetti negativi sulle prestazioni del server.</span><span class="sxs-lookup"><span data-stu-id="128a6-199">On some databases, including SQL Server, this can cause the TempDB table to grow very large, which can decrease server performance.</span></span> <span data-ttu-id="128a6-200">Occorre quindi prestare attenzione quando si eseguono query annidate.</span><span class="sxs-lookup"><span data-stu-id="128a6-200">Care should be taken when you execute nested queries.</span></span>  
  
- <span data-ttu-id="128a6-201">Qualsiasi query che restituisce un elevato numero di dati può causare una diminuzione delle prestazioni se il client in quel momento sta eseguendo operazioni che consumano risorse in modo proporzionale alle dimensioni del set dei risultati.</span><span class="sxs-lookup"><span data-stu-id="128a6-201">Any queries that return a large amount of data can cause decreased performance if the client is performing operations that consume resources in a way that is proportional to the size of the result set.</span></span> <span data-ttu-id="128a6-202">In tali casi, è necessario limitare la quantità di dati restituiti dalla query.</span><span class="sxs-lookup"><span data-stu-id="128a6-202">In such cases, you should consider limiting the amount of data returned by the query.</span></span> <span data-ttu-id="128a6-203">Per ulteriori informazioni, vedere [procedura: pagina tramite i risultati della query](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="128a6-203">For more information, see [How to: Page Through Query Results](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
 <span data-ttu-id="128a6-204">Qualsiasi comando generato automaticamente da Entity Framework può essere più complesso degli analoghi comandi scritti in modo esplicito da un sviluppatore del database.</span><span class="sxs-lookup"><span data-stu-id="128a6-204">Any commands automatically generated by the Entity Framework may be more complex than similar commands written explicitly by a database developer.</span></span> <span data-ttu-id="128a6-205">Se è necessario avere il controllo esplicito sui comandi eseguiti sull'origine dati, si può definire un mapping a una funzione con valori di tabella o una stored procedure.</span><span class="sxs-lookup"><span data-stu-id="128a6-205">If you need explicit control over the commands executed against your data source, consider defining a mapping to a table-valued function or stored procedure.</span></span>  
  
#### <a name="relationships"></a><span data-ttu-id="128a6-206">Relazioni</span><span class="sxs-lookup"><span data-stu-id="128a6-206">Relationships</span></span>  
 <span data-ttu-id="128a6-207">Per ottenere prestazioni ottimali nell'esecuzione delle query, è necessario definire delle relazioni tra entità sia come associazioni nel modello di entità che come relazioni logiche nell'origine dati.</span><span class="sxs-lookup"><span data-stu-id="128a6-207">For optimal query performance, you must define relationships between entities both as associations in the entity model and as logical relationships in the data source.</span></span>  
  
### <a name="query-paths"></a><span data-ttu-id="128a6-208">Percorsi della query</span><span class="sxs-lookup"><span data-stu-id="128a6-208">Query Paths</span></span>  
 <span data-ttu-id="128a6-209">Per impostazione predefinita, quando si esegue un <xref:System.Data.Objects.ObjectQuery%601>, gli oggetti correlati non vengono restituiti (anche se si tratta di oggetti che rappresentano le relazioni).</span><span class="sxs-lookup"><span data-stu-id="128a6-209">By default, when you execute an <xref:System.Data.Objects.ObjectQuery%601>, related objects are not returned (although objects that represent the relationships themselves are).</span></span> <span data-ttu-id="128a6-210">È possibile caricare oggetti correlati in una delle tre modalità riportate di seguito:</span><span class="sxs-lookup"><span data-stu-id="128a6-210">You can load related objects in one of three ways:</span></span>  
  
1. <span data-ttu-id="128a6-211">Impostando il percorso della query prima che venga eseguito l'oggetto <xref:System.Data.Objects.ObjectQuery%601>.</span><span class="sxs-lookup"><span data-stu-id="128a6-211">Set the query path before the <xref:System.Data.Objects.ObjectQuery%601> is executed.</span></span>  
  
2. <span data-ttu-id="128a6-212">Chiamando il metodo `Load` sulla proprietà di navigazione esposta dall'oggetto.</span><span class="sxs-lookup"><span data-stu-id="128a6-212">Call the `Load` method on the navigation property that the object exposes.</span></span>  
  
3. <span data-ttu-id="128a6-213">Impostando l'opzione <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> nell'oggetto <xref:System.Data.Objects.ObjectContext> su `true`.</span><span class="sxs-lookup"><span data-stu-id="128a6-213">Set the <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> option on the <xref:System.Data.Objects.ObjectContext> to `true`.</span></span> <span data-ttu-id="128a6-214">Si noti che questa operazione viene eseguita automaticamente quando si genera codice del livello oggetti con la [finestra di progettazione Entity Data Model](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="128a6-214">Note that this is done automatically when you generate object-layer code with the [Entity Data Model Designer](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100)).</span></span> <span data-ttu-id="128a6-215">Per ulteriori informazioni, vedere [Cenni preliminari sul codice generato](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="128a6-215">For more information see [Generated Code Overview](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100)).</span></span>  
  
 <span data-ttu-id="128a6-216">Nella scelta dell'opzione da usare, considerare il compromesso tra il numero di richieste nel database e la quantità di dati restituiti in una singola query.</span><span class="sxs-lookup"><span data-stu-id="128a6-216">When you consider which option to use, be aware that there is a tradeoff between the number of requests against the database and the amount of data returned in a single query.</span></span> <span data-ttu-id="128a6-217">Per ulteriori informazioni, vedere [caricamento di oggetti correlati](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="128a6-217">For more information, see [Loading Related Objects](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
#### <a name="using-query-paths"></a><span data-ttu-id="128a6-218">Uso di percorsi della query</span><span class="sxs-lookup"><span data-stu-id="128a6-218">Using query paths</span></span>  
 <span data-ttu-id="128a6-219">I percorsi della query definiscono il grafico degli oggetti restituiti da una query.</span><span class="sxs-lookup"><span data-stu-id="128a6-219">Query paths define the graph of objects that a query returns.</span></span> <span data-ttu-id="128a6-220">Quando si definisce un percorso della query, è sufficiente una sola richiesta al database per restituire tutti gli oggetti definiti dal percorso.</span><span class="sxs-lookup"><span data-stu-id="128a6-220">When you define a query path, only a single request against the database is required to return all objects that the path defines.</span></span> <span data-ttu-id="128a6-221">L'uso di percorsi della query può comportare l'esecuzione di comandi complessi nell'origine dati, derivanti da query di oggetto apparentemente semplici.</span><span class="sxs-lookup"><span data-stu-id="128a6-221">Using query paths can result in complex commands being executed against the data source from seemingly simple object queries.</span></span> <span data-ttu-id="128a6-222">Questo si verifica in quanto per restituire oggetti correlati in una singola query sono necessari uno o più join.</span><span class="sxs-lookup"><span data-stu-id="128a6-222">This occurs because one or more joins are required to return related objects in a single query.</span></span> <span data-ttu-id="128a6-223">Questa complessità è maggiore nelle query su un modello di entità complesso, ad esempio un'entità con ereditarietà o un percorso che include relazioni molti-a-molti.</span><span class="sxs-lookup"><span data-stu-id="128a6-223">This complexity is greater in queries against a complex entity model, such as an entity with inheritance or a path that includes many-to-many relationships.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="128a6-224">Usare il metodo <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> per visualizzare il comando che verrà generato da un oggetto <xref:System.Data.Objects.ObjectQuery%601>.</span><span class="sxs-lookup"><span data-stu-id="128a6-224">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method to see the command that will be generated by an <xref:System.Data.Objects.ObjectQuery%601>.</span></span> <span data-ttu-id="128a6-225">Per altre informazioni, vedere [procedura: visualizzare i comandi di archiviazione](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="128a6-225">For more information, see [How to: View the Store Commands](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
 <span data-ttu-id="128a6-226">Quando un percorso della query include troppi oggetti correlati o gli oggetti contengono troppi dati delle righe, potrebbe non essere possibile completare la query dall'origine dati.</span><span class="sxs-lookup"><span data-stu-id="128a6-226">When a query path includes too many related objects or the objects contain too much row data, the data source might be unable to complete the query.</span></span> <span data-ttu-id="128a6-227">Questo si verifica se la query richiede un'archiviazione temporanea intermedia superiore alle possibilità dell'origine dati.</span><span class="sxs-lookup"><span data-stu-id="128a6-227">This occurs if the query requires intermediate temporary storage that exceeds the capabilities of the data source.</span></span> <span data-ttu-id="128a6-228">In questo caso, è possibile ridurre la complessità della query sull'origine dati caricando in modo esplicito gli oggetti correlati.</span><span class="sxs-lookup"><span data-stu-id="128a6-228">When this occurs, you can reduce the complexity of the data source query by explicitly loading related objects.</span></span>  
  
#### <a name="explicitly-loading-related-objects"></a><span data-ttu-id="128a6-229">Caricamento esplicito di oggetti correlati</span><span class="sxs-lookup"><span data-stu-id="128a6-229">Explicitly loading related objects</span></span>  
 <span data-ttu-id="128a6-230">È possibile caricare in modo esplicito degli oggetti correlati chiamando il metodo `Load` in una proprietà di navigazione che restituisce un oggetto <xref:System.Data.Objects.DataClasses.EntityCollection%601> o <xref:System.Data.Objects.DataClasses.EntityReference%601>.</span><span class="sxs-lookup"><span data-stu-id="128a6-230">You can explicitly load related objects by calling the `Load` method on a navigation property that returns an <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601>.</span></span> <span data-ttu-id="128a6-231">Il caricamento esplicito di oggetti richiede un round trip al database ad ogni chiamata del metodo `Load`.</span><span class="sxs-lookup"><span data-stu-id="128a6-231">Explicitly loading objects requires a round-trip to the database every time `Load` is called.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="128a6-232">Se si chiama il metodo `Load` durante l'esecuzione di ciclo in una raccolta di oggetti restituiti, come quando si usa l'istruzione `foreach` (`For Each` in Visual Basic), è necessario che il provider specifico dell'origine dati supporti più set dei risultati attivi in un'unica connessione.</span><span class="sxs-lookup"><span data-stu-id="128a6-232">if you call `Load` while looping through a collection of returned objects, such as when you use the `foreach` statement (`For Each` in Visual Basic), the data source-specific provider must support multiple active results sets on a single connection.</span></span> <span data-ttu-id="128a6-233">Per un database di SQL Server, è necessario specificare un valore di `MultipleActiveResultSets = true` nella stringa di connessione del provider.</span><span class="sxs-lookup"><span data-stu-id="128a6-233">For a SQL Server database, you must specify a value of `MultipleActiveResultSets = true` in the provider connection string.</span></span>  
  
 <span data-ttu-id="128a6-234">È inoltre possibile usare il metodo <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> quando non si dispone di proprietà <xref:System.Data.Objects.DataClasses.EntityCollection%601> o <xref:System.Data.Objects.DataClasses.EntityReference%601> sulle entità.</span><span class="sxs-lookup"><span data-stu-id="128a6-234">You can also use the <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> method when there is no <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601> properties on entities.</span></span> <span data-ttu-id="128a6-235">Questa situazione si rivela utile quando si usano entità POCO.</span><span class="sxs-lookup"><span data-stu-id="128a6-235">This is useful when you are using POCO entities.</span></span>  
  
 <span data-ttu-id="128a6-236">Anche se il caricamento esplicito di oggetti correlati ridurrà il numero di join e ridurrà la quantità di dati ridondanti, `Load` richiede ripetute connessioni al database e questa procedura può diventare costosa se si caricano in modo esplicito molti oggetti.</span><span class="sxs-lookup"><span data-stu-id="128a6-236">Although explicitly loading related objects will reduce the number of joins and reduced the amount of redundant data, `Load` requires repeated connections to the database, which can become costly when explicitly loading a large number of objects.</span></span>  
  
### <a name="saving-changes"></a><span data-ttu-id="128a6-237">Salvataggio delle modifiche</span><span class="sxs-lookup"><span data-stu-id="128a6-237">Saving Changes</span></span>  
 <span data-ttu-id="128a6-238">Quando si chiama il metodo <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> in un oggetto <xref:System.Data.Objects.ObjectContext>, viene generato un comando di creazione, aggiornamento o eliminazione distinto per ogni oggetto aggiunto, aggiornato o eliminato nel contesto.</span><span class="sxs-lookup"><span data-stu-id="128a6-238">When you call the <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> method on an <xref:System.Data.Objects.ObjectContext>, a separate create, update, or delete command is generated for every added, updated, or deleted object in the context.</span></span> <span data-ttu-id="128a6-239">Questi comandi vengono eseguiti sull'origine dati in una sola transazione.</span><span class="sxs-lookup"><span data-stu-id="128a6-239">These commands are executed on the data source in a single transaction.</span></span> <span data-ttu-id="128a6-240">Come avviene per le query, le prestazioni delle operazioni di creazione, aggiornamento ed eliminazione dipendono dalla complessità del mapping nel modello concettuale.</span><span class="sxs-lookup"><span data-stu-id="128a6-240">As with queries, the performance of create, update, and delete operations depends on the complexity of the mapping in the conceptual model.</span></span>  
  
### <a name="distributed-transactions"></a><span data-ttu-id="128a6-241">Transazioni distribuite</span><span class="sxs-lookup"><span data-stu-id="128a6-241">Distributed Transactions</span></span>  
 <span data-ttu-id="128a6-242">Le operazioni in una transazione esplicita che richiedono risorse gestite dal DTC (Distributed Transaction Coordinator) saranno molto più costose di un'operazione analoga che non richiede il DTC.</span><span class="sxs-lookup"><span data-stu-id="128a6-242">Operations in an explicit transaction that require resources that are managed by the distributed transaction coordinator (DTC) will be much more expensive than a similar operation that does not require the DTC.</span></span> <span data-ttu-id="128a6-243">Una promozione al DTC avverrà nelle situazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="128a6-243">Promotion to the DTC will occur in the following situations:</span></span>  
  
- <span data-ttu-id="128a6-244">Una transazione esplicita con un'operazione su un database SQL Server 2000 o altra origine dati che promuove sempre transazioni esplicite al DTC.</span><span class="sxs-lookup"><span data-stu-id="128a6-244">An explicit transaction with an operation against a SQL Server 2000 database or other data source that always promote explicit transactions to the DTC.</span></span>  
  
- <span data-ttu-id="128a6-245">Transazione esplicita con un'operazione su SQL Server 2005 quando la connessione viene gestita dal Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="128a6-245">An explicit transaction with an operation against SQL Server 2005 when the connection is managed by the Entity Framework.</span></span> <span data-ttu-id="128a6-246">Questo problema si verifica perché SQL Server 2005 promuove a un DTC ogni volta che una connessione viene chiusa e riaperta all'interno di una singola transazione, che è il comportamento predefinito del Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="128a6-246">This occurs because SQL Server 2005 promotes to a DTC whenever a connection is closed and reopened within a single transaction, which is the default behavior of the Entity Framework.</span></span> <span data-ttu-id="128a6-247">Questa promozione al DTC non avviene quando si utilizza SQL Server 2008.</span><span class="sxs-lookup"><span data-stu-id="128a6-247">This DTC promotion does not occur when using SQL Server 2008.</span></span> <span data-ttu-id="128a6-248">Per evitare questa promozione quando si utilizza SQL Server 2005, è necessario aprire e chiudere la connessione in modo esplicito all'interno della transazione.</span><span class="sxs-lookup"><span data-stu-id="128a6-248">To avoid this promotion when using SQL Server 2005, you must explicitly open and close the connection within the transaction.</span></span> <span data-ttu-id="128a6-249">Per ulteriori informazioni, vedere [gestione delle connessioni e delle transazioni](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="128a6-249">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
 <span data-ttu-id="128a6-250">Una transazione esplicita viene usata quando una o più operazioni vengono eseguite all'interno di una transazione <xref:System.Transactions>.</span><span class="sxs-lookup"><span data-stu-id="128a6-250">An explicit transaction is used when one or more operations are executed inside a <xref:System.Transactions> transaction.</span></span> <span data-ttu-id="128a6-251">Per ulteriori informazioni, vedere [gestione delle connessioni e delle transazioni](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="128a6-251">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="strategies-for-improving-performance"></a><span data-ttu-id="128a6-252">Strategie per migliorare le prestazioni</span><span class="sxs-lookup"><span data-stu-id="128a6-252">Strategies for Improving Performance</span></span>  
 <span data-ttu-id="128a6-253">È possibile migliorare le prestazioni complessive delle query in Entity Framework usando le strategie seguenti.</span><span class="sxs-lookup"><span data-stu-id="128a6-253">You can improve the overall performance of queries in the Entity Framework by using the following strategies.</span></span>  
  
#### <a name="pre-generate-views"></a><span data-ttu-id="128a6-254">Generare in anticipo le visualizzazioni</span><span class="sxs-lookup"><span data-stu-id="128a6-254">Pre-generate views</span></span>  
 <span data-ttu-id="128a6-255">La generazione di visualizzazioni basate su un modello di entità ha un costo significativo la prima volta che un'applicazione esegue una query.</span><span class="sxs-lookup"><span data-stu-id="128a6-255">Generating views based on an entity model is a significant cost the first time that an application executes a query.</span></span> <span data-ttu-id="128a6-256">Usare EdmGen.exe per generare in anticipo visualizzazioni come un file di codice Visual Basic o C# che può essere aggiunto al progetto nella fase di progettazione.</span><span class="sxs-lookup"><span data-stu-id="128a6-256">Use the EdmGen.exe utility to pre-generate views as a Visual Basic or C# code file that can be added to the project during design.</span></span> <span data-ttu-id="128a6-257">Per generare visualizzazioni pre-compilate, è inoltre possibile usare il toolkit di trasformazione dei modelli di testo.</span><span class="sxs-lookup"><span data-stu-id="128a6-257">You could also use the Text Template Transformation Toolkit to generate pre-compiled views.</span></span> <span data-ttu-id="128a6-258">Le visualizzazioni generate in anticipo vengono convalidate in fase di esecuzione per garantirne la coerenza con la versione corrente del modello di entità specificato.</span><span class="sxs-lookup"><span data-stu-id="128a6-258">Pre-generated views are validated at runtime to ensure that they are consistent with the current version of the specified entity model.</span></span> <span data-ttu-id="128a6-259">Per altre informazioni, vedere [procedura: pre-generare viste per migliorare le prestazioni di esecuzione delle query](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="128a6-259">For more information, see [How to: Pre-Generate Views to Improve Query Performance](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>
  
 <span data-ttu-id="128a6-260">Quando si usano modelli di dimensioni elevate, si applica la considerazione seguente:</span><span class="sxs-lookup"><span data-stu-id="128a6-260">When working with very large models, the following consideration applies:</span></span>  
  
 <span data-ttu-id="128a6-261">Il formato dei metadati .NET limita il numero di caratteri di stringa specificabili dall'utente in un file binario a 16.777.215 (0xFFFFFF).</span><span class="sxs-lookup"><span data-stu-id="128a6-261">The .NET metadata format limits the number of user string characters in a given binary to 16,777,215 (0xFFFFFF).</span></span> <span data-ttu-id="128a6-262">Se si generano visualizzazioni per un modello di dimensioni molto grandi e il file di visualizzazione raggiunge tale limite, verrà visualizzato lo spazio logico per la creazione di altre stringhe utente.</span><span class="sxs-lookup"><span data-stu-id="128a6-262">If you are generating views for a very large model and the view file reaches this size limit, you will get the "No logical space left to create more user strings."</span></span> <span data-ttu-id="128a6-263">errore di compilazione.</span><span class="sxs-lookup"><span data-stu-id="128a6-263">compile error.</span></span> <span data-ttu-id="128a6-264">Questa limitazione delle dimensioni si applica a tutti i file binari gestiti.</span><span class="sxs-lookup"><span data-stu-id="128a6-264">This size limitation applies to all managed binaries.</span></span> <span data-ttu-id="128a6-265">Per ulteriori informazioni, vedere il [Blog](https://docs.microsoft.com/archive/blogs/appfabriccat/solving-the-no-logical-space-left-to-create-more-user-strings-error-and-improving-performance-of-pre-generated-views-in-visual-studio-net4-entity-framework) che illustra come evitare l'errore quando si utilizzano modelli complessi e di grandi dimensioni.</span><span class="sxs-lookup"><span data-stu-id="128a6-265">For more information see the [blog](https://docs.microsoft.com/archive/blogs/appfabriccat/solving-the-no-logical-space-left-to-create-more-user-strings-error-and-improving-performance-of-pre-generated-views-in-visual-studio-net4-entity-framework) that demonstrates how to avoid the error when working with large and complex models.</span></span>  
  
#### <a name="consider-using-the-notracking-merge-option-for-queries"></a><span data-ttu-id="128a6-266">Usare l'opzione di merge NoTracking per le query</span><span class="sxs-lookup"><span data-stu-id="128a6-266">Consider using the NoTracking merge option for queries</span></span>  
 <span data-ttu-id="128a6-267">Esiste un costo necessario per tenere traccia degli oggetti restituiti nel contesto dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="128a6-267">There is a cost required to track returned objects in the object context.</span></span> <span data-ttu-id="128a6-268">Il rilevamento di modifiche agli oggetti e la garanzia che più richieste per la stessa l'entità logica restituiscano la stessa istanza dell'oggetto richiedono che gli oggetti siano allegati a un'istanza <xref:System.Data.Objects.ObjectContext>.</span><span class="sxs-lookup"><span data-stu-id="128a6-268">Detecting changes to objects and ensuring that multiple requests for the same logical entity return the same object instance requires that objects be attached to an <xref:System.Data.Objects.ObjectContext> instance.</span></span> <span data-ttu-id="128a6-269">Se non si intende effettuare aggiornamenti o eliminazioni di oggetti e non è necessaria la gestione delle identità, è consigliabile utilizzare le <xref:System.Data.Objects.MergeOption.NoTracking> Opzioni di Unione quando si eseguono le query.</span><span class="sxs-lookup"><span data-stu-id="128a6-269">If you do not plan to make updates or deletes to objects and do not require identity management, consider using the <xref:System.Data.Objects.MergeOption.NoTracking> merge options when you execute queries.</span></span>  
  
#### <a name="return-the-correct-amount-of-data"></a><span data-ttu-id="128a6-270">Restituire la quantità corretta di dati</span><span class="sxs-lookup"><span data-stu-id="128a6-270">Return the correct amount of data</span></span>  
 <span data-ttu-id="128a6-271">In alcuni scenari, la specifica di un percorso della query usando il metodo <xref:System.Data.Objects.ObjectQuery%601.Include%2A> è molto più veloce perché richiede meno round trip al database.</span><span class="sxs-lookup"><span data-stu-id="128a6-271">In some scenarios, specifying a query path using the <xref:System.Data.Objects.ObjectQuery%601.Include%2A> method is much faster because it requires fewer round trips to the database.</span></span> <span data-ttu-id="128a6-272">Tuttavia, in altri scenari, l'esecuzione di round trip aggiuntivi al database per caricare oggetti correlati potrebbe risultare più veloce perché le query più semplici con meno join comportano meno ridondanza di dati.</span><span class="sxs-lookup"><span data-stu-id="128a6-272">However, in other scenarios, additional round trips to the database to load related objects may be faster because the simpler queries with fewer joins result in less redundancy of data.</span></span> <span data-ttu-id="128a6-273">Per questo motivo si consiglia di testare le prestazioni usando varie modalità di recupero di oggetti correlati.</span><span class="sxs-lookup"><span data-stu-id="128a6-273">Because of this, we recommend that you test the performance of various ways to retrieve related objects.</span></span> <span data-ttu-id="128a6-274">Per ulteriori informazioni, vedere [caricamento di oggetti correlati](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="128a6-274">For more information, see [Loading Related Objects](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
 <span data-ttu-id="128a6-275">Per evitare la restituzione di troppi dati in una sola query, si può considerare di eseguire il paging dei risultati della query in gruppi più gestibili.</span><span class="sxs-lookup"><span data-stu-id="128a6-275">To avoid returning too much data in a single query, consider paging the results of the query into more manageable groups.</span></span> <span data-ttu-id="128a6-276">Per ulteriori informazioni, vedere [procedura: pagina tramite i risultati della query](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="128a6-276">For more information, see [How to: Page Through Query Results](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
#### <a name="limit-the-scope-of-the-objectcontext"></a><span data-ttu-id="128a6-277">Limitare l'ambito di ObjectContext</span><span class="sxs-lookup"><span data-stu-id="128a6-277">Limit the scope of the ObjectContext</span></span>  
 <span data-ttu-id="128a6-278">Nella maggior parte dei casi, è necessario creare un'istanza <xref:System.Data.Objects.ObjectContext> all'interno di un'istruzione `using` (`Using…End Using` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="128a6-278">In most cases, you should create an <xref:System.Data.Objects.ObjectContext> instance within a `using` statement (`Using…End Using` in Visual Basic).</span></span> <span data-ttu-id="128a6-279">In questo modo le prestazioni migliorano in quanto viene garantita l'eliminazione automatica delle risorse associate al contesto dell'oggetto quando il codice esce dal blocco di istruzioni.</span><span class="sxs-lookup"><span data-stu-id="128a6-279">This can increase performance by ensuring that the resources associated with the object context are disposed automatically when the code exits the statement block.</span></span> <span data-ttu-id="128a6-280">Tuttavia, quando i controlli vengono associati a oggetti gestiti dal contesto dell'oggetto, l'istanza <xref:System.Data.Objects.ObjectContext> deve essere gestita finché l'associazione è necessaria e viene eliminata manualmente.</span><span class="sxs-lookup"><span data-stu-id="128a6-280">However, when controls are bound to objects managed by the object context, the <xref:System.Data.Objects.ObjectContext> instance should be maintained as long as the binding is needed and disposed of manually.</span></span> <span data-ttu-id="128a6-281">Per ulteriori informazioni, vedere [gestione delle connessioni e delle transazioni](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="128a6-281">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
#### <a name="consider-opening-the-database-connection-manually"></a><span data-ttu-id="128a6-282">Aprire manualmente la connessione al database</span><span class="sxs-lookup"><span data-stu-id="128a6-282">Consider opening the database connection manually</span></span>  
 <span data-ttu-id="128a6-283">Quando l'applicazione esegue una serie di query di oggetto o chiama <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> di frequente per rendere permanente le operazioni di creazione, aggiornamento ed eliminazione nell'origine dati, il Entity Framework deve aprire e chiudere continuamente la connessione all'origine dati.</span><span class="sxs-lookup"><span data-stu-id="128a6-283">When your application executes a series of object queries or frequently calls <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> to persist create, update, and delete operations to the data source, the Entity Framework must continuously open and close the connection to the data source.</span></span> <span data-ttu-id="128a6-284">In queste situazioni, può essere utile aprire manualmente la connessione all'inizio di queste operazioni e chiuderla o eliminarla quando le operazioni sono completate.</span><span class="sxs-lookup"><span data-stu-id="128a6-284">In these situations, consider manually opening the connection at the start of these operations and either closing or disposing of the connection when the operations are complete.</span></span> <span data-ttu-id="128a6-285">Per ulteriori informazioni, vedere [gestione delle connessioni e delle transazioni](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="128a6-285">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="performance-data"></a><span data-ttu-id="128a6-286">Dati prestazioni</span><span class="sxs-lookup"><span data-stu-id="128a6-286">Performance Data</span></span>  
 <span data-ttu-id="128a6-287">Alcuni dati sulle prestazioni per il Entity Framework sono pubblicati nei post seguenti nel [Blog del team di ADO.NET](https://docs.microsoft.com/archive/blogs/adonet/):</span><span class="sxs-lookup"><span data-stu-id="128a6-287">Some performance data for the Entity Framework is published in the following posts on the [ADO.NET team blog](https://docs.microsoft.com/archive/blogs/adonet/):</span></span>  
  
- [<span data-ttu-id="128a6-288">Analisi delle prestazioni di ADO.NET Entity Framework - parte 1</span><span class="sxs-lookup"><span data-stu-id="128a6-288">Exploring the Performance of the ADO.NET Entity Framework - Part 1</span></span>](https://docs.microsoft.com/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-1)  
  
- [<span data-ttu-id="128a6-289">Analisi delle prestazioni di ADO.NET Entity Framework - parte 2</span><span class="sxs-lookup"><span data-stu-id="128a6-289">Exploring the Performance of the ADO.NET Entity Framework – Part 2</span></span>](https://docs.microsoft.com/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-2)  
  
- [<span data-ttu-id="128a6-290">Confronto di prestazioni di ADO.NET Entity Framework</span><span class="sxs-lookup"><span data-stu-id="128a6-290">ADO.NET Entity Framework Performance Comparison</span></span>](https://docs.microsoft.com/archive/blogs/adonet/ado-net-entity-framework-performance-comparison)  
  
## <a name="see-also"></a><span data-ttu-id="128a6-291">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="128a6-291">See also</span></span>

- [<span data-ttu-id="128a6-292">Considerazioni sullo sviluppo e sulla distribuzione</span><span class="sxs-lookup"><span data-stu-id="128a6-292">Development and Deployment Considerations</span></span>](development-and-deployment-considerations.md)
