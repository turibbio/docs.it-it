---
title: Popolamento di un dataset da un oggetto DataAdapter
description: Informazioni su come popolare un set di dati da un DataAdapter in ADO.NET, che fornisce un modello di programmazione relazionale coerente indipendente dall'origine dati.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 3fa0ac7d-e266-4954-bfac-3fbe2f913153
ms.openlocfilehash: 3d4da840e1d51ec6f309915787caa8891db3eb59
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/02/2020
ms.locfileid: "84286663"
---
# <a name="populating-a-dataset-from-a-dataadapter"></a><span data-ttu-id="b389b-103">Popolamento di un dataset da un oggetto DataAdapter</span><span class="sxs-lookup"><span data-stu-id="b389b-103">Populating a DataSet from a DataAdapter</span></span>
<span data-ttu-id="b389b-104">ADO.NET <xref:System.Data.DataSet> è una rappresentazione di dati residente in memoria che fornisce un modello di programmazione relazionale coerente indipendente dall'origine dati.</span><span class="sxs-lookup"><span data-stu-id="b389b-104">The ADO.NET <xref:System.Data.DataSet> is a memory-resident representation of data that provides a consistent relational programming model independent of the data source.</span></span> <span data-ttu-id="b389b-105">Il `DataSet` rappresenta un set completo di dati che include tabelle, vincoli e relazioni tra tabelle.</span><span class="sxs-lookup"><span data-stu-id="b389b-105">The `DataSet` represents a complete set of data that includes tables, constraints, and relationships among the tables.</span></span> <span data-ttu-id="b389b-106">Poiché il `DataSet` è indipendente dall'origine dati, un `DataSet` può includere dati locali dell'applicazione nonché dati di più origini dati.</span><span class="sxs-lookup"><span data-stu-id="b389b-106">Because the `DataSet` is independent of the data source, a `DataSet` can include data local to the application, and data from multiple data sources.</span></span> <span data-ttu-id="b389b-107">L'interazione con le origini dati esistenti è controllata tramite `DataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="b389b-107">Interaction with existing data sources is controlled through the `DataAdapter`.</span></span>  
  
 <span data-ttu-id="b389b-108">La proprietà `SelectCommand` di `DataAdapter` è un oggetto `Command` che recupera i dati dall'origine dati.</span><span class="sxs-lookup"><span data-stu-id="b389b-108">The `SelectCommand` property of the `DataAdapter` is a `Command` object that retrieves data from the data source.</span></span> <span data-ttu-id="b389b-109">Le proprietà `InsertCommand`, `UpdateCommand`e `DeleteCommand` di `DataAdapter` sono oggetti `Command` che gestiscono gli aggiornamenti ai dati nell'origine dati in base alle modifiche apportate nel `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="b389b-109">The `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties of the `DataAdapter` are `Command` objects that manage updates to the data in the data source according to modifications made to the data in the `DataSet`.</span></span> <span data-ttu-id="b389b-110">Queste proprietà sono descritte in modo più dettagliato nell' [aggiornamento delle origini dati con i DataAdapter](updating-data-sources-with-dataadapters.md).</span><span class="sxs-lookup"><span data-stu-id="b389b-110">These properties are covered in more detail in [Updating Data Sources with DataAdapters](updating-data-sources-with-dataadapters.md).</span></span>  
  
 <span data-ttu-id="b389b-111">Il metodo `Fill` di `DataAdapter` viene usato per popolare un oggetto `DataSet` con i risultati dell'oggetto `SelectCommand` di `DataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="b389b-111">The `Fill` method of the `DataAdapter` is used to populate a `DataSet` with the results of the `SelectCommand` of the `DataAdapter`.</span></span> <span data-ttu-id="b389b-112">`Fill` accetta come argomenti un oggetto `DataSet` da popolare e un oggetto `DataTable` o il nome dell'oggetto `DataTable` da popolare con le righe restituite da `SelectCommand`.</span><span class="sxs-lookup"><span data-stu-id="b389b-112">`Fill` takes as its arguments a `DataSet` to be populated, and a `DataTable` object, or the name of the `DataTable` to be filled with the rows returned from the `SelectCommand`.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b389b-113">L'utilizzo di `DataAdapter` per recuperare un'intera tabella richiede del tempo, soprattutto se la tabella contiene molte righe.</span><span class="sxs-lookup"><span data-stu-id="b389b-113">Using the `DataAdapter` to retrieve all of a table takes time, especially if there are many rows in the table.</span></span> <span data-ttu-id="b389b-114">L'accesso al database, l'individuazione e l'elaborazione dei dati e il successivo trasferimento dei dati al client tramite rete sono infatti processi lunghi.</span><span class="sxs-lookup"><span data-stu-id="b389b-114">This is because accessing the database, locating and processing the data, and then transferring the data to the client is time-consuming.</span></span> <span data-ttu-id="b389b-115">Se viene eseguito il pull dell'intera tabella nel client, vengono anche bloccate tutte le righe sul server.</span><span class="sxs-lookup"><span data-stu-id="b389b-115">Pulling all of the table to the client also locks all of the rows on the server.</span></span> <span data-ttu-id="b389b-116">Per migliorare le prestazioni, è possibile usare la clausola `WHERE` in modo da ridurre sensibilmente il numero di righe restituite al client.</span><span class="sxs-lookup"><span data-stu-id="b389b-116">To improve performance, you can use the `WHERE` clause to greatly reduce the number of rows returned to the client.</span></span> <span data-ttu-id="b389b-117">È anche possibile ridurre la quantità di dati restituiti al client elencando in modo esplicito solo le colonne necessarie nell'istruzione `SELECT` .</span><span class="sxs-lookup"><span data-stu-id="b389b-117">You can also reduce the amount of data returned to the client by only explicitly listing required columns in the `SELECT` statement.</span></span> <span data-ttu-id="b389b-118">Un'altra soluzione alternativa efficace consiste nel recuperare le righe in batch, ad esempio diverse centinaia alla volta, e recuperare il batch successivo solo quando il client ha terminato con quello corrente.</span><span class="sxs-lookup"><span data-stu-id="b389b-118">Another good workaround is to retrieve the rows in batches (such as several hundred rows at a time) and only retrieve the next batch when the client is finished with the current batch.</span></span>  
  
 <span data-ttu-id="b389b-119">Nel metodo `Fill` viene usato in modo implicito l'oggetto `DataReader` per restituire i nomi e i tipi delle colonne usate per creare le tabelle nel `DataSet`, nonché i dati per compilare le righe delle tabelle nel `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="b389b-119">The `Fill` method uses the `DataReader` object implicitly to return the column names and types that are used to create the tables in the `DataSet`, and the data to populate the rows of the tables in the `DataSet`.</span></span> <span data-ttu-id="b389b-120">Le tabelle e le colonne vengono create solo se non esistono già. In caso contrario, nel metodo `Fill` viene usato lo schema del `DataSet` esistente.</span><span class="sxs-lookup"><span data-stu-id="b389b-120">Tables and columns are only created if they do not already exist; otherwise `Fill` uses the existing `DataSet` schema.</span></span> <span data-ttu-id="b389b-121">I tipi di colonna vengono creati come .NET Framework tipi in base alle tabelle nei [mapping dei tipi di dati in ADO.NET](data-type-mappings-in-ado-net.md).</span><span class="sxs-lookup"><span data-stu-id="b389b-121">Column types are created as .NET Framework types according to the tables in [Data Type Mappings in ADO.NET](data-type-mappings-in-ado-net.md).</span></span> <span data-ttu-id="b389b-122">Le chiavi primarie non vengono create a meno che non esistano nell'origine dati e `DataAdapter` **.**`MissingSchemaAction`</span><span class="sxs-lookup"><span data-stu-id="b389b-122">Primary keys are not created unless they exist in the data source and `DataAdapter`**.**`MissingSchemaAction`</span></span> <span data-ttu-id="b389b-123">è impostato su `MissingSchemaAction` **.** `AddWithKey`</span><span class="sxs-lookup"><span data-stu-id="b389b-123">is set to `MissingSchemaAction`**.**`AddWithKey`.</span></span> <span data-ttu-id="b389b-124">Se `Fill` rileva la presenza di una chiave primaria per una tabella, sovrascriverà i dati presenti nel `DataSet` con quelli prelevati dall'origine dati per le righe in cui i valori della colonna della chiave primaria corrispondono a quelli della riga restituita dall'origine dati.</span><span class="sxs-lookup"><span data-stu-id="b389b-124">If `Fill` finds that a primary key exists for a table, it will overwrite data in the `DataSet` with data from the data source for rows where the primary key column values match those of the row returned from the data source.</span></span> <span data-ttu-id="b389b-125">Se non vengono rilevate chiavi primarie , i dati vengono aggiunti alle tabelle nell'oggetto `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="b389b-125">If no primary key is found, the data is appended to the tables in the `DataSet`.</span></span> <span data-ttu-id="b389b-126">`Fill`USA i mapping che possono esistere quando si popola `DataSet` (vedere mapping di [DataAdapter DataTable e DataColumn](dataadapter-datatable-and-datacolumn-mappings.md)).</span><span class="sxs-lookup"><span data-stu-id="b389b-126">`Fill` uses any mappings that may exist when you populate the `DataSet` (see [DataAdapter DataTable and DataColumn Mappings](dataadapter-datatable-and-datacolumn-mappings.md)).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b389b-127">Se `SelectCommand` restituisce i risultati di un OUTER JOIN, mediante `DataAdapter` non viene impostato un valore di `PrimaryKey` per l'oggetto `DataTable`risultante.</span><span class="sxs-lookup"><span data-stu-id="b389b-127">If the `SelectCommand` returns the results of an OUTER JOIN, the `DataAdapter` does not set a `PrimaryKey` value for the resulting `DataTable`.</span></span> <span data-ttu-id="b389b-128">Per assicurarsi che le righe duplicate vengano risolte correttamente, sarà necessario definire `PrimaryKey` in modo autonomo.</span><span class="sxs-lookup"><span data-stu-id="b389b-128">You must define the `PrimaryKey` yourself to make sure that duplicate rows are resolved correctly.</span></span> <span data-ttu-id="b389b-129">Per ulteriori informazioni, vedere [definizione delle chiavi primarie](./dataset-datatable-dataview/defining-primary-keys.md).</span><span class="sxs-lookup"><span data-stu-id="b389b-129">For more information, see [Defining Primary Keys](./dataset-datatable-dataview/defining-primary-keys.md).</span></span>  
  
 <span data-ttu-id="b389b-130">Nell'esempio di codice seguente viene creata un'istanza di un tipo <xref:System.Data.SqlClient.SqlDataAdapter> che usa un tipo <xref:System.Data.SqlClient.SqlConnection> nel database `Northwind` di Microsoft SQL Server e viene compilato un tipo <xref:System.Data.DataTable> in un `DataSet` con l'elenco dei clienti.</span><span class="sxs-lookup"><span data-stu-id="b389b-130">The following code example creates an instance of a <xref:System.Data.SqlClient.SqlDataAdapter> that uses a <xref:System.Data.SqlClient.SqlConnection> to the Microsoft SQL Server `Northwind` database and populates a <xref:System.Data.DataTable> in a `DataSet` with the list of customers.</span></span> <span data-ttu-id="b389b-131">L'istruzione SQL e gli argomenti <xref:System.Data.SqlClient.SqlConnection> passati al costruttore <xref:System.Data.SqlClient.SqlDataAdapter> vengono usati per creare la proprietà <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A> del tipo <xref:System.Data.SqlClient.SqlDataAdapter>.</span><span class="sxs-lookup"><span data-stu-id="b389b-131">The SQL statement and <xref:System.Data.SqlClient.SqlConnection> arguments passed to the <xref:System.Data.SqlClient.SqlDataAdapter> constructor are used to create the <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A> property of the <xref:System.Data.SqlClient.SqlDataAdapter>.</span></span>  
  
## <a name="example"></a><span data-ttu-id="b389b-132">Esempio</span><span class="sxs-lookup"><span data-stu-id="b389b-132">Example</span></span>  
  
```vb  
' Assumes that connection is a valid SqlConnection object.  
Dim queryString As String = _  
  "SELECT CustomerID, CompanyName FROM dbo.Customers"  
Dim adapter As SqlDataAdapter = New SqlDataAdapter( _  
  queryString, connection)  
  
Dim customers As DataSet = New DataSet  
adapter.Fill(customers, "Customers")  
```  
  
```csharp  
// Assumes that connection is a valid SqlConnection object.  
string queryString =
  "SELECT CustomerID, CompanyName FROM dbo.Customers";  
SqlDataAdapter adapter = new SqlDataAdapter(queryString, connection);  
  
DataSet customers = new DataSet();  
adapter.Fill(customers, "Customers");  
```  
  
> [!NOTE]
> <span data-ttu-id="b389b-133">Con il codice illustrato in questo esempio, l'oggetto `Connection`non viene aperto e chiuso in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="b389b-133">The code shown in this example does not explicitly open and close the `Connection`.</span></span> <span data-ttu-id="b389b-134">Il metodo `Fill` apre in modo implicito l'oggetto `Connection` usato da `DataAdapter` se rileva che la connessione non è già aperta.</span><span class="sxs-lookup"><span data-stu-id="b389b-134">The `Fill` method implicitly opens the `Connection` that the `DataAdapter` is using if it finds that the connection is not already open.</span></span> <span data-ttu-id="b389b-135">Se la connessione è stata aperta da `Fill` , esso provvederà anche a chiuderla una volta terminato `Fill` .</span><span class="sxs-lookup"><span data-stu-id="b389b-135">If `Fill` opened the connection, it also closes the connection when `Fill` is finished.</span></span> <span data-ttu-id="b389b-136">Questa procedura consente di semplificare il codice quando si esegue una singola operazione come `Fill` o `Update`.</span><span class="sxs-lookup"><span data-stu-id="b389b-136">This can simplify your code when you deal with a single operation such as a `Fill` or an `Update`.</span></span> <span data-ttu-id="b389b-137">Tuttavia, se si eseguono più operazioni che richiedono una connessione aperta, per migliorare le prestazioni dell'applicazione è possibile chiamare in modo esplicito il metodo `Open` dell'oggetto `Connection`, eseguire le operazioni sull'origine dati, quindi chiamare il metodo `Close` dell'oggetto `Connection`.</span><span class="sxs-lookup"><span data-stu-id="b389b-137">However, if you are performing multiple operations that require an open connection, you can improve the performance of your application by explicitly calling the `Open` method of the `Connection`, performing the operations against the data source, and then calling the `Close` method of the `Connection`.</span></span> <span data-ttu-id="b389b-138">È necessario cercare di tenere aperte le connessioni con l'origine dati per un intervallo di tempo minimo, in modo da liberare le risorse che devono essere usate da altre applicazioni client.</span><span class="sxs-lookup"><span data-stu-id="b389b-138">You should try to keep connections to the data source open as briefly as possible to free resources for use by other client applications.</span></span>  
  
## <a name="multiple-result-sets"></a><span data-ttu-id="b389b-139">Più set di risultati</span><span class="sxs-lookup"><span data-stu-id="b389b-139">Multiple Result Sets</span></span>  
 <span data-ttu-id="b389b-140">Se l'oggetto `DataAdapter` rileva più set di risultati, vengono create più tabelle nel `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="b389b-140">If the `DataAdapter` encounters multiple result sets, it creates multiple tables in the `DataSet`.</span></span> <span data-ttu-id="b389b-141">Alle tabelle viene assegnato il nome predefinito incrementale Table*N*, che inizia con "Table" per Table0.</span><span class="sxs-lookup"><span data-stu-id="b389b-141">The tables are given an incremental default name of Table*N*, starting with "Table" for Table0.</span></span> <span data-ttu-id="b389b-142">Se il nome di una tabella viene passato come argomento al metodo `Fill` , alle tabelle viene assegnato il nome predefinito incrementale TableName*N*, che inizia con "TableName" per TableName0.</span><span class="sxs-lookup"><span data-stu-id="b389b-142">If a table name is passed as an argument to the `Fill` method, the tables are given an incremental default name of TableName*N*, starting with "TableName" for TableName0.</span></span>  
  
## <a name="populating-a-dataset-from-multiple-dataadapters"></a><span data-ttu-id="b389b-143">Compilazione di un DataSet da più oggetti DataAdapter</span><span class="sxs-lookup"><span data-stu-id="b389b-143">Populating a DataSet from Multiple DataAdapters</span></span>  
 <span data-ttu-id="b389b-144">`DataAdapter`È possibile usare qualsiasi numero di oggetti con un oggetto `DataSet` .</span><span class="sxs-lookup"><span data-stu-id="b389b-144">Any number of `DataAdapter` objects can be used with a `DataSet`.</span></span> <span data-ttu-id="b389b-145">Ogni oggetto `DataAdapter` può essere usato per compilare uno o più oggetti `DataTable` e risolvere gli aggiornamenti fino all'origine dati pertinente.</span><span class="sxs-lookup"><span data-stu-id="b389b-145">Each `DataAdapter` can be used to fill one or more `DataTable` objects and resolve updates back to the relevant data source.</span></span> <span data-ttu-id="b389b-146">Gli oggetti`DataRelation` e `Constraint` possono essere aggiunti all'oggetto `DataSet` localmente, consentendo di creare relazioni tra dati provenienti da origini dati diverse.</span><span class="sxs-lookup"><span data-stu-id="b389b-146">`DataRelation` and `Constraint` objects can be added to the `DataSet` locally, which enables you to relate data from dissimilar data sources.</span></span> <span data-ttu-id="b389b-147">Un `DataSet` , ad esempio, può contenere dati di un database Microsoft SQL Server, un database IBM DB2 esposto tramite OLE DB e un'origine dati che crea flussi XML.</span><span class="sxs-lookup"><span data-stu-id="b389b-147">For example, a `DataSet` can contain data from a Microsoft SQL Server database, an IBM DB2 database exposed through OLE DB, and a data source that streams XML.</span></span> <span data-ttu-id="b389b-148">Uno o più oggetti `DataAdapter` possono gestire le comunicazioni con ciascuna origine dati.</span><span class="sxs-lookup"><span data-stu-id="b389b-148">One or more `DataAdapter` objects can handle communication to each data source.</span></span>  
  
### <a name="example"></a><span data-ttu-id="b389b-149">Esempio</span><span class="sxs-lookup"><span data-stu-id="b389b-149">Example</span></span>  
 <span data-ttu-id="b389b-150">Nell'esempio di codice seguente vengono compilati un elenco di clienti dal database `Northwind` in Microsoft SQL Server e un elenco di ordini dal database `Northwind` archiviato in Microsoft Access 2000.</span><span class="sxs-lookup"><span data-stu-id="b389b-150">The following code example populates a list of customers from the `Northwind` database on Microsoft SQL Server, and a list of orders from the `Northwind` database stored in Microsoft Access 2000.</span></span> <span data-ttu-id="b389b-151">Viene creata una relazione tra le tabelle compilate tramite `DataRelation`e viene quindi visualizzato l'elenco di clienti con i relativi ordini.</span><span class="sxs-lookup"><span data-stu-id="b389b-151">The filled tables are related with a `DataRelation`, and the list of customers is then displayed with the orders for that customer.</span></span> <span data-ttu-id="b389b-152">Per ulteriori informazioni sugli `DataRelation` oggetti, vedere [aggiunta di DataRelation](./dataset-datatable-dataview/adding-datarelations.md) e spostamento di oggetti [DataRelation](./dataset-datatable-dataview/navigating-datarelations.md).</span><span class="sxs-lookup"><span data-stu-id="b389b-152">For more information about `DataRelation` objects, see [Adding DataRelations](./dataset-datatable-dataview/adding-datarelations.md) and [Navigating DataRelations](./dataset-datatable-dataview/navigating-datarelations.md).</span></span>  
  
```vb  
' Assumes that customerConnection is a valid SqlConnection object.  
' Assumes that orderConnection is a valid OleDbConnection object.  
Dim custAdapter As SqlDataAdapter = New SqlDataAdapter( _  
  "SELECT * FROM dbo.Customers", customerConnection)  
  
Dim ordAdapter As OleDbDataAdapter = New OleDbDataAdapter( _  
  "SELECT * FROM Orders", orderConnection)  
  
Dim customerOrders As DataSet = New DataSet()  
custAdapter.Fill(customerOrders, "Customers")  
ordAdapter.Fill(customerOrders, "Orders")  
  
Dim relation As DataRelation = _  
  customerOrders.Relations.Add("CustOrders", _  
  customerOrders.Tables("Customers").Columns("CustomerID"), _
  customerOrders.Tables("Orders").Columns("CustomerID"))  
  
Dim pRow, cRow As DataRow  
For Each pRow In customerOrders.Tables("Customers").Rows  
  Console.WriteLine(pRow("CustomerID").ToString())  
  
  For Each cRow In pRow.GetChildRows(relation)  
    Console.WriteLine(vbTab & cRow("OrderID").ToString())  
  Next  
Next  
```  
  
```csharp  
// Assumes that customerConnection is a valid SqlConnection object.  
// Assumes that orderConnection is a valid OleDbConnection object.  
SqlDataAdapter custAdapter = new SqlDataAdapter(  
  "SELECT * FROM dbo.Customers", customerConnection);  
OleDbDataAdapter ordAdapter = new OleDbDataAdapter(  
  "SELECT * FROM Orders", orderConnection);  
  
DataSet customerOrders = new DataSet();  
  
custAdapter.Fill(customerOrders, "Customers");  
ordAdapter.Fill(customerOrders, "Orders");  
  
DataRelation relation = customerOrders.Relations.Add("CustOrders",  
  customerOrders.Tables["Customers"].Columns["CustomerID"],  
  customerOrders.Tables["Orders"].Columns["CustomerID"]);  
  
foreach (DataRow pRow in customerOrders.Tables["Customers"].Rows)  
{  
  Console.WriteLine(pRow["CustomerID"]);  
   foreach (DataRow cRow in pRow.GetChildRows(relation))  
    Console.WriteLine("\t" + cRow["OrderID"]);  
}  
```  
  
## <a name="sql-server-decimal-type"></a><span data-ttu-id="b389b-153">Tipo decimal di SQL Server</span><span class="sxs-lookup"><span data-stu-id="b389b-153">SQL Server Decimal Type</span></span>  
 <span data-ttu-id="b389b-154">Per impostazione predefinita, `DataSet` archivia i dati usando .NET Framework tipi di dati.</span><span class="sxs-lookup"><span data-stu-id="b389b-154">By default, the `DataSet` stores data by using .NET Framework data types.</span></span> <span data-ttu-id="b389b-155">Per la maggior parte delle applicazioni, questi tipi consentono di rappresentare in modo adeguato le informazioni delle origini dei dati.</span><span class="sxs-lookup"><span data-stu-id="b389b-155">For most applications, these provide a convenient representation of data source information.</span></span> <span data-ttu-id="b389b-156">Tuttavia, questo tipo di rappresentazione può generare un problema quando il tipo di dati nell'origine dati ha valore numeric o decimal di SQL Server.</span><span class="sxs-lookup"><span data-stu-id="b389b-156">However, this representation may cause a problem when the data type in the data source is a SQL Server decimal or numeric data type.</span></span> <span data-ttu-id="b389b-157">Il `decimal` tipo di dati .NET Framework consente un massimo di 28 cifre significative, mentre il `decimal` tipo di dati SQL Server consente 38 cifre significative.</span><span class="sxs-lookup"><span data-stu-id="b389b-157">The .NET Framework `decimal` data type allows a maximum of 28 significant digits, whereas the SQL Server `decimal` data type allows 38 significant digits.</span></span> <span data-ttu-id="b389b-158">Se, durante un'operazione `SqlDataAdapter` , `Fill` determina che la precisione di un campo `decimal` di SQL Server è maggiore di 28 caratteri, la riga corrente non viene aggiunta all'oggetto `DataTable`.</span><span class="sxs-lookup"><span data-stu-id="b389b-158">If the `SqlDataAdapter` determines during a `Fill` operation that the precision of a SQL Server `decimal` field is larger than 28 characters, the current row is not added to the `DataTable`.</span></span> <span data-ttu-id="b389b-159">Viene invece generato un evento `FillError` , che consente di determinare se si è verificata una perdita di precisione e quindi di rispondere in modo appropriato.</span><span class="sxs-lookup"><span data-stu-id="b389b-159">Instead the `FillError` event occurs, which enables you to determine whether a loss of precision will occur, and respond appropriately.</span></span> <span data-ttu-id="b389b-160">Per ulteriori informazioni sull' `FillError` evento, vedere [gestione di eventi DataAdapter](handling-dataadapter-events.md).</span><span class="sxs-lookup"><span data-stu-id="b389b-160">For more information about the `FillError` event, see [Handling DataAdapter Events](handling-dataadapter-events.md).</span></span> <span data-ttu-id="b389b-161">Per ottenere il valore `decimal` di SQL Server, è anche possibile usare un oggetto <xref:System.Data.SqlClient.SqlDataReader> e chiamare il metodo <xref:System.Data.SqlClient.SqlDataReader.GetSqlDecimal%2A> .</span><span class="sxs-lookup"><span data-stu-id="b389b-161">To get the SQL Server `decimal` value, you can also use a <xref:System.Data.SqlClient.SqlDataReader> object and call the <xref:System.Data.SqlClient.SqlDataReader.GetSqlDecimal%2A> method.</span></span>  
  
 <span data-ttu-id="b389b-162">In ADO.NET 2,0 è stato introdotto un supporto migliorato per <xref:System.Data.SqlTypes> nel `DataSet` .</span><span class="sxs-lookup"><span data-stu-id="b389b-162">ADO.NET 2.0 introduced enhanced support for <xref:System.Data.SqlTypes> in the `DataSet`.</span></span> <span data-ttu-id="b389b-163">Per altre informazioni, vedere [SqlTypes and the DataSet](./sql/sqltypes-and-the-dataset.md).</span><span class="sxs-lookup"><span data-stu-id="b389b-163">For more information, see [SqlTypes and the DataSet](./sql/sqltypes-and-the-dataset.md).</span></span>  
  
## <a name="ole-db-chapters"></a><span data-ttu-id="b389b-164">Capitoli OLE DB</span><span class="sxs-lookup"><span data-stu-id="b389b-164">OLE DB Chapters</span></span>  
 <span data-ttu-id="b389b-165">I rowset gerarchici, o capitoli (tipo OLE DB `DBTYPE_HCHAPTER`, tipo ADO `adChapter`), possono essere usati per compilare il contenuto di un `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="b389b-165">Hierarchical rowsets, or chapters (OLE DB type `DBTYPE_HCHAPTER`, ADO type `adChapter`) can be used to fill the contents of a `DataSet`.</span></span> <span data-ttu-id="b389b-166">Quando l'oggetto <xref:System.Data.OleDb.OleDbDataAdapter> rileva una colonna con capitoli durante un'operazione `Fill` , viene creato un oggetto `DataTable` per la colonna e la tabella viene compilata con le colonne e le righe del capitolo.</span><span class="sxs-lookup"><span data-stu-id="b389b-166">When the <xref:System.Data.OleDb.OleDbDataAdapter> encounters a chaptered column during a `Fill` operation, a `DataTable` is created for the chaptered column, and that table is filled with the columns and rows from the chapter.</span></span> <span data-ttu-id="b389b-167">Il nome della tabella creata per la colonna con capitoli viene assegnato usando il nome della tabella padre e il nome della colonna con capitoli nel formato "*NomeTabellaPadreNomeColonnaConCapitoli*".</span><span class="sxs-lookup"><span data-stu-id="b389b-167">The table created for the chaptered column is named by using both the parent table name and the chaptered column name in the form "*ParentTableNameChapteredColumnName*".</span></span> <span data-ttu-id="b389b-168">Se nel `DataSet` esiste già una tabella con un nome corrispondente al nome della colonna con capitoli, la tabella corrente viene compilata con i dati del capitolo.</span><span class="sxs-lookup"><span data-stu-id="b389b-168">If a table already exists in the `DataSet` that matches the name of the chaptered column, the current table is filled with the chapter data.</span></span> <span data-ttu-id="b389b-169">Se in una tabella esistente non sono presenti colonne che corrispondono alla colonna rilevata nel capitolo, viene aggiunta una nuova colonna.</span><span class="sxs-lookup"><span data-stu-id="b389b-169">If there is no column in an existing table that matches a column found in the chapter, a new column is added.</span></span>  
  
 <span data-ttu-id="b389b-170">Prima che le tabelle nel `DataSet` siano compilate con i dati delle colonne con capitoli, viene creata una relazione tra le tabelle padre e figlio del rowset gerarchico aggiungendo una colonna di valori integer sia alla tabella padre che alla tabella figlio, impostando l'incremento automatico della colonna padre e creando un `DataRelation` con le colonne aggiunte dalle due tabelle.</span><span class="sxs-lookup"><span data-stu-id="b389b-170">Before the tables in the `DataSet` are filled with the data in the chaptered columns, a relation is created between the parent and child tables of the hierarchical rowset by adding an integer column to both the parent and child table, setting the parent column to auto-increment, and creating a `DataRelation` using the added columns from both tables.</span></span> <span data-ttu-id="b389b-171">Il nome della relazione aggiunta viene assegnato usando i nomi della tabella padre e della colonna con capitoli nel formato "*NomeTabellaPadreNomeColonnaConCapitoli*".</span><span class="sxs-lookup"><span data-stu-id="b389b-171">The added relation is named by using the parent table and chapter column names in the form "*ParentTableNameChapterColumnName*".</span></span>  
  
 <span data-ttu-id="b389b-172">Si noti che la colonna correlata esiste solo nel `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="b389b-172">Note that the related column only exists in the `DataSet`.</span></span> <span data-ttu-id="b389b-173">Nelle successive operazioni di inserimento dati dall'origine dati, anziché aggiornare le righe esistenti nelle tabelle in base alle modifiche, verranno aggiunte nuove righe.</span><span class="sxs-lookup"><span data-stu-id="b389b-173">Subsequent fills from the data source can cause new rows to be added to the tables instead of changes being merged into existing rows.</span></span>  
  
 <span data-ttu-id="b389b-174">Si noti inoltre che se si usa l'overload `DataAdapter.Fill` che accetta un `DataTable`, verrà compilata solo quella tabella.</span><span class="sxs-lookup"><span data-stu-id="b389b-174">Note also that, if you use the `DataAdapter.Fill` overload that takes a `DataTable`, only that table will be filled.</span></span> <span data-ttu-id="b389b-175">Una colonna di valori integer con incremento automatico verrà comunque aggiunta alla tabella, ma non verrà creata o compilata alcuna tabella figlio e non verrà creata alcuna relazione.</span><span class="sxs-lookup"><span data-stu-id="b389b-175">An auto-incrementing integer column will still be added to the table, but no child table will be created or filled, and no relation will be created.</span></span>  
  
 <span data-ttu-id="b389b-176">Nell'esempio seguente viene usato il provider MSDataShape per generare una colonna di ordini con capitoli per ogni cliente presente in un elenco di clienti.</span><span class="sxs-lookup"><span data-stu-id="b389b-176">The following example uses the MSDataShape Provider to generate a chapter column of orders for each customer in a list of customers.</span></span> <span data-ttu-id="b389b-177">Quindi, verrà compilato un `DataSet` con i dati.</span><span class="sxs-lookup"><span data-stu-id="b389b-177">A `DataSet` is then filled with the data.</span></span>  
  
```vb  
Using connection As OleDbConnection = New OleDbConnection( _  
  "Provider=MSDataShape;Data Provider=SQLOLEDB;" & _  
  "Data Source=(local);Integrated " & _  
  "Security=SSPI;Initial Catalog=northwind")  
  
Dim adapter As OleDbDataAdapter = New OleDbDataAdapter( _  
  "SHAPE {SELECT CustomerID, CompanyName FROM Customers} " & _  
  "APPEND ({SELECT CustomerID, OrderID FROM Orders} AS Orders " & _  
  "RELATE CustomerID TO CustomerID)", connection)  
  
Dim customers As DataSet = New DataSet()  
  
adapter.Fill(customers, "Customers")  
End Using  
```  
  
```csharp  
using (OleDbConnection connection = new OleDbConnection("Provider=MSDataShape;Data Provider=SQLOLEDB;" +  
  "Data Source=(local);Integrated Security=SSPI;Initial Catalog=northwind"))  
{  
OleDbDataAdapter adapter = new OleDbDataAdapter("SHAPE {SELECT CustomerID, CompanyName FROM Customers} " +  
  "APPEND ({SELECT CustomerID, OrderID FROM Orders} AS Orders " +  
  "RELATE CustomerID TO CustomerID)", connection);  
  
DataSet customers = new DataSet();  
adapter.Fill(customers, "Customers");  
}  
```  
  
 <span data-ttu-id="b389b-178">Al termine dell'operazione `Fill` , il `DataSet` contiene due tabelle: `Customers` e `CustomersOrders`, dove `CustomersOrders` rappresenta la colonna con capitoli.</span><span class="sxs-lookup"><span data-stu-id="b389b-178">When the `Fill` operation is complete, the `DataSet` contains two tables: `Customers` and `CustomersOrders`, where `CustomersOrders` represents the chaptered column.</span></span> <span data-ttu-id="b389b-179">Alla tabella `Orders` viene aggiunta un'altra colonna denominata `Customers` e alla tabella `CustomersOrders` viene aggiunta un'altra colonna denominata `CustomersOrders` .</span><span class="sxs-lookup"><span data-stu-id="b389b-179">An additional column named `Orders` is added to the `Customers` table, and an additional column named `CustomersOrders` is added to the `CustomersOrders` table.</span></span> <span data-ttu-id="b389b-180">Nella colonna `Orders` della tabella `Customers` viene impostato l'incremento automatico.</span><span class="sxs-lookup"><span data-stu-id="b389b-180">The `Orders` column in the `Customers` table is set to auto-increment.</span></span> <span data-ttu-id="b389b-181">Viene creato un oggetto `DataRelation`, `CustomersOrders`, usando le colonne aggiunte alle tabelle con `Customers` come tabella padre.</span><span class="sxs-lookup"><span data-stu-id="b389b-181">A `DataRelation`, `CustomersOrders`, is created by using the columns that were added to the tables with `Customers` as the parent table.</span></span> <span data-ttu-id="b389b-182">Nelle tabelle seguenti sono illustrati alcuni risultati di esempio.</span><span class="sxs-lookup"><span data-stu-id="b389b-182">The following tables show some sample results.</span></span>  
  
### <a name="tablename-customers"></a><span data-ttu-id="b389b-183">TableName: Customers</span><span class="sxs-lookup"><span data-stu-id="b389b-183">TableName: Customers</span></span>  
  
|<span data-ttu-id="b389b-184">CustomerID</span><span class="sxs-lookup"><span data-stu-id="b389b-184">CustomerID</span></span>|<span data-ttu-id="b389b-185">CompanyName</span><span class="sxs-lookup"><span data-stu-id="b389b-185">CompanyName</span></span>|<span data-ttu-id="b389b-186">Orders</span><span class="sxs-lookup"><span data-stu-id="b389b-186">Orders</span></span>|  
|----------------|-----------------|------------|  
|<span data-ttu-id="b389b-187">ALFKI</span><span class="sxs-lookup"><span data-stu-id="b389b-187">ALFKI</span></span>|<span data-ttu-id="b389b-188">Alfreds Futterkiste</span><span class="sxs-lookup"><span data-stu-id="b389b-188">Alfreds Futterkiste</span></span>|<span data-ttu-id="b389b-189">0</span><span class="sxs-lookup"><span data-stu-id="b389b-189">0</span></span>|  
|<span data-ttu-id="b389b-190">ANATR</span><span class="sxs-lookup"><span data-stu-id="b389b-190">ANATR</span></span>|<span data-ttu-id="b389b-191">Ana Trujillo Emparedados y helados</span><span class="sxs-lookup"><span data-stu-id="b389b-191">Ana Trujillo Emparedados y helados</span></span>|<span data-ttu-id="b389b-192">1</span><span class="sxs-lookup"><span data-stu-id="b389b-192">1</span></span>|  
  
### <a name="tablename-customersorders"></a><span data-ttu-id="b389b-193">TableName: CustomersOrders</span><span class="sxs-lookup"><span data-stu-id="b389b-193">TableName: CustomersOrders</span></span>  
  
|<span data-ttu-id="b389b-194">CustomerID</span><span class="sxs-lookup"><span data-stu-id="b389b-194">CustomerID</span></span>|<span data-ttu-id="b389b-195">OrderID</span><span class="sxs-lookup"><span data-stu-id="b389b-195">OrderID</span></span>|<span data-ttu-id="b389b-196">CustomersOrders</span><span class="sxs-lookup"><span data-stu-id="b389b-196">CustomersOrders</span></span>|  
|----------------|-------------|---------------------|  
|<span data-ttu-id="b389b-197">ALFKI</span><span class="sxs-lookup"><span data-stu-id="b389b-197">ALFKI</span></span>|<span data-ttu-id="b389b-198">10643</span><span class="sxs-lookup"><span data-stu-id="b389b-198">10643</span></span>|<span data-ttu-id="b389b-199">0</span><span class="sxs-lookup"><span data-stu-id="b389b-199">0</span></span>|  
|<span data-ttu-id="b389b-200">ALFKI</span><span class="sxs-lookup"><span data-stu-id="b389b-200">ALFKI</span></span>|<span data-ttu-id="b389b-201">10692</span><span class="sxs-lookup"><span data-stu-id="b389b-201">10692</span></span>|<span data-ttu-id="b389b-202">0</span><span class="sxs-lookup"><span data-stu-id="b389b-202">0</span></span>|  
|<span data-ttu-id="b389b-203">ANATR</span><span class="sxs-lookup"><span data-stu-id="b389b-203">ANATR</span></span>|<span data-ttu-id="b389b-204">10308</span><span class="sxs-lookup"><span data-stu-id="b389b-204">10308</span></span>|<span data-ttu-id="b389b-205">1</span><span class="sxs-lookup"><span data-stu-id="b389b-205">1</span></span>|  
|<span data-ttu-id="b389b-206">ANATR</span><span class="sxs-lookup"><span data-stu-id="b389b-206">ANATR</span></span>|<span data-ttu-id="b389b-207">10625</span><span class="sxs-lookup"><span data-stu-id="b389b-207">10625</span></span>|<span data-ttu-id="b389b-208">1</span><span class="sxs-lookup"><span data-stu-id="b389b-208">1</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="b389b-209">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="b389b-209">See also</span></span>

- [<span data-ttu-id="b389b-210">DataAdapter e DataReader</span><span class="sxs-lookup"><span data-stu-id="b389b-210">DataAdapters and DataReaders</span></span>](dataadapters-and-datareaders.md)
- [<span data-ttu-id="b389b-211">Mapping dei tipi di dati in ADO.NET</span><span class="sxs-lookup"><span data-stu-id="b389b-211">Data Type Mappings in ADO.NET</span></span>](data-type-mappings-in-ado-net.md)
- [<span data-ttu-id="b389b-212">Modifica di dati con un oggetto DbDataAdapter</span><span class="sxs-lookup"><span data-stu-id="b389b-212">Modifying Data with a DbDataAdapter</span></span>](modifying-data-with-a-dbdataadapter.md)
- [<span data-ttu-id="b389b-213">MARS (Multiple Active Result Sets)</span><span class="sxs-lookup"><span data-stu-id="b389b-213">Multiple Active Result Sets (MARS)</span></span>](./sql/multiple-active-result-sets-mars.md)
- [<span data-ttu-id="b389b-214">Panoramica di ADO.NET</span><span class="sxs-lookup"><span data-stu-id="b389b-214">ADO.NET Overview</span></span>](ado-net-overview.md)
