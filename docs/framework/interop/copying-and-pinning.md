---
title: copia e blocco
description: Esaminare il modo in cui il gestore di marshalling di interoperabilità può copiare o bloccare i dati sottoposti a marshalling. La copia di dati inserisce una copia dei dati da una posizione di memoria a un'altra.
ms.date: 03/30/2017
helpviewer_keywords:
- pinning, interop marshaling
- copying, interop marshaling
- interop marshaling, copying
- interop marshaling, pinning
ms.assetid: 0059f576-e460-4e70-b257-668870e420b8
ms.openlocfilehash: b7931813cd5254375eda81515f388c85c78fa284
ms.sourcegitcommit: e02d17b2cf9c1258dadda4810a5e6072a0089aee
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/01/2020
ms.locfileid: "85618779"
---
# <a name="copying-and-pinning"></a><span data-ttu-id="7e946-104">copia e blocco</span><span class="sxs-lookup"><span data-stu-id="7e946-104">Copying and Pinning</span></span>

<span data-ttu-id="7e946-105">Durante il marshalling il gestore di marshalling di interoperabilità può copiare o bloccare i dati interessati.</span><span class="sxs-lookup"><span data-stu-id="7e946-105">When marshaling data, the interop marshaler can copy or pin the data being marshaled.</span></span> <span data-ttu-id="7e946-106">Tramite l'operazione di copia, una copia dei dati viene spostata da una posizione della memoria a un'altra.</span><span class="sxs-lookup"><span data-stu-id="7e946-106">Copying the data places a copy of data from one memory location in another memory location.</span></span> <span data-ttu-id="7e946-107">La figura seguente illustra le differenze esistenti tra la copia di un tipo valore e quella di un tipo passato per riferimento dalla memoria gestita a quella non gestita.</span><span class="sxs-lookup"><span data-stu-id="7e946-107">The following illustration shows the differences between copying a value type and copying a type passed by reference from managed to unmanaged memory.</span></span>

![Diagramma che mostra come vengono copiati i tipi di riferimento e valore.](./media/copying-and-pinning/interop-marshal-copy.gif)

<span data-ttu-id="7e946-109">Il marshalling degli argomenti del metodo passati per valore a codice non gestito viene eseguito come marshalling di valori sullo stack.</span><span class="sxs-lookup"><span data-stu-id="7e946-109">Method arguments passed by value are marshaled to unmanaged code as values on the stack.</span></span> <span data-ttu-id="7e946-110">Il processo di copia è diretto.</span><span class="sxs-lookup"><span data-stu-id="7e946-110">The copying process is direct.</span></span> <span data-ttu-id="7e946-111">Gli argomenti passati per riferimento vengono passati come puntatori allo stack.</span><span class="sxs-lookup"><span data-stu-id="7e946-111">Arguments passed by reference are passed as pointers on the stack.</span></span> <span data-ttu-id="7e946-112">Anche i tipi riferimento vengono passati per valore e per riferimento.</span><span class="sxs-lookup"><span data-stu-id="7e946-112">Reference types are also passed by value and by reference.</span></span> <span data-ttu-id="7e946-113">Come illustrato nella figura seguente, i tipi riferimento passati per valore vengono copiati o bloccati:</span><span class="sxs-lookup"><span data-stu-id="7e946-113">As the following illustration shows, reference types passed by value are either copied or pinned:</span></span>

![Diagramma che mostra i tipi riferimento passati per valore e per riferimento.](./media/copying-and-pinning/interop-marshal-reference-pin.gif)

<span data-ttu-id="7e946-115">Con il blocco, i dati vengono temporaneamente bloccati nella posizione di memoria corrente, impedendone quindi il riposizionamento da parte del Garbage Collector di Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="7e946-115">Pinning temporarily locks the data in its current memory location, thus keeping it from being relocated by the common language runtime's garbage collector.</span></span> <span data-ttu-id="7e946-116">I dati vengono bloccati dal gestore di marshalling per ridurre il sovraccarico dell'operazione di copia e migliorare le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="7e946-116">The marshaler pins data to reduce the overhead of copying and enhance performance.</span></span> <span data-ttu-id="7e946-117">In base al tipo, si stabilisce se i dati verranno copiati o bloccati nel corso del processo di marshalling.</span><span class="sxs-lookup"><span data-stu-id="7e946-117">The type of the data determines whether it is copied or pinned during the marshaling process.</span></span>  <span data-ttu-id="7e946-118">Per oggetti come <xref:System.String>, il blocco viene eseguito automaticamente durante il marshalling. È tuttavia possibile bloccare la memoria manualmente tramite la classe <xref:System.Runtime.InteropServices.GCHandle>.</span><span class="sxs-lookup"><span data-stu-id="7e946-118">Pinning is automatically performed during marshaling for objects such as <xref:System.String>, however you can also manually pin memory using the <xref:System.Runtime.InteropServices.GCHandle> class.</span></span>

## <a name="formatted-blittable-classes"></a><span data-ttu-id="7e946-119">Classi copiabili da BLT formattate</span><span class="sxs-lookup"><span data-stu-id="7e946-119">Formatted Blittable Classes</span></span>

<span data-ttu-id="7e946-120">Le classi [copiabili da BLT](blittable-and-non-blittable-types.md) formattate hanno un layout fisso (formattato) e una rappresentazione dei dati comune sia nella memoria gestita che in quella non gestita.</span><span class="sxs-lookup"><span data-stu-id="7e946-120">Formatted [blittable](blittable-and-non-blittable-types.md) classes have fixed layout (formatted) and common data representation in both managed and unmanaged memory.</span></span> <span data-ttu-id="7e946-121">Quando questi tipi richiedono il marshalling, un puntatore all'oggetto nell'heap viene passato direttamente al chiamato,</span><span class="sxs-lookup"><span data-stu-id="7e946-121">When these types require marshaling, a pointer to the object in the heap is passed to the callee directly.</span></span> <span data-ttu-id="7e946-122">il quale può modificare il contenuto della posizione di memoria a cui il puntatore fa riferimento.</span><span class="sxs-lookup"><span data-stu-id="7e946-122">The callee can change the contents of the memory location being referenced by the pointer.</span></span>

> [!NOTE]
> <span data-ttu-id="7e946-123">Il chiamato può modificare il contenuto della memoria se il parametro è contrassegnato come out o in/out. Al contrario, il chiamato deve evitare di modificare il contenuto quando il parametro è impostato su Marshal come in, che è l'impostazione predefinita per i tipi copiabili in formato.</span><span class="sxs-lookup"><span data-stu-id="7e946-123">The callee can change the memory contents if the parameter is marked Out or In/Out. In contrast, the callee should avoid changing the contents when the parameter is set to marshal as In, which is the default for formatted blittable types.</span></span> <span data-ttu-id="7e946-124">La modifica di un oggetto In genera problemi quando la stessa classe viene esportata in una libreria dei tipi e usata per effettuare chiamate su più apartment.</span><span class="sxs-lookup"><span data-stu-id="7e946-124">Modifying an In object generates problems when the same class is exported to a type library and used to make cross-apartment calls.</span></span>

## <a name="formatted-non-blittable-classes"></a><span data-ttu-id="7e946-125">Classi non copiabili da BLT formattate</span><span class="sxs-lookup"><span data-stu-id="7e946-125">Formatted Non-Blittable Classes</span></span>

<span data-ttu-id="7e946-126">Le classi [non copiabili da BLT](blittable-and-non-blittable-types.md) formattate hanno un layout fisso (formattato) ma la rappresentazione dei dati è diversa nella memoria gestita e in quella non gestita.</span><span class="sxs-lookup"><span data-stu-id="7e946-126">Formatted [non-blittable](blittable-and-non-blittable-types.md) classes have fixed layout (formatted) but the data representation is different in managed and unmanaged memory.</span></span> <span data-ttu-id="7e946-127">Può essere necessaria la trasformazione dei dati nelle condizioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="7e946-127">The data can require transformation under the following conditions:</span></span>

- <span data-ttu-id="7e946-128">Se si esegue il marshalling di una classe non copiabile da BLT per valore, il chiamato riceve un puntatore a una copia della struttura dei dati.</span><span class="sxs-lookup"><span data-stu-id="7e946-128">If a non-blittable class is marshaled by value, the callee receives a pointer to a copy of the data structure.</span></span>

- <span data-ttu-id="7e946-129">Se si esegue il marshalling di una classe non copiabile da BLT per riferimento, il chiamato riceve un puntatore a un puntatore a una copia della struttura dei dati.</span><span class="sxs-lookup"><span data-stu-id="7e946-129">If a non-blittable class is marshaled by reference, the callee receives a pointer to a pointer to a copy of the data structure.</span></span>

- <span data-ttu-id="7e946-130">Se si imposta l'attributo <xref:System.Runtime.InteropServices.InAttribute>, la copia viene sempre inizializzata con lo stato dell'istanza. Il marshalling viene eseguito secondo necessità.</span><span class="sxs-lookup"><span data-stu-id="7e946-130">If the <xref:System.Runtime.InteropServices.InAttribute> attribute is set, this copy is always initialized with the instance's state, marshaling as necessary.</span></span>

- <span data-ttu-id="7e946-131">Se si imposta l'attributo <xref:System.Runtime.InteropServices.OutAttribute>, lo stato viene sempre restituito come copia all'istanza. Il marshalling viene eseguito secondo necessità.</span><span class="sxs-lookup"><span data-stu-id="7e946-131">If the <xref:System.Runtime.InteropServices.OutAttribute> attribute is set, the state is always copied back to the instance on return, marshaling as necessary.</span></span>

- <span data-ttu-id="7e946-132">Se si impostano sia **InAttribute** che **OutAttribute**, sono richieste entrambe le copie.</span><span class="sxs-lookup"><span data-stu-id="7e946-132">If both **InAttribute** and **OutAttribute** are set, both copies are required.</span></span> <span data-ttu-id="7e946-133">Se si omette uno degli attributi, il gestore di marshalling può ottimizzare il processo eliminando una delle copie.</span><span class="sxs-lookup"><span data-stu-id="7e946-133">If either attribute is omitted, the marshaler can optimize by eliminating either copy.</span></span>

## <a name="reference-types"></a><span data-ttu-id="7e946-134">Tipi riferimento</span><span class="sxs-lookup"><span data-stu-id="7e946-134">Reference Types</span></span>

<span data-ttu-id="7e946-135">È possibile passare i tipi riferimento per valore o per riferimento.</span><span class="sxs-lookup"><span data-stu-id="7e946-135">Reference types can be passed by value or by reference.</span></span> <span data-ttu-id="7e946-136">Quando sono passati per valore, sullo stack viene passato un puntatore al tipo.</span><span class="sxs-lookup"><span data-stu-id="7e946-136">When they are passed by value, a pointer to the type is passed on the stack.</span></span> <span data-ttu-id="7e946-137">Quando sono passati per riferimento, sullo stack viene passato un puntatore a un puntatore al tipo.</span><span class="sxs-lookup"><span data-stu-id="7e946-137">When passed by reference, a pointer to a pointer to the type is passed on the stack.</span></span>

<span data-ttu-id="7e946-138">Il comportamento dei tipi riferimento varia a seconda delle condizioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="7e946-138">Reference types have the following conditional behavior:</span></span>

- <span data-ttu-id="7e946-139">Se un tipo riferimento viene passato per valore e possiede membri di tipo non copiabile da BLT, i tipi vengono convertiti due volte:</span><span class="sxs-lookup"><span data-stu-id="7e946-139">If a reference type is passed by value and it has members of non-blittable types, the types are converted twice:</span></span>

  - <span data-ttu-id="7e946-140">Quando si passa un argomento al lato non gestito.</span><span class="sxs-lookup"><span data-stu-id="7e946-140">When an argument is passed to the unmanaged side.</span></span>

  - <span data-ttu-id="7e946-141">Al ritorno dalla chiamata.</span><span class="sxs-lookup"><span data-stu-id="7e946-141">On return from the call.</span></span>

  <span data-ttu-id="7e946-142">Per evitare inutili operazioni di copia e conversione, viene eseguito il marshalling di questi tipi come parametri In.</span><span class="sxs-lookup"><span data-stu-id="7e946-142">To avoid unnecessarily copying and conversion, these types are marshaled as In parameters.</span></span> <span data-ttu-id="7e946-143">Perché le modifiche apportate dal chiamato risultino visibili al chiamante, è necessario applicare gli attributi **InAttribute** e **OutAttribute** a un argomento in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="7e946-143">You must explicitly apply the **InAttribute** and **OutAttribute** attributes to an argument for the caller to see changes made by the callee.</span></span>

- <span data-ttu-id="7e946-144">Se un tipo riferimento viene passato per valore e possiede solo membri di tipi copiabili da BLT, è possibile bloccarlo durante il marshalling e le modifiche apportate ai membri del tipo dal chiamato saranno visibili al chiamante.</span><span class="sxs-lookup"><span data-stu-id="7e946-144">If a reference type is passed by value and it has only members of blittable types, it can be pinned during marshaling and any changes made to the members of the type by the callee are seen by the caller.</span></span> <span data-ttu-id="7e946-145">Per ottenere questo comportamento, applicare **InAttribute** e **OutAttribute** in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="7e946-145">Apply **InAttribute** and **OutAttribute** explicitly if you want this behavior.</span></span> <span data-ttu-id="7e946-146">Senza questi attributi direzionali, il gestore di marshalling di interoperabilità non esporta informazioni direzionali nella libreria dei tipi, ma come parametro In per impostazione predefinita. Potrebbero quindi verificarsi problemi con il marshalling su più apartment COM.</span><span class="sxs-lookup"><span data-stu-id="7e946-146">Without these directional attributes, the interop marshaler does not export directional information to the type library (it exports as In, which is the default) and this can cause problems with COM cross-apartment marshaling.</span></span>

- <span data-ttu-id="7e946-147">Se si passa un tipo riferimento per riferimento, il marshalling viene eseguito come In/Out per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="7e946-147">If a reference type is passed by reference, it will be marshaled as In/Out by default.</span></span>

## <a name="systemstring-and-systemtextstringbuilder"></a><span data-ttu-id="7e946-148">System.String e System.Text.StringBuilder</span><span class="sxs-lookup"><span data-stu-id="7e946-148">System.String and System.Text.StringBuilder</span></span>

<span data-ttu-id="7e946-149">Quando si esegue il marshalling dei dati nel codice non gestito per valore o per riferimento, in genere i dati vengono copiati dal gestore di marshalling in un buffer secondario, eventualmente convertendo i set di caratteri nel corso della copia, e un riferimento al buffer viene passato al chiamato.</span><span class="sxs-lookup"><span data-stu-id="7e946-149">When data is marshaled to unmanaged code by value or by reference, the marshaler typically copies the data to a secondary buffer (possibly converting character sets during the copy) and passes a reference to the buffer to the callee.</span></span> <span data-ttu-id="7e946-150">A meno che non si tratti di un **BSTR** allocato con **SysAllocString**, il riferimento viene sempre allocato con **CoTaskMemAlloc**.</span><span class="sxs-lookup"><span data-stu-id="7e946-150">Unless the reference is a **BSTR** allocated with **SysAllocString**, the reference is always allocated with **CoTaskMemAlloc**.</span></span>

<span data-ttu-id="7e946-151">Per ottimizzare il processo nel caso in cui il marshalling di uno dei tipi stringa venga eseguito per valore, come nel caso di una stringa di carattere Unicode, il gestore di marshalling passa al chiamato un puntatore diretto alle stringhe gestite nel buffer Unicode interno anziché copiarlo in uno nuovo.</span><span class="sxs-lookup"><span data-stu-id="7e946-151">As an optimization when either string type is marshaled by value (such as a Unicode character string), the marshaler passes the callee a direct pointer to managed strings in the internal Unicode buffer instead of copying it to a new buffer.</span></span>

> [!CAUTION]
> <span data-ttu-id="7e946-152">Quando una stringa viene passata per valore, il riferimento passato dal gestore di marshalling non deve mai essere modificato dal chiamato,</span><span class="sxs-lookup"><span data-stu-id="7e946-152">When a string is passed by value, the callee must never alter the reference passed by the marshaler.</span></span> <span data-ttu-id="7e946-153">per evitare danni all'heap gestito.</span><span class="sxs-lookup"><span data-stu-id="7e946-153">Doing so can corrupt the managed heap.</span></span>

<span data-ttu-id="7e946-154">Quando un oggetto <xref:System.String?displayProperty=nameWithType> viene passato per riferimento, il contenuto della stringa viene copiato dal gestore di marshalling in un buffer secondario prima di effettuare la chiamata.</span><span class="sxs-lookup"><span data-stu-id="7e946-154">When a <xref:System.String?displayProperty=nameWithType> is passed by reference, the marshaler copies the contents the string to a secondary buffer before making the call.</span></span> <span data-ttu-id="7e946-155">Il contenuto del buffer viene quindi copiato in una nuova stringa dopo la chiamata.</span><span class="sxs-lookup"><span data-stu-id="7e946-155">It then copies the contents of the buffer into a new string on return from the call.</span></span> <span data-ttu-id="7e946-156">Grazie a questa tecnica, si garantisce che la stringa gestita immutabile rimanga inalterata.</span><span class="sxs-lookup"><span data-stu-id="7e946-156">This technique ensures that the immutable managed string remains unaltered.</span></span>

<span data-ttu-id="7e946-157">Quando un oggetto <xref:System.Text.StringBuilder?displayProperty=nameWithType> viene passato per valore, un riferimento al buffer interno di **StringBuilder** viene passato dal gestore di marshalling direttamente al chiamante.</span><span class="sxs-lookup"><span data-stu-id="7e946-157">When a <xref:System.Text.StringBuilder?displayProperty=nameWithType> is passed by value, the marshaler passes a reference to the internal buffer of the **StringBuilder** directly to the caller.</span></span> <span data-ttu-id="7e946-158">Il chiamante e il chiamato devono concordare sulla dimensione del buffer.</span><span class="sxs-lookup"><span data-stu-id="7e946-158">The caller and callee must agree on the size of the buffer.</span></span> <span data-ttu-id="7e946-159">Il chiamante è responsabile della creazione di uno **StringBuilder** di lunghezza adeguata.</span><span class="sxs-lookup"><span data-stu-id="7e946-159">The caller is responsible for creating a **StringBuilder** of adequate length.</span></span> <span data-ttu-id="7e946-160">Il chiamato deve prendere le precauzioni necessarie per garantire che il buffer non risulti sovraccarico.</span><span class="sxs-lookup"><span data-stu-id="7e946-160">The callee must take the necessary precautions to ensure that the buffer is not overrun.</span></span> <span data-ttu-id="7e946-161">**StringBuilder** è un'eccezione alla regola in base alla quale i tipi di riferimento passati per valore vengono passati come parametri In per impostazione predefinita,</span><span class="sxs-lookup"><span data-stu-id="7e946-161">**StringBuilder** is an exception to the rule that reference types passed by value are passed as In parameters by default.</span></span> <span data-ttu-id="7e946-162">dato che viene sempre passato come parametro In/Out.</span><span class="sxs-lookup"><span data-stu-id="7e946-162">It is always passed as In/Out.</span></span>

## <a name="see-also"></a><span data-ttu-id="7e946-163">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="7e946-163">See also</span></span>

- [<span data-ttu-id="7e946-164">comportamento predefinito del marshalling</span><span class="sxs-lookup"><span data-stu-id="7e946-164">Default Marshaling Behavior</span></span>](default-marshaling-behavior.md)
- <span data-ttu-id="7e946-165">[Attributi direzionali](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/77e6taeh(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="7e946-165">[Directional Attributes](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/77e6taeh(v=vs.100))</span></span>
- [<span data-ttu-id="7e946-166">Marshalling di interoperabilità</span><span class="sxs-lookup"><span data-stu-id="7e946-166">Interop Marshaling</span></span>](interop-marshaling.md)
