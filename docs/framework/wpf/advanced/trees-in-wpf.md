---
title: Trees
ms.date: 03/30/2017
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
ms.openlocfilehash: aed4350f1a7084b7894a70ac9d6d00cf25b39e34
ms.sourcegitcommit: 62285ec11fa8e8424bab00511a90760c60e63c95
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/20/2020
ms.locfileid: "81646205"
---
# <a name="trees-in-wpf"></a>Strutture ad albero in WPF
In molte tecnologie gli elementi e i componenti sono organizzati in una struttura ad albero in cui gli sviluppatori modificano direttamente i nodi degli oggetti nell'albero per influire sul rendering o sul comportamento di un'applicazione. [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] usa anche molte metafore correlate alla struttura ad albero per definire le relazioni tra gli elementi del programma. In genere gli sviluppatori WPF possono creare un'applicazione nel codice o definire parti dell'applicazione in XAML usando come riferimento concettuale la metafora della struttura ad albero di oggetti, ma chiameranno un'API specifica o useranno un markup specifico a tale scopo anziché un'API di modifica della struttura ad albero di oggetti generica simile a quella usata nel modello DOM XML. WPFWPF espone due classi helper che <xref:System.Windows.LogicalTreeHelper> forniscono una visualizzazione metafora ad albero e <xref:System.Windows.Media.VisualTreeHelper>. Nella documentazione di WPF vengono inoltre usati i termini struttura ad albero visuale e albero logico, in quanto tali strutture ad albero sono utili per la comprensione del comportamento di alcune funzionalità chiave di WPF. In questo argomento viene definito il contenuto della struttura ad albero visuale e dell'albero logico, viene illustrato come tali alberi sono correlati a un concetto generale di struttura ad albero di oggetti e introduce <xref:System.Windows.LogicalTreeHelper> e <xref:System.Windows.Media.VisualTreeHelper>s.  

<a name="element_tree"></a>
## <a name="trees-in-wpf"></a>Strutture ad albero in WPF  
 La struttura ad albero più completa in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] è la struttura ad albero di oggetti. Se si definisce la pagina di un'applicazione in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] e quindi si carica il codice [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], la struttura ad albero viene creata in base alle relazioni di annidamento degli elementi nel markup. Se si definisce un'applicazione o una parte dell'applicazione nel codice, la struttura ad albero viene creata in base a come si assegnano i valori per le proprietà che implementano il modello di contenuto per un determinato oggetto. In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] la struttura ad albero di oggetti completa viene concettualizzata e può essere segnalata alla relativa API pubblica in due modi diversi: come albero logico e come struttura ad albero visuale. Le distinzioni tra albero logico e struttura ad albero visuale non sono sempre necessariamente importanti, ma possono talvolta causare problemi con alcuni sottosistemi [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] e influire sulle scelte fatte nel markup o nel codice.  
  
 Anche se non sempre si modifica direttamente l'albero logico o la struttura ad albero visuale, la corretta comprensione dei concetti correlati all'interazione delle strutture ad albero è utile per comprendere WPF in quanto tecnologia. Il concetto di WPF come metafora della struttura ad albero è anche essenziale per comprendere il funzionamento dell'ereditarietà delle proprietà e del routing degli eventi in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
> [!NOTE]
> Poiché la struttura ad albero di oggetti è più un concetto che un'API effettiva, è possibile pensare a tale concetto anche come a un oggetto grafico. In pratica, in fase di esecuzione ci sono relazioni tra gli oggetti per cui la metafora di struttura ad albero non è valida. Ciononostante, in particolare con l'interfaccia utente definita in XAML, la metafora della struttura ad albero è sufficientemente pertinente da far sì che nella maggior parte della documentazione di WPF venga usato il termine struttura ad albero di oggetti per fare riferimento a tale concetto generale.  
  
<a name="logical_tree"></a>
## <a name="the-logical-tree"></a>Albero logico  
 In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] è possibile aggiungere contenuto agli elementi dell'interfaccia utente impostando proprietà degli oggetti di supporto per tali elementi. Ad esempio, aggiungere elementi <xref:System.Windows.Controls.ListBox> a un <xref:System.Windows.Controls.ItemsControl.Items%2A> controllo modificandone la proprietà. In questo modo, si inseriscono gli elementi in <xref:System.Windows.Controls.ItemCollection> che è il valore della <xref:System.Windows.Controls.ItemsControl.Items%2A> proprietà. Analogamente, per aggiungere <xref:System.Windows.Controls.DockPanel>oggetti a <xref:System.Windows.Controls.Panel.Children%2A> un oggetto , è necessario modificarne il valore della proprietà. Qui si aggiungono oggetti <xref:System.Windows.Controls.UIElementCollection>al file . Per un esempio di codice, vedere [Procedura: aggiungere dinamicamente un elemento](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100)).  
  
 In [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)], quando si inseriscono elementi dell'elenco <xref:System.Windows.Controls.ListBox> <xref:System.Windows.Controls.DockPanel>in un controllo <xref:System.Windows.Controls.ItemsControl.Items%2A> <xref:System.Windows.Controls.Panel.Children%2A> o in altri elementi dell'interfaccia utente in un oggetto , si utilizzano anche le proprietà e , in modo esplicito o implicito, come nell'esempio seguente.  
  
 [!code-xaml[TreeOvwsSupport#AllCode](~/samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 Se si elaborasse questo codice XAML come XML in un modello DOM (Document Object Model) e fossero stati inclusi tag impostati come commenti impliciti (operazione consentita), la struttura ad albero DOM XML risultante includerebbe elementi per `<ListBox.Items>` e altri elementi impliciti. Poiché tuttavia XAML non elabora in questo modo durante la lettura del markup e la scrittura negli oggetti, l'oggetto grafico risultante non includerà letteralmente `ListBox.Items`. Tuttavia, dispone <xref:System.Windows.Controls.ListBox> di `Items` una <xref:System.Windows.Controls.ItemCollection>proprietà denominata che contiene un oggetto , che <xref:System.Windows.Controls.ItemCollection> viene inizializzata ma vuota quando viene elaborato il <xref:System.Windows.Controls.ListBox> codice XAML. Quindi, ogni elemento oggetto figlio esistente <xref:System.Windows.Controls.ListBox> come contenuto <xref:System.Windows.Controls.ItemCollection> per l'oggetto viene aggiunto al parser chiama a `ItemCollection.Add`. Fino a questo punto, in questo esempio di elaborazione di XAML in una struttura ad albero di oggetti la struttura ad albero di oggetti creata sembra fondamentalmente essere un albero logico.  
  
 Tuttavia, l'albero logico non è l'intero oggetto grafico esistente per l'interfaccia utente dell'applicazione in fase di esecuzione, anche con gli elementi di sintassi implicita XAML fattorizzati. La ragione principale di questo è immagini e modelli. Si consideri <xref:System.Windows.Controls.Button>ad esempio il file . L'albero logico <xref:System.Windows.Controls.Button> segnala l'oggetto e anche la relativa stringa `Content`. Nella struttura ad albero di oggetti di runtime, tuttavia, questo pulsante è molto più complesso. In particolare, il pulsante viene visualizzato solo <xref:System.Windows.Controls.Button> sullo schermo come quando è stato applicato un modello di controllo specifico. Gli oggetti visivi che provengono da un <xref:System.Windows.Controls.Border> modello applicato (ad esempio il modello definito dal grigio scuro intorno al pulsante visivo) non vengono segnalati nell'albero logico, anche se si sta esaminando l'albero logico durante la fase di esecuzione (ad esempio la gestione di un evento di input dall'interfaccia utente visibile e quindi la lettura dell'albero logico). Per trovare gli oggetti visivi del modello, è invece necessario esaminare la struttura ad albero visuale.  
  
 Per altre informazioni sul mapping tra la sintassi [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] e l'oggetto grafico creato e sulla sintassi implicita in XAML, vedere [Descrizione dettagliata della sintassi XAML](xaml-syntax-in-detail.md) o [Cenni preliminari su XAML (WPF)](../../../desktop-wpf/fundamentals/xaml.md).  
  
<a name="tree_property_inheritance_event_routing"></a>
### <a name="the-purpose-of-the-logical-tree"></a>Scopo dell'albero logico  
 L'albero logico consente ai modelli di contenuto di scorrere rapidamente i relativi oggetti figlio possibili e rende i modelli di contenuto estendibili. L'albero logico fornisce inoltre un framework per determinate notifiche, ad esempio relative al caricamento di tutti gli oggetti nell'albero logico stesso. Fondamentalmente l'albero logico è un'approssimazione di un oggetto grafico di runtime a livello di framework, che esclude gli oggetti visivi, ma è efficace per molte operazioni di query sulla composizione dell'applicazione di runtime.  
  
 Inoltre, entrambi i riferimenti alle risorse statiche e dinamiche <xref:System.Windows.FrameworkElement.Resources%2A> vengono risolti esaminando verso l'alto l'albero logico <xref:System.Windows.FrameworkElement> per <xref:System.Windows.FrameworkContentElement>le `Resources` raccolte nell'oggetto richiedente iniziale e quindi continuando l'albero logico e controllando ogni (o ) per un altro valore che contiene una <xref:System.Windows.ResourceDictionary>, eventualmente contenente tale chiave. L'albero logico viene usato per la ricerca delle risorse, quando sono presenti sia l'albero logico, sia la struttura ad albero visuale. Per altre informazioni sui dizionari risorse e sulla ricerca, vedere [Risorse XAML](../../../desktop-wpf/fundamentals/xaml-resources-define.md).  
  
<a name="composition"></a>
### <a name="composition-of-the-logical-tree"></a>Composizione dell'albero logico  
 L'albero logico viene definito a livello di framework WPFWPF, il che significa che <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkContentElement>l'elemento di base WPF più rilevante per le operazioni dell'albero logico è o . Tuttavia, come si può vedere <xref:System.Windows.LogicalTreeHelper> se si utilizza effettivamente l'API, l'albero logico a volte contiene nodi che non sono o <xref:System.Windows.FrameworkElement> . <xref:System.Windows.FrameworkContentElement> Ad esempio, l'albero <xref:System.Windows.Controls.TextBlock.Text%2A> logico <xref:System.Windows.Controls.TextBlock>riporta il valore di un oggetto , che è una stringa.  
  
<a name="override_logical_tree"></a>
### <a name="overriding-the-logical-tree"></a>Override dell'albero logico  
 Gli autori di controlli avanzati possono eseguire l'override dell'albero logico eseguendo l'override di diverse API che definiscono il modo in cui un oggetto generale o un modello di contenuto aggiunge o rimuove oggetti all'interno dell'albero logico. Per un esempio relativo all'override dell'albero logico, vedere [Eseguire l'override dell'albero logico](how-to-override-the-logical-tree.md).  
  
<a name="pvi"></a>
### <a name="property-value-inheritance"></a>Ereditarietà del valore della proprietà  
 L'ereditarietà dei valori delle proprietà funziona tramite un albero ibrido. I metadati effettivi <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> che contengono la proprietà che <xref:System.Windows.FrameworkPropertyMetadata> abilita l'ereditarietà della proprietà è la classe a livello di framework WPF. Pertanto, sia l'elemento padre che contiene il valore originale <xref:System.Windows.FrameworkElement> che <xref:System.Windows.FrameworkContentElement>l'oggetto figlio che eredita tale valore devono essere o , ed entrambi devono far parte di un albero logico. Per le proprietà WPF esistenti che supportano l'ereditarietà delle proprietà, tuttavia, l'ereditarietà dei valori delle proprietà può essere mantenuta tramite un nuovo oggetto non incluso nell'albero logico. Questa caratteristica è pertinente per lo più se si vuole fare in modo che gli elementi del modello usino valori di proprietà ereditati impostati sull'istanza basata sul modello o a livelli ancora superiori di composizione a livello di pagina e quindi più in alto nell'albero logico. Per garantire un funzionamento coerente dell'ereditarietà dei valori delle proprietà oltre tale limite, la proprietà che eredita deve essere registrata come proprietà associata. È consigliabile seguire questo modello anche se si vuole definire una proprietà di dipendenza personalizzata con un comportamento di ereditarietà della proprietà. L'albero esatto usato per l'ereditarietà delle proprietà non può essere completamente previsto da un metodo di utilità di una classe helper, nemmeno in fase di esecuzione. Per altre informazioni, vedere [Ereditarietà del valore della proprietà](property-value-inheritance.md).  
  
<a name="two_trees"></a>
## <a name="the-visual-tree"></a>Struttura ad albero visuale  
 In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] oltre al concetto di albero logico c'è anche il concetto di struttura ad albero visuale. La struttura ad albero visuale descrive la <xref:System.Windows.Media.Visual> struttura degli oggetti visivi, rappresentata dalla classe base. Quando si scrive un modello per un controllo, si definisce o ridefinisce la struttura ad albero visuale relativa a quel controllo. La struttura ad albero visuale è di interesse anche per gli sviluppatori che vogliono un controllo di livello inferiore sul disegno per ragioni di prestazioni e ottimizzazione. Un'esposizione della struttura ad albero visuale come parte della programmazione di applicazioni [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] convenzionale è rappresentata dal fatto che le route degli eventi indirizzati percorrono per lo più la struttura ad albero visuale e non l'albero logico. Questa sottigliezza del comportamento degli eventi indirizzati potrebbe non essere immediatamente visibile, a meno che l'utente non sia un autore di controlli. Il routing di eventi nella struttura ad albero visuale consente ai controlli che implementano la composizione a livello visivo di gestire eventi o creare setter di eventi.  
  
<a name="trees_content"></a>
## <a name="trees-content-elements-and-content-hosts"></a>Alberi, elementi di contenuto e host di contenuto  
 Gli elementi di contenuto <xref:System.Windows.ContentElement>(classi che derivano da ) non fanno parte della struttura ad albero visuale; non ereditano <xref:System.Windows.Media.Visual> da e non hanno una rappresentazione visiva. Per essere visualizzato in un'interfaccia <xref:System.Windows.ContentElement> utente, un oggetto deve essere <xref:System.Windows.Media.Visual> ospitato in un host di contenuto che sia sia un partecipante all'albero logico che un partecipante. Di solito tale <xref:System.Windows.FrameworkElement>oggetto è un file . È possibile pensare all'host di contenuto come a un "browser" per il contenuto, che sceglie come visualizzare tale contenuto all'interno dell'area dello schermo controllata dall'host. Quando il contenuto è ospitato, può partecipare ad alcuni processi dell'albero che normalmente sono associati alla struttura ad albero visuale. In genere, la <xref:System.Windows.FrameworkElement> classe host include <xref:System.Windows.ContentElement> codice di implementazione che aggiunge qualsiasi elemento ospitato alla route dell'evento tramite sottonodi dell'albero logico del contenuto, anche se il contenuto ospitato non fa parte della vera struttura ad albero visuale. Ciò è necessario <xref:System.Windows.ContentElement> in modo che un evento può originare un evento indirizzato che indirizza a qualsiasi elemento diverso da se stesso.  
  
<a name="tree_traversal"></a>
## <a name="tree-traversal"></a>Attraversamento dell'albero  
 La <xref:System.Windows.LogicalTreeHelper> classe <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>fornisce <xref:System.Windows.LogicalTreeHelper.GetParent%2A>i <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> metodi , e per l'attraversamento dell'albero logico. Nella maggior parte dei casi, non è necessario attraversare l'albero logico dei controlli esistenti, perché i controlli espongono quasi sempre i relativi elementi figlio logici come proprietà di raccolta dedicata che supporta l'accesso alla raccolta, ad esempio `Add`, un indicizzatore e così via. L'attraversamento della struttura ad albero è principalmente uno scenario utilizzato dagli <xref:System.Windows.Controls.ItemsControl> <xref:System.Windows.Controls.Panel> autori di controlli che scelgono di non derivare da pattern di controllo previsti, ad esempio o in cui le proprietà della raccolta sono già definite e che intendono fornire il supporto delle proprietà della raccolta.  
  
 La struttura ad albero visuale supporta anche <xref:System.Windows.Media.VisualTreeHelper>una classe helper per l'attraversamento della struttura ad albero visuale, . La struttura ad albero visuale non viene esposta <xref:System.Windows.Media.VisualTreeHelper> in modo conveniente tramite proprietà specifiche del controllo, pertanto la classe è il modo consigliato per attraversare la struttura ad albero visuale, se necessario per lo scenario di programmazione. Per altre informazioni, vedere [Cenni preliminari sul rendering della grafica WPF](../graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
> [!NOTE]
> A volte è necessario esaminare la struttura ad albero visuale di un modello applicato. Quando si usa questa tecnica, è necessario procedere con attenzione. Anche se si attraversa una struttura ad albero visuale per un controllo in cui si <xref:System.Windows.Controls.Control.Template%2A> definisce il modello, i consumer del controllo possono sempre modificare il modello impostando la proprietà sulle istanze e anche l'utente finale può influenzare il modello applicato modificando il tema di sistema.  
  
<a name="routes"></a>
## <a name="routes-for-routed-events-as-a-tree"></a>Route per eventi indirizzati come "albero"  
 Come indicato in precedenza, la route di qualsiasi evento indirizzato percorre un singolo percorso predeterminato di un albero che consiste in una forma ibrida delle rappresentazioni di struttura ad albero visuale e albero logico. La route degli eventi può percorrere l'albero procedendo verso l'alto o verso il basso, a seconda che si tratti di un evento indirizzato di bubbling o di tunneling. Il concetto di route dell'evento non prevede una classe helper di supporto diretto, che potrebbe essere usata per "percorrere" la route dell'evento indipendentemente dalla generazione di un evento che effettivamente percorre una route. Esiste una classe che rappresenta <xref:System.Windows.EventRoute>la route , ma i metodi di tale classe sono in genere solo per uso interno.  
  
<a name="resourcesandtrees"></a>
## <a name="resource-dictionaries-and-trees"></a>Dizionari risorse e alberi  
 La ricerca nei dizionari risorse di tutti gli oggetti `Resources` definiti in una pagina attraversa fondamentalmente l'albero logico. Gli oggetti non inclusi nell'albero logico possono fare riferimento a risorse con chiave, ma la sequenza di ricerca delle risorse inizia nel punto in cui l'oggetto è connesso all'albero logico. In WPFWPF, solo i `Resources` nodi dell'albero logico possono avere una proprietà che contiene un <xref:System.Windows.ResourceDictionary> <xref:System.Windows.ResourceDictionary>oggetto , pertanto non vi è alcun vantaggio nell'attraversare la struttura ad albero visuale alla ricerca di risorse con chiave da un oggetto .  
  
 La ricerca delle risorse può però estendersi anche oltre l'albero logico diretto. Per il markup dell'applicazione, la ricerca delle risorse può proseguire verso l'altro nei dizionari risorse a livello di applicazione e quindi verso il supporto dei temi e i valori di sistema a cui viene fatto riferimento come chiavi o proprietà statiche. Se i riferimenti alle risorse sono dinamici, i temi stessi possono fare riferimento anche ai valori di sistema esterni all'albero logico del tema. Per altre informazioni sui dizionari risorse e sulla logica di ricerca, vedere [Risorse XAML](../../../desktop-wpf/fundamentals/xaml-resources-define.md).  
  
## <a name="see-also"></a>Vedere anche

- [Cenni preliminari sull'input](input-overview.md)
- [Cenni preliminari sul rendering della grafica WPF](../graphics-multimedia/wpf-graphics-rendering-overview.md)
- [Cenni preliminari sugli eventi indirizzati](routed-events-overview.md)
- [Inizializzazione di elementi oggetto non presenti in una struttura ad albero di oggetti](initialization-for-object-elements-not-in-an-object-tree.md)
- [Architettura WPF](wpf-architecture.md)
