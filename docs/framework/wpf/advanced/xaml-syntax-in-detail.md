---
title: Descrizione dettagliata della sintassi XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
ms.openlocfilehash: 5f8bb862ce443fd7397036b10f69cda65a6960bc
ms.sourcegitcommit: 62285ec11fa8e8424bab00511a90760c60e63c95
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/20/2020
ms.locfileid: "81646151"
---
# <a name="xaml-syntax-in-detail"></a><span data-ttu-id="9d0df-102">Descrizione dettagliata della sintassi XAML</span><span class="sxs-lookup"><span data-stu-id="9d0df-102">XAML Syntax In Detail</span></span>
<span data-ttu-id="9d0df-103">In questo argomento vengono definiti i termini utilizzati per descrivere gli elementi della sintassi XAML.</span><span class="sxs-lookup"><span data-stu-id="9d0df-103">This topic defines the terms that are used to describe the elements of XAML syntax.</span></span> <span data-ttu-id="9d0df-104">Questi termini vengono usati frequentemente nella parte restante di questa documentazione, sia per la documentazione WPF in modo specifico che per gli altri framework che usano XAML o i concetti XAML di base abilitati dal supporto del linguaggio XAML a livello di System.Xaml.</span><span class="sxs-lookup"><span data-stu-id="9d0df-104">These terms are used frequently throughout the remainder of this documentation, both for WPF documentation specifically and for the other frameworks that use XAML or the basic XAML concepts enabled by the XAML language support at the System.Xaml level.</span></span> <span data-ttu-id="9d0df-105">Questo argomento si espande sulla terminologia di base introdotta nell'argomento [Cenni preliminari su XAML (WPF)](../../../desktop-wpf/fundamentals/xaml.md).</span><span class="sxs-lookup"><span data-stu-id="9d0df-105">This topic expands on the basic terminology introduced in the topic [XAML Overview (WPF)](../../../desktop-wpf/fundamentals/xaml.md).</span></span>  

<a name="the_xaml_language_specification"></a>
## <a name="the-xaml-language-specification"></a><span data-ttu-id="9d0df-106">Specifiche del linguaggio XAMLThe XAML Language Specification</span><span class="sxs-lookup"><span data-stu-id="9d0df-106">The XAML Language Specification</span></span>  
 <span data-ttu-id="9d0df-107">La terminologia della sintassi XAML definita qui è anche definita o a cui viene fatto riferimento all'interno della specifica del linguaggio XAML.</span><span class="sxs-lookup"><span data-stu-id="9d0df-107">The XAML syntax terminology defined here is also defined or referenced within the XAML language specification.</span></span> <span data-ttu-id="9d0df-108">XAML è un linguaggio basato su XML e segue o espande le regole strutturali XML.</span><span class="sxs-lookup"><span data-stu-id="9d0df-108">XAML is a language based on XML and follows or expands upon XML structural rules.</span></span> <span data-ttu-id="9d0df-109">Parte della terminologia è condivisa da o si basa sulla terminologia comunemente utilizzata per descrivere il linguaggio XML o il modello a oggetti del documento XML.</span><span class="sxs-lookup"><span data-stu-id="9d0df-109">Some of the terminology is shared from or is based on the terminology commonly used when describing the XML language or the XML document object model.</span></span>  
  
 <span data-ttu-id="9d0df-110">Per ulteriori informazioni sulla specifica del linguaggio XAML, scaricare [ \[MS-XAML\] ](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf) dall'Area download Microsoft.</span><span class="sxs-lookup"><span data-stu-id="9d0df-110">For more information about the XAML language specification, download [\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf) from the Microsoft Download Center.</span></span>  
  
<a name="xaml_and_clr"></a>
## <a name="xaml-and-clr"></a><span data-ttu-id="9d0df-111">XAML e CLR</span><span class="sxs-lookup"><span data-stu-id="9d0df-111">XAML and CLR</span></span>  
 <span data-ttu-id="9d0df-112">XAML è un linguaggio di markup.</span><span class="sxs-lookup"><span data-stu-id="9d0df-112">XAML is a markup language.</span></span> <span data-ttu-id="9d0df-113">Common Language Runtime (CLR), come implicito dal nome, consente l'esecuzione di runtime.</span><span class="sxs-lookup"><span data-stu-id="9d0df-113">The common language runtime (CLR), as implied by its name, enables runtime execution.</span></span> <span data-ttu-id="9d0df-114">XAML non è di per sé uno dei linguaggi comuni che viene utilizzato direttamente dal runtime CLR.</span><span class="sxs-lookup"><span data-stu-id="9d0df-114">XAML is not by itself one of the common languages that is directly consumed by the CLR runtime.</span></span> <span data-ttu-id="9d0df-115">Al contrario, è possibile pensare a XAML come supporto del proprio sistema di tipi.</span><span class="sxs-lookup"><span data-stu-id="9d0df-115">Instead, you can think of XAML as supporting its own type system.</span></span> <span data-ttu-id="9d0df-116">Il particolare sistema di analisi XAML utilizzato da WPFWPF si basa su CLR e sul sistema di tipi CLR.</span><span class="sxs-lookup"><span data-stu-id="9d0df-116">The particular XAML parsing system that is used by WPF is built on the CLR and the CLR type system.</span></span> <span data-ttu-id="9d0df-117">I tipi XAML vengono mappati ai tipi CLR per creare un'istanza di una rappresentazione in fase di esecuzione quando il codice XAML per WPF viene analizzato.</span><span class="sxs-lookup"><span data-stu-id="9d0df-117">XAML types are mapped to CLR types to instantiate a run time representation when the XAML for WPF is parsed.</span></span> <span data-ttu-id="9d0df-118">Per questo motivo, il resto della discussione sulla sintassi in questo documento includerà riferimenti al sistema di tipi CLR, anche se le discussioni di sintassi equivalenti nella specifica del linguaggio XAML non lo fanno.</span><span class="sxs-lookup"><span data-stu-id="9d0df-118">For this reason, the remainder of discussion of syntax in this document will include references to the CLR type system, even though the equivalent syntax discussions in the XAML language specification do not.</span></span> <span data-ttu-id="9d0df-119">(In base al livello di specifica del linguaggio XAML, i tipi XAML potrebbero essere mappati a qualsiasi altro sistema di tipi, che non deve essere CLR, ma che richiederebbe la creazione e l'uso di un parser XAML diverso.)</span><span class="sxs-lookup"><span data-stu-id="9d0df-119">(Per the XAML language specification level, XAML types could be mapped to any other type system, which does not have to be the CLR, but that would require the creation and use of a different XAML parser.)</span></span>  
  
#### <a name="members-of-types-and-class-inheritance"></a><span data-ttu-id="9d0df-120">Membri di tipi ed ereditarietà delle classi</span><span class="sxs-lookup"><span data-stu-id="9d0df-120">Members of Types and Class Inheritance</span></span>  
 <span data-ttu-id="9d0df-121">Le proprietà e gli eventi visualizzati come membri XAML di un [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] tipo vengono spesso ereditati dai tipi di base.</span><span class="sxs-lookup"><span data-stu-id="9d0df-121">Properties and events as they appear as XAML members of a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] type are often inherited from base types.</span></span> <span data-ttu-id="9d0df-122">Si consideri ad `<Button Background="Blue" .../>`esempio questo esempio: .</span><span class="sxs-lookup"><span data-stu-id="9d0df-122">For example, consider this example: `<Button Background="Blue" .../>`.</span></span> <span data-ttu-id="9d0df-123">La <xref:System.Windows.Controls.Control.Background%2A> proprietà non è una <xref:System.Windows.Controls.Button> proprietà dichiarata immediatamente nella classe, se si esamina la definizione della classe, i risultati della reflection o la documentazione.</span><span class="sxs-lookup"><span data-stu-id="9d0df-123">The <xref:System.Windows.Controls.Control.Background%2A> property is not an immediately declared property on the <xref:System.Windows.Controls.Button> class, if you were to look at the class definition, reflection results, or the documentation.</span></span> <span data-ttu-id="9d0df-124">Al <xref:System.Windows.Controls.Control.Background%2A> contrario, viene <xref:System.Windows.Controls.Control> ereditato dalla classe di base.</span><span class="sxs-lookup"><span data-stu-id="9d0df-124">Instead, <xref:System.Windows.Controls.Control.Background%2A> is inherited from the base <xref:System.Windows.Controls.Control> class.</span></span>  
  
 <span data-ttu-id="9d0df-125">Il comportamento di [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] ereditarietà delle classi degli elementi XAML è una deviazione significativa rispetto a un'interpretazione applicata allo schema del markup XML.</span><span class="sxs-lookup"><span data-stu-id="9d0df-125">The class inheritance behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML elements is a significant departure from a schema-enforced interpretation of XML markup.</span></span> <span data-ttu-id="9d0df-126">L'ereditarietà delle classi può diventare complessa, in particolare quando le classi di base intermedie sono astratte o quando sono coinvolte interfacce.</span><span class="sxs-lookup"><span data-stu-id="9d0df-126">Class inheritance can become complex, particularly when intermediate base classes are abstract, or when interfaces are involved.</span></span> <span data-ttu-id="9d0df-127">Questo è uno dei motivi per cui il set di elementi XAML e i relativi attributi consentiti è difficile da rappresentare in modo accurato e completo utilizzando i tipi di schema che vengono in genere utilizzati per la programmazione XML, ad esempio il formato DTD o XSD.</span><span class="sxs-lookup"><span data-stu-id="9d0df-127">This is one reason that the set of XAML elements and their permissible attributes is difficult to represent accurately and completely using the schema types that are typically used for XML programming, such as DTD or XSD format.</span></span> <span data-ttu-id="9d0df-128">Un altro motivo è che le funzionalità di estendibilità e mapping dei tipi del linguaggio XAML stesso impediscono la completezza di qualsiasi rappresentazione fissa dei tipi e dei membri consentiti.</span><span class="sxs-lookup"><span data-stu-id="9d0df-128">Another reason is that extensibility and type-mapping features of the XAML language itself preclude completeness of any fixed representation of the permissible types and members.</span></span>  
  
<a name="object_element_syntax"></a>
## <a name="object-element-syntax"></a><span data-ttu-id="9d0df-129">Sintassi degli elementi oggetto</span><span class="sxs-lookup"><span data-stu-id="9d0df-129">Object Element Syntax</span></span>  
 <span data-ttu-id="9d0df-130">*La sintassi* degli elementi oggetto è la sintassi del markup XAML che crea un'istanza di una classe o struttura CLR dichiarando un elemento XML.</span><span class="sxs-lookup"><span data-stu-id="9d0df-130">*Object element syntax* is the XAML markup syntax that instantiates a CLR class or structure by declaring an XML element.</span></span> <span data-ttu-id="9d0df-131">Questa sintassi è simile alla sintassi degli elementi di altri linguaggi di markup, ad esempio HTML.</span><span class="sxs-lookup"><span data-stu-id="9d0df-131">This syntax resembles the element syntax of other markup languages such as HTML.</span></span> <span data-ttu-id="9d0df-132">La sintassi degli elementi oggetto\<inizia con una parentesi angolare sinistra ( ), seguita immediatamente dal nome del tipo della classe o della struttura di cui viene creata un'istanza.</span><span class="sxs-lookup"><span data-stu-id="9d0df-132">Object element syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure being instantiated.</span></span> <span data-ttu-id="9d0df-133">Zero o più spazi possono seguire il nome del tipo e zero o più attributi possono anche essere dichiarati sull'elemento oggetto, con uno o più spazi che separano ogni attributo nome -"valore" coppia.</span><span class="sxs-lookup"><span data-stu-id="9d0df-133">Zero or more spaces can follow the type name, and zero or more attributes may also be declared on the object element, with one or more spaces separating each attribute name="value" pair.</span></span> <span data-ttu-id="9d0df-134">Infine, deve essere vera una delle seguenti condizioni:</span><span class="sxs-lookup"><span data-stu-id="9d0df-134">Finally, one of the following must be true:</span></span>  
  
- <span data-ttu-id="9d0df-135">L'elemento e il tag devono essere chiusi da una barra (/) seguita immediatamente da una parentesi angolare destra (>).</span><span class="sxs-lookup"><span data-stu-id="9d0df-135">The element and tag must be closed by a forward slash (/) followed immediately by a right angle bracket (>).</span></span>  
  
- <span data-ttu-id="9d0df-136">Il tag di apertura deve essere completato da una parentesi angolare destra (>).</span><span class="sxs-lookup"><span data-stu-id="9d0df-136">The opening tag must be completed by a right angle bracket (>).</span></span> <span data-ttu-id="9d0df-137">Altri elementi oggetto, elementi di proprietà o testo interno possono seguire il tag di apertura.</span><span class="sxs-lookup"><span data-stu-id="9d0df-137">Other object elements, property elements, or inner text, can follow the opening tag.</span></span> <span data-ttu-id="9d0df-138">Il contenuto può essere contenuto in questo caso è in genere vincolato dal modello a oggetti dell'elemento.</span><span class="sxs-lookup"><span data-stu-id="9d0df-138">Exactly what content may be contained here is typically constrained by the object model of the element.</span></span> <span data-ttu-id="9d0df-139">Deve esistere anche il tag di chiusura equivalente per l'elemento oggetto, nella corretta nidificazione ed equilibrio con altre coppie di tag di apertura e chiusura.</span><span class="sxs-lookup"><span data-stu-id="9d0df-139">The equivalent closing tag for the object element must also exist, in proper nesting and balance with other opening and closing tag pairs.</span></span>  
  
 <span data-ttu-id="9d0df-140">XAML come implementato da .NET dispone di un set di regole che eseguono il mapping di elementi oggetto in tipi, attributi in proprietà o eventi e spazi dei nomi XAML agli spazi dei nomi CLR più assembly.</span><span class="sxs-lookup"><span data-stu-id="9d0df-140">XAML as implemented by .NET has a set of rules that map object elements into types, attributes into properties or events, and XAML namespaces to CLR namespaces plus assembly.</span></span> <span data-ttu-id="9d0df-141">Per WPF e .NET, gli elementi oggetto XAML eseguono il mapping ai tipi .NET definiti negli assembly a cui si fa riferimento e gli attributi eseguono il mapping ai membri di tali tipi.</span><span class="sxs-lookup"><span data-stu-id="9d0df-141">For WPF and .NET, XAML object elements map to .NET types as defined in referenced assemblies, and the attributes map to members of those types.</span></span> <span data-ttu-id="9d0df-142">Quando si fa riferimento a un tipo CLR in XAML, si ha accesso anche ai membri ereditati di tale tipo.</span><span class="sxs-lookup"><span data-stu-id="9d0df-142">When you reference a CLR type in XAML, you have access to the inherited members of that type as well.</span></span>  
  
 <span data-ttu-id="9d0df-143">Ad esempio, l'esempio seguente è la sintassi <xref:System.Windows.Controls.Button> degli elementi oggetto che <xref:System.Windows.FrameworkElement.Name%2A> crea un'istanza di una nuova istanza della classe e specifica anche un attributo e un valore per tale attributo:</span><span class="sxs-lookup"><span data-stu-id="9d0df-143">For example, the following example is object element syntax that instantiates a new instance of the <xref:System.Windows.Controls.Button> class, and also specifies a <xref:System.Windows.FrameworkElement.Name%2A> attribute and a value for that attribute:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 <span data-ttu-id="9d0df-144">L'esempio seguente è la sintassi degli elementi oggetto che include anche la sintassi delle proprietà di contenuto XAML.</span><span class="sxs-lookup"><span data-stu-id="9d0df-144">The following example is object element syntax that also includes XAML content property syntax.</span></span> <span data-ttu-id="9d0df-145">Il testo interno contenuto all'interno <xref:System.Windows.Controls.TextBox> verrà utilizzato <xref:System.Windows.Controls.TextBox.Text%2A>per impostare la proprietà di contenuto XAML, .</span><span class="sxs-lookup"><span data-stu-id="9d0df-145">The inner text contained within will be used to set the <xref:System.Windows.Controls.TextBox> XAML content property, <xref:System.Windows.Controls.TextBox.Text%2A>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a><span data-ttu-id="9d0df-146">Modelli di contenuto</span><span class="sxs-lookup"><span data-stu-id="9d0df-146">Content Models</span></span>  
 <span data-ttu-id="9d0df-147">Una classe potrebbe supportare un utilizzo come elemento oggetto XAML in termini di sintassi, ma tale elemento funzionerà correttamente solo in un'applicazione o una pagina quando viene posizionato in una posizione prevista di un modello di contenuto o di una struttura ad albero dell'elemento.</span><span class="sxs-lookup"><span data-stu-id="9d0df-147">A class might support a usage as a XAML object element in terms of the syntax, but that element will only function properly in an application or page when it is placed in an expected position of an overall content model or element tree.</span></span> <span data-ttu-id="9d0df-148">Ad esempio, <xref:System.Windows.Controls.MenuItem> un oggetto deve in genere <xref:System.Windows.Controls.Primitives.MenuBase> essere inserito solo come figlio di una classe derivata, ad <xref:System.Windows.Controls.Menu>esempio .</span><span class="sxs-lookup"><span data-stu-id="9d0df-148">For example, a <xref:System.Windows.Controls.MenuItem> should typically only be placed as a child of a <xref:System.Windows.Controls.Primitives.MenuBase> derived class such as <xref:System.Windows.Controls.Menu>.</span></span> <span data-ttu-id="9d0df-149">I modelli di contenuto per elementi specifici vengono documentati come [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] parte delle osservazioni nelle pagine delle classi per i controlli e altre classi che possono essere usate come elementi XAML.</span><span class="sxs-lookup"><span data-stu-id="9d0df-149">Content models for specific elements are documented as part of the remarks on the class pages for controls and other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes that can be used as XAML elements.</span></span>  
  
<a name="properties_of_object_elements"></a>
## <a name="properties-of-object-elements"></a><span data-ttu-id="9d0df-150">Proprietà degli elementi oggetto</span><span class="sxs-lookup"><span data-stu-id="9d0df-150">Properties of Object Elements</span></span>  
 <span data-ttu-id="9d0df-151">Le proprietà in XAML vengono impostate da una varietà di sintassi possibili.</span><span class="sxs-lookup"><span data-stu-id="9d0df-151">Properties in XAML are set by a variety of possible syntaxes.</span></span> <span data-ttu-id="9d0df-152">La sintassi che può essere utilizzata per una determinata proprietà varia in base alle caratteristiche del sistema di tipi sottostanti della proprietà che si sta impostando.</span><span class="sxs-lookup"><span data-stu-id="9d0df-152">Which syntax can be used for a particular property will vary, based on the underlying type system characteristics of the property that you are setting.</span></span>  
  
 <span data-ttu-id="9d0df-153">Impostando i valori delle proprietà, si aggiungono feature o caratteristiche agli oggetti così come esistono nell'oggetto grafico della fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="9d0df-153">By setting values of properties, you add features or characteristics to objects as they exist in the run time object graph.</span></span> <span data-ttu-id="9d0df-154">Lo stato iniziale dell'oggetto creato da un elemento oggetto si basa sul comportamento del costruttore senza parametri.</span><span class="sxs-lookup"><span data-stu-id="9d0df-154">The initial state of the created object from a object element is based on the parameterless constructor behavior.</span></span> <span data-ttu-id="9d0df-155">In genere, l'applicazione utilizzerà un elemento diverso da un'istanza completamente predefinita di qualsiasi oggetto specificato.</span><span class="sxs-lookup"><span data-stu-id="9d0df-155">Typically, your application will use something other than a completely default instance of any given object.</span></span>  
  
<a name="attribute_syntax_properties"></a>
## <a name="attribute-syntax-properties"></a><span data-ttu-id="9d0df-156">Sintassi per attributi (proprietà)</span><span class="sxs-lookup"><span data-stu-id="9d0df-156">Attribute Syntax (Properties)</span></span>  
 <span data-ttu-id="9d0df-157">La sintassi degli attributi è la sintassi del markup XAML che imposta un valore per una proprietà dichiarando un attributo su un elemento oggetto esistente.</span><span class="sxs-lookup"><span data-stu-id="9d0df-157">Attribute syntax is the XAML markup syntax that sets a value for a property by declaring an attribute on an existing object element.</span></span> <span data-ttu-id="9d0df-158">Il nome dell'attributo deve corrispondere al nome del membro CLR della proprietà della classe che supporta l'elemento oggetto pertinente.</span><span class="sxs-lookup"><span data-stu-id="9d0df-158">The attribute name must match the CLR member name of the property of the class that backs the relevant object element.</span></span> <span data-ttu-id="9d0df-159">Il nome dell'attributo è seguito da un operatore di assegnazione (Sezione ).</span><span class="sxs-lookup"><span data-stu-id="9d0df-159">The attribute name is followed by an assignment operator (=).</span></span> <span data-ttu-id="9d0df-160">Il valore dell'attributo deve essere una stringa racchiusa tra virgolette.</span><span class="sxs-lookup"><span data-stu-id="9d0df-160">The attribute value must be a string enclosed within quotes.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9d0df-161">È possibile utilizzare le virgolette alternate per inserire una virgoletta letterale all'interno di un attributo.</span><span class="sxs-lookup"><span data-stu-id="9d0df-161">You can use alternating quotes to place a literal quotation mark within an attribute.</span></span> <span data-ttu-id="9d0df-162">Ad esempio, è possibile utilizzare le virgolette singole come mezzo per dichiarare una stringa che contiene un carattere di virgolette doppie al suo interno.</span><span class="sxs-lookup"><span data-stu-id="9d0df-162">For instance you can use single quotes as a means to declare a string that contains a double quote character within it.</span></span> <span data-ttu-id="9d0df-163">Se si utilizzano virgolette singole o doppie, è necessario utilizzare una coppia corrispondente per aprire e chiudere la stringa del valore dell'attributo.</span><span class="sxs-lookup"><span data-stu-id="9d0df-163">Whether you use single or double quotes, you should use a matching pair for opening and closing the attribute value string.</span></span> <span data-ttu-id="9d0df-164">Sono inoltre disponibili sequenze di escape o altre tecniche per aggirare le restrizioni relative ai caratteri imposte da una particolare sintassi XAML.</span><span class="sxs-lookup"><span data-stu-id="9d0df-164">There are also escape sequences or other techniques available for working around character restrictions imposed by any particular XAML syntax.</span></span> <span data-ttu-id="9d0df-165">Vedere [Entità carattere XML e XAML.](../../../desktop-wpf/xaml-services/xml-character-entities.md)</span><span class="sxs-lookup"><span data-stu-id="9d0df-165">See [XML Character Entities and XAML](../../../desktop-wpf/xaml-services/xml-character-entities.md).</span></span>  
  
 <span data-ttu-id="9d0df-166">Per essere impostata tramite la sintassi dell'attributo, una proprietà deve essere pubblica e scrivibile.</span><span class="sxs-lookup"><span data-stu-id="9d0df-166">In order to be set through attribute syntax, a property must be public and must be writeable.</span></span> <span data-ttu-id="9d0df-167">Il valore della proprietà nel sistema di tipi di supporto deve essere un tipo di valore o deve essere un tipo di riferimento di cui può essere creata un'istanza o referenziata da un processore XAML quando si accede al tipo di supporto pertinente.</span><span class="sxs-lookup"><span data-stu-id="9d0df-167">The value of the property in the backing type system must be a value type, or must be a reference type that can be instantiated or referenced by a XAML processor when accessing the relevant backing type.</span></span>  
  
 <span data-ttu-id="9d0df-168">Per gli eventi XAML WPFWPF, l'evento a cui viene fatto riferimento come nome dell'attributo deve essere pubblico e disporre di un delegato pubblico.</span><span class="sxs-lookup"><span data-stu-id="9d0df-168">For WPF XAML events, the event that is referenced as the attribute name must be public and have a public delegate.</span></span>  
  
 <span data-ttu-id="9d0df-169">La proprietà o l'evento deve essere un membro della classe o della struttura di cui viene creata un'istanza dall'elemento oggetto contenitore.</span><span class="sxs-lookup"><span data-stu-id="9d0df-169">The property or event must be a member of the class or structure that is instantiated by the containing object element.</span></span>  
  
### <a name="processing-of-attribute-values"></a><span data-ttu-id="9d0df-170">Elaborazione dei valori degli attributiProcessing of Attribute Values</span><span class="sxs-lookup"><span data-stu-id="9d0df-170">Processing of Attribute Values</span></span>  
 <span data-ttu-id="9d0df-171">Il valore stringa contenuto nelle virgolette di apertura e chiusura viene elaborato da un processore XAML.</span><span class="sxs-lookup"><span data-stu-id="9d0df-171">The string value contained within the opening and closing quotation marks is processed by a XAML processor.</span></span> <span data-ttu-id="9d0df-172">Per le proprietà, il comportamento di elaborazione predefinito è determinato dal tipo della proprietà CLR sottostante.</span><span class="sxs-lookup"><span data-stu-id="9d0df-172">For properties, the default processing behavior is determined by the type of the underlying CLR property.</span></span>  
  
 <span data-ttu-id="9d0df-173">Il valore dell'attributo viene compilato da uno dei seguenti elementi, utilizzando questo ordine di elaborazione:</span><span class="sxs-lookup"><span data-stu-id="9d0df-173">The attribute value is filled by one of the following, using this processing order:</span></span>  
  
1. <span data-ttu-id="9d0df-174">Se il processore XAML rileva una parentesi graffa o <xref:System.Windows.Markup.MarkupExtension>un elemento oggetto che deriva da , l'estensione di markup a cui si fa riferimento viene valutata prima anziché elaborare il valore come stringa e l'oggetto restituito dall'estensione di markup viene utilizzato come valore.</span><span class="sxs-lookup"><span data-stu-id="9d0df-174">If the XAML processor encounters a curly brace, or an object element that derives from <xref:System.Windows.Markup.MarkupExtension>, then the referenced markup extension is evaluated first rather than processing the value as a string, and the object returned by the markup extension is used as the value.</span></span> <span data-ttu-id="9d0df-175">In molti casi l'oggetto restituito da un'estensione di markup sarà un riferimento a un oggetto esistente o un'espressione che rinvia la valutazione fino alla fase di esecuzione e non è un oggetto appena istanziato.</span><span class="sxs-lookup"><span data-stu-id="9d0df-175">In many cases the object returned by a markup extension will be a reference to an existing object, or an expression that defers evaluation until run time, and is not a newly instantiated object.</span></span>  
  
2. <span data-ttu-id="9d0df-176">Se la proprietà viene dichiarata <xref:System.ComponentModel.TypeConverter>con un attributo o il tipo <xref:System.ComponentModel.TypeConverter>di valore di tale proprietà viene dichiarato con un attributo , il valore stringa dell'attributo viene inviato al convertitore di tipi come input di conversione e il convertitore restituirà una nuova istanza dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="9d0df-176">If the property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, or the value type of that property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, the string value of the attribute is submitted to the type converter as a conversion input, and the converter will return a new object instance.</span></span>  
  
3. <span data-ttu-id="9d0df-177">Se non <xref:System.ComponentModel.TypeConverter>è presente alcun , viene tentata una conversione diretta al tipo di proprietà.</span><span class="sxs-lookup"><span data-stu-id="9d0df-177">If there is no <xref:System.ComponentModel.TypeConverter>, a direct conversion to the property type is attempted.</span></span> <span data-ttu-id="9d0df-178">Questo livello finale è una conversione diretta in corrispondenza del valore nativo del parser tra i tipi primitivi del linguaggio XAML o un controllo per i nomi delle costanti denominate in un'enumerazione (il parser accede quindi ai valori corrispondenti).</span><span class="sxs-lookup"><span data-stu-id="9d0df-178">This final level is a direct conversion at the parser-native value between XAML language primitive types, or a check for the names of named constants in an enumeration (the parser then accesses the matching values).</span></span>  
  
#### <a name="enumeration-attribute-values"></a><span data-ttu-id="9d0df-179">Valori degli attributi di enumerazione</span><span class="sxs-lookup"><span data-stu-id="9d0df-179">Enumeration Attribute Values</span></span>  
 <span data-ttu-id="9d0df-180">Le enumerazioni in XAML vengono elaborate intrinsecamente dai parser XAML e i membri di un'enumerazione devono essere specificati specificando il nome di stringa di una delle costanti denominate dell'enumerazione.</span><span class="sxs-lookup"><span data-stu-id="9d0df-180">Enumerations in XAML are processed intrinsically by XAML parsers, and the members of an enumeration should be specified by specifying the string name of one of the enumeration's named constants.</span></span>  
  
 <span data-ttu-id="9d0df-181">Per i valori di enumerazione non flag, il comportamento nativo consiste nell'elaborare la stringa di un valore di attributo e risolverla in uno dei valori di enumerazione.</span><span class="sxs-lookup"><span data-stu-id="9d0df-181">For nonflag enumeration values, the native behavior is to process the string of an attribute value and resolve it to one of the enumeration values.</span></span> <span data-ttu-id="9d0df-182">Non si specifica l'enumerazione nel formato *Enumerazione*. *Valore*, come nel codice.</span><span class="sxs-lookup"><span data-stu-id="9d0df-182">You do not specify the enumeration in the format *Enumeration*.*Value*, as you do in code.</span></span> <span data-ttu-id="9d0df-183">Si specifica invece solo *Value*e *Enumeration* viene dedotto dal tipo della proprietà che si sta impostando.</span><span class="sxs-lookup"><span data-stu-id="9d0df-183">Instead, you specify only *Value*, and *Enumeration* is inferred by the type of the property you are setting.</span></span> <span data-ttu-id="9d0df-184">Se si specifica un attributo nella finestra *Enumeration*. Modulo di *valore,* non si risolverà correttamente.</span><span class="sxs-lookup"><span data-stu-id="9d0df-184">If you specify an attribute in the *Enumeration*.*Value* form, it will not resolve correctly.</span></span>  
  
 <span data-ttu-id="9d0df-185">Per le enumerazioni flagwise, il <xref:System.Enum.Parse%2A?displayProperty=nameWithType> comportamento è basato sul metodo .</span><span class="sxs-lookup"><span data-stu-id="9d0df-185">For flagwise enumerations, the behavior is based on the <xref:System.Enum.Parse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="9d0df-186">È possibile specificare più valori per un'enumerazione flagwise separando ogni valore con una virgola.</span><span class="sxs-lookup"><span data-stu-id="9d0df-186">You can specify multiple values for a flagwise enumeration by separating each value with a comma.</span></span> <span data-ttu-id="9d0df-187">Tuttavia, è possibile combinare valori di enumerazione che non sono flagwise.</span><span class="sxs-lookup"><span data-stu-id="9d0df-187">However, you cannot combine enumeration values that are not flagwise.</span></span> <span data-ttu-id="9d0df-188">Ad esempio, non è possibile utilizzare la <xref:System.Windows.Trigger> sintassi della virgola per tentare di creare un che agisce su più condizioni di un'enumerazione non flag:For instance, you cannot use the comma syntax to attempt to create a that acts on multiple conditions of a nonflag enumeration:</span><span class="sxs-lookup"><span data-stu-id="9d0df-188">For instance, you cannot use the comma syntax to attempt to create a <xref:System.Windows.Trigger> that acts on multiple conditions of a nonflag enumeration:</span></span>  
  
```xaml  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 <span data-ttu-id="9d0df-189">Le enumerazioni Flagwise che supportano gli attributi impostabili in XAML sono rare in WPFWPF.</span><span class="sxs-lookup"><span data-stu-id="9d0df-189">Flagwise enumerations that support attributes that are settable in XAML are rare in WPF.</span></span> <span data-ttu-id="9d0df-190">Tuttavia, una <xref:System.Windows.Media.StyleSimulations>di queste enumerazioni è .</span><span class="sxs-lookup"><span data-stu-id="9d0df-190">However, one such enumeration is <xref:System.Windows.Media.StyleSimulations>.</span></span> <span data-ttu-id="9d0df-191">È possibile, ad esempio, utilizzare la sintassi dell'attributo flagwise delimitata da virgole per modificare l'esempio fornito nelle osservazioni per la <xref:System.Windows.Documents.Glyphs> classe; `StyleSimulations = "BoldSimulation"` potrebbe `StyleSimulations = "BoldSimulation,ItalicSimulation"`diventare .</span><span class="sxs-lookup"><span data-stu-id="9d0df-191">You could, for instance, use the comma-delimited flagwise attribute syntax to modify the example provided in the Remarks for the <xref:System.Windows.Documents.Glyphs> class; `StyleSimulations = "BoldSimulation"` could become `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span></span> <span data-ttu-id="9d0df-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>è un'altra proprietà in cui è possibile specificare più di un valore di enumerazione.</span><span class="sxs-lookup"><span data-stu-id="9d0df-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> is another property where more than one enumeration value can be specified.</span></span> <span data-ttu-id="9d0df-193">Tuttavia, questa proprietà si verifica per <xref:System.Windows.Input.ModifierKeys> essere un caso speciale, perché l'enumerazione supporta il proprio convertitore di tipi.</span><span class="sxs-lookup"><span data-stu-id="9d0df-193">However, this property happens to be a special case, because the <xref:System.Windows.Input.ModifierKeys> enumeration supports its own type converter.</span></span> <span data-ttu-id="9d0df-194">Il convertitore di tipi per i modificatori utilizza un segno più (-) come delimitatore anziché una virgola (,).</span><span class="sxs-lookup"><span data-stu-id="9d0df-194">The type converter for modifiers uses a plus sign (+) as a delimiter rather than a comma (,).</span></span> <span data-ttu-id="9d0df-195">Questa conversione supporta la sintassi più tradizionale per rappresentare le combinazioni di tasti nella programmazione di Microsoft Windows, ad esempio "Ctrl-Alt".</span><span class="sxs-lookup"><span data-stu-id="9d0df-195">This conversion supports the more traditional syntax to represent key combinations in Microsoft Windows programming, such as "Ctrl+Alt".</span></span>  
  
### <a name="properties-and-event-member-name-references"></a><span data-ttu-id="9d0df-196">Proprietà e riferimenti a nomi di membri evento</span><span class="sxs-lookup"><span data-stu-id="9d0df-196">Properties and Event Member Name References</span></span>  
 <span data-ttu-id="9d0df-197">Quando si specifica un attributo, è possibile fare riferimento a qualsiasi proprietà o evento esistente come membro del tipo CLR di cui è stata creata un'istanza per l'elemento oggetto contenitore.</span><span class="sxs-lookup"><span data-stu-id="9d0df-197">When specifying an attribute, you can reference any property or event that exists as a member of the CLR type you instantiated for the containing object element.</span></span>  
  
 <span data-ttu-id="9d0df-198">In alternativa, è possibile fare riferimento a una proprietà associata o a un evento associato, indipendentemente dall'elemento oggetto che lo contiene.</span><span class="sxs-lookup"><span data-stu-id="9d0df-198">Or, you can reference an attached property or attached event, independent of the containing object element.</span></span> <span data-ttu-id="9d0df-199">Le proprietà associate vengono descritte in una sezione successiva.</span><span class="sxs-lookup"><span data-stu-id="9d0df-199">(Attached properties are discussed in an upcoming section.)</span></span>  
  
 <span data-ttu-id="9d0df-200">È inoltre possibile assegnare un nome a qualsiasi evento da qualsiasi oggetto accessibile tramite lo spazio dei nomi predefinito utilizzando *typeName*. nome parzialmente qualificato *dell'evento;* questa sintassi supporta l'associazione di gestori per gli eventi indirizzati in cui il gestore è destinato a gestire il routing degli eventi dagli elementi figlio, ma l'elemento padre non dispone anche di tale evento nella relativa tabella dei membri.</span><span class="sxs-lookup"><span data-stu-id="9d0df-200">You can also name any event from any object that is accessible through the default namespace by using a *typeName*.*event* partially qualified name; this syntax supports attaching handlers for routed events where the handler is intended to handle events routing from child elements, but the parent element does not also have that event in its members table.</span></span> <span data-ttu-id="9d0df-201">Questa sintassi è simile a una sintassi dell'evento associato, ma l'evento qui non è un vero evento associato.</span><span class="sxs-lookup"><span data-stu-id="9d0df-201">This syntax resembles an attached event syntax, but the event here is not a true attached event.</span></span> <span data-ttu-id="9d0df-202">Si fa invece riferimento a un evento con un nome completo.</span><span class="sxs-lookup"><span data-stu-id="9d0df-202">Instead, you are referencing an event with a qualified name.</span></span> <span data-ttu-id="9d0df-203">Per ulteriori informazioni, vedere [Cenni preliminari sugli eventi indirizzati](routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="9d0df-203">For more information, see [Routed Events Overview](routed-events-overview.md).</span></span>  
  
 <span data-ttu-id="9d0df-204">Per alcuni scenari, i nomi delle proprietà vengono talvolta forniti come valore di un attributo, anziché come nome dell'attributo.</span><span class="sxs-lookup"><span data-stu-id="9d0df-204">For some scenarios, property names are sometimes provided as the value of an attribute, rather than the attribute name.</span></span> <span data-ttu-id="9d0df-205">Tale nome di proprietà può includere anche qualificatori, ad esempio la proprietà specificata nel form *ownerType*. *dependencyPropertyName*.</span><span class="sxs-lookup"><span data-stu-id="9d0df-205">That property name can also include qualifiers, such as the property specified in the form *ownerType*.*dependencyPropertyName*.</span></span> <span data-ttu-id="9d0df-206">Questo scenario è comune quando si scrivono stili o modelli in XAML.</span><span class="sxs-lookup"><span data-stu-id="9d0df-206">This scenario is common when writing styles or templates in XAML.</span></span> <span data-ttu-id="9d0df-207">Le regole di elaborazione per i nomi di proprietà fornite come valore di attributo sono diverse e sono regolate dal tipo della proprietà impostata o dai comportamenti di particolari sottosistemi WPFWPF.</span><span class="sxs-lookup"><span data-stu-id="9d0df-207">The processing rules for property names provided as an attribute value are different, and are governed by the type of the property being set or by the behaviors of particular WPF subsystems.</span></span> <span data-ttu-id="9d0df-208">Per informazioni dettagliate, consultate [Applicazione di stili e modelli.](../../../desktop-wpf/fundamentals/styles-templates-overview.md)</span><span class="sxs-lookup"><span data-stu-id="9d0df-208">For details, see [Styling and Templating](../../../desktop-wpf/fundamentals/styles-templates-overview.md).</span></span>  
  
 <span data-ttu-id="9d0df-209">Un altro utilizzo per i nomi delle proprietà è quando un valore di attributo descrive una relazione proprietà-proprietà.</span><span class="sxs-lookup"><span data-stu-id="9d0df-209">Another usage for property names is when an attribute value describes a property-property relationship.</span></span> <span data-ttu-id="9d0df-210">Questa funzionalità viene utilizzata per l'associazione dati <xref:System.Windows.PropertyPath> e per le destinazioni dello storyboard ed è abilitata dalla classe e dal relativo convertitore di tipi.</span><span class="sxs-lookup"><span data-stu-id="9d0df-210">This feature is used for data binding and for storyboard targets, and is enabled by the <xref:System.Windows.PropertyPath> class and its type converter.</span></span> <span data-ttu-id="9d0df-211">Per una descrizione più completa della semantica di ricerca, vedere [Sintassi XAML PropertyPath](propertypath-xaml-syntax.md).</span><span class="sxs-lookup"><span data-stu-id="9d0df-211">For a more complete description of the lookup semantics, see [PropertyPath XAML Syntax](propertypath-xaml-syntax.md).</span></span>  
  
<a name="property_element_syntax"></a>
## <a name="property-element-syntax"></a><span data-ttu-id="9d0df-212">Sintassi per gli elementi proprietà</span><span class="sxs-lookup"><span data-stu-id="9d0df-212">Property Element Syntax</span></span>  
 <span data-ttu-id="9d0df-213">*La sintassi* degli elementi proprietà è una sintassi che differisce in qualche modo dalle regole di sintassi XML di base per gli elementi.</span><span class="sxs-lookup"><span data-stu-id="9d0df-213">*Property element syntax* is a syntax that diverges somewhat from the basic XML syntax rules for elements.</span></span> <span data-ttu-id="9d0df-214">In XML, il valore di un attributo è una stringa de facto, con l'unica variazione possibile da quale formato di codifica stringa viene utilizzato.</span><span class="sxs-lookup"><span data-stu-id="9d0df-214">In XML, the value of an attribute is a de facto string, with the only possible variation being which string encoding format is being used.</span></span> <span data-ttu-id="9d0df-215">In XAML, è possibile assegnare altri elementi oggetto come valore di una proprietà.</span><span class="sxs-lookup"><span data-stu-id="9d0df-215">In XAML, you can assign other object elements to be the value of a property.</span></span> <span data-ttu-id="9d0df-216">Questa funzionalità è abilitata dalla sintassi degli elementi proprietà.</span><span class="sxs-lookup"><span data-stu-id="9d0df-216">This capability is enabled by the property element syntax.</span></span> <span data-ttu-id="9d0df-217">Anziché essere specificata come attributo all'interno del tag dell'elemento, la proprietà viene specificata utilizzando un tag di elemento di apertura in *elementTypeName*. *propertyName,* il valore della proprietà viene specificato all'interno e quindi l'elemento proprietà viene chiuso.</span><span class="sxs-lookup"><span data-stu-id="9d0df-217">Instead of the property being specified as an attribute within the element tag, the property is specified using an opening element tag in *elementTypeName*.*propertyName* form, the value of the property is specified within, and then the property element is closed.</span></span>  
  
 <span data-ttu-id="9d0df-218">In particolare, la sintassi inizia\<con una parentesi angolare sinistra ( ), seguita immediatamente dal nome del tipo della classe o della struttura in cui è contenuta la sintassi dell'elemento proprietà.</span><span class="sxs-lookup"><span data-stu-id="9d0df-218">Specifically, the syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure that the property element syntax is contained within.</span></span> <span data-ttu-id="9d0df-219">Questo è seguito immediatamente da un singolo punto (.), quindi dal nome di una proprietà, quindi da una parentesi angolare destra (>).</span><span class="sxs-lookup"><span data-stu-id="9d0df-219">This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (>).</span></span> <span data-ttu-id="9d0df-220">Come per la sintassi dell'attributo, tale proprietà deve esistere all'interno dei membri pubblici dichiarati del tipo specificato.</span><span class="sxs-lookup"><span data-stu-id="9d0df-220">As with attribute syntax, that property must exist within the declared public members of the specified type.</span></span> <span data-ttu-id="9d0df-221">Il valore da assegnare alla proprietà è contenuto all'interno dell'elemento proprietà.</span><span class="sxs-lookup"><span data-stu-id="9d0df-221">The value to be assigned to the property is contained within the property element.</span></span> <span data-ttu-id="9d0df-222">In genere, il valore viene fornito come uno o più elementi oggetto, perché la specifica di oggetti come valori è lo scenario a cui la sintassi degli elementi proprietà deve essere indirizzata.</span><span class="sxs-lookup"><span data-stu-id="9d0df-222">Typically, the value is given as one or more object elements, because specifying objects as values is the scenario that property element syntax is intended to address.</span></span> <span data-ttu-id="9d0df-223">Infine, un tag di chiusura equivalente che specifica lo stesso *elementTypeName*. È necessario fornire la combinazione *propertyName,* in modo corretto annidamento ed equilibrio con altri tag di elemento.</span><span class="sxs-lookup"><span data-stu-id="9d0df-223">Finally, an equivalent closing tag specifying the same *elementTypeName*.*propertyName* combination must be provided, in proper nesting and balance with other element tags.</span></span>  
  
 <span data-ttu-id="9d0df-224">Di seguito è riportata, ad <xref:System.Windows.FrameworkElement.ContextMenu%2A> esempio, <xref:System.Windows.Controls.Button>la sintassi degli elementi proprietà per la proprietà di un oggetto .</span><span class="sxs-lookup"><span data-stu-id="9d0df-224">For example, the following is property element syntax for the <xref:System.Windows.FrameworkElement.ContextMenu%2A> property of a <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 <span data-ttu-id="9d0df-225">Il valore all'interno di un elemento proprietà può essere specificato anche come testo interno, <xref:System.String>nei casi in cui il tipo di proprietà specificato è un tipo di valore primitivo, ad esempio , o un'enumerazione in cui viene specificato un nome.</span><span class="sxs-lookup"><span data-stu-id="9d0df-225">The value within a property element can also be given as inner text, in cases where the property type being specified is a primitive value type, such as <xref:System.String>, or an enumeration where a name is specified.</span></span> <span data-ttu-id="9d0df-226">Questi due utilizzi sono in qualche modo rari, perché ognuno di questi casi potrebbe anche usare una sintassi degli attributi più semplice.</span><span class="sxs-lookup"><span data-stu-id="9d0df-226">These two usages are somewhat uncommon, because each of these cases could also use a simpler attribute syntax.</span></span> <span data-ttu-id="9d0df-227">Uno scenario per il riempimento di un elemento proprietà con una stringa è per le proprietà che non sono la proprietà di contenuto XAML ma vengono comunque utilizzate per la rappresentazione del testo dell'interfaccia utente e particolari elementi di spazio vuoto, ad esempio gli avanzamenti riga, devono essere visualizzati nel testo dell'interfaccia utente.</span><span class="sxs-lookup"><span data-stu-id="9d0df-227">One scenario for filling a property element with a string is for properties that are not the XAML content property but still are used for representation of UI text, and particular white-space elements such as linefeeds are required to appear in that UI text.</span></span> <span data-ttu-id="9d0df-228">La sintassi degli attributi non può mantenere gli avanzamenti riga, ma la sintassi degli elementi proprietà può, purché sia attiva una conservazione significativa degli spazi vuoti (per informazioni dettagliate, vedere [Elaborazione degli spazi vuoti in XAML).](../../../desktop-wpf/xaml-services/white-space-processing.md)</span><span class="sxs-lookup"><span data-stu-id="9d0df-228">Attribute syntax cannot preserve linefeeds, but property element syntax can, so long as significant white-space preservation is active (for details, see [White space processing in XAML](../../../desktop-wpf/xaml-services/white-space-processing.md)).</span></span> <span data-ttu-id="9d0df-229">Un altro scenario è in modo che [x:Uid direttiva](../../../desktop-wpf/xaml-services/xuid-directive.md) può essere applicata all'elemento proprietà e quindi contrassegnare il valore all'interno come un valore che deve essere localizzato nel BAML di output WPFWPF o da altre tecniche.</span><span class="sxs-lookup"><span data-stu-id="9d0df-229">Another scenario is so that [x:Uid Directive](../../../desktop-wpf/xaml-services/xuid-directive.md) can be applied to the property element and thus mark the value within as a value that should be localized in the WPF output BAML or by other techniques.</span></span>  
  
 <span data-ttu-id="9d0df-230">Un elemento proprietà non è rappresentato nell'albero logico WPFWPF.</span><span class="sxs-lookup"><span data-stu-id="9d0df-230">A property element is not represented in the WPF logical tree.</span></span> <span data-ttu-id="9d0df-231">Un elemento proprietà è solo una sintassi specifica per l'impostazione di una proprietà e non è un elemento che dispone di un'istanza o di un oggetto che lo esegue.</span><span class="sxs-lookup"><span data-stu-id="9d0df-231">A property element is just a particular syntax for setting a property, and is not an element that has an instance or object backing it.</span></span> <span data-ttu-id="9d0df-232">Per informazioni dettagliate sul concetto di albero logico, vedere [Strutture ad albero in WPF.](trees-in-wpf.md)</span><span class="sxs-lookup"><span data-stu-id="9d0df-232">(For details on the logical tree concept, see [Trees in WPF](trees-in-wpf.md).)</span></span>  
  
 <span data-ttu-id="9d0df-233">Per le proprietà in cui sono supportate sia la sintassi degli attributi che quelli degli elementi proprietà, le due sintassi hanno in genere lo stesso risultato, anche se le sottigliezze, ad esempio la gestione degli spazi vuoti, possono variare leggermente tra le sintassi.</span><span class="sxs-lookup"><span data-stu-id="9d0df-233">For properties where both attribute and property element syntax are supported, the two syntaxes generally have the same result, although subtleties such as white-space handling can vary slightly between syntaxes.</span></span>  
  
<a name="collection_syntax"></a>
## <a name="collection-syntax"></a><span data-ttu-id="9d0df-234">Sintassi per raccolte</span><span class="sxs-lookup"><span data-stu-id="9d0df-234">Collection Syntax</span></span>  
 <span data-ttu-id="9d0df-235">La specifica XAML richiede implementazioni del processore XAML per identificare le proprietà in cui il tipo di valore è una raccolta.</span><span class="sxs-lookup"><span data-stu-id="9d0df-235">The XAML specification requires XAML processor implementations to identify properties where the value type is a collection.</span></span> <span data-ttu-id="9d0df-236">L'implementazione generale del processore XAML in .NET è basata sul codice gestito e CLR e identifica i tipi di raccolta tramite uno degli elementi seguenti:</span><span class="sxs-lookup"><span data-stu-id="9d0df-236">The general XAML processor implementation in .NET is based on managed code and the CLR, and it identifies collection types through one of the following:</span></span>  
  
- <span data-ttu-id="9d0df-237">Tipo <xref:System.Collections.IList>implementa .</span><span class="sxs-lookup"><span data-stu-id="9d0df-237">Type implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="9d0df-238">Tipo <xref:System.Collections.IDictionary>implementa .</span><span class="sxs-lookup"><span data-stu-id="9d0df-238">Type implements <xref:System.Collections.IDictionary>.</span></span>  
  
- <span data-ttu-id="9d0df-239">Il tipo <xref:System.Array> deriva da (per ulteriori informazioni sulle matrici in XAML, vedere [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span><span class="sxs-lookup"><span data-stu-id="9d0df-239">Type derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span></span>  
  
 <span data-ttu-id="9d0df-240">Se il tipo di una proprietà è una raccolta, non è necessario specificare il tipo di raccolta dedotta nel markup come elemento oggetto.</span><span class="sxs-lookup"><span data-stu-id="9d0df-240">If the type of a property is a collection, then the inferred collection type does not need to be specified in the markup as an object element.</span></span> <span data-ttu-id="9d0df-241">Al contrario, gli elementi che devono diventare gli elementi nella raccolta vengono specificati come uno o più elementi figlio dell'elemento proprietà.</span><span class="sxs-lookup"><span data-stu-id="9d0df-241">Instead, the elements that are intended to become the items in the collection are specified as one or more child elements of the property element.</span></span> <span data-ttu-id="9d0df-242">Ogni elemento di questo tipo viene valutato a un `Add` oggetto durante il caricamento e aggiunto alla raccolta chiamando il metodo della raccolta implicita.</span><span class="sxs-lookup"><span data-stu-id="9d0df-242">Each such item is evaluated to an object during loading and added to the collection by calling the `Add` method of the implied collection.</span></span> <span data-ttu-id="9d0df-243">Ad esempio, <xref:System.Windows.Style.Triggers%2A> la <xref:System.Windows.Style> proprietà di <xref:System.Windows.TriggerCollection>accetta il <xref:System.Collections.IList>tipo di insieme specializzato , che implementa .</span><span class="sxs-lookup"><span data-stu-id="9d0df-243">For example, the <xref:System.Windows.Style.Triggers%2A> property of <xref:System.Windows.Style> takes the specialized collection type <xref:System.Windows.TriggerCollection>, which implements <xref:System.Collections.IList>.</span></span> <span data-ttu-id="9d0df-244">Non è necessario creare <xref:System.Windows.TriggerCollection> un'istanza di un elemento oggetto nel markup.</span><span class="sxs-lookup"><span data-stu-id="9d0df-244">It is not necessary to instantiate a <xref:System.Windows.TriggerCollection> object element in the markup.</span></span> <span data-ttu-id="9d0df-245">È invece necessario <xref:System.Windows.Trigger> specificare uno `Style.Triggers` o più <xref:System.Windows.Trigger> elementi come elementi all'interno dell'elemento proprietà, dove (o <xref:System.Windows.TriggerCollection>una classe derivata) è il tipo previsto come tipo di elemento per l'elemento fortemente tipizzato e implicito.</span><span class="sxs-lookup"><span data-stu-id="9d0df-245">Instead, you specify one or more <xref:System.Windows.Trigger> items as elements within the `Style.Triggers` property element, where <xref:System.Windows.Trigger> (or a derived class) is the type expected as the item type for the strongly typed and implicit <xref:System.Windows.TriggerCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 <span data-ttu-id="9d0df-246">Una proprietà può essere sia un tipo di raccolta che la proprietà di contenuto XAML per il tipo e i tipi derivati, come descritto nella sezione successiva di questo argomento.</span><span class="sxs-lookup"><span data-stu-id="9d0df-246">A property may be both a collection type and the XAML content property for that type and derived types, which is discussed in the next section of this topic.</span></span>  
  
 <span data-ttu-id="9d0df-247">Un elemento di raccolta implicito crea un membro nella rappresentazione dell'albero logico, anche se non viene visualizzato nel markup come elemento.</span><span class="sxs-lookup"><span data-stu-id="9d0df-247">An implicit collection element creates a member in the logical tree representation, even though it does not appear in the markup as an element.</span></span> <span data-ttu-id="9d0df-248">In genere il costruttore del tipo padre esegue la creazione di istanze per la raccolta che è una delle relative proprietà e la raccolta inizialmente vuota diventa parte della struttura ad albero di oggetti.</span><span class="sxs-lookup"><span data-stu-id="9d0df-248">Usually the constructor of the parent type performs the instantiation for the collection that is one of its properties, and the initially empty collection becomes part of the object tree.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9d0df-249">Le interfacce di elenco<xref:System.Collections.Generic.IList%601> <xref:System.Collections.Generic.IDictionary%602>e dizionario generiche ( e ) non sono supportate per il rilevamento delle raccolte.</span><span class="sxs-lookup"><span data-stu-id="9d0df-249">The generic list and dictionary interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection.</span></span> <span data-ttu-id="9d0df-250">Tuttavia, è <xref:System.Collections.Generic.List%601> possibile usare la classe come <xref:System.Collections.IList> classe <xref:System.Collections.Generic.Dictionary%602> base, perché implementa direttamente <xref:System.Collections.IDictionary> o come classe base, perché implementa direttamente.</span><span class="sxs-lookup"><span data-stu-id="9d0df-250">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="9d0df-251">Nelle pagine di riferimento .NET per i tipi di raccolta, questa sintassi con l'omissione intenzionale dell'elemento oggetto per una raccolta è occasionalmente indicata nelle sezioni della sintassi XAML come Sintassi di raccolta implicita.</span><span class="sxs-lookup"><span data-stu-id="9d0df-251">In the .NET Reference pages for collection types, this syntax with the deliberate omission of the object element for a collection is occasionally noted in the XAML syntax sections as Implicit Collection Syntax.</span></span>  
  
 <span data-ttu-id="9d0df-252">Ad eccezione dell'elemento radice, ogni elemento oggetto in un file XAML annidato come elemento figlio di un altro elemento è in realtà un elemento che è uno o entrambi i casi seguenti: un membro di una proprietà di raccolta implicita del relativo elemento padre o un elemento che specifica il valore della proprietà di contenuto XAML per l'elemento padre (le proprietà di contenuto XAML verranno illustrate in una sezione successiva).</span><span class="sxs-lookup"><span data-stu-id="9d0df-252">With the exception of the root element, every object element in a XAML file that is nested as a child element of another element is really an element that is one or both of the following cases: a member of an implicit collection property of its parent element, or an element that specifies the value of the XAML content property for the parent element (XAML content properties will be discussed in an upcoming section).</span></span> <span data-ttu-id="9d0df-253">In altre parole, la relazione degli elementi padre e degli elementi figlio in una pagina di markup è in realtà un singolo oggetto alla radice e ogni elemento oggetto sotto la radice è una singola istanza che fornisce un valore di proprietà dell'elemento padre o uno degli elementi all'interno di una raccolta che è anche un valore della proprietà di tipo raccolta dell'elemento padre.</span><span class="sxs-lookup"><span data-stu-id="9d0df-253">In other words, the relationship of parent elements and child elements in a markup page is really a single object at the root, and every object element beneath the root is either a single instance that provides a property value of the parent, or one of the items within a collection that is also a collection-type property value of the parent.</span></span> <span data-ttu-id="9d0df-254">Questo concetto a radice singola è comune con XML ed è spesso rafforzato <xref:System.Windows.Markup.XamlReader.Load%2A>nel comportamento delle API che caricano XAML, ad esempio .</span><span class="sxs-lookup"><span data-stu-id="9d0df-254">This single-root concept is common with XML, and is frequently reinforced in the behavior of APIs that load XAML such as <xref:System.Windows.Markup.XamlReader.Load%2A>.</span></span>  
  
 <span data-ttu-id="9d0df-255">L'esempio seguente è una sintassi con<xref:System.Windows.Media.GradientStopCollection>l'elemento oggetto per un insieme ( ) specificato in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="9d0df-255">The following example is a syntax with the object element for a collection (<xref:System.Windows.Media.GradientStopCollection>) specified explicitly.</span></span>  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 <span data-ttu-id="9d0df-256">Si noti che non è sempre possibile dichiarare in modo esplicito la raccolta.</span><span class="sxs-lookup"><span data-stu-id="9d0df-256">Note that it is not always possible to explicitly declare the collection.</span></span> <span data-ttu-id="9d0df-257">Ad esempio, il <xref:System.Windows.TriggerCollection> tentativo di dichiarare <xref:System.Windows.Style.Triggers%2A> in modo esplicito nell'esempio illustrato in precedenza avrebbe esito negativo.</span><span class="sxs-lookup"><span data-stu-id="9d0df-257">For instance, attempting to declare <xref:System.Windows.TriggerCollection> explicitly in the previously shown <xref:System.Windows.Style.Triggers%2A> example would fail.</span></span> <span data-ttu-id="9d0df-258">La dichiarazione esplicita dell'insieme richiede che la <xref:System.Windows.TriggerCollection> classe di raccolta supporti un costruttore senza parametri e non disponga di un costruttore senza parametri.</span><span class="sxs-lookup"><span data-stu-id="9d0df-258">Explicitly declaring the collection requires that the collection class must support a parameterless constructor, and <xref:System.Windows.TriggerCollection> does not have a parameterless constructor.</span></span>  
  
<a name="xaml_content_properties"></a>
## <a name="xaml-content-properties"></a><span data-ttu-id="9d0df-259">Proprietà di contenuto XAML</span><span class="sxs-lookup"><span data-stu-id="9d0df-259">XAML Content Properties</span></span>  
 <span data-ttu-id="9d0df-260">La sintassi del contenuto XAML è una <xref:System.Windows.Markup.ContentPropertyAttribute> sintassi abilitata solo nelle classi che specificano la classe come parte della relativa dichiarazione di classe.</span><span class="sxs-lookup"><span data-stu-id="9d0df-260">XAML content syntax is a syntax that is only enabled on classes that specify the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of their class declaration.</span></span> <span data-ttu-id="9d0df-261">Il <xref:System.Windows.Markup.ContentPropertyAttribute> riferimento al nome della proprietà che è la proprietà di contenuto per quel tipo di elemento (incluse le classi derivate).</span><span class="sxs-lookup"><span data-stu-id="9d0df-261">The <xref:System.Windows.Markup.ContentPropertyAttribute> references the property name that is the content property for that type of element (including derived classes).</span></span> <span data-ttu-id="9d0df-262">Quando vengono elaborati da un processore XAML, tutti gli elementi figlio o il testo interno che si trovano tra i tag di apertura e chiusura dell'elemento oggetto verranno assegnati come valore della proprietà di contenuto XAML per tale oggetto.</span><span class="sxs-lookup"><span data-stu-id="9d0df-262">When processed by a XAML processor, any child elements or inner text that are found between the opening and closing tags of the object element will be assigned to be the value of the XAML content property for that object.</span></span> <span data-ttu-id="9d0df-263">È possibile specificare elementi di proprietà espliciti per la proprietà di contenuto, ma questo utilizzo non viene in genere illustrato nelle sezioni della sintassi XAML nel riferimento .NET.</span><span class="sxs-lookup"><span data-stu-id="9d0df-263">You are permitted to specify explicit property elements for the content property, but this usage is not generally shown in the XAML syntax sections in the .NET reference.</span></span> <span data-ttu-id="9d0df-264">La tecnica explicit/verbose ha un valore occasionale per la chiarezza del markup o per una questione di stile di markup, ma in genere lo scopo di una proprietà di contenuto è semplificare il markup in modo che gli elementi che sono intuitivamente correlati come padre-figlio possono essere annidati direttamente.</span><span class="sxs-lookup"><span data-stu-id="9d0df-264">The explicit/verbose technique has occasional value for markup clarity or as a matter of markup style, but usually the intent of a content property is to streamline the markup so that elements that are intuitively related as parent-child can be nested directly.</span></span> <span data-ttu-id="9d0df-265">I tag degli elementi proprietà per altre proprietà in un elemento non vengono assegnati come "contenuto" in base a una definizione di linguaggio XAML rigorosa; vengono elaborati in precedenza nell'ordine di elaborazione del parser XAML e non sono considerati "contenuto".</span><span class="sxs-lookup"><span data-stu-id="9d0df-265">Property element tags for other properties on an element are not assigned as "content" per a strict XAML language definition; they are processed previously in the XAML parser's processing order and are not considered to be "content".</span></span>  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a><span data-ttu-id="9d0df-266">XAML Content Property Values Must Be Contiguous</span><span class="sxs-lookup"><span data-stu-id="9d0df-266">XAML Content Property Values Must Be Contiguous</span></span>  
 <span data-ttu-id="9d0df-267">Il valore di una proprietà di contenuto XAML deve essere specificato interamente prima o interamente dopo qualsiasi altro elemento proprietà in tale elemento oggetto.</span><span class="sxs-lookup"><span data-stu-id="9d0df-267">The value of a XAML content property must be given either entirely before or entirely after any other property elements on that object element.</span></span> <span data-ttu-id="9d0df-268">Questo è vero se il valore di una proprietà di contenuto XAML è specificato come stringa o come uno o più oggetti.</span><span class="sxs-lookup"><span data-stu-id="9d0df-268">This is true whether the value of a XAML content property is specified as a string, or as one or more objects.</span></span> <span data-ttu-id="9d0df-269">Ad esempio, il markup seguente non analizza:For example, the following markup does not parse:</span><span class="sxs-lookup"><span data-stu-id="9d0df-269">For example, the following markup does not parse:</span></span>  
  
```xaml  
<Button>I am a
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 <span data-ttu-id="9d0df-270">Ciò non è illegale essenzialmente perché se questa sintassi fosse resa esplicita utilizzando la sintassi degli elementi proprietà per la proprietà content, la proprietà content verrebbe impostata due volte:</span><span class="sxs-lookup"><span data-stu-id="9d0df-270">This is illegal essentially because if this syntax were made explicit by using property element syntax for the content property, then the content property would be set twice:</span></span>  
  
```xaml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 <span data-ttu-id="9d0df-271">Un esempio simile non valido è se la proprietà content è una raccolta e gli elementi figlio sono intervallati da elementi proprietà:A similarly illegal example is if the content property is a collection, and child elements are interspersed with property elements:</span><span class="sxs-lookup"><span data-stu-id="9d0df-271">A similarly illegal example is if the content property is a collection, and child elements are interspersed with property elements:</span></span>  
  
```xaml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>
## <a name="content-properties-and-collection-syntax-combined"></a><span data-ttu-id="9d0df-272">Combinazione di proprietà di contenuto e sintassi per raccolte</span><span class="sxs-lookup"><span data-stu-id="9d0df-272">Content Properties and Collection Syntax Combined</span></span>  
 <span data-ttu-id="9d0df-273">Per accettare più di un singolo elemento oggetto come contenuto, il tipo della proprietà di contenuto deve essere in modo specifico un tipo di raccolta.</span><span class="sxs-lookup"><span data-stu-id="9d0df-273">In order to accept more than a single object element as content, the type of the content property must specifically be a collection type.</span></span> <span data-ttu-id="9d0df-274">Analogamente alla sintassi degli elementi proprietà per i tipi di raccolta, un processore XAML deve identificare i tipi che sono tipi di raccolta.</span><span class="sxs-lookup"><span data-stu-id="9d0df-274">Similar to property element syntax for collection types, a XAML processor must identify types that are collection types.</span></span> <span data-ttu-id="9d0df-275">Se un elemento ha una proprietà di contenuto XAML e il tipo della proprietà di contenuto XAML è una raccolta, non è necessario specificare il tipo di raccolta implicita nel markup come elemento oggetto e la proprietà di contenuto XAML non deve essere specificata come elemento proprietà.</span><span class="sxs-lookup"><span data-stu-id="9d0df-275">If an element has a XAML content property and the type of the XAML content property is a collection, then the implied collection type does not need to be specified in the markup as an object element and the XAML content property does not need to be specified as a property element.</span></span> <span data-ttu-id="9d0df-276">Pertanto, il modello di contenuto apparente nel markup può ora avere più di un elemento figlio assegnato come contenuto.</span><span class="sxs-lookup"><span data-stu-id="9d0df-276">Therefore the apparent content model in the markup can now have more than one child element assigned as the content.</span></span> <span data-ttu-id="9d0df-277">Di seguito è riportata la sintassi del contenuto per una <xref:System.Windows.Controls.Panel> classe derivata.</span><span class="sxs-lookup"><span data-stu-id="9d0df-277">The following is content syntax for a <xref:System.Windows.Controls.Panel> derived class.</span></span> <span data-ttu-id="9d0df-278">Tutte <xref:System.Windows.Controls.Panel> le classi derivate stabiliscono che la proprietà di contenuto XAML è <xref:System.Windows.Controls.Panel.Children%2A>, che richiede un valore di tipo <xref:System.Windows.Controls.UIElementCollection>.</span><span class="sxs-lookup"><span data-stu-id="9d0df-278">All <xref:System.Windows.Controls.Panel> derived classes establish the XAML content property to be <xref:System.Windows.Controls.Panel.Children%2A>, which requires a value of type <xref:System.Windows.Controls.UIElementCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 <span data-ttu-id="9d0df-279">Si noti che <xref:System.Windows.Controls.Panel.Children%2A> né l'elemento <xref:System.Windows.Controls.UIElementCollection> proprietà per né l'elemento per è obbligatorio nel markup.</span><span class="sxs-lookup"><span data-stu-id="9d0df-279">Note that neither the property element for <xref:System.Windows.Controls.Panel.Children%2A> nor the element for the <xref:System.Windows.Controls.UIElementCollection> is required in the markup.</span></span> <span data-ttu-id="9d0df-280">Si tratta di una funzionalità di progettazione di XAML [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] in modo che gli elementi concontenuti in modo ricorsivo che definiscono un sono rappresentati in modo più intuitivo come una struttura ad albero di elementi annidati con relazioni immediate degli elementi padre-figlio, senza intervenire i tag degli elementi proprietà o gli oggetti raccolta.</span><span class="sxs-lookup"><span data-stu-id="9d0df-280">This is a design feature of XAML so that recursively contained elements that define a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] are more intuitively represented as a tree of nested elements with immediate parent-child element relationships, without intervening property element tags or collection objects.</span></span> <span data-ttu-id="9d0df-281">Infatti, <xref:System.Windows.Controls.UIElementCollection> non può essere specificato in modo esplicito nel markup come elemento oggetto, in base alla progettazione.</span><span class="sxs-lookup"><span data-stu-id="9d0df-281">In fact, <xref:System.Windows.Controls.UIElementCollection> cannot be specified explicitly in markup as an object element, by design.</span></span> <span data-ttu-id="9d0df-282">Poiché l'unico utilizzo previsto <xref:System.Windows.Controls.UIElementCollection> è come una raccolta implicita, non espone un costruttore pubblico senza parametri e pertanto non è possibile creare un'istanza come elemento oggetto.</span><span class="sxs-lookup"><span data-stu-id="9d0df-282">Because its only intended use is as an implicit collection, <xref:System.Windows.Controls.UIElementCollection> does not expose a public parameterless constructor and thus cannot be instantiated as an object element.</span></span>  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a><span data-ttu-id="9d0df-283">Combinazione di elementi di proprietà ed elementi oggetto in un oggetto con una proprietà di contenutoMixing Property Elements and Object Elements in an Object with a Content Property</span><span class="sxs-lookup"><span data-stu-id="9d0df-283">Mixing Property Elements and Object Elements in an Object with a Content Property</span></span>  
 <span data-ttu-id="9d0df-284">La specifica XAML dichiara che un processore XAML può imporre che gli elementi oggetto utilizzati per riempire la proprietà di contenuto XAML all'interno di un elemento oggetto devono essere contigui e non devono essere combinati.</span><span class="sxs-lookup"><span data-stu-id="9d0df-284">The XAML specification declares that a XAML processor can enforce that object elements that are used to fill the XAML content property within an object element must be contiguous, and must not be mixed.</span></span> <span data-ttu-id="9d0df-285">Questa restrizione sulla combinazione di elementi [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] di proprietà e contenuto viene applicata dai processori XAML.</span><span class="sxs-lookup"><span data-stu-id="9d0df-285">This restriction against mixing property elements and content is enforced by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processors.</span></span>  
  
 <span data-ttu-id="9d0df-286">È possibile avere un elemento oggetto figlio come primo markup immediato all'interno di un elemento oggetto.</span><span class="sxs-lookup"><span data-stu-id="9d0df-286">You can have a child object element as the first immediate markup within an object element.</span></span> <span data-ttu-id="9d0df-287">È quindi possibile introdurre elementi di proprietà.</span><span class="sxs-lookup"><span data-stu-id="9d0df-287">Then you can introduce property elements.</span></span> <span data-ttu-id="9d0df-288">In alternativa, è possibile specificare uno o più elementi proprietà, quindi il contenuto e altri elementi di proprietà.</span><span class="sxs-lookup"><span data-stu-id="9d0df-288">Or, you can specify one or more property elements, then content, then more property elements.</span></span> <span data-ttu-id="9d0df-289">Tuttavia, una volta che un elemento proprietà segue il contenuto, non è possibile introdurre altro contenuto, è possibile aggiungere solo elementi proprietà.</span><span class="sxs-lookup"><span data-stu-id="9d0df-289">But once a property element follows content, you cannot introduce any further content, you can only add property elements.</span></span>  
  
 <span data-ttu-id="9d0df-290">Questo requisito di ordine dell'elemento contenuto/proprietà non si applica al testo interno utilizzato come contenuto.</span><span class="sxs-lookup"><span data-stu-id="9d0df-290">This content / property element order requirement does not apply to inner text used as content.</span></span> <span data-ttu-id="9d0df-291">Tuttavia, è ancora un buon stile di markup per mantenere il testo interno contiguo, perché uno spazio vuoto significativo sarà difficile da rilevare visivamente nel markup se gli elementi della proprietà sono intervallati da testo interno.</span><span class="sxs-lookup"><span data-stu-id="9d0df-291">However, it is still a good markup style to keep inner text contiguous, because significant white space will be difficult to detect visually in the markup if property elements are interspersed with inner text.</span></span>  
  
<a name="xaml_namespaces"></a>
## <a name="xaml-namespaces"></a><span data-ttu-id="9d0df-292">Spazi dei nomi XAML</span><span class="sxs-lookup"><span data-stu-id="9d0df-292">XAML Namespaces</span></span>  
 <span data-ttu-id="9d0df-293">Nessuno degli esempi di sintassi precedenti ha specificato uno spazio dei nomi XAML diverso dallo spazio dei nomi XAML predefinito.</span><span class="sxs-lookup"><span data-stu-id="9d0df-293">None of the preceding syntax examples specified a XAML namespace other than the default XAML namespace.</span></span> <span data-ttu-id="9d0df-294">Nelle [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applicazioni tipiche, lo spazio dei [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] nomi XAML predefinito viene specificato come spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="9d0df-294">In typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, the default XAML namespace is specified to be the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] namespace.</span></span> <span data-ttu-id="9d0df-295">È possibile specificare spazi dei nomi XAML diversi dallo spazio dei nomi XAML predefinito e utilizzare comunque una sintassi simile.</span><span class="sxs-lookup"><span data-stu-id="9d0df-295">You can specify XAML namespaces other than the default XAML namespace and still use similar syntax.</span></span> <span data-ttu-id="9d0df-296">Tuttavia, in qualsiasi punto in cui viene denominata una classe che non è accessibile all'interno dello spazio dei nomi XAML predefinito, tale nome di classe deve essere preceduto dal prefisso dello spazio dei nomi XAML come mappato allo spazio dei nomi CLR corrispondente.</span><span class="sxs-lookup"><span data-stu-id="9d0df-296">But then, anywhere where a class is named that is not accessible within the default XAML namespace, that class name must be preceded with the prefix of the XAML namespace as mapped to the corresponding CLR namespace.</span></span> <span data-ttu-id="9d0df-297">Ad esempio, `<custom:Example/>` è la sintassi degli `Example` elementi oggetto per creare un'istanza della classe, in cui lo spazio dei `custom` nomi CLR contenente tale classe (ed eventualmente le informazioni sull'assembly esterno che contiene i tipi di supporto) è stato precedentemente mappato al prefisso.</span><span class="sxs-lookup"><span data-stu-id="9d0df-297">For example, `<custom:Example/>` is object element syntax to instantiate an instance of the `Example` class, where the CLR namespace containing that class (and possibly the external assembly information that contains backing types) was previously mapped to the `custom` prefix.</span></span>  
  
 <span data-ttu-id="9d0df-298">Per altre informazioni sugli spazi dei nomi XAML, vedere [Spazi dei nomi XAML e Mapping degli spazi dei nomi per XAML WPF.](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)</span><span class="sxs-lookup"><span data-stu-id="9d0df-298">For more information about XAML namespaces, see [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="markup_extensions"></a>
## <a name="markup-extensions"></a><span data-ttu-id="9d0df-299">Estensioni di markup</span><span class="sxs-lookup"><span data-stu-id="9d0df-299">Markup Extensions</span></span>  
 <span data-ttu-id="9d0df-300">XAML definisce un'entità di programmazione dell'estensione di markup che consente un escape dalla normale gestione del processore XAML di valori di attributo stringa o elementi oggetto e rinvia l'elaborazione a una classe di backup.</span><span class="sxs-lookup"><span data-stu-id="9d0df-300">XAML defines a markup extension programming entity that enables an escape from the normal XAML processor handling of string attribute values or object elements, and defers the processing to a backing class.</span></span> <span data-ttu-id="9d0df-301">Il carattere che identifica un'estensione di markup per un processore XAML quando si usa la sintassi degli attributi è la parentesi graffa di apertura, seguita da qualsiasi carattere diverso da una parentesi graffa di chiusura (').</span><span class="sxs-lookup"><span data-stu-id="9d0df-301">The character that identifies a markup extension to a XAML processor when using attribute syntax is the opening curly brace ({), followed by any character other than a closing curly brace (}).</span></span> <span data-ttu-id="9d0df-302">La prima stringa che segue la parentesi graffa di apertura deve fare riferimento alla classe che fornisce il particolare comportamento di estensione, in cui il riferimento può omettere la sottostringa "Extension" se tale sottostringa fa parte del nome della classe true.</span><span class="sxs-lookup"><span data-stu-id="9d0df-302">The first string following the opening curly brace must reference the class that provides the particular extension behavior, where the reference may omit the substring "Extension" if that substring is part of the true class name.</span></span> <span data-ttu-id="9d0df-303">Successivamente, può essere visualizzato un singolo spazio e quindi ogni carattere successivo viene utilizzato come input dall'implementazione dell'estensione, fino a quando non viene rilevata la parentesi graffa di chiusura.</span><span class="sxs-lookup"><span data-stu-id="9d0df-303">Thereafter, a single space may appear, and then each succeeding character is used as input by the extension implementation, up until the closing curly brace is encountered.</span></span>  
  
 <span data-ttu-id="9d0df-304">L'implementazione XAML <xref:System.Windows.Markup.MarkupExtension> di .NET usa la classe astratta [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] come base per tutte le estensioni di markup supportate da oltre ad altri framework o tecnologie.</span><span class="sxs-lookup"><span data-stu-id="9d0df-304">The .NET XAML implementation uses the <xref:System.Windows.Markup.MarkupExtension> abstract class as the basis for all of the markup extensions supported by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] as well as other frameworks or technologies.</span></span> <span data-ttu-id="9d0df-305">Le estensioni [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] di markup che implementa in modo specifico sono spesso destinate a fornire un mezzo per fare riferimento ad altri oggetti esistenti o per creare riferimenti posticipati a oggetti che verranno valutati in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="9d0df-305">The markup extensions that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifically implements are often intended to provide a means to reference other existing objects, or to make deferred references to objects that will be evaluated at run time.</span></span> <span data-ttu-id="9d0df-306">Ad esempio, un'associazione dati WPF semplice `{Binding}` viene eseguita specificando l'estensione di markup al posto del valore che una determinata proprietà normalmente richiederebbe.</span><span class="sxs-lookup"><span data-stu-id="9d0df-306">For example, a simple WPF data binding is accomplished by specifying the `{Binding}` markup extension in place of the value that a particular property would ordinarily take.</span></span> <span data-ttu-id="9d0df-307">Molte delle estensioni di markup WPFWPF consentono una sintassi degli attributi per le proprietà in cui una sintassi degli attributi non sarebbe altrimenti possibile.</span><span class="sxs-lookup"><span data-stu-id="9d0df-307">Many of the WPF markup extensions enable an attribute syntax for properties where an attribute syntax would not otherwise be possible.</span></span> <span data-ttu-id="9d0df-308">Ad esempio, <xref:System.Windows.Style> un oggetto è un tipo relativamente complesso che contiene una serie annidata di oggetti e proprietà.</span><span class="sxs-lookup"><span data-stu-id="9d0df-308">For example, a <xref:System.Windows.Style> object is a relatively complex type that contains a nested series of objects and properties.</span></span> <span data-ttu-id="9d0df-309">Gli stili in WPFWPF vengono <xref:System.Windows.ResourceDictionary>in genere definiti come una risorsa in un oggetto , quindi su cui viene fatto riferimento tramite una delle due estensioni di markup WPFWPF che richiedono una risorsa.</span><span class="sxs-lookup"><span data-stu-id="9d0df-309">Styles in WPF are typically defined as a resource in a <xref:System.Windows.ResourceDictionary>, and then referenced through one of the two WPF markup extensions that request a resource.</span></span> <span data-ttu-id="9d0df-310">L'estensione di markup rinvia la valutazione del valore della proprietà <xref:System.Windows.FrameworkElement.Style%2A> a una <xref:System.Windows.Style>ricerca di risorse e consente di fornire il valore della proprietà, prendendo tipo , nella sintassi degli attributi come nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="9d0df-310">The markup extension defers the evaluation of the property value to a resource lookup and enables providing the value of the <xref:System.Windows.FrameworkElement.Style%2A> property, taking type <xref:System.Windows.Style>, in attribute syntax as in the following example:</span></span>  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 <span data-ttu-id="9d0df-311">In `StaticResource` questo <xref:System.Windows.StaticResourceExtension> caso, identifica la classe che fornisce l'implementazione dell'estensione di markup.</span><span class="sxs-lookup"><span data-stu-id="9d0df-311">Here, `StaticResource` identifies the <xref:System.Windows.StaticResourceExtension> class providing the markup extension implementation.</span></span> <span data-ttu-id="9d0df-312">La stringa `MyStyle` successiva viene utilizzata come input <xref:System.Windows.StaticResourceExtension> per il costruttore non predefinito, in <xref:System.Windows.ResourceKey>cui il parametro derivato dalla stringa di estensione dichiara l'oggetto richiesto.</span><span class="sxs-lookup"><span data-stu-id="9d0df-312">The next string `MyStyle` is used as the input for the non-default <xref:System.Windows.StaticResourceExtension> constructor, where the parameter as taken from the extension string declares the requested <xref:System.Windows.ResourceKey>.</span></span> <span data-ttu-id="9d0df-313">`MyStyle`è previsto che sia il valore <xref:System.Windows.Style> [x:Key](../../../desktop-wpf/xaml-services/xkey-directive.md) di un oggetto definito come risorsa.</span><span class="sxs-lookup"><span data-stu-id="9d0df-313">`MyStyle` is expected to be the [x:Key](../../../desktop-wpf/xaml-services/xkey-directive.md) value of a <xref:System.Windows.Style> defined as a resource.</span></span> <span data-ttu-id="9d0df-314">L'utilizzo [dell'estensione di markup StaticResource](staticresource-markup-extension.md) <xref:System.Windows.Style> richiede che la risorsa venga utilizzata per fornire il valore della proprietà tramite la logica di ricerca di risorse statiche in fase di caricamento.</span><span class="sxs-lookup"><span data-stu-id="9d0df-314">The [StaticResource Markup Extension](staticresource-markup-extension.md) usage requests that the resource be used to provide the <xref:System.Windows.Style> property value through static resource lookup logic at load time.</span></span>  
  
 <span data-ttu-id="9d0df-315">Per altre informazioni sulle estensioni di markup, vedere [Estensioni di markup e WPF XAML](markup-extensions-and-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="9d0df-315">For more information about markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span> <span data-ttu-id="9d0df-316">Per un riferimento alle estensioni di markup e ad altre funzionalità di programmazione XAML abilitate nell'implementazione XAML generale di .NET, vedere [Spazio dei nomi XAML (x:) Caratteristiche del linguaggio](../../../desktop-wpf/xaml-services/namespace-language-features.md).</span><span class="sxs-lookup"><span data-stu-id="9d0df-316">For a reference of markup extensions and other XAML programming features enabled in the general .NET XAML implementation, see [XAML Namespace (x:) Language Features](../../../desktop-wpf/xaml-services/namespace-language-features.md).</span></span> <span data-ttu-id="9d0df-317">Per le estensioni di markup specifiche di WPF, consultate [Estensioni XAML WPF.](wpf-xaml-extensions.md)</span><span class="sxs-lookup"><span data-stu-id="9d0df-317">For WPF-specific markup extensions, see [WPF XAML Extensions](wpf-xaml-extensions.md).</span></span>  
  
<a name="attached_properties"></a>
## <a name="attached-properties"></a><span data-ttu-id="9d0df-318">Proprietà associate</span><span class="sxs-lookup"><span data-stu-id="9d0df-318">Attached Properties</span></span>  
 <span data-ttu-id="9d0df-319">Le proprietà associate sono un concetto di programmazione introdotto in XAML in cui le proprietà possono essere di proprietà e definite da un particolare tipo, ma impostate come attributi o elementi proprietà in qualsiasi elemento.</span><span class="sxs-lookup"><span data-stu-id="9d0df-319">Attached properties are a programming concept introduced in XAML whereby properties can be owned and defined by a particular type, but set as attributes or property elements on any element.</span></span> <span data-ttu-id="9d0df-320">Lo scenario principale a cui sono destinate le proprietà associate è consentire agli elementi figlio in una struttura di markup di riportare le informazioni a un elemento padre senza richiedere un modello a oggetti ampiamente condiviso tra tutti gli elementi.</span><span class="sxs-lookup"><span data-stu-id="9d0df-320">The primary scenario that attached properties are intended for is to enable child elements in a markup structure to report information to a parent element without requiring an extensively shared object model across all elements.</span></span> <span data-ttu-id="9d0df-321">Al contrario, le proprietà associate possono essere utilizzate dagli elementi padre per riportare le informazioni agli elementi figlio.</span><span class="sxs-lookup"><span data-stu-id="9d0df-321">Conversely, attached properties can be used by parent elements to report information to child elements.</span></span> <span data-ttu-id="9d0df-322">Per ulteriori informazioni sullo scopo delle proprietà associate e su come creare proprietà associate personalizzate, vedere [Cenni preliminari](attached-properties-overview.md)sulle proprietà associate .</span><span class="sxs-lookup"><span data-stu-id="9d0df-322">For more information on the purpose of attached properties and how to create your own attached properties, see [Attached Properties Overview](attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="9d0df-323">Le proprietà associate utilizzano una sintassi che assomiglia superficialmente alla sintassi degli elementi proprietà, in quanto si specifica anche un *typeName*. combinazione *propertyName.*</span><span class="sxs-lookup"><span data-stu-id="9d0df-323">Attached properties use a syntax that superficially resembles property element syntax, in that you also specify a *typeName*.*propertyName* combination.</span></span> <span data-ttu-id="9d0df-324">Vi sono due differenze importanti:</span><span class="sxs-lookup"><span data-stu-id="9d0df-324">There are two important differences:</span></span>  
  
- <span data-ttu-id="9d0df-325">È possibile utilizzare il *typeName*. *combinazione propertyName* anche quando si imposta una proprietà associata tramite la sintassi degli attributi.</span><span class="sxs-lookup"><span data-stu-id="9d0df-325">You can use the *typeName*.*propertyName* combination even when setting an attached property through attribute syntax.</span></span> <span data-ttu-id="9d0df-326">Le proprietà associate sono l'unico caso in cui la qualifica del nome della proprietà è un requisito in una sintassi degli attributi.</span><span class="sxs-lookup"><span data-stu-id="9d0df-326">Attached properties are the only case where qualifying the property name is a requirement in an attribute syntax.</span></span>  
  
- <span data-ttu-id="9d0df-327">È inoltre possibile utilizzare la sintassi degli elementi proprietà per le proprietà associate.</span><span class="sxs-lookup"><span data-stu-id="9d0df-327">You can also use property element syntax for attached properties.</span></span> <span data-ttu-id="9d0df-328">Tuttavia, per la sintassi tipica degli elementi proprietà, il *typeName* specificato è l'elemento oggetto che contiene l'elemento proprietà.</span><span class="sxs-lookup"><span data-stu-id="9d0df-328">However, for typical property element syntax, the *typeName* you specify is the object element that contains the property element.</span></span> <span data-ttu-id="9d0df-329">Se si fa riferimento a una proprietà associata, *typeName* è la classe che definisce la proprietà associata, non l'elemento oggetto contenitore.</span><span class="sxs-lookup"><span data-stu-id="9d0df-329">If you are referring to an attached property, then the *typeName* is the class that defines the attached property, not the containing object element.</span></span>  
  
<a name="attached_events"></a>
## <a name="attached-events"></a><span data-ttu-id="9d0df-330">Eventi associati</span><span class="sxs-lookup"><span data-stu-id="9d0df-330">Attached Events</span></span>  
 <span data-ttu-id="9d0df-331">Gli eventi associati sono un altro concetto di programmazione introdotto in XAML in cui gli eventi possono essere definiti da un tipo specifico, ma i gestori possono essere associati a qualsiasi elemento oggetto.</span><span class="sxs-lookup"><span data-stu-id="9d0df-331">Attached events are another programming concept introduced in XAML where events can be defined by a specific type, but handlers may be attached on any object element.</span></span> <span data-ttu-id="9d0df-332">Nell'implementazione WOF, spesso il tipo che definisce un evento associato è un tipo statico che definisce un servizio e talvolta tali eventi associati vengono esposti da un alias di evento indirizzato nei tipi che espongono il servizio.</span><span class="sxs-lookup"><span data-stu-id="9d0df-332">In the WOF implementation, often the type that defines an attached event is a static type that defines a service, and sometimes those attached events are exposed by a routed event alias in types that expose the service.</span></span> <span data-ttu-id="9d0df-333">I gestori per gli eventi associati vengono specificati tramite la sintassi degli attributi.</span><span class="sxs-lookup"><span data-stu-id="9d0df-333">Handlers for attached events are specified through attribute syntax.</span></span> <span data-ttu-id="9d0df-334">Come per gli eventi associati, la sintassi degli attributi viene espansa per gli eventi associati per consentire un *typeName*. *eventName* usage, dove *typeName* è `Add` `Remove` la classe che fornisce e le funzioni di accesso del gestore eventi per l'infrastruttura dell'evento associato e *eventName* è il nome dell'evento.</span><span class="sxs-lookup"><span data-stu-id="9d0df-334">As with attached events, the attribute syntax is expanded for attached events to allow a *typeName*.*eventName* usage, where *typeName* is the class that provides `Add` and `Remove` event handler accessors for the attached event infrastructure, and *eventName* is the event name.</span></span>  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>
## <a name="anatomy-of-a-xaml-root-element"></a><span data-ttu-id="9d0df-335">Anatomia di un elemento radice XAMLAnatomy of a XAML Root Element</span><span class="sxs-lookup"><span data-stu-id="9d0df-335">Anatomy of a XAML Root Element</span></span>  
 <span data-ttu-id="9d0df-336">Nella tabella seguente viene illustrato un tipico elemento radice XAML suddiviso, che mostra gli attributi specifici di un elemento radice:The following table shows a typical XAML root element broken down, showing the specific attributes of a root element:</span><span class="sxs-lookup"><span data-stu-id="9d0df-336">The following table shows a typical XAML root element broken down, showing the specific attributes of a root element:</span></span>  
  
|||  
|-|-|  
|`<Page`|<span data-ttu-id="9d0df-337">Apertura dell'elemento object dell'elemento radice</span><span class="sxs-lookup"><span data-stu-id="9d0df-337">Opening object element of the root element</span></span>|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|<span data-ttu-id="9d0df-338">Spazio dei[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]nomi XAML predefinito ( )</span><span class="sxs-lookup"><span data-stu-id="9d0df-338">The default ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML namespace</span></span>|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|<span data-ttu-id="9d0df-339">Spazio dei nomi XAML del linguaggio XAML</span><span class="sxs-lookup"><span data-stu-id="9d0df-339">The XAML language XAML namespace</span></span>|  
|`x:Class="ExampleNamespace.ExampleCode"`|<span data-ttu-id="9d0df-340">Dichiarazione di classe parziale che connette il markup a qualsiasi code-behind definito per la classe parziale</span><span class="sxs-lookup"><span data-stu-id="9d0df-340">The partial class declaration that connects markup to any code-behind defined for the partial class</span></span>|  
|`>`|<span data-ttu-id="9d0df-341">Fine dell'elemento oggetto per la radice.</span><span class="sxs-lookup"><span data-stu-id="9d0df-341">End of object element for the root.</span></span> <span data-ttu-id="9d0df-342">L'oggetto non è ancora chiuso perché l'elemento contiene elementi figlio</span><span class="sxs-lookup"><span data-stu-id="9d0df-342">Object is not closed yet because the element contains child elements</span></span>|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>
## <a name="optional-and-nonrecommended-xaml-usages"></a><span data-ttu-id="9d0df-343">Utilizzo XAML facoltativo e non consigliatoOptional and Nonrecommended XAML Usages</span><span class="sxs-lookup"><span data-stu-id="9d0df-343">Optional and Nonrecommended XAML Usages</span></span>  
 <span data-ttu-id="9d0df-344">Le sezioni seguenti descrivono gli utilizzi XAML tecnicamente supportati dai processori XAML, ma che producono dettaglio o altri problemi estetici che interferiscono con i file XAML che rimangono leggibili quando si sviluppano applicazioni che contengono origini XAML.</span><span class="sxs-lookup"><span data-stu-id="9d0df-344">The following sections describe XAML usages that are technically supported by XAML processors, but that produce verbosity or other aesthetic issues that interfere with XAML files remaining human-readable when you develop applications that contain XAML sources.</span></span>  
  
### <a name="optional-property-element-usages"></a><span data-ttu-id="9d0df-345">Utilizzo facoltativo degli elementi proprietàOptional Property Element Usages</span><span class="sxs-lookup"><span data-stu-id="9d0df-345">Optional Property Element Usages</span></span>  
 <span data-ttu-id="9d0df-346">Gli utilizzi facoltativi degli elementi proprietà includono la scrittura esplicita delle proprietà di contenuto dell'elemento considerate implicite dal processore XAML.</span><span class="sxs-lookup"><span data-stu-id="9d0df-346">Optional property element usages include explicitly writing out element content properties that the XAML processor considers implicit.</span></span> <span data-ttu-id="9d0df-347">Ad esempio, quando si dichiara <xref:System.Windows.Controls.Menu>il contenuto di un <xref:System.Windows.Controls.ItemsControl.Items%2A> oggetto <xref:System.Windows.Controls.Menu> , `<Menu.Items>` è possibile scegliere di <xref:System.Windows.Controls.MenuItem> dichiarare in modo esplicito l'insieme di come tag dell'elemento proprietà e di inserirla `<Menu.Items>`all'interno di , anziché utilizzare il comportamento implicito del processore XAML che tutti gli elementi figlio di un <xref:System.Windows.Controls.Menu> oggetto devono essere a <xref:System.Windows.Controls.MenuItem> e vengono inseriti nell'insieme. <xref:System.Windows.Controls.ItemsControl.Items%2A></span><span class="sxs-lookup"><span data-stu-id="9d0df-347">For example, when you declare the contents of a <xref:System.Windows.Controls.Menu>, you could choose to explicitly declare the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection of the <xref:System.Windows.Controls.Menu> as a `<Menu.Items>` property element tag, and place each <xref:System.Windows.Controls.MenuItem> within `<Menu.Items>`, rather than using the implicit XAML processor behavior that all child elements of a <xref:System.Windows.Controls.Menu> must be a <xref:System.Windows.Controls.MenuItem> and are placed in the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection.</span></span> <span data-ttu-id="9d0df-348">A volte gli utilizzi facoltativi consentono di chiarire visivamente la struttura dell'oggetto rappresentata nel markup.</span><span class="sxs-lookup"><span data-stu-id="9d0df-348">Sometimes the optional usages can help to visually clarify the object structure as represented in the markup.</span></span> <span data-ttu-id="9d0df-349">O a volte l'utilizzo esplicito di un elemento proprietà può evitare markup tecnicamente funzionale ma visivamente confuso, ad esempio le estensioni di markup annidate all'interno di un valore di attributo.</span><span class="sxs-lookup"><span data-stu-id="9d0df-349">Or sometimes an explicit property element usage can avoid markup that is technically functional but visually confusing, such as nested markup extensions within an attribute value.</span></span>  
  
### <a name="full-typenamemembername-qualified-attributes"></a><span data-ttu-id="9d0df-350">Attributi qualificati typeName.memberName completi</span><span class="sxs-lookup"><span data-stu-id="9d0df-350">Full typeName.memberName Qualified Attributes</span></span>  
 <span data-ttu-id="9d0df-351">Il *typeName*. *memberName* per un attributo funziona in realtà in modo più universale rispetto al caso dell'evento indirizzato.</span><span class="sxs-lookup"><span data-stu-id="9d0df-351">The *typeName*.*memberName* form for an attribute actually works more universally than just the routed event case.</span></span> <span data-ttu-id="9d0df-352">Ma in altre situazioni che formano è superfluo e si dovrebbe evitare, se non altro per motivi di stile di markup e leggibilità.</span><span class="sxs-lookup"><span data-stu-id="9d0df-352">But in other situations that form is superfluous and you should avoid it, if only for reasons of markup style and readability.</span></span> <span data-ttu-id="9d0df-353">Nell'esempio seguente, ognuno dei <xref:System.Windows.Controls.Control.Background%2A> tre riferimenti all'attributo è completamente equivalente:</span><span class="sxs-lookup"><span data-stu-id="9d0df-353">In the following example, each of the three references to the <xref:System.Windows.Controls.Control.Background%2A> attribute are completely equivalent:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 <span data-ttu-id="9d0df-354">`Button.Background`funziona perché la ricerca qualificata per tale proprietà <xref:System.Windows.Controls.Button> ha esito positivo (è<xref:System.Windows.Controls.Control.Background%2A> stato ereditato da Control) ed <xref:System.Windows.Controls.Button> è la classe dell'elemento oggetto o una classe base.</span><span class="sxs-lookup"><span data-stu-id="9d0df-354">`Button.Background` works because the qualified lookup for that property on <xref:System.Windows.Controls.Button> is successful (<xref:System.Windows.Controls.Control.Background%2A> was inherited from Control) and <xref:System.Windows.Controls.Button> is the class of the object element or a base class.</span></span> <span data-ttu-id="9d0df-355">`Control.Background`funziona perché <xref:System.Windows.Controls.Control> la classe <xref:System.Windows.Controls.Control.Background%2A> <xref:System.Windows.Controls.Control> definisce <xref:System.Windows.Controls.Button> effettivamente ed è una classe base.</span><span class="sxs-lookup"><span data-stu-id="9d0df-355">`Control.Background` works because the <xref:System.Windows.Controls.Control> class actually defines <xref:System.Windows.Controls.Control.Background%2A> and <xref:System.Windows.Controls.Control> is a <xref:System.Windows.Controls.Button> base class.</span></span>  
  
 <span data-ttu-id="9d0df-356">Tuttavia, il seguente *typeName*. L'esempio del modulo *nomemembro* non funziona e viene quindi visualizzato commentato:</span><span class="sxs-lookup"><span data-stu-id="9d0df-356">However, the following *typeName*.*memberName* form example does not work and is thus shown commented:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <span data-ttu-id="9d0df-357"><xref:System.Windows.Controls.Label>è un'altra <xref:System.Windows.Controls.Control>classe derivata `Label.Background` di <xref:System.Windows.Controls.Label> , e se si fosse specificato all'interno di un elemento oggetto, questo utilizzo avrebbe funzionato.</span><span class="sxs-lookup"><span data-stu-id="9d0df-357"><xref:System.Windows.Controls.Label> is another derived class of <xref:System.Windows.Controls.Control>, and if you had specified `Label.Background` within a <xref:System.Windows.Controls.Label> object element, this usage would have worked.</span></span> <span data-ttu-id="9d0df-358">Tuttavia, <xref:System.Windows.Controls.Label> poiché non è <xref:System.Windows.Controls.Button>la classe o la classe `Label.Background` base di , il comportamento del processore XAML specificato consiste nel elaborare come proprietà associata.</span><span class="sxs-lookup"><span data-stu-id="9d0df-358">However, because <xref:System.Windows.Controls.Label> is not the class or base class of <xref:System.Windows.Controls.Button>, the specified XAML processor behavior is to then process `Label.Background` as an attached property.</span></span> <span data-ttu-id="9d0df-359">`Label.Background`non è una proprietà associata disponibile e questo utilizzo non riesce.</span><span class="sxs-lookup"><span data-stu-id="9d0df-359">`Label.Background` is not an available attached property, and this usage fails.</span></span>  
  
### <a name="basetypenamemembername-property-elements"></a><span data-ttu-id="9d0df-360">Elementi di proprietà baseTypeName.memberName</span><span class="sxs-lookup"><span data-stu-id="9d0df-360">baseTypeName.memberName Property Elements</span></span>  
 <span data-ttu-id="9d0df-361">In modo analogo al modo in cui *typeName*. *memberName* funziona per la sintassi degli attributi, un *baseTypeName*. La sintassi *di nomemembro* funziona per la sintassi degli elementi proprietà.</span><span class="sxs-lookup"><span data-stu-id="9d0df-361">In an analogous way to how the *typeName*.*memberName* form works for attribute syntax, a *baseTypeName*.*memberName* syntax works for property element syntax.</span></span> <span data-ttu-id="9d0df-362">Ad esempio, la sintassi seguente funziona:</span><span class="sxs-lookup"><span data-stu-id="9d0df-362">For instance, the following syntax works:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 <span data-ttu-id="9d0df-363">In questo caso, l'elemento proprietà è stato fornito come `Control.Background` anche se l'elemento proprietà era contenuto in `Button`.</span><span class="sxs-lookup"><span data-stu-id="9d0df-363">Here, the property element was given as `Control.Background` even though the property element was contained in `Button`.</span></span>  
  
 <span data-ttu-id="9d0df-364">Ma proprio come *typeName*. *memberName* per gli attributi, *baseTypeName*. *memberName* è di stile scadente nel markup ed è consigliabile evitarlo.</span><span class="sxs-lookup"><span data-stu-id="9d0df-364">But just like *typeName*.*memberName* form for attributes, *baseTypeName*.*memberName* is poor style in markup, and you should avoid it.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9d0df-365">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="9d0df-365">See also</span></span>

- [<span data-ttu-id="9d0df-366">Panoramica di XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="9d0df-366">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="9d0df-367">Spazio dei nomi XAML (x:) Funzionalità del linguaggio</span><span class="sxs-lookup"><span data-stu-id="9d0df-367">XAML Namespace (x:) Language Features</span></span>](../../../desktop-wpf/xaml-services/namespace-language-features.md)
- [<span data-ttu-id="9d0df-368">Estensioni XAML WPF</span><span class="sxs-lookup"><span data-stu-id="9d0df-368">WPF XAML Extensions</span></span>](wpf-xaml-extensions.md)
- [<span data-ttu-id="9d0df-369">Panoramica sulle proprietà di dipendenza</span><span class="sxs-lookup"><span data-stu-id="9d0df-369">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="9d0df-370">TypeConverter e XAML</span><span class="sxs-lookup"><span data-stu-id="9d0df-370">TypeConverters and XAML</span></span>](typeconverters-and-xaml.md)
- [<span data-ttu-id="9d0df-371">Classi XAML e personalizzate per WPF</span><span class="sxs-lookup"><span data-stu-id="9d0df-371">XAML and Custom Classes for WPF</span></span>](xaml-and-custom-classes-for-wpf.md)
