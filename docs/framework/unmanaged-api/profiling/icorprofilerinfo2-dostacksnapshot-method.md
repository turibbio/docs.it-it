---
title: Metodo ICorProfilerInfo2::DoStackSnapshot
ms.date: 03/30/2017
api_name:
- ICorProfilerInfo2.DoStackSnapshot
api_location:
- mscorwks.dll
api_type:
- COM
f1_keywords:
- ICorProfilerInfo2::DoStackSnapshot
helpviewer_keywords:
- ICorProfilerInfo2::DoStackSnapshot method [.NET Framework profiling]
- DoStackSnapshot method [.NET Framework profiling]
ms.assetid: 287b11e9-7c52-4a13-ba97-751203fa97f4
topic_type:
- apiref
ms.openlocfilehash: b9a7142de01d818390b740a795f70a4606952780
ms.sourcegitcommit: da21fc5a8cce1e028575acf31974681a1bc5aeed
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/08/2020
ms.locfileid: "84497374"
---
# <a name="icorprofilerinfo2dostacksnapshot-method"></a><span data-ttu-id="46cfe-102">Metodo ICorProfilerInfo2::DoStackSnapshot</span><span class="sxs-lookup"><span data-stu-id="46cfe-102">ICorProfilerInfo2::DoStackSnapshot Method</span></span>
<span data-ttu-id="46cfe-103">Esamina i frame gestiti nello stack per il thread specificato e invia le informazioni al profiler tramite un callback.</span><span class="sxs-lookup"><span data-stu-id="46cfe-103">Walks the managed frames on the stack for the specified thread, and sends information to the profiler through a callback.</span></span>  
  
## <a name="syntax"></a><span data-ttu-id="46cfe-104">Sintassi</span><span class="sxs-lookup"><span data-stu-id="46cfe-104">Syntax</span></span>  
  
```cpp  
HRESULT DoStackSnapshot(  
    [in] ThreadID thread,  
    [in] StackSnapshotCallback *callback,  
    [in] ULONG32 infoFlags,  
    [in] void *clientData,  
    [in, size_is(contextSize), length_is(contextSize)] BYTE context[],  
    [in] ULONG32 contextSize);  
```  
  
## <a name="parameters"></a><span data-ttu-id="46cfe-105">Parametri</span><span class="sxs-lookup"><span data-stu-id="46cfe-105">Parameters</span></span>  
 `thread`  
 <span data-ttu-id="46cfe-106">in ID del thread di destinazione.</span><span class="sxs-lookup"><span data-stu-id="46cfe-106">[in] The ID of the target thread.</span></span>  
  
 <span data-ttu-id="46cfe-107">Il passaggio di un valore null in `thread` genera uno snapshot del thread corrente.</span><span class="sxs-lookup"><span data-stu-id="46cfe-107">Passing null in `thread` yields a snapshot of the current thread.</span></span> <span data-ttu-id="46cfe-108">Se `ThreadID` viene passato un oggetto di un thread diverso, il Common Language Runtime (CLR) sospende il thread, esegue lo snapshot e riprende.</span><span class="sxs-lookup"><span data-stu-id="46cfe-108">If a `ThreadID` of a different thread is passed, the common language runtime (CLR) suspends that thread, performs the snapshot, and resumes.</span></span>  
  
 `callback`  
 <span data-ttu-id="46cfe-109">in Puntatore all'implementazione del metodo [StackSnapshotCallback](stacksnapshotcallback-function.md) , che viene chiamato da CLR per fornire al profiler informazioni su ogni frame gestito e ogni esecuzione di frame non gestiti.</span><span class="sxs-lookup"><span data-stu-id="46cfe-109">[in] A pointer to the implementation of the [StackSnapshotCallback](stacksnapshotcallback-function.md) method, which is called by the CLR to provide the profiler with information on each managed frame and each run of unmanaged frames.</span></span>  
  
 <span data-ttu-id="46cfe-110">Il `StackSnapshotCallback` metodo viene implementato dal writer del profiler.</span><span class="sxs-lookup"><span data-stu-id="46cfe-110">The `StackSnapshotCallback` method is implemented by the profiler writer.</span></span>  
  
 `infoFlags`  
 <span data-ttu-id="46cfe-111">in Valore dell'enumerazione [COR_PRF_SNAPSHOT_INFO](cor-prf-snapshot-info-enumeration.md) , che specifica la quantità di dati da passare di nuovo per ogni frame da `StackSnapshotCallback` .</span><span class="sxs-lookup"><span data-stu-id="46cfe-111">[in] A value of the [COR_PRF_SNAPSHOT_INFO](cor-prf-snapshot-info-enumeration.md) enumeration, which specifies the amount of data to be passed back for each frame by `StackSnapshotCallback`.</span></span>  
  
 `clientData`  
 <span data-ttu-id="46cfe-112">in Puntatore ai dati del client, che viene passato direttamente alla `StackSnapshotCallback` funzione di callback.</span><span class="sxs-lookup"><span data-stu-id="46cfe-112">[in] A pointer to the client data, which is passed straight through to the `StackSnapshotCallback` callback function.</span></span>  
  
 `context`  
 <span data-ttu-id="46cfe-113">in Puntatore a una struttura Win32 `CONTEXT` utilizzata per eseguire il seeding del percorso stack.</span><span class="sxs-lookup"><span data-stu-id="46cfe-113">[in] A pointer to a Win32 `CONTEXT` structure, which is used to seed the stack walk.</span></span> <span data-ttu-id="46cfe-114">La `CONTEXT` struttura Win32 contiene i valori dei registri della CPU e rappresenta lo stato della CPU in un determinato momento.</span><span class="sxs-lookup"><span data-stu-id="46cfe-114">The Win32 `CONTEXT` structure contains values of the CPU registers and represents the state of the CPU at a particular moment in time.</span></span>  
  
 <span data-ttu-id="46cfe-115">Il valore di inizializzazione consente a CLR di determinare dove iniziare il percorso dello stack, se la parte superiore dello stack è codice di supporto non gestito; in caso contrario, il valore di inizializzazione viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="46cfe-115">The seed helps the CLR determine where to begin the stack walk, if the top of the stack is unmanaged helper code; otherwise, the seed is ignored.</span></span> <span data-ttu-id="46cfe-116">È necessario specificare un valore di inizializzazione per un percorso asincrono.</span><span class="sxs-lookup"><span data-stu-id="46cfe-116">A seed must be supplied for an asynchronous walk.</span></span> <span data-ttu-id="46cfe-117">Se si sta eseguendo un percorso sincrono, non è necessario alcun valore di inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="46cfe-117">If you are doing a synchronous walk, no seed is necessary.</span></span>  
  
 <span data-ttu-id="46cfe-118">Il `context` parametro è valido solo se il flag di COR_PRF_SNAPSHOT_CONTEXT è stato passato nel `infoFlags` parametro.</span><span class="sxs-lookup"><span data-stu-id="46cfe-118">The `context` parameter is valid only if the COR_PRF_SNAPSHOT_CONTEXT flag was passed in the `infoFlags` parameter.</span></span>  
  
 `contextSize`  
 <span data-ttu-id="46cfe-119">in Dimensione della `CONTEXT` struttura, a cui fa riferimento il `context` parametro.</span><span class="sxs-lookup"><span data-stu-id="46cfe-119">[in] The size of the `CONTEXT` structure, which is referenced by the `context` parameter.</span></span>  
  
## <a name="remarks"></a><span data-ttu-id="46cfe-120">Osservazioni</span><span class="sxs-lookup"><span data-stu-id="46cfe-120">Remarks</span></span>  
 <span data-ttu-id="46cfe-121">Il passaggio di null per `thread` restituisce uno snapshot del thread corrente.</span><span class="sxs-lookup"><span data-stu-id="46cfe-121">Passing null for `thread` yields a snapshot of the current thread.</span></span> <span data-ttu-id="46cfe-122">Gli snapshot possono essere presi da altri thread solo se il thread di destinazione è sospeso al momento.</span><span class="sxs-lookup"><span data-stu-id="46cfe-122">Snapshots can be taken of other threads only if the target thread is suspended at the time.</span></span>  
  
 <span data-ttu-id="46cfe-123">Quando il profiler vuole esaminare lo stack, chiama `DoStackSnapshot` .</span><span class="sxs-lookup"><span data-stu-id="46cfe-123">When the profiler wants to walk the stack, it calls `DoStackSnapshot`.</span></span> <span data-ttu-id="46cfe-124">Prima che CLR torni da tale chiamata, viene chiamato `StackSnapshotCallback` più volte, una volta per ogni frame gestito (o per l'esecuzione di frame non gestiti) nello stack.</span><span class="sxs-lookup"><span data-stu-id="46cfe-124">Before the CLR returns from that call, it calls your `StackSnapshotCallback` several times, once for each managed frame (or run of unmanaged frames) on the stack.</span></span> <span data-ttu-id="46cfe-125">Quando vengono rilevati frame non gestiti, è necessario eseguirli manualmente.</span><span class="sxs-lookup"><span data-stu-id="46cfe-125">When unmanaged frames are encountered, you must walk them yourself.</span></span>  
  
 <span data-ttu-id="46cfe-126">L'ordine in cui viene camminato lo stack è il contrario rispetto alla modalità di push dei frame nello stack: primo fotogramma (ultimo push), principale (primo push).</span><span class="sxs-lookup"><span data-stu-id="46cfe-126">The order in which the stack is walked is the reverse of how the frames were pushed onto the stack: leaf (last-pushed) frame first, main (first-pushed) frame last.</span></span>  
  
 <span data-ttu-id="46cfe-127">Per altre informazioni su come programmare il profiler per l'analisi degli stack gestiti, vedere [analisi dello stack del profiler nella .NET Framework 2,0: Nozioni di base e oltre](https://docs.microsoft.com/previous-versions/dotnet/articles/bb264782(v=msdn.10)).</span><span class="sxs-lookup"><span data-stu-id="46cfe-127">For more information about how to program the profiler to walk managed stacks, see [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](https://docs.microsoft.com/previous-versions/dotnet/articles/bb264782(v=msdn.10)).</span></span>  
  
 <span data-ttu-id="46cfe-128">Un percorso stack può essere sincrono o asincrono, come illustrato nelle sezioni seguenti.</span><span class="sxs-lookup"><span data-stu-id="46cfe-128">A stack walk can be synchronous or asynchronous, as explained in the following sections.</span></span>  
  
## <a name="synchronous-stack-walk"></a><span data-ttu-id="46cfe-129">Percorso stack sincrono</span><span class="sxs-lookup"><span data-stu-id="46cfe-129">Synchronous Stack Walk</span></span>  
 <span data-ttu-id="46cfe-130">Un percorso stack sincrono prevede l'analisi dello stack del thread corrente in risposta a un callback.</span><span class="sxs-lookup"><span data-stu-id="46cfe-130">A synchronous stack walk involves walking the stack of the current thread in response to a callback.</span></span> <span data-ttu-id="46cfe-131">Non richiede il seeding o la sospensione.</span><span class="sxs-lookup"><span data-stu-id="46cfe-131">It does not require seeding or suspending.</span></span>  
  
 <span data-ttu-id="46cfe-132">Si esegue una chiamata sincrona quando, in risposta a CLR che chiama uno dei metodi [ICorProfilerCallback](icorprofilercallback-interface.md) (o [ICorProfilerCallback2](icorprofilercallback2-interface.md)) del profiler, si chiama `DoStackSnapshot` per esaminare lo stack del thread corrente.</span><span class="sxs-lookup"><span data-stu-id="46cfe-132">You make a synchronous call when, in response to the CLR calling one of your profiler's [ICorProfilerCallback](icorprofilercallback-interface.md) (or [ICorProfilerCallback2](icorprofilercallback2-interface.md)) methods, you call `DoStackSnapshot` to walk the stack of the current thread.</span></span> <span data-ttu-id="46cfe-133">Questa operazione è utile quando si desidera visualizzare l'aspetto dello stack in una notifica, ad esempio [ICorProfilerCallback:: ObjectAllocated](icorprofilercallback-objectallocated-method.md).</span><span class="sxs-lookup"><span data-stu-id="46cfe-133">This is useful when you want to see what the stack looks like at a notification such as [ICorProfilerCallback::ObjectAllocated](icorprofilercallback-objectallocated-method.md).</span></span> <span data-ttu-id="46cfe-134">È sufficiente chiamare `DoStackSnapshot` dall'interno del `ICorProfilerCallback` metodo, passando null nei `context` parametri e `thread` .</span><span class="sxs-lookup"><span data-stu-id="46cfe-134">You just call `DoStackSnapshot` from within your `ICorProfilerCallback` method, passing null in the `context` and `thread` parameters.</span></span>  
  
## <a name="asynchronous-stack-walk"></a><span data-ttu-id="46cfe-135">Percorso stack asincrono</span><span class="sxs-lookup"><span data-stu-id="46cfe-135">Asynchronous Stack Walk</span></span>  
 <span data-ttu-id="46cfe-136">Un percorso stack asincrono comporta l'analisi dello stack di un thread diverso o l'analisi dello stack del thread corrente, non in risposta a un callback, ma il hijack del puntatore all'istruzione del thread corrente.</span><span class="sxs-lookup"><span data-stu-id="46cfe-136">An asynchronous stack walk entails walking the stack of a different thread, or walking the stack of the current thread, not in response to a callback, but by hijacking the current thread's instruction pointer.</span></span> <span data-ttu-id="46cfe-137">Un percorso asincrono richiede un valore di inizializzazione se il primo dello stack è codice non gestito che non fa parte di una chiamata a platform invoke (PInvoke) o COM, ma codice di supporto in CLR stesso.</span><span class="sxs-lookup"><span data-stu-id="46cfe-137">An asynchronous walk requires a seed if the top of the stack is unmanaged code that is not part of a platform invoke (PInvoke) or COM call, but helper code in the CLR itself.</span></span> <span data-ttu-id="46cfe-138">Ad esempio, il codice che esegue la compilazione JIT (just-in-Time) o Garbage Collection è codice helper.</span><span class="sxs-lookup"><span data-stu-id="46cfe-138">For example, code that does just-in-time (JIT) compiling or garbage collection is helper code.</span></span>  
  
 <span data-ttu-id="46cfe-139">Si ottiene un valore di inizializzazione sospendendo direttamente il thread di destinazione e spostando il relativo stack fino a trovare il frame gestito in primo piano.</span><span class="sxs-lookup"><span data-stu-id="46cfe-139">You obtain a seed by directly suspending the target thread and walking its stack yourself, until you find the topmost managed frame.</span></span> <span data-ttu-id="46cfe-140">Dopo la sospensione del thread di destinazione, ottenere il contesto di registro corrente del thread di destinazione.</span><span class="sxs-lookup"><span data-stu-id="46cfe-140">After the target thread is suspended, get the target thread's current register context.</span></span> <span data-ttu-id="46cfe-141">Determinare quindi se il contesto del registro punta a codice non gestito chiamando [ICorProfilerInfo:: GetFunctionFromIP](icorprofilerinfo-getfunctionfromip-method.md) , se restituisce un `FunctionID` valore uguale a zero, il frame è codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="46cfe-141">Next, determine whether the register context points to unmanaged code by calling [ICorProfilerInfo::GetFunctionFromIP](icorprofilerinfo-getfunctionfromip-method.md) — if it returns a `FunctionID` equal to zero, the frame is unmanaged code.</span></span> <span data-ttu-id="46cfe-142">A questo punto, scorrere lo stack fino a raggiungere il primo frame gestito, quindi calcolare il contesto di inizializzazione in base al contesto di registro per il frame.</span><span class="sxs-lookup"><span data-stu-id="46cfe-142">Now, walk the stack until you reach the first managed frame, and then calculate the seed context based on the register context for that frame.</span></span>  
  
 <span data-ttu-id="46cfe-143">Chiamare `DoStackSnapshot` con il contesto di inizializzazione per avviare il percorso dello stack asincrono.</span><span class="sxs-lookup"><span data-stu-id="46cfe-143">Call `DoStackSnapshot` with your seed context to begin the asynchronous stack walk.</span></span> <span data-ttu-id="46cfe-144">Se non si specifica un valore di inizializzazione, `DoStackSnapshot` potrebbe ignorare i frame gestiti nella parte superiore dello stack e, di conseguenza, fornirà un percorso stack incompleto.</span><span class="sxs-lookup"><span data-stu-id="46cfe-144">If you do not supply a seed, `DoStackSnapshot` might skip managed frames at the top of the stack and, consequently, will give you an incomplete stack walk.</span></span> <span data-ttu-id="46cfe-145">Se si fornisce un valore di inizializzazione, deve puntare al codice generato con compilazione JIT o Native Image Generator (Ngen. exe); in caso contrario, `DoStackSnapshot` restituisce il codice di errore CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX.</span><span class="sxs-lookup"><span data-stu-id="46cfe-145">If you do supply a seed, it must point to JIT-compiled or Native Image Generator (Ngen.exe)-generated code; otherwise, `DoStackSnapshot` returns the failure code, CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX.</span></span>  
  
 <span data-ttu-id="46cfe-146">I percorsi di stack asincroni possono causare facilmente deadlock o violazioni di accesso, a meno che non si seguano le seguenti linee guida:</span><span class="sxs-lookup"><span data-stu-id="46cfe-146">Asynchronous stack walks can easily cause deadlocks or access violations, unless you follow these guidelines:</span></span>  
  
- <span data-ttu-id="46cfe-147">Quando si sospendono direttamente i thread, tenere presente che solo un thread che non esegue mai codice gestito può sospendere un altro thread.</span><span class="sxs-lookup"><span data-stu-id="46cfe-147">When you directly suspend threads, remember that only a thread that has never run managed code can suspend another thread.</span></span>  
  
- <span data-ttu-id="46cfe-148">Blocca sempre nel callback [ICorProfilerCallback:: ThreadDestroyed](icorprofilercallback-threaddestroyed-method.md) fino al completamento del percorso stack del thread.</span><span class="sxs-lookup"><span data-stu-id="46cfe-148">Always block in your [ICorProfilerCallback::ThreadDestroyed](icorprofilercallback-threaddestroyed-method.md) callback until that thread's stack walk is complete.</span></span>  
  
- <span data-ttu-id="46cfe-149">Non mantenere un blocco quando il profiler chiama una funzione CLR che può attivare un Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="46cfe-149">Do not hold a lock while your profiler calls into a CLR function that can trigger a garbage collection.</span></span> <span data-ttu-id="46cfe-150">Ovvero, non mantenere un blocco se il thread proprietario può effettuare una chiamata che attiva un Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="46cfe-150">That is, do not hold a lock if the owning thread might make a call that triggers a garbage collection.</span></span>  
  
 <span data-ttu-id="46cfe-151">Esiste anche il rischio di deadlock se si chiama `DoStackSnapshot` da un thread creato dal profiler per poter scorrere lo stack di un thread di destinazione separato.</span><span class="sxs-lookup"><span data-stu-id="46cfe-151">There is also a risk of deadlock if you call `DoStackSnapshot` from a thread that your profiler has created so that you can walk the stack of a separate target thread.</span></span> <span data-ttu-id="46cfe-152">La prima volta che il thread creato immette determinati `ICorProfilerInfo*` metodi (incluso `DoStackSnapshot` ), CLR eseguirà l'inizializzazione specifica di CLR per thread su tale thread.</span><span class="sxs-lookup"><span data-stu-id="46cfe-152">The first time the thread you created enters certain `ICorProfilerInfo*` methods (including `DoStackSnapshot`), the CLR will perform per-thread, CLR-specific initialization on that thread.</span></span> <span data-ttu-id="46cfe-153">Se il profiler ha sospeso il thread di destinazione il cui stack si sta tentando di esaminare e se il thread di destinazione è proprietario di un blocco necessario per eseguire questa inizializzazione per thread, si verificherà un deadlock.</span><span class="sxs-lookup"><span data-stu-id="46cfe-153">If your profiler has suspended the target thread whose stack you are trying to walk, and if that target thread happened to own a lock necessary for performing this per-thread initialization, a deadlock will occur.</span></span> <span data-ttu-id="46cfe-154">Per evitare questo deadlock, effettuare una chiamata iniziale al `DoStackSnapshot` thread creato dal profiler per esaminare un thread di destinazione separato, ma non sospendere prima il thread di destinazione.</span><span class="sxs-lookup"><span data-stu-id="46cfe-154">To avoid this deadlock, make an initial call into `DoStackSnapshot` from your profiler-created thread to walk a separate target thread, but do not suspend the target thread first.</span></span> <span data-ttu-id="46cfe-155">Questa chiamata iniziale garantisce che l'inizializzazione per thread possa essere completata senza deadlock.</span><span class="sxs-lookup"><span data-stu-id="46cfe-155">This initial call ensures that the per-thread initialization can complete without deadlock.</span></span> <span data-ttu-id="46cfe-156">Se `DoStackSnapshot` ha esito positivo e segnala almeno un frame, dopo tale punto sarà sicuro per quel thread creato dal profiler sospendere qualsiasi thread di destinazione e chiamare `DoStackSnapshot` per esaminare lo stack del thread di destinazione.</span><span class="sxs-lookup"><span data-stu-id="46cfe-156">If `DoStackSnapshot` succeeds and reports at least one frame, after that point, it will be safe for that profiler-created thread to suspend any target thread and call `DoStackSnapshot` to walk the stack of that target thread.</span></span>  
  
## <a name="requirements"></a><span data-ttu-id="46cfe-157">Requisiti</span><span class="sxs-lookup"><span data-stu-id="46cfe-157">Requirements</span></span>  
 <span data-ttu-id="46cfe-158">**Piattaforme:** vedere [Requisiti di sistema di .NET Framework](../../get-started/system-requirements.md).</span><span class="sxs-lookup"><span data-stu-id="46cfe-158">**Platforms:** See [System Requirements](../../get-started/system-requirements.md).</span></span>  
  
 <span data-ttu-id="46cfe-159">**Intestazione:** CorProf.idl, CorProf.h</span><span class="sxs-lookup"><span data-stu-id="46cfe-159">**Header:** CorProf.idl, CorProf.h</span></span>  
  
 <span data-ttu-id="46cfe-160">**Libreria:** CorGuids.lib</span><span class="sxs-lookup"><span data-stu-id="46cfe-160">**Library:** CorGuids.lib</span></span>  
  
 <span data-ttu-id="46cfe-161">**Versioni .NET Framework:**[!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]</span><span class="sxs-lookup"><span data-stu-id="46cfe-161">**.NET Framework Versions:** [!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="46cfe-162">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="46cfe-162">See also</span></span>

- [<span data-ttu-id="46cfe-163">Interfaccia ICorProfilerInfo</span><span class="sxs-lookup"><span data-stu-id="46cfe-163">ICorProfilerInfo Interface</span></span>](icorprofilerinfo-interface.md)
- [<span data-ttu-id="46cfe-164">Interfaccia ICorProfilerInfo2</span><span class="sxs-lookup"><span data-stu-id="46cfe-164">ICorProfilerInfo2 Interface</span></span>](icorprofilerinfo2-interface.md)
