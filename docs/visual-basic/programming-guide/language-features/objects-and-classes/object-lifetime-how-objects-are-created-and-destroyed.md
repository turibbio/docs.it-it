---
title: 'Durata degli oggetti: come creare e distruggere oggetti'
ms.date: 07/20/2015
f1_keywords:
- vb.Constructor
helpviewer_keywords:
- destructors, object lifetime
- Sub Finalize destructor
- objects [Visual Basic], destroying
- lifetime [Visual Basic], objects
- Sub New constructor, object lifetime
- Finalize method [Visual Basic], object lifetime
- objects [Visual Basic], creating
- Class_Terminate
- Dispose method [Visual Basic], object lifetime
- Class_Initialize
- object creation [Visual Basic], object lifetime
- parameterized constructors
- objects [Visual Basic], lifetime
- objects [Visual Basic], garbage collection
- constructors [Visual Basic], object lifetime
- Sub Dispose destructor
- garbage collection [Visual Basic], Visual Basic
ms.assetid: f1ee8458-b156-44e0-9a8a-5dd171648cd8
ms.openlocfilehash: e81e131933e0997756ed4185a3ceb12ad19b78de
ms.sourcegitcommit: f8c270376ed905f6a8896ce0fe25b4f4b38ff498
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/04/2020
ms.locfileid: "84392883"
---
# <a name="object-lifetime-how-objects-are-created-and-destroyed-visual-basic"></a><span data-ttu-id="6d089-102">Durata degli oggetti: come creare ed eliminare definitivamente oggetti (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="6d089-102">Object Lifetime: How Objects Are Created and Destroyed (Visual Basic)</span></span>

<span data-ttu-id="6d089-103">È stata creata un'istanza di una classe, un oggetto, mediante la parola chiave `New`.</span><span class="sxs-lookup"><span data-stu-id="6d089-103">An instance of a class, an object, is created by using the `New` keyword.</span></span> <span data-ttu-id="6d089-104">Prima di usare i nuovi oggetti per la prima volta, è spesso necessario eseguire attività di inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="6d089-104">Initialization tasks often must be performed on new objects before they are used.</span></span> <span data-ttu-id="6d089-105">Tra le attività di inizializzazione più comuni vi sono l'apertura dei file, la connessione a un database e la lettura dei valori delle chiavi del Registro di sistema.</span><span class="sxs-lookup"><span data-stu-id="6d089-105">Common initialization tasks include opening files, connecting to databases, and reading values of registry keys.</span></span> <span data-ttu-id="6d089-106">Visual Basic controlla l'inizializzazione di nuovi oggetti usando routine denominate *costruttori* (metodi speciali che consentono il controllo dell'inizializzazione).</span><span class="sxs-lookup"><span data-stu-id="6d089-106">Visual Basic controls the initialization of new objects using procedures called *constructors* (special methods that allow control over initialization).</span></span>

<span data-ttu-id="6d089-107">Dopo aver abbandona un ambito, un oggetto viene rilasciato da Common Language Runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="6d089-107">After an object leaves scope, it is released by the common language runtime (CLR).</span></span> <span data-ttu-id="6d089-108">Visual Basic controlla il rilascio delle risorse di sistema mediante procedure denominate *distruttori*.</span><span class="sxs-lookup"><span data-stu-id="6d089-108">Visual Basic controls the release of system resources using procedures called *destructors*.</span></span> <span data-ttu-id="6d089-109">Sia i costruttori che i distruttori supportano la creazione di librerie di classi prevedibili e affidabili.</span><span class="sxs-lookup"><span data-stu-id="6d089-109">Together, constructors and destructors support the creation of robust and predictable class libraries.</span></span>

## <a name="using-constructors-and-destructors"></a><span data-ttu-id="6d089-110">Uso di costruttori e distruttori</span><span class="sxs-lookup"><span data-stu-id="6d089-110">Using Constructors and Destructors</span></span>

<span data-ttu-id="6d089-111">È possibile usare costruttori e distruttori per controllare la creazione e l'eliminazione di oggetti.</span><span class="sxs-lookup"><span data-stu-id="6d089-111">Constructors and destructors control the creation and destruction of objects.</span></span> <span data-ttu-id="6d089-112">Le `Sub New` `Sub Finalize` routine e in Visual Basic inizializzano ed eliminano oggetti; sostituiscono i `Class_Initialize` `Class_Terminate` metodi e usati in Visual Basic 6,0 e versioni precedenti.</span><span class="sxs-lookup"><span data-stu-id="6d089-112">The `Sub New` and `Sub Finalize` procedures in Visual Basic initialize and destroy objects; they replace the `Class_Initialize` and `Class_Terminate` methods used in Visual Basic 6.0 and earlier versions.</span></span>

### <a name="sub-new"></a><span data-ttu-id="6d089-113">Sub New</span><span class="sxs-lookup"><span data-stu-id="6d089-113">Sub New</span></span>

<span data-ttu-id="6d089-114">Il costruttore `Sub New` può essere eseguito solo una volta dopo la creazione di una classe.</span><span class="sxs-lookup"><span data-stu-id="6d089-114">The `Sub New` constructor can run only once when a class is created.</span></span> <span data-ttu-id="6d089-115">Non può essere chiamato in modo esplicito in alcun punto che non sia la prima riga di codice di un altro costruttore, dalla stessa classe o da una classe derivata.</span><span class="sxs-lookup"><span data-stu-id="6d089-115">It cannot be called explicitly anywhere other than in the first line of code of another constructor from either the same class or from a derived class.</span></span> <span data-ttu-id="6d089-116">Inoltre, il codice nel metodo `Sub New` viene sempre eseguito prima di qualsiasi altro codice in una classe.</span><span class="sxs-lookup"><span data-stu-id="6d089-116">Furthermore, the code in the `Sub New` method always runs before any other code in a class.</span></span> <span data-ttu-id="6d089-117">Visual Basic crea in modo implicito un `Sub New` costruttore in fase di esecuzione se non si definisce in modo esplicito una `Sub New` routine per una classe.</span><span class="sxs-lookup"><span data-stu-id="6d089-117">Visual Basic implicitly creates a `Sub New` constructor at run time if you do not explicitly define a `Sub New` procedure for a class.</span></span>

<span data-ttu-id="6d089-118">Per creare un costruttore per una classe, creare una routine denominata `Sub New` in qualsiasi punto della definizione della classe.</span><span class="sxs-lookup"><span data-stu-id="6d089-118">To create a constructor for a class, create a procedure named `Sub New` anywhere in the class definition.</span></span> <span data-ttu-id="6d089-119">Per creare un costruttore con parametri, specificare i nomi e i tipi di dati degli argomenti su `Sub New` analogamente a come si specificano argomenti per qualsiasi altra routine, come illustrato nel codice seguente:</span><span class="sxs-lookup"><span data-stu-id="6d089-119">To create a parameterized constructor, specify the names and data types of arguments to `Sub New` just as you would specify arguments for any other procedure, as in the following code:</span></span>

[!code-vb[VbVbalrOOP#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/WhidbeyStuff.vb#42)]

<span data-ttu-id="6d089-120">I costruttori sono spesso in overload, come nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="6d089-120">Constructors are frequently overloaded, as in the following code:</span></span>

[!code-vb[VbVbalrOOP#116](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/WhidbeyStuff.vb#116)]

<span data-ttu-id="6d089-121">Quando si definisce una classe derivata da un'altra classe, la prima riga di un costruttore deve essere una chiamata al costruttore della classe base, a meno che questa disponga di un costruttore accessibile che non accetta parametri.</span><span class="sxs-lookup"><span data-stu-id="6d089-121">When you define a class derived from another class, the first line of a constructor must be a call to the constructor of the base class, unless the base class has an accessible constructor that takes no parameters.</span></span> <span data-ttu-id="6d089-122">Una chiamata della classe base che contiene questo costruttore sarebbe ad esempio `MyBase.New(s)`.</span><span class="sxs-lookup"><span data-stu-id="6d089-122">A call to the base class that contains the above constructor, for example, would be `MyBase.New(s)`.</span></span> <span data-ttu-id="6d089-123">In caso contrario, `MyBase.New` è facoltativo e il runtime di Visual Basic lo chiama in modo implicito.</span><span class="sxs-lookup"><span data-stu-id="6d089-123">Otherwise, `MyBase.New` is optional, and the Visual Basic runtime calls it implicitly.</span></span>

<span data-ttu-id="6d089-124">Dopo aver scritto il codice per chiamare il costruttore di un oggetto padre, è possibile aggiungere un codice di inizializzazione alla routine `Sub New`.</span><span class="sxs-lookup"><span data-stu-id="6d089-124">After you write the code to call the parent object's constructor, you can add any additional initialization code to the `Sub New` procedure.</span></span> <span data-ttu-id="6d089-125">La routine `Sub New` può accettare gli argomenti quando viene chiamata come costruttore con parametri.</span><span class="sxs-lookup"><span data-stu-id="6d089-125">`Sub New` can accept arguments when called as a parameterized constructor.</span></span> <span data-ttu-id="6d089-126">Tali parametri vengono passati dalla routine che chiama il costruttore, ad esempio, `Dim AnObject As New ThisClass(X)`.</span><span class="sxs-lookup"><span data-stu-id="6d089-126">These parameters are passed from the procedure calling the constructor, for example, `Dim AnObject As New ThisClass(X)`.</span></span>

### <a name="sub-finalize"></a><span data-ttu-id="6d089-127">Sub Finalize</span><span class="sxs-lookup"><span data-stu-id="6d089-127">Sub Finalize</span></span>

<span data-ttu-id="6d089-128">Prima di rilasciare oggetti, CLR richiede automaticamente al metodo `Finalize` gli oggetti che definiscono una routine `Sub Finalize`.</span><span class="sxs-lookup"><span data-stu-id="6d089-128">Before releasing objects, the CLR automatically calls the `Finalize` method for objects that define a `Sub Finalize` procedure.</span></span> <span data-ttu-id="6d089-129">È possibile che il metodo `Finalize` contenga codice che è necessario eseguire subito prima dell'eliminazione definitiva di un oggetto, ad esempio codice relativo alla chiusura di file e al salvataggio delle informazioni sullo stato.</span><span class="sxs-lookup"><span data-stu-id="6d089-129">The `Finalize` method can contain code that needs to execute just before an object is destroyed, such as code for closing files and saving state information.</span></span> <span data-ttu-id="6d089-130">L'esecuzione di `Sub Finalize` comporta una lieve riduzione delle prestazioni. Si consiglia quindi di definire un metodo `Sub Finalize` solo quando è necessario rilasciare in modo esplicito gli oggetti.</span><span class="sxs-lookup"><span data-stu-id="6d089-130">There is a slight performance penalty for executing `Sub Finalize`, so you should define a `Sub Finalize` method only when you need to release objects explicitly.</span></span>

> [!NOTE]
> <span data-ttu-id="6d089-131">Il Garbage Collector in CLR non (e non può) eliminare gli *oggetti non gestiti*, ovvero gli oggetti eseguiti direttamente dal sistema operativo, all'esterno dell'ambiente CLR.</span><span class="sxs-lookup"><span data-stu-id="6d089-131">The garbage collector in the CLR does not (and cannot) dispose of *unmanaged objects*, objects that the operating system executes directly, outside the CLR environment.</span></span> <span data-ttu-id="6d089-132">Questo perché i diversi oggetti non gestiti devono essere eliminati in modi differenti.</span><span class="sxs-lookup"><span data-stu-id="6d089-132">This is because different unmanaged objects must be disposed of in different ways.</span></span> <span data-ttu-id="6d089-133">Le informazioni non sono direttamente associate all'oggetto non gestito e devono quindi essere identificate nella documentazione relativa all'oggetto.</span><span class="sxs-lookup"><span data-stu-id="6d089-133">That information is not directly associated with the unmanaged object; it must be found in the documentation for the object.</span></span> <span data-ttu-id="6d089-134">Se una classe usa oggetti non gestiti, è necessario eliminarli nel relativo metodo `Finalize`.</span><span class="sxs-lookup"><span data-stu-id="6d089-134">A class that uses unmanaged objects must dispose of them in its `Finalize` method.</span></span>

<span data-ttu-id="6d089-135">Il distruttore `Finalize` è un metodo protetto che può essere chiamato solo dalla classe a cui appartiene o dalle classi derivate.</span><span class="sxs-lookup"><span data-stu-id="6d089-135">The `Finalize` destructor is a protected method that can be called only from the class it belongs to, or from derived classes.</span></span> <span data-ttu-id="6d089-136">Poiché `Finalize` viene chiamato automaticamente dal sistema quando viene eliminato definitivamente un oggetto, si consiglia di non chiamare `Finalize` in modo esplicito dall'esterno dell'implementazione `Finalize` di una classe derivata.</span><span class="sxs-lookup"><span data-stu-id="6d089-136">The system calls `Finalize` automatically when an object is destroyed, so you should not explicitly call `Finalize` from outside of a derived class's `Finalize` implementation.</span></span>

<span data-ttu-id="6d089-137">A differenza del metodo `Class_Terminate` che viene eseguito subito dopo aver impostato un oggetto su Nothing, tra l'abbandono dell'ambito da parte di un oggetto e la chiamata del distruttore `Finalize` da parte di Visual Basic si verifica generalmente un ritardo.</span><span class="sxs-lookup"><span data-stu-id="6d089-137">Unlike `Class_Terminate`, which executes as soon as an object is set to nothing, there is usually a delay between when an object loses scope and when Visual Basic calls the `Finalize` destructor.</span></span> <span data-ttu-id="6d089-138">Visual Basic .NET consente un secondo tipo di distruttore, <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> , che può essere chiamato in modo esplicito in qualsiasi momento per rilasciare immediatamente le risorse.</span><span class="sxs-lookup"><span data-stu-id="6d089-138">Visual Basic .NET allows for a second kind of destructor, <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>, which can be explicitly called at any time to immediately release resources.</span></span>

> [!NOTE]
> <span data-ttu-id="6d089-139">Un distruttore `Finalize` non deve generare eccezioni, perché queste non possono essere gestite dall'applicazione e possono provocarne l'interruzione.</span><span class="sxs-lookup"><span data-stu-id="6d089-139">A `Finalize` destructor should not throw exceptions, because they cannot be handled by the application and can cause the application to terminate.</span></span>

### <a name="how-new-and-finalize-methods-work-in-a-class-hierarchy"></a><span data-ttu-id="6d089-140">Uso dei metodi New e Finalize in una gerarchia di classi</span><span class="sxs-lookup"><span data-stu-id="6d089-140">How New and Finalize Methods Work in a Class Hierarchy</span></span>

<span data-ttu-id="6d089-141">Ogni volta che viene creata un'istanza di una classe, nel Common Language Runtime (CLR) viene effettuato un tentativo di eseguire una routine denominata `New`, se esiste in quell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="6d089-141">Whenever an instance of a class is created, the common language runtime (CLR) attempts to execute a procedure named `New`, if it exists in that object.</span></span> <span data-ttu-id="6d089-142">`New` è un tipo di routine chiamato `constructor` che consente di inizializzare nuovi oggetti prima che venga eseguito qualsiasi altro codice in un oggetto.</span><span class="sxs-lookup"><span data-stu-id="6d089-142">`New` is a type of procedure called a `constructor` that is used to initialize new objects before any other code in an object executes.</span></span> <span data-ttu-id="6d089-143">Un costruttore `New` consente di aprire file, collegarsi a database, inizializzare variabili e svolgere ogni altra attività necessaria prima che un oggetto possa essere usato.</span><span class="sxs-lookup"><span data-stu-id="6d089-143">A `New` constructor can be used to open files, connect to databases, initialize variables, and take care of any other tasks that need to be done before an object can be used.</span></span>

<span data-ttu-id="6d089-144">Quando viene creata un'istanza di una classe derivata, viene eseguito innanzitutto il costruttore `Sub New` della classe base, seguito dai costruttori delle classi derivate.</span><span class="sxs-lookup"><span data-stu-id="6d089-144">When an instance of a derived class is created, the `Sub New` constructor of the base class executes first, followed by constructors in derived classes.</span></span> <span data-ttu-id="6d089-145">Nella prima riga del codice di un costruttore `Sub New`, infatti, viene usata la sintassi `MyBase.New()` per chiamare il costruttore della classe immediatamente superiore nella gerarchia delle classi.</span><span class="sxs-lookup"><span data-stu-id="6d089-145">This happens because the first line of code in a `Sub New` constructor uses the syntax `MyBase.New()`to call the constructor of the class immediately above itself in the class hierarchy.</span></span> <span data-ttu-id="6d089-146">Viene quindi eseguita la chiamata al costruttore `Sub New` di ogni classe della gerarchia fino al raggiungimento del costruttore della classe base.</span><span class="sxs-lookup"><span data-stu-id="6d089-146">The `Sub New` constructor is then called for each class in the class hierarchy until the constructor for the base class is reached.</span></span> <span data-ttu-id="6d089-147">A quel punto viene eseguito il codice del costruttore della classe base, seguito dal codice del costruttore di tutte le classi derivate. In ultimo viene eseguito il codice delle classi derivate di livello più basso.</span><span class="sxs-lookup"><span data-stu-id="6d089-147">At that point, the code in the constructor for the base class executes, followed by the code in each constructor in all derived classes and the code in the most derived classes is executed last.</span></span>

![Screenshot che mostra i costruttori e l'ereditarietà della gerarchia di classi.](./media/object-lifetime-how-objects-are-created-and-destroyed/subnew-constructor-inheritance.gif)

<span data-ttu-id="6d089-149">Quando un oggetto non è più necessario, prima di liberare la memoria corrispondente viene chiamato il metodo <xref:System.Object.Finalize%2A> relativo a quell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="6d089-149">When an object is no longer needed, the CLR calls the <xref:System.Object.Finalize%2A> method for that object before freeing its memory.</span></span> <span data-ttu-id="6d089-150">Il metodo <xref:System.Object.Finalize%2A> è denominato `destructor`, perché consente di eseguire attività di pulizia, quali il salvataggio delle informazioni sullo stato, la chiusura dei file e delle connessioni ai database e altre attività necessarie prima del rilascio dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="6d089-150">The <xref:System.Object.Finalize%2A> method is called a `destructor` because it performs cleanup tasks, such as saving state information, closing files and connections to databases, and other tasks that must be done before releasing the object.</span></span>

![Screenshot che illustra il distruttore del metodo Finalize.](./media/object-lifetime-how-objects-are-created-and-destroyed/finalize-method-destructor.gif)

## <a name="idisposable-interface"></a><span data-ttu-id="6d089-152">Interfaccia IDisposable</span><span class="sxs-lookup"><span data-stu-id="6d089-152">IDisposable Interface</span></span>

<span data-ttu-id="6d089-153">Le istanze di classe controllano spesso risorse non gestite da CLR, quali gli handle di Windows e le connessioni al database.</span><span class="sxs-lookup"><span data-stu-id="6d089-153">Class instances often control resources not managed by the CLR, such as Windows handles and database connections.</span></span> <span data-ttu-id="6d089-154">È necessario eliminare definitivamente queste risorse nel metodo `Finalize` della classe per consentirne il rilascio quando il Garbage Collector elimina definitivamente l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="6d089-154">These resources must be disposed of in the `Finalize` method of the class, so that they will be released when the object is destroyed by the garbage collector.</span></span> <span data-ttu-id="6d089-155">Tuttavia, poiché il Garbage Collector elimina definitivamente gli oggetti solo quando CLR richiede la disponibilità di maggiore memoria,</span><span class="sxs-lookup"><span data-stu-id="6d089-155">However, the garbage collector destroys objects only when the CLR requires more free memory.</span></span> <span data-ttu-id="6d089-156">è possibile che le risorse vengano rilasciate solo molto tempo dopo l'abbandono dell'ambito da parte dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="6d089-156">This means that the resources may not be released until long after the object goes out of scope.</span></span>

<span data-ttu-id="6d089-157">A supporto del Garbage Collector, le classi possono implementare l'interfaccia <xref:System.IDisposable> per fornire un sistema di gestione attiva delle risorse di sistema.</span><span class="sxs-lookup"><span data-stu-id="6d089-157">To supplement garbage collection, your classes can provide a mechanism to actively manage system resources if they implement the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="6d089-158"><xref:System.IDisposable> dispone di un metodo, <xref:System.IDisposable.Dispose%2A> che i client chiamano dopo aver usato un oggetto.</span><span class="sxs-lookup"><span data-stu-id="6d089-158"><xref:System.IDisposable> has one method, <xref:System.IDisposable.Dispose%2A>, which clients should call when they finish using an object.</span></span> <span data-ttu-id="6d089-159">È possibile usare il metodo <xref:System.IDisposable.Dispose%2A> per rilasciare immediatamente risorse ed eseguire attività quali la chiusura di file e le connessioni al database.</span><span class="sxs-lookup"><span data-stu-id="6d089-159">You can use the <xref:System.IDisposable.Dispose%2A> method to immediately release resources and perform tasks such as closing files and database connections.</span></span> <span data-ttu-id="6d089-160">A differenza del distruttore `Finalize`, il metodo <xref:System.IDisposable.Dispose%2A> non viene chiamato automaticamente.</span><span class="sxs-lookup"><span data-stu-id="6d089-160">Unlike the `Finalize` destructor, the <xref:System.IDisposable.Dispose%2A> method is not called automatically.</span></span> <span data-ttu-id="6d089-161">Quando si vogliono rilasciare immediatamente risorse, è necessario che i client di una classe chiamino in modo esplicito il metodo <xref:System.IDisposable.Dispose%2A>.</span><span class="sxs-lookup"><span data-stu-id="6d089-161">Clients of a class must explicitly call <xref:System.IDisposable.Dispose%2A> when you want to immediately release resources.</span></span>

### <a name="implementing-idisposable"></a><span data-ttu-id="6d089-162">Implementazione di IDisposable</span><span class="sxs-lookup"><span data-stu-id="6d089-162">Implementing IDisposable</span></span>

<span data-ttu-id="6d089-163">Una classe che implementa l'interfaccia <xref:System.IDisposable> deve includere il codice seguente:</span><span class="sxs-lookup"><span data-stu-id="6d089-163">A class that implements the <xref:System.IDisposable> interface should include these sections of code:</span></span>

- <span data-ttu-id="6d089-164">Campo che consente di controllare se l'oggetto è stato eliminato in modo permanente:</span><span class="sxs-lookup"><span data-stu-id="6d089-164">A field for keeping track of whether the object has been disposed:</span></span>

  ```vb
  Protected disposed As Boolean = False
  ```

- <span data-ttu-id="6d089-165">Overload del metodo <xref:System.IDisposable.Dispose%2A> che consente di liberare le risorse della classe.</span><span class="sxs-lookup"><span data-stu-id="6d089-165">An overload of the <xref:System.IDisposable.Dispose%2A> that frees the class's resources.</span></span> <span data-ttu-id="6d089-166">Questo metodo deve essere chiamato dai metodi <xref:System.IDisposable.Dispose%2A> e `Finalize` della classe base:</span><span class="sxs-lookup"><span data-stu-id="6d089-166">This method should be called by the <xref:System.IDisposable.Dispose%2A> and `Finalize` methods of the base class:</span></span>

  ```vb
  Protected Overridable Sub Dispose(ByVal disposing As Boolean)
      If Not Me.disposed Then
          If disposing Then
              ' Insert code to free managed resources.
          End If
          ' Insert code to free unmanaged resources.
      End If
      Me.disposed = True
  End Sub
  ```

- <span data-ttu-id="6d089-167">Implementazione di <xref:System.IDisposable.Dispose%2A> che contiene solo il codice seguente:</span><span class="sxs-lookup"><span data-stu-id="6d089-167">An implementation of <xref:System.IDisposable.Dispose%2A> that contains only the following code:</span></span>

  ```vb
  Public Sub Dispose() Implements IDisposable.Dispose
      Dispose(True)
      GC.SuppressFinalize(Me)
  End Sub
  ```

- <span data-ttu-id="6d089-168">Override del metodo `Finalize` che contiene solo il codice seguente:</span><span class="sxs-lookup"><span data-stu-id="6d089-168">An override of the `Finalize` method that contains only the following code:</span></span>

  ```vb
  Protected Overrides Sub Finalize()
      Dispose(False)
      MyBase.Finalize()
  End Sub
  ```

### <a name="deriving-from-a-class-that-implements-idisposable"></a><span data-ttu-id="6d089-169">Derivazione da una classe che implementa IDisposable</span><span class="sxs-lookup"><span data-stu-id="6d089-169">Deriving from a Class that Implements IDisposable</span></span>

<span data-ttu-id="6d089-170">Non è necessario eseguire l'override di tutti i metodi di base in una classe derivata da una classe base che implementa l'interfaccia <xref:System.IDisposable>, a meno che tale classe non usi risorse aggiuntive che devono essere eliminate in modo permanente.</span><span class="sxs-lookup"><span data-stu-id="6d089-170">A class that derives from a base class that implements the <xref:System.IDisposable> interface does not need to override any of the base methods unless it uses additional resources that need to be disposed.</span></span> <span data-ttu-id="6d089-171">In questo caso, la classe derivata deve eseguire l'override del metodo `Dispose(disposing)` della classe base per eliminare in modo permanente le risorse della classe derivata.</span><span class="sxs-lookup"><span data-stu-id="6d089-171">In that situation, the derived class should override the base class's `Dispose(disposing)` method to dispose of the derived class's resources.</span></span> <span data-ttu-id="6d089-172">Inoltre, tale override deve chiamare il metodo `Dispose(disposing)` della classe base.</span><span class="sxs-lookup"><span data-stu-id="6d089-172">This override must call the base class's `Dispose(disposing)` method.</span></span>

```vb
Protected Overrides Sub Dispose(ByVal disposing As Boolean)
    If Not Me.disposed Then
        If disposing Then
            ' Insert code to free managed resources.
        End If
        ' Insert code to free unmanaged resources.
    End If
    MyBase.Dispose(disposing)
End Sub
```

<span data-ttu-id="6d089-173">Una classe derivata non deve eseguire l'override del metodi <xref:System.IDisposable.Dispose%2A> e `Finalize` della classe base.</span><span class="sxs-lookup"><span data-stu-id="6d089-173">A derived class should not override the base class's <xref:System.IDisposable.Dispose%2A> and `Finalize` methods.</span></span> <span data-ttu-id="6d089-174">Infatti, quando questi metodi vengono chiamati da un'istanza della classe derivata, la relativa implementazione della classe base chiama l'override del metodo `Dispose(disposing)` della classe derivata.</span><span class="sxs-lookup"><span data-stu-id="6d089-174">When those methods are called from an instance of the derived class, the base class's implementation of those methods call the derived class's override of the `Dispose(disposing)` method.</span></span>

## <a name="garbage-collection-and-the-finalize-destructor"></a><span data-ttu-id="6d089-175">Garbage Collection e il distruttore Finalize</span><span class="sxs-lookup"><span data-stu-id="6d089-175">Garbage Collection and the Finalize Destructor</span></span>

<span data-ttu-id="6d089-176">Il .NET Framework usa il sistema di *Garbage Collection di traccia di riferimento* per rilasciare periodicamente le risorse inutilizzate.</span><span class="sxs-lookup"><span data-stu-id="6d089-176">The .NET Framework uses the *reference-tracing garbage collection* system to periodically release unused resources.</span></span> <span data-ttu-id="6d089-177">Visual Basic 6,0 e versioni precedenti usavano un sistema diverso denominato *conteggio dei riferimenti* per gestire le risorse.</span><span class="sxs-lookup"><span data-stu-id="6d089-177">Visual Basic 6.0 and earlier versions used a different system called *reference counting* to manage resources.</span></span> <span data-ttu-id="6d089-178">Anche se in entrambi i casi viene eseguita automaticamente la stessa funzione, vi sono alcune importanti differenze.</span><span class="sxs-lookup"><span data-stu-id="6d089-178">Although both systems perform the same function automatically, there are a few important differences.</span></span>

<span data-ttu-id="6d089-179">Mediante il metodo CLR gli oggetti vengono eliminati definitivamente con cadenza periodica quando il sistema stabilisce che non sono più necessari.</span><span class="sxs-lookup"><span data-stu-id="6d089-179">The CLR periodically destroys objects when the system determines that such objects are no longer needed.</span></span> <span data-ttu-id="6d089-180">Gli oggetti vengono rilasciati più rapidamente quando le risorse di sistema sono insufficienti e con una frequenza minore in caso contrario.</span><span class="sxs-lookup"><span data-stu-id="6d089-180">Objects are released more quickly when system resources are in short supply, and less frequently otherwise.</span></span> <span data-ttu-id="6d089-181">Il ritardo tra il momento in cui un oggetto abbandona l'ambito e il relativo rilascio da parte di CLR indica che, a differenza di quanto avveniva in Visual Basic 6.0 e nelle versioni precedenti, non è possibile stabilire esattamente quando l'oggetto verrà eliminato in modo permanente.</span><span class="sxs-lookup"><span data-stu-id="6d089-181">The delay between when an object loses scope and when the CLR releases it means that, unlike with objects in Visual Basic 6.0 and earlier versions, you cannot determine exactly when the object will be destroyed.</span></span> <span data-ttu-id="6d089-182">In una situazione di questo tipo, si dice che gli oggetti hanno una *durata non deterministica*.</span><span class="sxs-lookup"><span data-stu-id="6d089-182">In such a situation, objects are said to have *non-deterministic lifetime*.</span></span> <span data-ttu-id="6d089-183">Nella maggior parte dei casi la durata non deterministica non influisce sulla modalità di scrittura delle applicazioni, purché si ricordi che è possibile che il distruttore `Finalize` non venga eseguito immediatamente dopo la perdita di ambito di un oggetto.</span><span class="sxs-lookup"><span data-stu-id="6d089-183">In most cases, non-deterministic lifetime does not change how you write applications, as long as you remember that the `Finalize` destructor may not immediately execute when an object loses scope.</span></span>

<span data-ttu-id="6d089-184">Un'altra differenza tra i sistemi di Garbage Collection riguarda l'uso di `Nothing`.</span><span class="sxs-lookup"><span data-stu-id="6d089-184">Another difference between the garbage-collection systems involves the use of `Nothing`.</span></span> <span data-ttu-id="6d089-185">Per poter usare il conteggio dei riferimenti, in Visual Basic 6.0 e nelle versioni precedenti, a volte veniva assegnato `Nothing` alle variabili oggetto in modo da rilasciare i riferimenti contenuti in tali variabili.</span><span class="sxs-lookup"><span data-stu-id="6d089-185">To take advantage of reference counting in Visual Basic 6.0 and earlier versions, programmers sometimes assigned `Nothing` to object variables to release the references those variables held.</span></span> <span data-ttu-id="6d089-186">Se la variabile conteneva l'ultimo riferimento all'oggetto, le risorse dell'oggetto venivano rilasciate immediatamente.</span><span class="sxs-lookup"><span data-stu-id="6d089-186">If the variable held the last reference to the object, the object's resources were released immediately.</span></span> <span data-ttu-id="6d089-187">Anche se in alcuni casi questa routine può risultare ancora utile, la sua esecuzione nelle versioni successive di Visual Basic non risulta mai nel rilascio immediato delle risorse da parte dell'oggetto a cui si fa riferimento.</span><span class="sxs-lookup"><span data-stu-id="6d089-187">In later versions of Visual Basic, while there may be cases in which this procedure is still valuable, performing it never causes the referenced object to release its resources immediately.</span></span> <span data-ttu-id="6d089-188">Per rilasciare subito le risorse, usare il metodo <xref:System.IDisposable.Dispose%2A> dell'oggetto, se disponibile.</span><span class="sxs-lookup"><span data-stu-id="6d089-188">To release resources immediately, use the object's <xref:System.IDisposable.Dispose%2A> method, if available.</span></span> <span data-ttu-id="6d089-189">Si consiglia di impostare una variabile su `Nothing` solo nel caso in cui la durata della variabile risulti lunga in relazione al tempo necessario per l'individuazione degli oggetti isolati tramite le operazioni del Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="6d089-189">The only time you should set a variable to `Nothing` is when its lifetime is long relative to the time the garbage collector takes to detect orphaned objects.</span></span>

## <a name="see-also"></a><span data-ttu-id="6d089-190">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="6d089-190">See also</span></span>

- <xref:System.IDisposable.Dispose%2A>
- <span data-ttu-id="6d089-191">[Inizializzazione e terminazione di componenti](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2013/ws9dc6t6(v=vs.120))</span><span class="sxs-lookup"><span data-stu-id="6d089-191">[Initialization and Termination of Components](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2013/ws9dc6t6(v=vs.120))</span></span>
- [<span data-ttu-id="6d089-192">Operatore New</span><span class="sxs-lookup"><span data-stu-id="6d089-192">New Operator</span></span>](../../../language-reference/operators/new-operator.md)
- [<span data-ttu-id="6d089-193">Pulizia delle risorse non gestite</span><span class="sxs-lookup"><span data-stu-id="6d089-193">Cleaning Up Unmanaged Resources</span></span>](../../../../standard/garbage-collection/unmanaged.md)
- [<span data-ttu-id="6d089-194">Nothing</span><span class="sxs-lookup"><span data-stu-id="6d089-194">Nothing</span></span>](../../../language-reference/nothing.md)
