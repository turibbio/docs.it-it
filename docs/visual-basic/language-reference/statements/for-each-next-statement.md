---
title: Istruzione For Each...Next
ms.date: 07/20/2015
f1_keywords:
- vb.ForEach
- vb.ForEachNext
- vb.Each
- ForEachNext
helpviewer_keywords:
- infinite loops
- Next statement [Visual Basic], For Each...Next
- endless loops
- loop structures [Visual Basic], For Each...Next
- loops, endless
- Each keyword [Visual Basic]
- instructions, repeating
- For Each statement [Visual Basic]
- collections, instruction repetition
- loops, infinite
- For Each...Next statements
- For keyword [Visual Basic], For Each...Next statements
- Exit statement [Visual Basic], For Each...Next statements
- iteration
ms.assetid: ebce3120-95c3-42b1-b70b-fa7da40c75e2
ms.openlocfilehash: 0feb938121a97b06509b472652e6a753841ab2b8
ms.sourcegitcommit: f8c270376ed905f6a8896ce0fe25b4f4b38ff498
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/04/2020
ms.locfileid: "84404654"
---
# <a name="for-eachnext-statement-visual-basic"></a><span data-ttu-id="54f50-102">Istruzione For Each...Next (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="54f50-102">For Each...Next Statement (Visual Basic)</span></span>

<span data-ttu-id="54f50-103">Ripete un gruppo di istruzioni per ogni elemento di una raccolta.</span><span class="sxs-lookup"><span data-stu-id="54f50-103">Repeats a group of statements for each element in a collection.</span></span>

## <a name="syntax"></a><span data-ttu-id="54f50-104">Sintassi</span><span class="sxs-lookup"><span data-stu-id="54f50-104">Syntax</span></span>

```vb
For Each element [ As datatype ] In group
    [ statements ]
    [ Continue For ]
    [ statements ]
    [ Exit For ]
    [ statements ]
Next [ element ]
```

## <a name="parts"></a><span data-ttu-id="54f50-105">Parti</span><span class="sxs-lookup"><span data-stu-id="54f50-105">Parts</span></span>

|<span data-ttu-id="54f50-106">Termine</span><span class="sxs-lookup"><span data-stu-id="54f50-106">Term</span></span>|<span data-ttu-id="54f50-107">Definizione</span><span class="sxs-lookup"><span data-stu-id="54f50-107">Definition</span></span>|
|---|---|
|`element`|<span data-ttu-id="54f50-108">Obbligatorio nell' `For Each` istruzione.</span><span class="sxs-lookup"><span data-stu-id="54f50-108">Required in the `For Each` statement.</span></span> <span data-ttu-id="54f50-109">Facoltativo nell' `Next` istruzione.</span><span class="sxs-lookup"><span data-stu-id="54f50-109">Optional in the `Next` statement.</span></span> <span data-ttu-id="54f50-110">Variabile.</span><span class="sxs-lookup"><span data-stu-id="54f50-110">Variable.</span></span> <span data-ttu-id="54f50-111">Utilizzato per scorrere gli elementi della raccolta.</span><span class="sxs-lookup"><span data-stu-id="54f50-111">Used to iterate through the elements of the collection.</span></span>|
|`datatype`|<span data-ttu-id="54f50-112">Facoltativo se [`Option Infer`](option-infer-statement.md) è on (impostazione predefinita) o `element` è già dichiarato; obbligatorio se `Option Infer` è disattivato e `element` non è già dichiarato.</span><span class="sxs-lookup"><span data-stu-id="54f50-112">Optional if [`Option Infer`](option-infer-statement.md) is on (the default) or `element` is already declared; required if `Option Infer` is off and `element` isn't already declared.</span></span> <span data-ttu-id="54f50-113">Tipo di dati del parametro `element`.</span><span class="sxs-lookup"><span data-stu-id="54f50-113">The data type of `element`.</span></span>|
|`group`|<span data-ttu-id="54f50-114">Obbligatorio.</span><span class="sxs-lookup"><span data-stu-id="54f50-114">Required.</span></span> <span data-ttu-id="54f50-115">Una variabile con un tipo che è un tipo di raccolta o un oggetto.</span><span class="sxs-lookup"><span data-stu-id="54f50-115">A variable with a type that's a collection type or Object.</span></span> <span data-ttu-id="54f50-116">Si riferisce alla raccolta sulla quale devono `statements` essere ripetuti.</span><span class="sxs-lookup"><span data-stu-id="54f50-116">Refers to the collection over which the `statements` are to be repeated.</span></span>|
|`statements`|<span data-ttu-id="54f50-117">Facoltativa.</span><span class="sxs-lookup"><span data-stu-id="54f50-117">Optional.</span></span> <span data-ttu-id="54f50-118">Una o più istruzioni tra `For Each` e `Next` eseguite in ogni elemento in `group` .</span><span class="sxs-lookup"><span data-stu-id="54f50-118">One or more statements between `For Each` and `Next` that run on each item in `group`.</span></span>|
|`Continue For`|<span data-ttu-id="54f50-119">Facoltativa.</span><span class="sxs-lookup"><span data-stu-id="54f50-119">Optional.</span></span> <span data-ttu-id="54f50-120">Trasferisce il controllo all'inizio del `For Each` ciclo.</span><span class="sxs-lookup"><span data-stu-id="54f50-120">Transfers control to the start of the `For Each` loop.</span></span>|
|`Exit For`|<span data-ttu-id="54f50-121">Facoltativa.</span><span class="sxs-lookup"><span data-stu-id="54f50-121">Optional.</span></span> <span data-ttu-id="54f50-122">Trasferisce il controllo all'esterno del `For Each` ciclo.</span><span class="sxs-lookup"><span data-stu-id="54f50-122">Transfers control out of the `For Each` loop.</span></span>|
|`Next`|<span data-ttu-id="54f50-123">Obbligatorio.</span><span class="sxs-lookup"><span data-stu-id="54f50-123">Required.</span></span> <span data-ttu-id="54f50-124">Termina la definizione del `For Each` ciclo.</span><span class="sxs-lookup"><span data-stu-id="54f50-124">Terminates the definition of the `For Each` loop.</span></span>|

## <a name="simple-example"></a><span data-ttu-id="54f50-125">Esempio semplice</span><span class="sxs-lookup"><span data-stu-id="54f50-125">Simple Example</span></span>

<span data-ttu-id="54f50-126">Utilizzare un `For Each` ciclo... `Next` quando si desidera ripetere un set di istruzioni per ogni elemento di una raccolta o di una matrice.</span><span class="sxs-lookup"><span data-stu-id="54f50-126">Use a `For Each`...`Next` loop when you want to repeat a set of statements for each element of a collection or array.</span></span>

> [!TIP]
> <span data-ttu-id="54f50-127">Oggetto [per... L'istruzione successiva](for-next-statement.md) funziona bene quando è possibile associare ogni iterazione di un ciclo a una variabile di controllo e determinare i valori iniziale e finale della variabile.</span><span class="sxs-lookup"><span data-stu-id="54f50-127">A [For...Next Statement](for-next-statement.md) works well when you can associate each iteration of a loop with a control variable and determine that variable's initial and final values.</span></span> <span data-ttu-id="54f50-128">Tuttavia, quando si tratta di una raccolta, il concetto di valori iniziali e finali non è significativo e non si conosce necessariamente il numero di elementi della raccolta.</span><span class="sxs-lookup"><span data-stu-id="54f50-128">However, when you are dealing with a collection, the concept of initial and final values isn't meaningful, and you don't necessarily know how many elements the collection has.</span></span> <span data-ttu-id="54f50-129">In questo tipo di caso, un `For Each` ciclo... `Next` è spesso una scelta migliore.</span><span class="sxs-lookup"><span data-stu-id="54f50-129">In this kind of case, a `For Each`...`Next` loop is often a better choice.</span></span>

<span data-ttu-id="54f50-130">Nell'esempio seguente, il `For Each` ...`Next`</span><span class="sxs-lookup"><span data-stu-id="54f50-130">In the following example, the `For Each`…`Next`</span></span> <span data-ttu-id="54f50-131">l'istruzione scorre tutti gli elementi di una raccolta di elenchi.</span><span class="sxs-lookup"><span data-stu-id="54f50-131">statement iterates through all the elements of a List collection.</span></span>

[!code-vb[VbVbalrStatements#121](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/class9.vb#121)]

<span data-ttu-id="54f50-132">Per altri esempi, vedere [raccolte](../../../standard/collections/index.md) e [matrici](../../programming-guide/language-features/arrays/index.md).</span><span class="sxs-lookup"><span data-stu-id="54f50-132">For more examples, see [Collections](../../../standard/collections/index.md) and [Arrays](../../programming-guide/language-features/arrays/index.md).</span></span>

## <a name="nested-loops"></a><span data-ttu-id="54f50-133">Nested Loops</span><span class="sxs-lookup"><span data-stu-id="54f50-133">Nested Loops</span></span>

<span data-ttu-id="54f50-134">È possibile annidare `For Each` cicli inserendo un ciclo all'interno di un altro.</span><span class="sxs-lookup"><span data-stu-id="54f50-134">You can nest `For Each` loops by putting one loop within another.</span></span>

<span data-ttu-id="54f50-135">Nell'esempio seguente viene illustrato l'oggetto annidato `For Each` ...`Next`</span><span class="sxs-lookup"><span data-stu-id="54f50-135">The following example demonstrates nested `For Each`…`Next`</span></span> <span data-ttu-id="54f50-136">strutture.</span><span class="sxs-lookup"><span data-stu-id="54f50-136">structures.</span></span>

[!code-vb[VbVbalrStatements#122](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/class9.vb#122)]

<span data-ttu-id="54f50-137">Quando si annidano i cicli, ogni ciclo deve avere una variabile univoca `element` .</span><span class="sxs-lookup"><span data-stu-id="54f50-137">When you nest loops, each loop must have a unique `element` variable.</span></span>

<span data-ttu-id="54f50-138">È anche possibile annidare diversi tipi di strutture di controllo tra loro.</span><span class="sxs-lookup"><span data-stu-id="54f50-138">You can also nest different kinds of control structures within each other.</span></span> <span data-ttu-id="54f50-139">Per altre informazioni, vedere [strutture di controlli annidati](../../programming-guide/language-features/control-flow/nested-control-structures.md).</span><span class="sxs-lookup"><span data-stu-id="54f50-139">For more information, see [Nested Control Structures](../../programming-guide/language-features/control-flow/nested-control-structures.md).</span></span>

## <a name="exit-for-and-continue-for"></a><span data-ttu-id="54f50-140">Esci per e continua per</span><span class="sxs-lookup"><span data-stu-id="54f50-140">Exit For and Continue For</span></span>

<span data-ttu-id="54f50-141">L'istruzione [Exit for](exit-statement.md) causa l'uscita dall'esecuzione di `For` ...`Next`</span><span class="sxs-lookup"><span data-stu-id="54f50-141">The [Exit For](exit-statement.md) statement causes execution to exit the `For`…`Next`</span></span> <span data-ttu-id="54f50-142">esegue il ciclo e trasferisce il controllo all'istruzione che segue l' `Next` istruzione.</span><span class="sxs-lookup"><span data-stu-id="54f50-142">loop and transfers control to the statement that follows the `Next` statement.</span></span>

<span data-ttu-id="54f50-143">L' `Continue For` istruzione trasferisce immediatamente il controllo all'iterazione successiva del ciclo.</span><span class="sxs-lookup"><span data-stu-id="54f50-143">The `Continue For` statement transfers control immediately to the next iteration of the loop.</span></span> <span data-ttu-id="54f50-144">Per ulteriori informazioni, vedere [istruzione continue](continue-statement.md).</span><span class="sxs-lookup"><span data-stu-id="54f50-144">For more information, see [Continue Statement](continue-statement.md).</span></span>

<span data-ttu-id="54f50-145">Nell'esempio seguente viene illustrato come utilizzare le `Continue For` `Exit For` istruzioni e.</span><span class="sxs-lookup"><span data-stu-id="54f50-145">The following example shows how to use the `Continue For` and `Exit For` statements.</span></span>

[!code-vb[VbVbalrStatements#123](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/class9.vb#123)]

<span data-ttu-id="54f50-146">È possibile inserire un numero qualsiasi di `Exit For` istruzioni in un `For Each` ciclo.</span><span class="sxs-lookup"><span data-stu-id="54f50-146">You can put any number of `Exit For` statements in a `For Each` loop.</span></span> <span data-ttu-id="54f50-147">Quando viene utilizzato all'interno di cicli annidati `For Each` , `Exit For` l'esecuzione esce dal ciclo più interno e trasferisce il controllo al livello di nidificazione successivo.</span><span class="sxs-lookup"><span data-stu-id="54f50-147">When used within nested `For Each` loops, `Exit For` causes execution to exit the innermost loop and transfers control to the next higher level of nesting.</span></span>

<span data-ttu-id="54f50-148">`Exit For`viene spesso usato dopo una valutazione di una determinata condizione, ad esempio in un `If` ... `Then` ...`Else` struttura.</span><span class="sxs-lookup"><span data-stu-id="54f50-148">`Exit For` is often used after an evaluation of some condition, for example, in an `If`...`Then`...`Else` structure.</span></span> <span data-ttu-id="54f50-149">Può essere utile usare `Exit For` per le condizioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="54f50-149">You might want to use `Exit For` for the following conditions:</span></span>

- <span data-ttu-id="54f50-150">La continuazione dell'iterazione non è necessaria o impossibile.</span><span class="sxs-lookup"><span data-stu-id="54f50-150">Continuing to iterate is unnecessary or impossible.</span></span> <span data-ttu-id="54f50-151">Il problema potrebbe essere causato da un valore errato o da una richiesta di terminazione.</span><span class="sxs-lookup"><span data-stu-id="54f50-151">This might be caused by an erroneous value or a termination request.</span></span>

- <span data-ttu-id="54f50-152">Viene rilevata un'eccezione in `Try` ... `Catch` ...`Finally`. È possibile utilizzare `Exit For` alla fine del `Finally` blocco.</span><span class="sxs-lookup"><span data-stu-id="54f50-152">An exception is caught in a `Try`...`Catch`...`Finally`. You might use `Exit For` at the end of the `Finally` block.</span></span>

- <span data-ttu-id="54f50-153">Un ciclo infinito, ovvero un ciclo che può eseguire un numero di volte elevato o infinito.</span><span class="sxs-lookup"><span data-stu-id="54f50-153">There an endless loop, which is a loop that could run a large or even infinite number of times.</span></span> <span data-ttu-id="54f50-154">Se si rileva una condizione di questo tipo, è possibile utilizzare `Exit For` per eseguire l'escape del ciclo.</span><span class="sxs-lookup"><span data-stu-id="54f50-154">If you detect such a condition, you can use `Exit For` to escape the loop.</span></span> <span data-ttu-id="54f50-155">Per ulteriori informazioni, vedere [... Istruzione Loop](do-loop-statement.md).</span><span class="sxs-lookup"><span data-stu-id="54f50-155">For more information, see [Do...Loop Statement](do-loop-statement.md).</span></span>

## <a name="iterators"></a><span data-ttu-id="54f50-156">Iterators</span><span class="sxs-lookup"><span data-stu-id="54f50-156">Iterators</span></span>

<span data-ttu-id="54f50-157">Si usa un *iteratore* per eseguire un'iterazione personalizzata su una raccolta.</span><span class="sxs-lookup"><span data-stu-id="54f50-157">You use an *iterator* to perform a custom iteration over a collection.</span></span> <span data-ttu-id="54f50-158">Un iteratore può essere una funzione o una funzione di `Get` accesso.</span><span class="sxs-lookup"><span data-stu-id="54f50-158">An iterator can be a function or a `Get` accessor.</span></span> <span data-ttu-id="54f50-159">Viene utilizzata un' `Yield` istruzione per restituire ogni elemento della raccolta uno alla volta.</span><span class="sxs-lookup"><span data-stu-id="54f50-159">It uses a `Yield` statement to return each element of the collection one at a time.</span></span>

<span data-ttu-id="54f50-160">È possibile chiamare un iteratore usando un' `For Each...Next` istruzione.</span><span class="sxs-lookup"><span data-stu-id="54f50-160">You call an iterator by using a `For Each...Next` statement.</span></span> <span data-ttu-id="54f50-161">Ogni iterazione del ciclo `For Each` chiama l'iteratore.</span><span class="sxs-lookup"><span data-stu-id="54f50-161">Each iteration of the `For Each` loop calls the iterator.</span></span> <span data-ttu-id="54f50-162">Quando `Yield` viene raggiunta un'istruzione nell'iteratore, viene restituita l'espressione nell' `Yield` istruzione e viene mantenuta la posizione corrente nel codice.</span><span class="sxs-lookup"><span data-stu-id="54f50-162">When a `Yield` statement is reached in the iterator, the expression in the `Yield` statement is returned, and the current location in code is retained.</span></span> <span data-ttu-id="54f50-163">L'esecuzione viene ripresa a partire da quella posizione la volta successiva che viene chiamato l'iteratore.</span><span class="sxs-lookup"><span data-stu-id="54f50-163">Execution is restarted from that location the next time that the iterator is called.</span></span>

<span data-ttu-id="54f50-164">Nell'esempio seguente viene utilizzata una funzione iteratore.</span><span class="sxs-lookup"><span data-stu-id="54f50-164">The following example uses an iterator function.</span></span> <span data-ttu-id="54f50-165">La funzione iteratore ha un' `Yield` istruzione che si trova all'interno di un oggetto [per... Ciclo successivo](for-next-statement.md) .</span><span class="sxs-lookup"><span data-stu-id="54f50-165">The iterator function has a `Yield` statement that's inside a [For…Next](for-next-statement.md) loop.</span></span> <span data-ttu-id="54f50-166">Nel `ListEvenNumbers` Metodo ogni iterazione del corpo dell' `For Each` istruzione crea una chiamata alla funzione iteratore, che procede all' `Yield` istruzione successiva.</span><span class="sxs-lookup"><span data-stu-id="54f50-166">In the `ListEvenNumbers` method, each iteration of the `For Each` statement body creates a call to the iterator function, which proceeds to the next `Yield` statement.</span></span>

[!code-vb[VbVbalrStatements#127](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/class9.vb#127)]

<span data-ttu-id="54f50-167">Per ulteriori informazioni, vedere [iteratori](../../programming-guide/concepts/iterators.md), [istruzione yield](yield-statement.md)e [iteratore](../modifiers/iterator.md).</span><span class="sxs-lookup"><span data-stu-id="54f50-167">For more information, see [Iterators](../../programming-guide/concepts/iterators.md), [Yield Statement](yield-statement.md), and [Iterator](../modifiers/iterator.md).</span></span>

## <a name="technical-implementation"></a><span data-ttu-id="54f50-168">Implementazione tecnica</span><span class="sxs-lookup"><span data-stu-id="54f50-168">Technical Implementation</span></span>

<span data-ttu-id="54f50-169">Quando un `For Each` ...`Next`</span><span class="sxs-lookup"><span data-stu-id="54f50-169">When a `For Each`…`Next`</span></span> <span data-ttu-id="54f50-170">l'istruzione viene eseguita, Visual Basic valuta la raccolta solo una volta, prima dell'avvio del ciclo.</span><span class="sxs-lookup"><span data-stu-id="54f50-170">statement runs, Visual Basic evaluates the collection only one time, before the loop starts.</span></span> <span data-ttu-id="54f50-171">Se il blocco di istruzioni cambia `element` o `group` , queste modifiche non influiscono sull'iterazione del ciclo.</span><span class="sxs-lookup"><span data-stu-id="54f50-171">If your statement block changes `element` or `group`, these changes don't affect the iteration of the loop.</span></span>

<span data-ttu-id="54f50-172">Quando tutti gli elementi della raccolta sono stati assegnati successivamente a `element` , il `For Each` ciclo viene arrestato e il controllo passa all'istruzione che segue l' `Next` istruzione.</span><span class="sxs-lookup"><span data-stu-id="54f50-172">When all the elements in the collection have been successively assigned to `element`, the `For Each` loop stops and control passes to the statement following the `Next` statement.</span></span>

<span data-ttu-id="54f50-173">Se [Option deduce](option-infer-statement.md) è on (impostazione predefinita), il Visual Basic compilatore può dedurre il tipo di dati di `element` .</span><span class="sxs-lookup"><span data-stu-id="54f50-173">If [Option Infer](option-infer-statement.md) is on (its default setting), the Visual Basic compiler can infer the data type of `element`.</span></span> <span data-ttu-id="54f50-174">Se è disattivata e `element` non è stata dichiarata al di fuori del ciclo, è necessario dichiararla nell' `For Each` istruzione.</span><span class="sxs-lookup"><span data-stu-id="54f50-174">If it is off and `element` hasn't been declared outside the loop, you must declare it in the `For Each` statement.</span></span> <span data-ttu-id="54f50-175">Per dichiarare il tipo di dati di in `element` modo esplicito, utilizzare una `As` clausola.</span><span class="sxs-lookup"><span data-stu-id="54f50-175">To declare the data type of `element` explicitly, use an `As` clause.</span></span> <span data-ttu-id="54f50-176">A meno che il tipo di dati dell'elemento non sia definito al di fuori del `For Each` costrutto... `Next` , il relativo ambito è il corpo del ciclo.</span><span class="sxs-lookup"><span data-stu-id="54f50-176">Unless the data type of element is defined outside the `For Each`...`Next` construct, its scope is the body of the loop.</span></span> <span data-ttu-id="54f50-177">Si noti che non è possibile dichiarare `element` sia all'esterno che all'interno del ciclo.</span><span class="sxs-lookup"><span data-stu-id="54f50-177">Note that you cannot declare `element` both outside and inside the loop.</span></span>

<span data-ttu-id="54f50-178">Facoltativamente, è possibile specificare `element` nell' `Next` istruzione.</span><span class="sxs-lookup"><span data-stu-id="54f50-178">You can optionally specify `element` in the `Next` statement.</span></span> <span data-ttu-id="54f50-179">Ciò migliora la leggibilità del programma, soprattutto se sono presenti cicli nidificati `For Each` .</span><span class="sxs-lookup"><span data-stu-id="54f50-179">This improves the readability of your program, especially if you have nested `For Each` loops.</span></span> <span data-ttu-id="54f50-180">È necessario specificare la stessa variabile di quella visualizzata nell' `For Each` istruzione corrispondente.</span><span class="sxs-lookup"><span data-stu-id="54f50-180">You must specify the same variable as the one that appears in the corresponding `For Each` statement.</span></span>

<span data-ttu-id="54f50-181">È consigliabile evitare di modificare il valore di `element` all'interno di un ciclo.</span><span class="sxs-lookup"><span data-stu-id="54f50-181">You might want to avoid changing the value of `element` inside a loop.</span></span> <span data-ttu-id="54f50-182">Questa operazione può rendere più difficile la lettura e il debug del codice.</span><span class="sxs-lookup"><span data-stu-id="54f50-182">Doing this can make it more difficult to read and debug your code.</span></span> <span data-ttu-id="54f50-183">La modifica del valore di `group` non influisce sulla raccolta o sui relativi elementi, che sono stati determinati quando il ciclo è stato immesso per la prima volta.</span><span class="sxs-lookup"><span data-stu-id="54f50-183">Changing the value of `group` doesn't affect the collection or its elements, which were determined when the loop was first entered.</span></span>

<span data-ttu-id="54f50-184">Quando si annidano i cicli, se `Next` viene rilevata un'istruzione di un livello di nidificazione esterno prima `Next` di di un livello interno, il compilatore segnala un errore.</span><span class="sxs-lookup"><span data-stu-id="54f50-184">When you're nesting loops, if a `Next` statement of an outer nesting level is encountered before the `Next` of an inner level, the compiler signals an error.</span></span> <span data-ttu-id="54f50-185">Tuttavia, il compilatore può rilevare questo errore di sovrapposizione solo se si specifica `element` in ogni `Next` istruzione.</span><span class="sxs-lookup"><span data-stu-id="54f50-185">However, the compiler can detect this overlapping error only if you specify `element` in every `Next` statement.</span></span>

<span data-ttu-id="54f50-186">Se il codice dipende dall'attraversamento di una raccolta in un ordine particolare, un `For Each` ciclo... `Next` non è la scelta migliore, a meno che non si conoscano le caratteristiche dell'oggetto enumeratore esposto dalla raccolta.</span><span class="sxs-lookup"><span data-stu-id="54f50-186">If your code depends on traversing a collection in a particular order, a `For Each`...`Next` loop isn't the best choice, unless you know the characteristics of the enumerator object the collection exposes.</span></span> <span data-ttu-id="54f50-187">L'ordine di attraversamento non è determinato dal Visual Basic, ma dal <xref:System.Collections.IEnumerator.MoveNext%2A> metodo dell'oggetto enumeratore.</span><span class="sxs-lookup"><span data-stu-id="54f50-187">The order of traversal isn't determined by Visual Basic, but by the <xref:System.Collections.IEnumerator.MoveNext%2A> method of the enumerator object.</span></span> <span data-ttu-id="54f50-188">Pertanto, potrebbe non essere possibile stimare quale elemento della raccolta è il primo da restituire in `element` o che è il successivo da restituire dopo un determinato elemento.</span><span class="sxs-lookup"><span data-stu-id="54f50-188">Therefore, you might not be able to predict which element of the collection is the first to be returned in `element`, or which is the next to be returned after a given element.</span></span> <span data-ttu-id="54f50-189">È possibile ottenere risultati più affidabili utilizzando una struttura di ciclo diversa, ad esempio `For` ... `Next` o `Do` ... `Loop` .</span><span class="sxs-lookup"><span data-stu-id="54f50-189">You might achieve more reliable results using a different loop structure, such as `For`...`Next` or `Do`...`Loop`.</span></span>

<span data-ttu-id="54f50-190">Il runtime deve essere in grado di convertire gli elementi di in `group` `element` .</span><span class="sxs-lookup"><span data-stu-id="54f50-190">The runtime must be able to convert the elements in `group` to `element`.</span></span> <span data-ttu-id="54f50-191">L' `Option Strict` istruzione [] controlla se sono consentite entrambe le conversioni verso un tipo di ingrandimento e più piccolo ( `Option Strict` è disattivato, il valore predefinito) o se sono consentite solo conversioni verso un tipo di ingrandimento ( `Option Strict` è on).</span><span class="sxs-lookup"><span data-stu-id="54f50-191">The [`Option Strict`] statement controls whether both widening and narrowing conversions are allowed (`Option Strict` is off, its default value), or whether only widening conversions are allowed (`Option Strict` is on).</span></span> <span data-ttu-id="54f50-192">Per altre informazioni, vedere [conversioni](#narrowing-conversions)verso un tipo di dati più piccolo.</span><span class="sxs-lookup"><span data-stu-id="54f50-192">For more information, see [Narrowing conversions](#narrowing-conversions).</span></span>

<span data-ttu-id="54f50-193">Il tipo di dati di `group` deve essere un tipo di riferimento che fa riferimento a una raccolta o a una matrice enumerabile.</span><span class="sxs-lookup"><span data-stu-id="54f50-193">The data type of `group` must be a reference type that refers to a collection or an array that's enumerable.</span></span> <span data-ttu-id="54f50-194">In genere, ciò significa che `group` fa riferimento a un oggetto che implementa l' <xref:System.Collections.IEnumerable> interfaccia dello `System.Collections` spazio dei nomi o l' <xref:System.Collections.Generic.IEnumerable%601> interfaccia dello `System.Collections.Generic` spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="54f50-194">Most commonly this means that `group` refers to an object that implements the <xref:System.Collections.IEnumerable> interface of the `System.Collections` namespace or the <xref:System.Collections.Generic.IEnumerable%601> interface of the `System.Collections.Generic` namespace.</span></span> <span data-ttu-id="54f50-195">`System.Collections.IEnumerable`definisce il <xref:System.Collections.IEnumerable.GetEnumerator%2A> metodo, che restituisce un oggetto enumeratore per la raccolta.</span><span class="sxs-lookup"><span data-stu-id="54f50-195">`System.Collections.IEnumerable` defines the <xref:System.Collections.IEnumerable.GetEnumerator%2A> method, which returns an enumerator object for the collection.</span></span> <span data-ttu-id="54f50-196">L'oggetto enumeratore implementa l' `System.Collections.IEnumerator` interfaccia dello `System.Collections` spazio dei nomi ed espone la <xref:System.Collections.IEnumerator.Current%2A> proprietà e i <xref:System.Collections.IEnumerator.Reset%2A> <xref:System.Collections.IEnumerator.MoveNext%2A> metodi e.</span><span class="sxs-lookup"><span data-stu-id="54f50-196">The enumerator object implements the `System.Collections.IEnumerator` interface of the `System.Collections` namespace and exposes the <xref:System.Collections.IEnumerator.Current%2A> property and the <xref:System.Collections.IEnumerator.Reset%2A> and <xref:System.Collections.IEnumerator.MoveNext%2A> methods.</span></span> <span data-ttu-id="54f50-197">Visual Basic utilizza questi per attraversare la raccolta.</span><span class="sxs-lookup"><span data-stu-id="54f50-197">Visual Basic uses these to traverse the collection.</span></span>

### <a name="narrowing-conversions"></a><span data-ttu-id="54f50-198">conversioni verso un tipo di dati più piccolo</span><span class="sxs-lookup"><span data-stu-id="54f50-198">Narrowing Conversions</span></span>

<span data-ttu-id="54f50-199">Quando `Option Strict` è impostato su, le conversioni verso un tipo di caratteri più `On` piccolo generano in genere errori del compilatore.</span><span class="sxs-lookup"><span data-stu-id="54f50-199">When `Option Strict` is set to `On`, narrowing conversions ordinarily cause compiler errors.</span></span> <span data-ttu-id="54f50-200">In un' `For Each` istruzione, tuttavia, le conversioni dagli elementi in `group` a `element` vengono valutate e eseguite in fase di esecuzione e gli errori del compilatore causati da conversioni verso un tipo di caratteri più piccolo vengono eliminati.</span><span class="sxs-lookup"><span data-stu-id="54f50-200">In a `For Each` statement, however, conversions from the elements in `group` to `element` are evaluated and performed at run time, and compiler errors caused by narrowing conversions are suppressed.</span></span>

<span data-ttu-id="54f50-201">Nell'esempio seguente l'assegnazione di `m` come valore iniziale di `n` non viene compilata quando `Option Strict` è impostata su on perché la conversione di un oggetto `Long` in un oggetto `Integer` è una conversione verso un tipo di caratteri più piccolo.</span><span class="sxs-lookup"><span data-stu-id="54f50-201">In the following example, the assignment of `m` as the initial value for `n` doesn't compile when `Option Strict` is on because the conversion of a `Long` to an `Integer` is a narrowing conversion.</span></span> <span data-ttu-id="54f50-202">Nell' `For Each` istruzione, tuttavia, non viene segnalato alcun errore del compilatore, anche se l'assegnazione a `number` richiede la stessa conversione da `Long` a `Integer` .</span><span class="sxs-lookup"><span data-stu-id="54f50-202">In the `For Each` statement, however, no compiler error is reported, even though the assignment to `number` requires the same conversion from `Long` to `Integer`.</span></span> <span data-ttu-id="54f50-203">Nell' `For Each` istruzione che contiene un numero elevato, si verifica un errore di run-time quando <xref:Microsoft.VisualBasic.CompilerServices.Conversions.ToInteger%2A> viene applicato al numero elevato.</span><span class="sxs-lookup"><span data-stu-id="54f50-203">In the `For Each` statement that contains a large number, a run-time error occurs when <xref:Microsoft.VisualBasic.CompilerServices.Conversions.ToInteger%2A> is applied to the large number.</span></span>

[!code-vb[VbVbalrStatements#89](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class3.vb#89)]

### <a name="ienumerator-calls"></a><span data-ttu-id="54f50-204">Chiamate IEnumerator</span><span class="sxs-lookup"><span data-stu-id="54f50-204">IEnumerator Calls</span></span>

<span data-ttu-id="54f50-205">Quando viene avviata l'esecuzione di un `For Each` ciclo... `Next` Visual Basic verifica che faccia `group` riferimento a un oggetto raccolta valido.</span><span class="sxs-lookup"><span data-stu-id="54f50-205">When execution of a `For Each`...`Next` loop starts, Visual Basic verifies that `group` refers to a valid collection object.</span></span> <span data-ttu-id="54f50-206">In caso contrario, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="54f50-206">If not, it throws an exception.</span></span> <span data-ttu-id="54f50-207">In caso contrario, chiama il <xref:System.Collections.IEnumerator.MoveNext%2A> metodo e la <xref:System.Collections.IEnumerator.Current%2A> proprietà dell'oggetto enumeratore per restituire il primo elemento.</span><span class="sxs-lookup"><span data-stu-id="54f50-207">Otherwise, it calls the <xref:System.Collections.IEnumerator.MoveNext%2A> method and the <xref:System.Collections.IEnumerator.Current%2A> property of the enumerator object to return the first element.</span></span> <span data-ttu-id="54f50-208">Se `MoveNext` indica che non è presente alcun elemento successivo, ovvero se la raccolta è vuota, il `For Each` ciclo viene arrestato e il controllo passa all'istruzione che segue l' `Next` istruzione.</span><span class="sxs-lookup"><span data-stu-id="54f50-208">If `MoveNext` indicates that there is no next element, that is, if the collection is empty, the `For Each` loop stops and control passes to the statement following the `Next` statement.</span></span> <span data-ttu-id="54f50-209">In caso contrario, Visual Basic imposta sul `element` primo elemento ed esegue il blocco di istruzioni.</span><span class="sxs-lookup"><span data-stu-id="54f50-209">Otherwise, Visual Basic sets `element` to the first element and runs the statement block.</span></span>

<span data-ttu-id="54f50-210">Ogni volta che Visual Basic rileva l' `Next` istruzione, viene restituito all' `For Each` istruzione.</span><span class="sxs-lookup"><span data-stu-id="54f50-210">Each time Visual Basic encounters the `Next` statement, it returns to the `For Each` statement.</span></span> <span data-ttu-id="54f50-211">Anche in questo caso chiama `MoveNext` e `Current` per restituire l'elemento successivo, quindi esegue di nuovo il blocco o arresta il ciclo a seconda del risultato.</span><span class="sxs-lookup"><span data-stu-id="54f50-211">Again it calls `MoveNext` and `Current` to return the next element, and again it either runs the block or stops the loop depending on the result.</span></span> <span data-ttu-id="54f50-212">Questo processo continua fino a `MoveNext` indicare che non è presente alcun elemento successivo o che `Exit For` viene rilevata un'istruzione.</span><span class="sxs-lookup"><span data-stu-id="54f50-212">This process continues until `MoveNext` indicates that there is no next element or an `Exit For` statement is encountered.</span></span>

<span data-ttu-id="54f50-213">**Modifica della raccolta.**</span><span class="sxs-lookup"><span data-stu-id="54f50-213">**Modifying the Collection.**</span></span> <span data-ttu-id="54f50-214">L'oggetto enumeratore restituito da <xref:System.Collections.IEnumerable.GetEnumerator%2A> normalmente non consente di modificare la raccolta aggiungendo, eliminando, sostituendo o riordinando gli elementi.</span><span class="sxs-lookup"><span data-stu-id="54f50-214">The enumerator object returned by <xref:System.Collections.IEnumerable.GetEnumerator%2A> normally doesn't let you change the collection by adding, deleting, replacing, or reordering any elements.</span></span> <span data-ttu-id="54f50-215">Se si modifica la raccolta dopo che è stato avviato un `For Each` ciclo... `Next` , l'oggetto enumeratore diventa non valido e il tentativo successivo di accedere a un elemento causa un' <xref:System.InvalidOperationException> eccezione.</span><span class="sxs-lookup"><span data-stu-id="54f50-215">If you change the collection after you have initiated a `For Each`...`Next` loop, the enumerator object becomes invalid, and the next attempt to access an element causes an <xref:System.InvalidOperationException> exception.</span></span>

<span data-ttu-id="54f50-216">Tuttavia, questo blocco di modifiche non è determinato dall'Visual Basic, bensì dall'implementazione dell' <xref:System.Collections.IEnumerable> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="54f50-216">However, this blocking of modification isn't determined by Visual Basic, but rather by the implementation of the <xref:System.Collections.IEnumerable> interface.</span></span> <span data-ttu-id="54f50-217">È possibile implementare `IEnumerable` in modo da consentire la modifica durante l'iterazione.</span><span class="sxs-lookup"><span data-stu-id="54f50-217">It is possible to implement `IEnumerable` in a way that allows for modification during iteration.</span></span> <span data-ttu-id="54f50-218">Se si sta prendendo in considerazione questa modifica dinamica, assicurarsi di comprendere le caratteristiche dell' `IEnumerable` implementazione nella raccolta in uso.</span><span class="sxs-lookup"><span data-stu-id="54f50-218">If you are considering doing such dynamic modification, make sure that you understand the characteristics of the `IEnumerable` implementation on the collection you are using.</span></span>

<span data-ttu-id="54f50-219">**Modifica degli elementi della raccolta.**</span><span class="sxs-lookup"><span data-stu-id="54f50-219">**Modifying Collection Elements.**</span></span> <span data-ttu-id="54f50-220">La <xref:System.Collections.IEnumerator.Current%2A> proprietà dell'oggetto enumeratore è [ReadOnly](../modifiers/readonly.md)e restituisce una copia locale di ogni elemento della raccolta.</span><span class="sxs-lookup"><span data-stu-id="54f50-220">The <xref:System.Collections.IEnumerator.Current%2A> property of the enumerator object is [ReadOnly](../modifiers/readonly.md), and it returns a local copy of each collection element.</span></span> <span data-ttu-id="54f50-221">Ciò significa che non è possibile modificare gli elementi stessi in un `For Each` ciclo... `Next` .</span><span class="sxs-lookup"><span data-stu-id="54f50-221">This means that you cannot modify the elements themselves in a `For Each`...`Next` loop.</span></span> <span data-ttu-id="54f50-222">Eventuali modifiche apportate influiscono solo sulla copia locale da `Current` e non vengono riflesse nella raccolta sottostante.</span><span class="sxs-lookup"><span data-stu-id="54f50-222">Any modification you make affects only the local copy from `Current` and isn't reflected back into the underlying collection.</span></span> <span data-ttu-id="54f50-223">Tuttavia, se un elemento è un tipo riferimento, è possibile modificare i membri dell'istanza a cui fa riferimento.</span><span class="sxs-lookup"><span data-stu-id="54f50-223">However, if an element is a reference type, you can modify the members of the instance to which it points.</span></span> <span data-ttu-id="54f50-224">Nell'esempio seguente viene modificato il `BackColor` membro di ogni `thisControl` elemento.</span><span class="sxs-lookup"><span data-stu-id="54f50-224">The following example modifies the `BackColor` member of each `thisControl` element.</span></span> <span data-ttu-id="54f50-225">Non è tuttavia possibile modificare `thisControl` se stesso.</span><span class="sxs-lookup"><span data-stu-id="54f50-225">You cannot, however, modify `thisControl` itself.</span></span>

```vb
Sub LightBlueBackground(thisForm As System.Windows.Forms.Form)
    For Each thisControl In thisForm.Controls
        thisControl.BackColor = System.Drawing.Color.LightBlue
    Next thisControl
End Sub
```

<span data-ttu-id="54f50-226">Nell'esempio precedente è possibile modificare il `BackColor` membro di ogni `thisControl` elemento, sebbene non sia possibile modificarlo `thisControl` .</span><span class="sxs-lookup"><span data-stu-id="54f50-226">The previous example can modify the `BackColor` member of each `thisControl` element, although it cannot modify `thisControl` itself.</span></span>

<span data-ttu-id="54f50-227">**Attraversamento di matrici.**</span><span class="sxs-lookup"><span data-stu-id="54f50-227">**Traversing Arrays.**</span></span> <span data-ttu-id="54f50-228">Poiché la <xref:System.Array> classe implementa l' <xref:System.Collections.IEnumerable> interfaccia, tutte le matrici espongono il <xref:System.Array.GetEnumerator%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="54f50-228">Because the <xref:System.Array> class implements the <xref:System.Collections.IEnumerable> interface, all arrays expose the <xref:System.Array.GetEnumerator%2A> method.</span></span> <span data-ttu-id="54f50-229">Ciò significa che è possibile scorrere una matrice con un `For Each` ciclo... `Next` .</span><span class="sxs-lookup"><span data-stu-id="54f50-229">This means that you can iterate through an array with a `For Each`...`Next` loop.</span></span> <span data-ttu-id="54f50-230">Tuttavia, è possibile leggere solo gli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="54f50-230">However, you can only read the array elements.</span></span> <span data-ttu-id="54f50-231">Non è possibile modificarli.</span><span class="sxs-lookup"><span data-stu-id="54f50-231">You cannot change them.</span></span>

## <a name="example"></a><span data-ttu-id="54f50-232">Esempio</span><span class="sxs-lookup"><span data-stu-id="54f50-232">Example</span></span>

<span data-ttu-id="54f50-233">Nell'esempio seguente vengono elencate tutte le cartelle presenti in C:\ Directory tramite la <xref:System.IO.DirectoryInfo> classe.</span><span class="sxs-lookup"><span data-stu-id="54f50-233">The following example lists all the folders in the C:\ directory by using the <xref:System.IO.DirectoryInfo> class.</span></span>

[!code-vb[VbVbalrStatements#124](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/class9.vb#124)]

## <a name="example"></a><span data-ttu-id="54f50-234">Esempio</span><span class="sxs-lookup"><span data-stu-id="54f50-234">Example</span></span>

<span data-ttu-id="54f50-235">L'esempio seguente illustra una procedura per ordinare una raccolta.</span><span class="sxs-lookup"><span data-stu-id="54f50-235">The following example illustrates a procedure for sorting a collection.</span></span> <span data-ttu-id="54f50-236">Nell'esempio vengono ordinate le istanze di una `Car` classe archiviate in un oggetto <xref:System.Collections.Generic.List%601> .</span><span class="sxs-lookup"><span data-stu-id="54f50-236">The example sorts instances of a `Car` class that are stored in a <xref:System.Collections.Generic.List%601>.</span></span> <span data-ttu-id="54f50-237">La classe `Car` implementa l'interfaccia <xref:System.IComparable%601>, che richiede l'implementazione del metodo <xref:System.IComparable%601.CompareTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="54f50-237">The `Car` class implements the <xref:System.IComparable%601> interface, which requires that the <xref:System.IComparable%601.CompareTo%2A> method be implemented.</span></span>

<span data-ttu-id="54f50-238">Ogni chiamata al <xref:System.IComparable%601.CompareTo%2A> metodo esegue un confronto singolo usato per l'ordinamento.</span><span class="sxs-lookup"><span data-stu-id="54f50-238">Each call to the <xref:System.IComparable%601.CompareTo%2A> method makes a single comparison that's used for sorting.</span></span> <span data-ttu-id="54f50-239">Il codice scritto dall'utente presente nel metodo `CompareTo` restituisce un valore per ogni confronto dell'oggetto corrente con un altro oggetto.</span><span class="sxs-lookup"><span data-stu-id="54f50-239">User-written code in the `CompareTo` method returns a value for each comparison of the current object with another object.</span></span> <span data-ttu-id="54f50-240">Il valore restituito è minore di zero se l'oggetto corrente è inferiore all'altro oggetto, maggiore di zero se l'oggetto corrente è superiore all'altro oggetto e zero se sono uguali.</span><span class="sxs-lookup"><span data-stu-id="54f50-240">The value returned is less than zero if the current object is less than the other object, greater than zero if the current object is greater than the other object, and zero if they are equal.</span></span> <span data-ttu-id="54f50-241">In questo modo è possibile definire nel codice i criteri di maggiore, minore e uguale.</span><span class="sxs-lookup"><span data-stu-id="54f50-241">This enables you to define in code the criteria for greater than, less than, and equal.</span></span>

<span data-ttu-id="54f50-242">Nel metodo `ListCars` l'istruzione `cars.Sort()` ordina l'elenco.</span><span class="sxs-lookup"><span data-stu-id="54f50-242">In the `ListCars` method, the `cars.Sort()` statement sorts the list.</span></span> <span data-ttu-id="54f50-243">Questa chiamata al metodo <xref:System.Collections.Generic.List%601.Sort%2A> di <xref:System.Collections.Generic.List%601> determina la chiamata automatica al metodo `CompareTo` per gli oggetti `Car` in `List`.</span><span class="sxs-lookup"><span data-stu-id="54f50-243">This call to the <xref:System.Collections.Generic.List%601.Sort%2A> method of the <xref:System.Collections.Generic.List%601> causes the `CompareTo` method to be called automatically for the `Car` objects in the `List`.</span></span>

[!code-vb[VbVbalrStatements#125](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/class9.vb#125)]

## <a name="see-also"></a><span data-ttu-id="54f50-244">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="54f50-244">See also</span></span>

- [<span data-ttu-id="54f50-245">raccolte</span><span class="sxs-lookup"><span data-stu-id="54f50-245">Collections</span></span>](../../../standard/collections/index.md)
- [<span data-ttu-id="54f50-246">Istruzione For...Next</span><span class="sxs-lookup"><span data-stu-id="54f50-246">For...Next Statement</span></span>](for-next-statement.md)
- [<span data-ttu-id="54f50-247">Strutture di ciclo</span><span class="sxs-lookup"><span data-stu-id="54f50-247">Loop Structures</span></span>](../../programming-guide/language-features/control-flow/loop-structures.md)
- [<span data-ttu-id="54f50-248">Istruzione While...End While</span><span class="sxs-lookup"><span data-stu-id="54f50-248">While...End While Statement</span></span>](while-end-while-statement.md)
- [<span data-ttu-id="54f50-249">Istruzione Do...Loop</span><span class="sxs-lookup"><span data-stu-id="54f50-249">Do...Loop Statement</span></span>](do-loop-statement.md)
- [<span data-ttu-id="54f50-250">Widening and Narrowing Conversions</span><span class="sxs-lookup"><span data-stu-id="54f50-250">Widening and Narrowing Conversions</span></span>](../../programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)
- [<span data-ttu-id="54f50-251">Inizializzatori di oggetto: tipi denominati e tipi anonimi</span><span class="sxs-lookup"><span data-stu-id="54f50-251">Object Initializers: Named and Anonymous Types</span></span>](../../programming-guide/language-features/objects-and-classes/object-initializers-named-and-anonymous-types.md)
- [<span data-ttu-id="54f50-252">Inizializzatori di insieme</span><span class="sxs-lookup"><span data-stu-id="54f50-252">Collection Initializers</span></span>](../../programming-guide/language-features/collection-initializers/index.md)
- [<span data-ttu-id="54f50-253">Matrici</span><span class="sxs-lookup"><span data-stu-id="54f50-253">Arrays</span></span>](../../programming-guide/language-features/arrays/index.md)
